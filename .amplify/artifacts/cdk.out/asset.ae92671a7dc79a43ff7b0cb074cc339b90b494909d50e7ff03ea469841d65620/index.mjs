/** * Reads SSM environment context from a known Amplify environment variable, * fetches values from SSM and places those values in the corresponding environment variables */ export const internalAmplifyFunctionResolveSsmParams =
  async (client) => {
    const envPathObject = JSON.parse(
      process.env.AMPLIFY_SSM_ENV_CONFIG ?? "{}",
    );
    const paths = Object.values(envPathObject).map((paths) => paths.path);
    if (paths.length === 0) {
      return;
    }
    let actualSsmClient;
    if (client) {
      actualSsmClient = client;
    } else {
      const ssmSdk = await import("@aws-sdk/client-ssm");
      actualSsmClient = new ssmSdk.SSM();
    }
    const chunkArray = (array, chunkSize) => {
      const chunks = [];
      for (let i = 0; i < array.length; i += chunkSize) {
        chunks.push(array.slice(i, i + chunkSize));
      }
      return chunks;
    };
    const resolveSecrets = async (paths) => {
      const response = (
        await Promise.all(
          chunkArray(paths, 10).map(
            async (chunkedPaths) =>
              await actualSsmClient.getParameters({
                Names: chunkedPaths,
                WithDecryption: true,
              }),
          ),
        )
      ).reduce(
        (accumulator, res) => {
          accumulator.Parameters?.push(...(res.Parameters ?? []));
          accumulator.InvalidParameters?.push(...(res.InvalidParameters ?? []));
          return accumulator;
        },
        { Parameters: [], InvalidParameters: [] },
      );
      if (response.Parameters && response.Parameters.length > 0) {
        for (const parameter of response.Parameters) {
          if (parameter.Name) {
            const envKey = Object.keys(envPathObject).find(
              (key) =>
                envPathObject[key].sharedPath === parameter.Name ||
                envPathObject[key].path === parameter.Name,
            );
            if (envKey) {
              process.env[envKey] = parameter.Value;
            }
          }
        }
      }
      return response;
    };
    const response = await resolveSecrets(paths);
    const sharedPaths = (response?.InvalidParameters || [])
      .map(
        (invalidParam) =>
          Object.values(envPathObject).find(
            (paths) => paths.path === invalidParam,
          )?.sharedPath,
      )
      .filter((sharedParam) => !!sharedParam);
    if (sharedPaths.length > 0) {
      await resolveSecrets(sharedPaths);
    }
  };
await internalAmplifyFunctionResolveSsmParams();
const SSM_PARAMETER_REFRESH_MS = 1000 * 60;
setInterval(async () => {
  try {
    await internalAmplifyFunctionResolveSsmParams();
  } catch (error) {
    try {
      console.debug(error);
    } catch {}
  }
}, SSM_PARAMETER_REFRESH_MS);
export {};
var Krt = Object.create;
var sA = Object.defineProperty;
var Wrt = Object.getOwnPropertyDescriptor;
var Qrt = Object.getOwnPropertyNames;
var Yrt = Object.getPrototypeOf,
  Xrt = Object.prototype.hasOwnProperty;
var G = ((e) =>
  typeof require < "u"
    ? require
    : typeof Proxy < "u"
      ? new Proxy(e, { get: (t, r) => (typeof require < "u" ? require : t)[r] })
      : e)(function (e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
});
var w = (e, t) => () => (e && (t = e((e = 0))), t);
var g = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
  bn = (e, t) => {
    for (var r in t) sA(e, r, { get: t[r], enumerable: !0 });
  },
  Jre = (e, t, r, n) => {
    if ((t && typeof t == "object") || typeof t == "function")
      for (let i of Qrt(t))
        !Xrt.call(e, i) &&
          i !== r &&
          sA(e, i, {
            get: () => t[i],
            enumerable: !(n = Wrt(t, i)) || n.enumerable,
          });
    return e;
  };
var A = (e, t, r) => (
    (r = e != null ? Krt(Yrt(e)) : {}),
    Jre(
      t || !e || !e.__esModule
        ? sA(r, "default", { value: e, enumerable: !0 })
        : r,
      e,
    )
  ),
  ue = (e) => Jre(sA({}, "__esModule", { value: !0 }), e);
import { createRequire as Jrt } from "node:module";
import Zrt from "node:path";
import ent from "node:url";
var c = w(() => {
  global.require = Jrt(import.meta.url);
  global.__filename = ent.fileURLToPath(import.meta.url);
  global.__dirname = Zrt.dirname(__filename);
});
var ho = {};
bn(ho, {
  __addDisposableResource: () => qne,
  __assign: () => pA,
  __asyncDelegator: () => Rne,
  __asyncGenerator: () => Pne,
  __asyncValues: () => Ine,
  __await: () => Qg,
  __awaiter: () => Sne,
  __classPrivateFieldGet: () => Dne,
  __classPrivateFieldIn: () => Mne,
  __classPrivateFieldSet: () => Lne,
  __createBinding: () => hA,
  __decorate: () => hne,
  __disposeResources: () => jne,
  __esDecorate: () => vne,
  __exportStar: () => wne,
  __extends: () => pne,
  __generator: () => Cne,
  __importDefault: () => kne,
  __importStar: () => Nne,
  __makeTemplateObject: () => xne,
  __metadata: () => bne,
  __param: () => gne,
  __propKey: () => _ne,
  __read: () => E3,
  __rest: () => mne,
  __rewriteRelativeImportExtension: () => Fne,
  __runInitializers: () => yne,
  __setFunctionName: () => Ene,
  __spread: () => One,
  __spreadArray: () => Ane,
  __spreadArrays: () => Tne,
  __values: () => mA,
  default: () => Cnt,
});
function pne(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError(
      "Class extends value " + String(t) + " is not a constructor or null",
    );
  y3(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype =
    t === null ? Object.create(t) : ((r.prototype = t.prototype), new r());
}
function mne(e, t) {
  var r = {};
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) &&
      t.indexOf(n) < 0 &&
      (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
      t.indexOf(n[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, n[i]) &&
        (r[n[i]] = e[n[i]]);
  return r;
}
function hne(e, t, r, n) {
  var i = arguments.length,
    o =
      i < 3 ? t : n === null ? (n = Object.getOwnPropertyDescriptor(t, r)) : n,
    a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(e, t, r, n);
  else
    for (var s = e.length - 1; s >= 0; s--)
      (a = e[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(t, r, o) : a(t, r)) || o);
  return i > 3 && o && Object.defineProperty(t, r, o), o;
}
function gne(e, t) {
  return function (r, n) {
    t(r, n, e);
  };
}
function vne(e, t, r, n, i, o) {
  function a(b) {
    if (b !== void 0 && typeof b != "function")
      throw new TypeError("Function expected");
    return b;
  }
  for (
    var s = n.kind,
      u = s === "getter" ? "get" : s === "setter" ? "set" : "value",
      l = !t && e ? (n.static ? e : e.prototype) : null,
      d = t || (l ? Object.getOwnPropertyDescriptor(l, n.name) : {}),
      f,
      m = !1,
      h = r.length - 1;
    h >= 0;
    h--
  ) {
    var y = {};
    for (var _ in n) y[_] = _ === "access" ? {} : n[_];
    for (var _ in n.access) y.access[_] = n.access[_];
    y.addInitializer = function (b) {
      if (m)
        throw new TypeError(
          "Cannot add initializers after decoration has completed",
        );
      o.push(a(b || null));
    };
    var E = (0, r[h])(s === "accessor" ? { get: d.get, set: d.set } : d[u], y);
    if (s === "accessor") {
      if (E === void 0) continue;
      if (E === null || typeof E != "object")
        throw new TypeError("Object expected");
      (f = a(E.get)) && (d.get = f),
        (f = a(E.set)) && (d.set = f),
        (f = a(E.init)) && i.unshift(f);
    } else (f = a(E)) && (s === "field" ? i.unshift(f) : (d[u] = f));
  }
  l && Object.defineProperty(l, n.name, d), (m = !0);
}
function yne(e, t, r) {
  for (var n = arguments.length > 2, i = 0; i < t.length; i++)
    r = n ? t[i].call(e, r) : t[i].call(e);
  return n ? r : void 0;
}
function _ne(e) {
  return typeof e == "symbol" ? e : "".concat(e);
}
function Ene(e, t, r) {
  return (
    typeof t == "symbol" &&
      (t = t.description ? "[".concat(t.description, "]") : ""),
    Object.defineProperty(e, "name", {
      configurable: !0,
      value: r ? "".concat(r, " ", t) : t,
    })
  );
}
function bne(e, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(e, t);
}
function Sne(e, t, r, n) {
  function i(o) {
    return o instanceof r
      ? o
      : new r(function (a) {
          a(o);
        });
  }
  return new (r || (r = Promise))(function (o, a) {
    function s(d) {
      try {
        l(n.next(d));
      } catch (f) {
        a(f);
      }
    }
    function u(d) {
      try {
        l(n.throw(d));
      } catch (f) {
        a(f);
      }
    }
    function l(d) {
      d.done ? o(d.value) : i(d.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
}
function Cne(e, t) {
  var r = {
      label: 0,
      sent: function () {
        if (o[0] & 1) throw o[1];
        return o[1];
      },
      trys: [],
      ops: [],
    },
    n,
    i,
    o,
    a = Object.create(
      (typeof Iterator == "function" ? Iterator : Object).prototype,
    );
  return (
    (a.next = s(0)),
    (a.throw = s(1)),
    (a.return = s(2)),
    typeof Symbol == "function" &&
      (a[Symbol.iterator] = function () {
        return this;
      }),
    a
  );
  function s(l) {
    return function (d) {
      return u([l, d]);
    };
  }
  function u(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; a && ((a = 0), l[0] && (r = 0)), r; )
      try {
        if (
          ((n = 1),
          i &&
            (o =
              l[0] & 2
                ? i.return
                : l[0]
                  ? i.throw || ((o = i.return) && o.call(i), 0)
                  : i.next) &&
            !(o = o.call(i, l[1])).done)
        )
          return o;
        switch (((i = 0), o && (l = [l[0] & 2, o.value]), l[0])) {
          case 0:
          case 1:
            o = l;
            break;
          case 4:
            return r.label++, { value: l[1], done: !1 };
          case 5:
            r.label++, (i = l[1]), (l = [0]);
            continue;
          case 7:
            (l = r.ops.pop()), r.trys.pop();
            continue;
          default:
            if (
              ((o = r.trys),
              !(o = o.length > 0 && o[o.length - 1]) &&
                (l[0] === 6 || l[0] === 2))
            ) {
              r = 0;
              continue;
            }
            if (l[0] === 3 && (!o || (l[1] > o[0] && l[1] < o[3]))) {
              r.label = l[1];
              break;
            }
            if (l[0] === 6 && r.label < o[1]) {
              (r.label = o[1]), (o = l);
              break;
            }
            if (o && r.label < o[2]) {
              (r.label = o[2]), r.ops.push(l);
              break;
            }
            o[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        l = t.call(e, r);
      } catch (d) {
        (l = [6, d]), (i = 0);
      } finally {
        n = o = 0;
      }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function wne(e, t) {
  for (var r in e)
    r !== "default" &&
      !Object.prototype.hasOwnProperty.call(t, r) &&
      hA(t, e, r);
}
function mA(e) {
  var t = typeof Symbol == "function" && Symbol.iterator,
    r = t && e[t],
    n = 0;
  if (r) return r.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function () {
        return (
          e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e }
        );
      },
    };
  throw new TypeError(
    t ? "Object is not iterable." : "Symbol.iterator is not defined.",
  );
}
function E3(e, t) {
  var r = typeof Symbol == "function" && e[Symbol.iterator];
  if (!r) return e;
  var n = r.call(e),
    i,
    o = [],
    a;
  try {
    for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; ) o.push(i.value);
  } catch (s) {
    a = { error: s };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a) throw a.error;
    }
  }
  return o;
}
function One() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(E3(arguments[t]));
  return e;
}
function Tne() {
  for (var e = 0, t = 0, r = arguments.length; t < r; t++)
    e += arguments[t].length;
  for (var n = Array(e), i = 0, t = 0; t < r; t++)
    for (var o = arguments[t], a = 0, s = o.length; a < s; a++, i++)
      n[i] = o[a];
  return n;
}
function Ane(e, t, r) {
  if (r || arguments.length === 2)
    for (var n = 0, i = t.length, o; n < i; n++)
      (o || !(n in t)) &&
        (o || (o = Array.prototype.slice.call(t, 0, n)), (o[n] = t[n]));
  return e.concat(o || Array.prototype.slice.call(t));
}
function Qg(e) {
  return this instanceof Qg ? ((this.v = e), this) : new Qg(e);
}
function Pne(e, t, r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(e, t || []),
    i,
    o = [];
  return (
    (i = Object.create(
      (typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype,
    )),
    s("next"),
    s("throw"),
    s("return", a),
    (i[Symbol.asyncIterator] = function () {
      return this;
    }),
    i
  );
  function a(h) {
    return function (y) {
      return Promise.resolve(y).then(h, f);
    };
  }
  function s(h, y) {
    n[h] &&
      ((i[h] = function (_) {
        return new Promise(function (E, b) {
          o.push([h, _, E, b]) > 1 || u(h, _);
        });
      }),
      y && (i[h] = y(i[h])));
  }
  function u(h, y) {
    try {
      l(n[h](y));
    } catch (_) {
      m(o[0][3], _);
    }
  }
  function l(h) {
    h.value instanceof Qg
      ? Promise.resolve(h.value.v).then(d, f)
      : m(o[0][2], h);
  }
  function d(h) {
    u("next", h);
  }
  function f(h) {
    u("throw", h);
  }
  function m(h, y) {
    h(y), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
}
function Rne(e) {
  var t, r;
  return (
    (t = {}),
    n("next"),
    n("throw", function (i) {
      throw i;
    }),
    n("return"),
    (t[Symbol.iterator] = function () {
      return this;
    }),
    t
  );
  function n(i, o) {
    t[i] = e[i]
      ? function (a) {
          return (r = !r) ? { value: Qg(e[i](a)), done: !1 } : o ? o(a) : a;
        }
      : o;
  }
}
function Ine(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator],
    r;
  return t
    ? t.call(e)
    : ((e = typeof mA == "function" ? mA(e) : e[Symbol.iterator]()),
      (r = {}),
      n("next"),
      n("throw"),
      n("return"),
      (r[Symbol.asyncIterator] = function () {
        return this;
      }),
      r);
  function n(o) {
    r[o] =
      e[o] &&
      function (a) {
        return new Promise(function (s, u) {
          (a = e[o](a)), i(s, u, a.done, a.value);
        });
      };
  }
  function i(o, a, s, u) {
    Promise.resolve(u).then(function (l) {
      o({ value: l, done: s });
    }, a);
  }
}
function xne(e, t) {
  return (
    Object.defineProperty
      ? Object.defineProperty(e, "raw", { value: t })
      : (e.raw = t),
    e
  );
}
function Nne(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null)
    for (var r = _3(e), n = 0; n < r.length; n++)
      r[n] !== "default" && hA(t, e, r[n]);
  return bnt(t, e), t;
}
function kne(e) {
  return e && e.__esModule ? e : { default: e };
}
function Dne(e, t, r, n) {
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !n : !t.has(e))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it",
    );
  return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
}
function Lne(e, t, r, n, i) {
  if (n === "m") throw new TypeError("Private method is not writable");
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it",
    );
  return n === "a" ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r;
}
function Mne(e, t) {
  if (t === null || (typeof t != "object" && typeof t != "function"))
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof e == "function" ? t === e : e.has(t);
}
function qne(e, t, r) {
  if (t != null) {
    if (typeof t != "object" && typeof t != "function")
      throw new TypeError("Object expected.");
    var n, i;
    if (r) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      n = t[Symbol.asyncDispose];
    }
    if (n === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      (n = t[Symbol.dispose]), r && (i = n);
    }
    if (typeof n != "function") throw new TypeError("Object not disposable.");
    i &&
      (n = function () {
        try {
          i.call(this);
        } catch (o) {
          return Promise.reject(o);
        }
      }),
      e.stack.push({ value: t, dispose: n, async: r });
  } else r && e.stack.push({ async: !0 });
  return t;
}
function jne(e) {
  function t(o) {
    (e.error = e.hasError
      ? new Snt(o, e.error, "An error was suppressed during disposal.")
      : o),
      (e.hasError = !0);
  }
  var r,
    n = 0;
  function i() {
    for (; (r = e.stack.pop()); )
      try {
        if (!r.async && n === 1)
          return (n = 0), e.stack.push(r), Promise.resolve().then(i);
        if (r.dispose) {
          var o = r.dispose.call(r.value);
          if (r.async)
            return (
              (n |= 2),
              Promise.resolve(o).then(i, function (a) {
                return t(a), i();
              })
            );
        } else n |= 1;
      } catch (a) {
        t(a);
      }
    if (n === 1)
      return e.hasError ? Promise.reject(e.error) : Promise.resolve();
    if (e.hasError) throw e.error;
  }
  return i();
}
function Fne(e, t) {
  return typeof e == "string" && /^\.\.?\//.test(e)
    ? e.replace(
        /\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,
        function (r, n, i, o, a) {
          return n
            ? t
              ? ".jsx"
              : ".js"
            : i && (!o || !a)
              ? r
              : i + o + "." + a.toLowerCase() + "js";
        },
      )
    : e;
}
var y3,
  pA,
  hA,
  bnt,
  _3,
  Snt,
  Cnt,
  go = w(() => {
    c();
    y3 = function (e, t) {
      return (
        (y3 =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, n) {
              r.__proto__ = n;
            }) ||
          function (r, n) {
            for (var i in n)
              Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i]);
          }),
        y3(e, t)
      );
    };
    pA = function () {
      return (
        (pA =
          Object.assign ||
          function (t) {
            for (var r, n = 1, i = arguments.length; n < i; n++) {
              r = arguments[n];
              for (var o in r)
                Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o]);
            }
            return t;
          }),
        pA.apply(this, arguments)
      );
    };
    hA = Object.create
      ? function (e, t, r, n) {
          n === void 0 && (n = r);
          var i = Object.getOwnPropertyDescriptor(t, r);
          (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) &&
            (i = {
              enumerable: !0,
              get: function () {
                return t[r];
              },
            }),
            Object.defineProperty(e, n, i);
        }
      : function (e, t, r, n) {
          n === void 0 && (n = r), (e[n] = t[r]);
        };
    (bnt = Object.create
      ? function (e, t) {
          Object.defineProperty(e, "default", { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
      (_3 = function (e) {
        return (
          (_3 =
            Object.getOwnPropertyNames ||
            function (t) {
              var r = [];
              for (var n in t)
                Object.prototype.hasOwnProperty.call(t, n) && (r[r.length] = n);
              return r;
            }),
          _3(e)
        );
      });
    Snt =
      typeof SuppressedError == "function"
        ? SuppressedError
        : function (e, t, r) {
            var n = new Error(r);
            return (
              (n.name = "SuppressedError"), (n.error = e), (n.suppressed = t), n
            );
          };
    Cnt = {
      __extends: pne,
      __assign: pA,
      __rest: mne,
      __decorate: hne,
      __param: gne,
      __esDecorate: vne,
      __runInitializers: yne,
      __propKey: _ne,
      __setFunctionName: Ene,
      __metadata: bne,
      __awaiter: Sne,
      __generator: Cne,
      __createBinding: hA,
      __exportStar: wne,
      __values: mA,
      __read: E3,
      __spread: One,
      __spreadArrays: Tne,
      __spreadArray: Ane,
      __await: Qg,
      __asyncGenerator: Pne,
      __asyncDelegator: Rne,
      __asyncValues: Ine,
      __makeTemplateObject: xne,
      __importStar: Nne,
      __importDefault: kne,
      __classPrivateFieldGet: Dne,
      __classPrivateFieldSet: Lne,
      __classPrivateFieldIn: Mne,
      __addDisposableResource: qne,
      __disposeResources: jne,
      __rewriteRelativeImportExtension: Fne,
    };
  });
var b3 = g((ba) => {
  "use strict";
  c();
  Object.defineProperty(ba, "__esModule", { value: !0 });
  ba.MAX_HASHABLE_LENGTH =
    ba.INIT =
    ba.KEY =
    ba.DIGEST_LENGTH =
    ba.BLOCK_SIZE =
      void 0;
  ba.BLOCK_SIZE = 64;
  ba.DIGEST_LENGTH = 32;
  ba.KEY = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]);
  ba.INIT = [
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
    528734635, 1541459225,
  ];
  ba.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
});
var Bne = g((gA) => {
  "use strict";
  c();
  Object.defineProperty(gA, "__esModule", { value: !0 });
  gA.RawSha256 = void 0;
  var Sa = b3(),
    wnt = (function () {
      function e() {
        (this.state = Int32Array.from(Sa.INIT)),
          (this.temp = new Int32Array(64)),
          (this.buffer = new Uint8Array(64)),
          (this.bufferLength = 0),
          (this.bytesHashed = 0),
          (this.finished = !1);
      }
      return (
        (e.prototype.update = function (t) {
          if (this.finished)
            throw new Error("Attempted to update an already finished hash.");
          var r = 0,
            n = t.byteLength;
          if (
            ((this.bytesHashed += n),
            this.bytesHashed * 8 > Sa.MAX_HASHABLE_LENGTH)
          )
            throw new Error("Cannot hash more than 2^53 - 1 bits");
          for (; n > 0; )
            (this.buffer[this.bufferLength++] = t[r++]),
              n--,
              this.bufferLength === Sa.BLOCK_SIZE &&
                (this.hashBuffer(), (this.bufferLength = 0));
        }),
        (e.prototype.digest = function () {
          if (!this.finished) {
            var t = this.bytesHashed * 8,
              r = new DataView(
                this.buffer.buffer,
                this.buffer.byteOffset,
                this.buffer.byteLength,
              ),
              n = this.bufferLength;
            if (
              (r.setUint8(this.bufferLength++, 128),
              n % Sa.BLOCK_SIZE >= Sa.BLOCK_SIZE - 8)
            ) {
              for (var i = this.bufferLength; i < Sa.BLOCK_SIZE; i++)
                r.setUint8(i, 0);
              this.hashBuffer(), (this.bufferLength = 0);
            }
            for (var i = this.bufferLength; i < Sa.BLOCK_SIZE - 8; i++)
              r.setUint8(i, 0);
            r.setUint32(Sa.BLOCK_SIZE - 8, Math.floor(t / 4294967296), !0),
              r.setUint32(Sa.BLOCK_SIZE - 4, t),
              this.hashBuffer(),
              (this.finished = !0);
          }
          for (var o = new Uint8Array(Sa.DIGEST_LENGTH), i = 0; i < 8; i++)
            (o[i * 4] = (this.state[i] >>> 24) & 255),
              (o[i * 4 + 1] = (this.state[i] >>> 16) & 255),
              (o[i * 4 + 2] = (this.state[i] >>> 8) & 255),
              (o[i * 4 + 3] = (this.state[i] >>> 0) & 255);
          return o;
        }),
        (e.prototype.hashBuffer = function () {
          for (
            var t = this,
              r = t.buffer,
              n = t.state,
              i = n[0],
              o = n[1],
              a = n[2],
              s = n[3],
              u = n[4],
              l = n[5],
              d = n[6],
              f = n[7],
              m = 0;
            m < Sa.BLOCK_SIZE;
            m++
          ) {
            if (m < 16)
              this.temp[m] =
                ((r[m * 4] & 255) << 24) |
                ((r[m * 4 + 1] & 255) << 16) |
                ((r[m * 4 + 2] & 255) << 8) |
                (r[m * 4 + 3] & 255);
            else {
              var h = this.temp[m - 2],
                y =
                  ((h >>> 17) | (h << 15)) ^
                  ((h >>> 19) | (h << 13)) ^
                  (h >>> 10);
              h = this.temp[m - 15];
              var _ =
                ((h >>> 7) | (h << 25)) ^ ((h >>> 18) | (h << 14)) ^ (h >>> 3);
              this.temp[m] =
                ((y + this.temp[m - 7]) | 0) + ((_ + this.temp[m - 16]) | 0);
            }
            var E =
                ((((((u >>> 6) | (u << 26)) ^
                  ((u >>> 11) | (u << 21)) ^
                  ((u >>> 25) | (u << 7))) +
                  ((u & l) ^ (~u & d))) |
                  0) +
                  ((f + ((Sa.KEY[m] + this.temp[m]) | 0)) | 0)) |
                0,
              b =
                ((((i >>> 2) | (i << 30)) ^
                  ((i >>> 13) | (i << 19)) ^
                  ((i >>> 22) | (i << 10))) +
                  ((i & o) ^ (i & a) ^ (o & a))) |
                0;
            (f = d),
              (d = l),
              (l = u),
              (u = (s + E) | 0),
              (s = a),
              (a = o),
              (o = i),
              (i = (E + b) | 0);
          }
          (n[0] += i),
            (n[1] += o),
            (n[2] += a),
            (n[3] += s),
            (n[4] += u),
            (n[5] += l),
            (n[6] += d),
            (n[7] += f);
        }),
        e
      );
    })();
  gA.RawSha256 = wnt;
});
var Gne = g((Azr, Hne) => {
  c();
  var vA = Object.defineProperty,
    Ont = Object.getOwnPropertyDescriptor,
    Tnt = Object.getOwnPropertyNames,
    Ant = Object.prototype.hasOwnProperty,
    Pnt = (e, t) => vA(e, "name", { value: t, configurable: !0 }),
    Rnt = (e, t) => {
      for (var r in t) vA(e, r, { get: t[r], enumerable: !0 });
    },
    Int = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Tnt(t))
          !Ant.call(e, i) &&
            i !== r &&
            vA(e, i, {
              get: () => t[i],
              enumerable: !(n = Ont(t, i)) || n.enumerable,
            });
      return e;
    },
    xnt = (e) => Int(vA({}, "__esModule", { value: !0 }), e),
    Une = {};
  Rnt(Une, { isArrayBuffer: () => Nnt });
  Hne.exports = xnt(Une);
  var Nnt = Pnt(
    (e) =>
      (typeof ArrayBuffer == "function" && e instanceof ArrayBuffer) ||
      Object.prototype.toString.call(e) === "[object ArrayBuffer]",
    "isArrayBuffer",
  );
});
var Kne = g((Rzr, zne) => {
  c();
  var yA = Object.defineProperty,
    knt = Object.getOwnPropertyDescriptor,
    Dnt = Object.getOwnPropertyNames,
    Lnt = Object.prototype.hasOwnProperty,
    Vne = (e, t) => yA(e, "name", { value: t, configurable: !0 }),
    Mnt = (e, t) => {
      for (var r in t) yA(e, r, { get: t[r], enumerable: !0 });
    },
    qnt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Dnt(t))
          !Lnt.call(e, i) &&
            i !== r &&
            yA(e, i, {
              get: () => t[i],
              enumerable: !(n = knt(t, i)) || n.enumerable,
            });
      return e;
    },
    jnt = (e) => qnt(yA({}, "__esModule", { value: !0 }), e),
    $ne = {};
  Mnt($ne, { fromArrayBuffer: () => Bnt, fromString: () => Unt });
  zne.exports = jnt($ne);
  var Fnt = Gne(),
    S3 = G("buffer"),
    Bnt = Vne((e, t = 0, r = e.byteLength - t) => {
      if (!(0, Fnt.isArrayBuffer)(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`,
        );
      return S3.Buffer.from(e, t, r);
    }, "fromArrayBuffer"),
    Unt = Vne((e, t) => {
      if (typeof e != "string")
        throw new TypeError(
          `The "input" argument must be of type string. Received type ${typeof e} (${e})`,
        );
      return t ? S3.Buffer.from(e, t) : S3.Buffer.from(e);
    }, "fromString");
});
var Jne = g((xzr, Xne) => {
  c();
  var _A = Object.defineProperty,
    Hnt = Object.getOwnPropertyDescriptor,
    Gnt = Object.getOwnPropertyNames,
    Vnt = Object.prototype.hasOwnProperty,
    C3 = (e, t) => _A(e, "name", { value: t, configurable: !0 }),
    $nt = (e, t) => {
      for (var r in t) _A(e, r, { get: t[r], enumerable: !0 });
    },
    znt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Gnt(t))
          !Vnt.call(e, i) &&
            i !== r &&
            _A(e, i, {
              get: () => t[i],
              enumerable: !(n = Hnt(t, i)) || n.enumerable,
            });
      return e;
    },
    Knt = (e) => znt(_A({}, "__esModule", { value: !0 }), e),
    Wne = {};
  $nt(Wne, { fromUtf8: () => Yne, toUint8Array: () => Wnt, toUtf8: () => Qnt });
  Xne.exports = Knt(Wne);
  var Qne = Kne(),
    Yne = C3((e) => {
      let t = (0, Qne.fromString)(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT,
      );
    }, "fromUtf8"),
    Wnt = C3(
      (e) =>
        typeof e == "string"
          ? Yne(e)
          : ArrayBuffer.isView(e)
            ? new Uint8Array(
                e.buffer,
                e.byteOffset,
                e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
              )
            : new Uint8Array(e),
      "toUint8Array",
    ),
    Qnt = C3((e) => {
      if (typeof e == "string") return e;
      if (
        typeof e != "object" ||
        typeof e.byteOffset != "number" ||
        typeof e.byteLength != "number"
      )
        throw new Error(
          "@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.",
        );
      return (0, Qne.fromArrayBuffer)(
        e.buffer,
        e.byteOffset,
        e.byteLength,
      ).toString("utf8");
    }, "toUtf8");
});
var Zne = g((EA) => {
  "use strict";
  c();
  Object.defineProperty(EA, "__esModule", { value: !0 });
  EA.convertToBuffer = void 0;
  var Ynt = Jne(),
    Xnt =
      typeof Buffer < "u" && Buffer.from
        ? function (e) {
            return Buffer.from(e, "utf8");
          }
        : Ynt.fromUtf8;
  function Jnt(e) {
    return e instanceof Uint8Array
      ? e
      : typeof e == "string"
        ? Xnt(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
            )
          : new Uint8Array(e);
  }
  EA.convertToBuffer = Jnt;
});
var eie = g((bA) => {
  "use strict";
  c();
  Object.defineProperty(bA, "__esModule", { value: !0 });
  bA.isEmptyData = void 0;
  function Znt(e) {
    return typeof e == "string" ? e.length === 0 : e.byteLength === 0;
  }
  bA.isEmptyData = Znt;
});
var tie = g((SA) => {
  "use strict";
  c();
  Object.defineProperty(SA, "__esModule", { value: !0 });
  SA.numToUint8 = void 0;
  function eit(e) {
    return new Uint8Array([
      (e & 4278190080) >> 24,
      (e & 16711680) >> 16,
      (e & 65280) >> 8,
      e & 255,
    ]);
  }
  SA.numToUint8 = eit;
});
var rie = g((CA) => {
  "use strict";
  c();
  Object.defineProperty(CA, "__esModule", { value: !0 });
  CA.uint32ArrayFrom = void 0;
  function tit(e) {
    if (!Uint32Array.from) {
      for (var t = new Uint32Array(e.length), r = 0; r < e.length; )
        (t[r] = e[r]), (r += 1);
      return t;
    }
    return Uint32Array.from(e);
  }
  CA.uint32ArrayFrom = tit;
});
var Vp = g((mc) => {
  "use strict";
  c();
  Object.defineProperty(mc, "__esModule", { value: !0 });
  mc.uint32ArrayFrom =
    mc.numToUint8 =
    mc.isEmptyData =
    mc.convertToBuffer =
      void 0;
  var rit = Zne();
  Object.defineProperty(mc, "convertToBuffer", {
    enumerable: !0,
    get: function () {
      return rit.convertToBuffer;
    },
  });
  var nit = eie();
  Object.defineProperty(mc, "isEmptyData", {
    enumerable: !0,
    get: function () {
      return nit.isEmptyData;
    },
  });
  var iit = tie();
  Object.defineProperty(mc, "numToUint8", {
    enumerable: !0,
    get: function () {
      return iit.numToUint8;
    },
  });
  var oit = rie();
  Object.defineProperty(mc, "uint32ArrayFrom", {
    enumerable: !0,
    get: function () {
      return oit.uint32ArrayFrom;
    },
  });
});
var iie = g((TA) => {
  "use strict";
  c();
  Object.defineProperty(TA, "__esModule", { value: !0 });
  TA.Sha256 = void 0;
  var nie = (go(), ue(ho)),
    OA = b3(),
    wA = Bne(),
    w3 = Vp(),
    ait = (function () {
      function e(t) {
        (this.secret = t), (this.hash = new wA.RawSha256()), this.reset();
      }
      return (
        (e.prototype.update = function (t) {
          if (!((0, w3.isEmptyData)(t) || this.error))
            try {
              this.hash.update((0, w3.convertToBuffer)(t));
            } catch (r) {
              this.error = r;
            }
        }),
        (e.prototype.digestSync = function () {
          if (this.error) throw this.error;
          return this.outer
            ? (this.outer.finished || this.outer.update(this.hash.digest()),
              this.outer.digest())
            : this.hash.digest();
        }),
        (e.prototype.digest = function () {
          return nie.__awaiter(this, void 0, void 0, function () {
            return nie.__generator(this, function (t) {
              return [2, this.digestSync()];
            });
          });
        }),
        (e.prototype.reset = function () {
          if (((this.hash = new wA.RawSha256()), this.secret)) {
            this.outer = new wA.RawSha256();
            var t = sit(this.secret),
              r = new Uint8Array(OA.BLOCK_SIZE);
            r.set(t);
            for (var n = 0; n < OA.BLOCK_SIZE; n++) (t[n] ^= 54), (r[n] ^= 92);
            this.hash.update(t), this.outer.update(r);
            for (var n = 0; n < t.byteLength; n++) t[n] = 0;
          }
        }),
        e
      );
    })();
  TA.Sha256 = ait;
  function sit(e) {
    var t = (0, w3.convertToBuffer)(e);
    if (t.byteLength > OA.BLOCK_SIZE) {
      var r = new wA.RawSha256();
      r.update(t), (t = r.digest());
    }
    var n = new Uint8Array(OA.BLOCK_SIZE);
    return n.set(t), n;
  }
});
var ad = g((O3) => {
  "use strict";
  c();
  Object.defineProperty(O3, "__esModule", { value: !0 });
  var cit = (go(), ue(ho));
  cit.__exportStar(iie(), O3);
});
var sd = g((Yg) => {
  "use strict";
  c();
  Object.defineProperty(Yg, "__esModule", { value: !0 });
  Yg.toHex = Yg.fromHex = void 0;
  var oie = {},
    T3 = {};
  for (let e = 0; e < 256; e++) {
    let t = e.toString(16).toLowerCase();
    t.length === 1 && (t = `0${t}`), (oie[e] = t), (T3[t] = e);
  }
  function uit(e) {
    if (e.length % 2 !== 0)
      throw new Error("Hex encoded strings must have an even number length");
    let t = new Uint8Array(e.length / 2);
    for (let r = 0; r < e.length; r += 2) {
      let n = e.slice(r, r + 2).toLowerCase();
      if (n in T3) t[r / 2] = T3[n];
      else
        throw new Error(
          `Cannot decode unrecognized sequence ${n} as hexadecimal`,
        );
    }
    return t;
  }
  Yg.fromHex = uit;
  function lit(e) {
    let t = "";
    for (let r = 0; r < e.byteLength; r++) t += oie[e[r]];
    return t;
  }
  Yg.toHex = lit;
});
var Jt = g((NA) => {
  "use strict";
  c();
  Object.defineProperty(NA, "__esModule", { value: !0 });
  NA.isFunction = void 0;
  function yit(e) {
    return typeof e == "function";
  }
  NA.isFunction = yit;
});
var ld = g((kA) => {
  "use strict";
  c();
  Object.defineProperty(kA, "__esModule", { value: !0 });
  kA.createErrorClass = void 0;
  function _it(e) {
    var t = function (n) {
        Error.call(n), (n.stack = new Error().stack);
      },
      r = e(t);
    return (
      (r.prototype = Object.create(Error.prototype)),
      (r.prototype.constructor = r),
      r
    );
  }
  kA.createErrorClass = _it;
});
var F3 = g((DA) => {
  "use strict";
  c();
  Object.defineProperty(DA, "__esModule", { value: !0 });
  DA.UnsubscriptionError = void 0;
  var Eit = ld();
  DA.UnsubscriptionError = Eit.createErrorClass(function (e) {
    return function (r) {
      e(this),
        (this.message = r
          ? r.length +
            ` errors occurred during unsubscription:
` +
            r.map(function (n, i) {
              return i + 1 + ") " + n.toString();
            }).join(`
  `)
          : ""),
        (this.name = "UnsubscriptionError"),
        (this.errors = r);
    };
  });
});
var Fu = g((LA) => {
  "use strict";
  c();
  Object.defineProperty(LA, "__esModule", { value: !0 });
  LA.arrRemove = void 0;
  function bit(e, t) {
    if (e) {
      var r = e.indexOf(t);
      0 <= r && e.splice(r, 1);
    }
  }
  LA.arrRemove = bit;
});
var Jo = g((vo) => {
  "use strict";
  c();
  var Aie =
      (vo && vo.__values) ||
      function (e) {
        var t = typeof Symbol == "function" && Symbol.iterator,
          r = t && e[t],
          n = 0;
        if (r) return r.call(e);
        if (e && typeof e.length == "number")
          return {
            next: function () {
              return (
                e && n >= e.length && (e = void 0),
                { value: e && e[n++], done: !e }
              );
            },
          };
        throw new TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined.",
        );
      },
    Pie =
      (vo && vo.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Rie =
      (vo && vo.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(vo, "__esModule", { value: !0 });
  vo.isSubscription = vo.EMPTY_SUBSCRIPTION = vo.Subscription = void 0;
  var CS = Jt(),
    B3 = F3(),
    Iie = Fu(),
    U3 = (function () {
      function e(t) {
        (this.initialTeardown = t),
          (this.closed = !1),
          (this._parentage = null),
          (this._finalizers = null);
      }
      return (
        (e.prototype.unsubscribe = function () {
          var t, r, n, i, o;
          if (!this.closed) {
            this.closed = !0;
            var a = this._parentage;
            if (a)
              if (((this._parentage = null), Array.isArray(a)))
                try {
                  for (var s = Aie(a), u = s.next(); !u.done; u = s.next()) {
                    var l = u.value;
                    l.remove(this);
                  }
                } catch (_) {
                  t = { error: _ };
                } finally {
                  try {
                    u && !u.done && (r = s.return) && r.call(s);
                  } finally {
                    if (t) throw t.error;
                  }
                }
              else a.remove(this);
            var d = this.initialTeardown;
            if (CS.isFunction(d))
              try {
                d();
              } catch (_) {
                o = _ instanceof B3.UnsubscriptionError ? _.errors : [_];
              }
            var f = this._finalizers;
            if (f) {
              this._finalizers = null;
              try {
                for (var m = Aie(f), h = m.next(); !h.done; h = m.next()) {
                  var y = h.value;
                  try {
                    xie(y);
                  } catch (_) {
                    (o = o ?? []),
                      _ instanceof B3.UnsubscriptionError
                        ? (o = Rie(Rie([], Pie(o)), Pie(_.errors)))
                        : o.push(_);
                  }
                }
              } catch (_) {
                n = { error: _ };
              } finally {
                try {
                  h && !h.done && (i = m.return) && i.call(m);
                } finally {
                  if (n) throw n.error;
                }
              }
            }
            if (o) throw new B3.UnsubscriptionError(o);
          }
        }),
        (e.prototype.add = function (t) {
          var r;
          if (t && t !== this)
            if (this.closed) xie(t);
            else {
              if (t instanceof e) {
                if (t.closed || t._hasParent(this)) return;
                t._addParent(this);
              }
              (this._finalizers =
                (r = this._finalizers) !== null && r !== void 0 ? r : []).push(
                t,
              );
            }
        }),
        (e.prototype._hasParent = function (t) {
          var r = this._parentage;
          return r === t || (Array.isArray(r) && r.includes(t));
        }),
        (e.prototype._addParent = function (t) {
          var r = this._parentage;
          this._parentage = Array.isArray(r) ? (r.push(t), r) : r ? [r, t] : t;
        }),
        (e.prototype._removeParent = function (t) {
          var r = this._parentage;
          r === t
            ? (this._parentage = null)
            : Array.isArray(r) && Iie.arrRemove(r, t);
        }),
        (e.prototype.remove = function (t) {
          var r = this._finalizers;
          r && Iie.arrRemove(r, t), t instanceof e && t._removeParent(this);
        }),
        (e.EMPTY = (function () {
          var t = new e();
          return (t.closed = !0), t;
        })()),
        e
      );
    })();
  vo.Subscription = U3;
  vo.EMPTY_SUBSCRIPTION = U3.EMPTY;
  function Sit(e) {
    return (
      e instanceof U3 ||
      (e &&
        "closed" in e &&
        CS.isFunction(e.remove) &&
        CS.isFunction(e.add) &&
        CS.isFunction(e.unsubscribe))
    );
  }
  vo.isSubscription = Sit;
  function xie(e) {
    CS.isFunction(e) ? e() : e.unsubscribe();
  }
});
var Jg = g((MA) => {
  "use strict";
  c();
  Object.defineProperty(MA, "__esModule", { value: !0 });
  MA.config = void 0;
  MA.config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: !1,
    useDeprecatedNextContext: !1,
  };
});
var H3 = g((hc) => {
  "use strict";
  c();
  var Nie =
      (hc && hc.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    kie =
      (hc && hc.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(hc, "__esModule", { value: !0 });
  hc.timeoutProvider = void 0;
  hc.timeoutProvider = {
    setTimeout: function (e, t) {
      for (var r = [], n = 2; n < arguments.length; n++)
        r[n - 2] = arguments[n];
      var i = hc.timeoutProvider.delegate;
      return i?.setTimeout
        ? i.setTimeout.apply(i, kie([e, t], Nie(r)))
        : setTimeout.apply(void 0, kie([e, t], Nie(r)));
    },
    clearTimeout: function (e) {
      var t = hc.timeoutProvider.delegate;
      return (t?.clearTimeout || clearTimeout)(e);
    },
    delegate: void 0,
  };
});
var G3 = g((qA) => {
  "use strict";
  c();
  Object.defineProperty(qA, "__esModule", { value: !0 });
  qA.reportUnhandledError = void 0;
  var Cit = Jg(),
    wit = H3();
  function Oit(e) {
    wit.timeoutProvider.setTimeout(function () {
      var t = Cit.config.onUnhandledError;
      if (t) t(e);
      else throw e;
    });
  }
  qA.reportUnhandledError = Oit;
});
var mi = g((jA) => {
  "use strict";
  c();
  Object.defineProperty(jA, "__esModule", { value: !0 });
  jA.noop = void 0;
  function Tit() {}
  jA.noop = Tit;
});
var Die = g((gc) => {
  "use strict";
  c();
  Object.defineProperty(gc, "__esModule", { value: !0 });
  gc.createNotification =
    gc.nextNotification =
    gc.errorNotification =
    gc.COMPLETE_NOTIFICATION =
      void 0;
  gc.COMPLETE_NOTIFICATION = (function () {
    return FA("C", void 0, void 0);
  })();
  function Ait(e) {
    return FA("E", void 0, e);
  }
  gc.errorNotification = Ait;
  function Pit(e) {
    return FA("N", e, void 0);
  }
  gc.nextNotification = Pit;
  function FA(e, t, r) {
    return { kind: e, value: t, error: r };
  }
  gc.createNotification = FA;
});
var BA = g((Zg) => {
  "use strict";
  c();
  Object.defineProperty(Zg, "__esModule", { value: !0 });
  Zg.captureError = Zg.errorContext = void 0;
  var Lie = Jg(),
    zp = null;
  function Rit(e) {
    if (Lie.config.useDeprecatedSynchronousErrorHandling) {
      var t = !zp;
      if ((t && (zp = { errorThrown: !1, error: null }), e(), t)) {
        var r = zp,
          n = r.errorThrown,
          i = r.error;
        if (((zp = null), n)) throw i;
      }
    } else e();
  }
  Zg.errorContext = Rit;
  function Iit(e) {
    Lie.config.useDeprecatedSynchronousErrorHandling &&
      zp &&
      ((zp.errorThrown = !0), (zp.error = e));
  }
  Zg.captureError = Iit;
});
var ev = g((Ps) => {
  "use strict";
  c();
  var jie =
    (Ps && Ps.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(Ps, "__esModule", { value: !0 });
  Ps.EMPTY_OBSERVER = Ps.SafeSubscriber = Ps.Subscriber = void 0;
  var xit = Jt(),
    Mie = Jo(),
    K3 = Jg(),
    Nit = G3(),
    qie = mi(),
    V3 = Die(),
    kit = H3(),
    Dit = BA(),
    Fie = (function (e) {
      jie(t, e);
      function t(r) {
        var n = e.call(this) || this;
        return (
          (n.isStopped = !1),
          r
            ? ((n.destination = r), Mie.isSubscription(r) && r.add(n))
            : (n.destination = Ps.EMPTY_OBSERVER),
          n
        );
      }
      return (
        (t.create = function (r, n, i) {
          return new Bie(r, n, i);
        }),
        (t.prototype.next = function (r) {
          this.isStopped ? z3(V3.nextNotification(r), this) : this._next(r);
        }),
        (t.prototype.error = function (r) {
          this.isStopped
            ? z3(V3.errorNotification(r), this)
            : ((this.isStopped = !0), this._error(r));
        }),
        (t.prototype.complete = function () {
          this.isStopped
            ? z3(V3.COMPLETE_NOTIFICATION, this)
            : ((this.isStopped = !0), this._complete());
        }),
        (t.prototype.unsubscribe = function () {
          this.closed ||
            ((this.isStopped = !0),
            e.prototype.unsubscribe.call(this),
            (this.destination = null));
        }),
        (t.prototype._next = function (r) {
          this.destination.next(r);
        }),
        (t.prototype._error = function (r) {
          try {
            this.destination.error(r);
          } finally {
            this.unsubscribe();
          }
        }),
        (t.prototype._complete = function () {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        }),
        t
      );
    })(Mie.Subscription);
  Ps.Subscriber = Fie;
  var Lit = Function.prototype.bind;
  function $3(e, t) {
    return Lit.call(e, t);
  }
  var Mit = (function () {
      function e(t) {
        this.partialObserver = t;
      }
      return (
        (e.prototype.next = function (t) {
          var r = this.partialObserver;
          if (r.next)
            try {
              r.next(t);
            } catch (n) {
              UA(n);
            }
        }),
        (e.prototype.error = function (t) {
          var r = this.partialObserver;
          if (r.error)
            try {
              r.error(t);
            } catch (n) {
              UA(n);
            }
          else UA(t);
        }),
        (e.prototype.complete = function () {
          var t = this.partialObserver;
          if (t.complete)
            try {
              t.complete();
            } catch (r) {
              UA(r);
            }
        }),
        e
      );
    })(),
    Bie = (function (e) {
      jie(t, e);
      function t(r, n, i) {
        var o = e.call(this) || this,
          a;
        if (xit.isFunction(r) || !r)
          a = { next: r ?? void 0, error: n ?? void 0, complete: i ?? void 0 };
        else {
          var s;
          o && K3.config.useDeprecatedNextContext
            ? ((s = Object.create(r)),
              (s.unsubscribe = function () {
                return o.unsubscribe();
              }),
              (a = {
                next: r.next && $3(r.next, s),
                error: r.error && $3(r.error, s),
                complete: r.complete && $3(r.complete, s),
              }))
            : (a = r);
        }
        return (o.destination = new Mit(a)), o;
      }
      return t;
    })(Fie);
  Ps.SafeSubscriber = Bie;
  function UA(e) {
    K3.config.useDeprecatedSynchronousErrorHandling
      ? Dit.captureError(e)
      : Nit.reportUnhandledError(e);
  }
  function qit(e) {
    throw e;
  }
  function z3(e, t) {
    var r = K3.config.onStoppedNotification;
    r &&
      kit.timeoutProvider.setTimeout(function () {
        return r(e, t);
      });
  }
  Ps.EMPTY_OBSERVER = {
    closed: !0,
    next: qie.noop,
    error: qit,
    complete: qie.noop,
  };
});
var wS = g((HA) => {
  "use strict";
  c();
  Object.defineProperty(HA, "__esModule", { value: !0 });
  HA.observable = void 0;
  HA.observable = (function () {
    return (typeof Symbol == "function" && Symbol.observable) || "@@observable";
  })();
});
var hi = g((GA) => {
  "use strict";
  c();
  Object.defineProperty(GA, "__esModule", { value: !0 });
  GA.identity = void 0;
  function jit(e) {
    return e;
  }
  GA.identity = jit;
});
var OS = g((tv) => {
  "use strict";
  c();
  Object.defineProperty(tv, "__esModule", { value: !0 });
  tv.pipeFromArray = tv.pipe = void 0;
  var Fit = hi();
  function Bit() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return Uie(e);
  }
  tv.pipe = Bit;
  function Uie(e) {
    return e.length === 0
      ? Fit.identity
      : e.length === 1
        ? e[0]
        : function (r) {
            return e.reduce(function (n, i) {
              return i(n);
            }, r);
          };
  }
  tv.pipeFromArray = Uie;
});
var ar = g((VA) => {
  "use strict";
  c();
  Object.defineProperty(VA, "__esModule", { value: !0 });
  VA.Observable = void 0;
  var Q3 = ev(),
    Uit = Jo(),
    Hit = wS(),
    Git = OS(),
    Vit = Jg(),
    W3 = Jt(),
    $it = BA(),
    zit = (function () {
      function e(t) {
        t && (this._subscribe = t);
      }
      return (
        (e.prototype.lift = function (t) {
          var r = new e();
          return (r.source = this), (r.operator = t), r;
        }),
        (e.prototype.subscribe = function (t, r, n) {
          var i = this,
            o = Wit(t) ? t : new Q3.SafeSubscriber(t, r, n);
          return (
            $it.errorContext(function () {
              var a = i,
                s = a.operator,
                u = a.source;
              o.add(
                s ? s.call(o, u) : u ? i._subscribe(o) : i._trySubscribe(o),
              );
            }),
            o
          );
        }),
        (e.prototype._trySubscribe = function (t) {
          try {
            return this._subscribe(t);
          } catch (r) {
            t.error(r);
          }
        }),
        (e.prototype.forEach = function (t, r) {
          var n = this;
          return (
            (r = Hie(r)),
            new r(function (i, o) {
              var a = new Q3.SafeSubscriber({
                next: function (s) {
                  try {
                    t(s);
                  } catch (u) {
                    o(u), a.unsubscribe();
                  }
                },
                error: o,
                complete: i,
              });
              n.subscribe(a);
            })
          );
        }),
        (e.prototype._subscribe = function (t) {
          var r;
          return (r = this.source) === null || r === void 0
            ? void 0
            : r.subscribe(t);
        }),
        (e.prototype[Hit.observable] = function () {
          return this;
        }),
        (e.prototype.pipe = function () {
          for (var t = [], r = 0; r < arguments.length; r++)
            t[r] = arguments[r];
          return Git.pipeFromArray(t)(this);
        }),
        (e.prototype.toPromise = function (t) {
          var r = this;
          return (
            (t = Hie(t)),
            new t(function (n, i) {
              var o;
              r.subscribe(
                function (a) {
                  return (o = a);
                },
                function (a) {
                  return i(a);
                },
                function () {
                  return n(o);
                },
              );
            })
          );
        }),
        (e.create = function (t) {
          return new e(t);
        }),
        e
      );
    })();
  VA.Observable = zit;
  function Hie(e) {
    var t;
    return (t = e ?? Vit.config.Promise) !== null && t !== void 0 ? t : Promise;
  }
  function Kit(e) {
    return (
      e &&
      W3.isFunction(e.next) &&
      W3.isFunction(e.error) &&
      W3.isFunction(e.complete)
    );
  }
  function Wit(e) {
    return (
      (e && e instanceof Q3.Subscriber) || (Kit(e) && Uit.isSubscription(e))
    );
  }
});
var ve = g((rv) => {
  "use strict";
  c();
  Object.defineProperty(rv, "__esModule", { value: !0 });
  rv.operate = rv.hasLift = void 0;
  var Qit = Jt();
  function Gie(e) {
    return Qit.isFunction(e?.lift);
  }
  rv.hasLift = Gie;
  function Yit(e) {
    return function (t) {
      if (Gie(t))
        return t.lift(function (r) {
          try {
            return e(r, this);
          } catch (n) {
            this.error(n);
          }
        });
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  rv.operate = Yit;
});
var ke = g((dd) => {
  "use strict";
  c();
  var Xit =
    (dd && dd.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(dd, "__esModule", { value: !0 });
  dd.OperatorSubscriber = dd.createOperatorSubscriber = void 0;
  var Jit = ev();
  function Zit(e, t, r, n, i) {
    return new Vie(e, t, r, n, i);
  }
  dd.createOperatorSubscriber = Zit;
  var Vie = (function (e) {
    Xit(t, e);
    function t(r, n, i, o, a, s) {
      var u = e.call(this, r) || this;
      return (
        (u.onFinalize = a),
        (u.shouldUnsubscribe = s),
        (u._next = n
          ? function (l) {
              try {
                n(l);
              } catch (d) {
                r.error(d);
              }
            }
          : e.prototype._next),
        (u._error = o
          ? function (l) {
              try {
                o(l);
              } catch (d) {
                r.error(d);
              } finally {
                this.unsubscribe();
              }
            }
          : e.prototype._error),
        (u._complete = i
          ? function () {
              try {
                i();
              } catch (l) {
                r.error(l);
              } finally {
                this.unsubscribe();
              }
            }
          : e.prototype._complete),
        u
      );
    }
    return (
      (t.prototype.unsubscribe = function () {
        var r;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var n = this.closed;
          e.prototype.unsubscribe.call(this),
            !n &&
              ((r = this.onFinalize) === null || r === void 0 || r.call(this));
        }
      }),
      t
    );
  })(Jit.Subscriber);
  dd.OperatorSubscriber = Vie;
});
var Y3 = g(($A) => {
  "use strict";
  c();
  Object.defineProperty($A, "__esModule", { value: !0 });
  $A.refCount = void 0;
  var eot = ve(),
    tot = ke();
  function rot() {
    return eot.operate(function (e, t) {
      var r = null;
      e._refCount++;
      var n = tot.createOperatorSubscriber(
        t,
        void 0,
        void 0,
        void 0,
        function () {
          if (!e || e._refCount <= 0 || 0 < --e._refCount) {
            r = null;
            return;
          }
          var i = e._connection,
            o = r;
          (r = null), i && (!o || i === o) && i.unsubscribe(), t.unsubscribe();
        },
      );
      e.subscribe(n), n.closed || (r = e.connect());
    });
  }
  $A.refCount = rot;
});
var TS = g((nv) => {
  "use strict";
  c();
  var not =
    (nv && nv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(nv, "__esModule", { value: !0 });
  nv.ConnectableObservable = void 0;
  var iot = ar(),
    $ie = Jo(),
    oot = Y3(),
    aot = ke(),
    sot = ve(),
    cot = (function (e) {
      not(t, e);
      function t(r, n) {
        var i = e.call(this) || this;
        return (
          (i.source = r),
          (i.subjectFactory = n),
          (i._subject = null),
          (i._refCount = 0),
          (i._connection = null),
          sot.hasLift(r) && (i.lift = r.lift),
          i
        );
      }
      return (
        (t.prototype._subscribe = function (r) {
          return this.getSubject().subscribe(r);
        }),
        (t.prototype.getSubject = function () {
          var r = this._subject;
          return (
            (!r || r.isStopped) && (this._subject = this.subjectFactory()),
            this._subject
          );
        }),
        (t.prototype._teardown = function () {
          this._refCount = 0;
          var r = this._connection;
          (this._subject = this._connection = null), r?.unsubscribe();
        }),
        (t.prototype.connect = function () {
          var r = this,
            n = this._connection;
          if (!n) {
            n = this._connection = new $ie.Subscription();
            var i = this.getSubject();
            n.add(
              this.source.subscribe(
                aot.createOperatorSubscriber(
                  i,
                  void 0,
                  function () {
                    r._teardown(), i.complete();
                  },
                  function (o) {
                    r._teardown(), i.error(o);
                  },
                  function () {
                    return r._teardown();
                  },
                ),
              ),
            ),
              n.closed &&
                ((this._connection = null), (n = $ie.Subscription.EMPTY));
          }
          return n;
        }),
        (t.prototype.refCount = function () {
          return oot.refCount()(this);
        }),
        t
      );
    })(iot.Observable);
  nv.ConnectableObservable = cot;
});
var zie = g((AS) => {
  "use strict";
  c();
  Object.defineProperty(AS, "__esModule", { value: !0 });
  AS.performanceTimestampProvider = void 0;
  AS.performanceTimestampProvider = {
    now: function () {
      return (AS.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: void 0,
  };
});
var X3 = g((Rs) => {
  "use strict";
  c();
  var Kie =
      (Rs && Rs.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Wie =
      (Rs && Rs.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Rs, "__esModule", { value: !0 });
  Rs.animationFrameProvider = void 0;
  var uot = Jo();
  Rs.animationFrameProvider = {
    schedule: function (e) {
      var t = requestAnimationFrame,
        r = cancelAnimationFrame,
        n = Rs.animationFrameProvider.delegate;
      n && ((t = n.requestAnimationFrame), (r = n.cancelAnimationFrame));
      var i = t(function (o) {
        (r = void 0), e(o);
      });
      return new uot.Subscription(function () {
        return r?.(i);
      });
    },
    requestAnimationFrame: function () {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      var r = Rs.animationFrameProvider.delegate;
      return (r?.requestAnimationFrame || requestAnimationFrame).apply(
        void 0,
        Wie([], Kie(e)),
      );
    },
    cancelAnimationFrame: function () {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      var r = Rs.animationFrameProvider.delegate;
      return (r?.cancelAnimationFrame || cancelAnimationFrame).apply(
        void 0,
        Wie([], Kie(e)),
      );
    },
    delegate: void 0,
  };
});
var Xie = g((zA) => {
  "use strict";
  c();
  Object.defineProperty(zA, "__esModule", { value: !0 });
  zA.animationFrames = void 0;
  var lot = ar(),
    dot = zie(),
    Qie = X3();
  function fot(e) {
    return e ? Yie(e) : pot;
  }
  zA.animationFrames = fot;
  function Yie(e) {
    return new lot.Observable(function (t) {
      var r = e || dot.performanceTimestampProvider,
        n = r.now(),
        i = 0,
        o = function () {
          t.closed ||
            (i = Qie.animationFrameProvider.requestAnimationFrame(function (a) {
              i = 0;
              var s = r.now();
              t.next({ timestamp: e ? s : a, elapsed: s - n }), o();
            }));
        };
      return (
        o(),
        function () {
          i && Qie.animationFrameProvider.cancelAnimationFrame(i);
        }
      );
    });
  }
  var pot = Yie();
});
var J3 = g((KA) => {
  "use strict";
  c();
  Object.defineProperty(KA, "__esModule", { value: !0 });
  KA.ObjectUnsubscribedError = void 0;
  var mot = ld();
  KA.ObjectUnsubscribedError = mot.createErrorClass(function (e) {
    return function () {
      e(this),
        (this.name = "ObjectUnsubscribedError"),
        (this.message = "object unsubscribed");
    };
  });
});
var gi = g((vc) => {
  "use strict";
  c();
  var Zie =
      (vc && vc.__extends) ||
      (function () {
        var e = function (t, r) {
          return (
            (e =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i;
                }) ||
              function (n, i) {
                for (var o in i)
                  Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
              }),
            e(t, r)
          );
        };
        return function (t, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError(
              "Class extends value " +
                String(r) +
                " is not a constructor or null",
            );
          e(t, r);
          function n() {
            this.constructor = t;
          }
          t.prototype =
            r === null
              ? Object.create(r)
              : ((n.prototype = r.prototype), new n());
        };
      })(),
    hot =
      (vc && vc.__values) ||
      function (e) {
        var t = typeof Symbol == "function" && Symbol.iterator,
          r = t && e[t],
          n = 0;
        if (r) return r.call(e);
        if (e && typeof e.length == "number")
          return {
            next: function () {
              return (
                e && n >= e.length && (e = void 0),
                { value: e && e[n++], done: !e }
              );
            },
          };
        throw new TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined.",
        );
      };
  Object.defineProperty(vc, "__esModule", { value: !0 });
  vc.AnonymousSubject = vc.Subject = void 0;
  var Jie = ar(),
    eG = Jo(),
    got = J3(),
    vot = Fu(),
    Z3 = BA(),
    eoe = (function (e) {
      Zie(t, e);
      function t() {
        var r = e.call(this) || this;
        return (
          (r.closed = !1),
          (r.currentObservers = null),
          (r.observers = []),
          (r.isStopped = !1),
          (r.hasError = !1),
          (r.thrownError = null),
          r
        );
      }
      return (
        (t.prototype.lift = function (r) {
          var n = new tG(this, this);
          return (n.operator = r), n;
        }),
        (t.prototype._throwIfClosed = function () {
          if (this.closed) throw new got.ObjectUnsubscribedError();
        }),
        (t.prototype.next = function (r) {
          var n = this;
          Z3.errorContext(function () {
            var i, o;
            if ((n._throwIfClosed(), !n.isStopped)) {
              n.currentObservers ||
                (n.currentObservers = Array.from(n.observers));
              try {
                for (
                  var a = hot(n.currentObservers), s = a.next();
                  !s.done;
                  s = a.next()
                ) {
                  var u = s.value;
                  u.next(r);
                }
              } catch (l) {
                i = { error: l };
              } finally {
                try {
                  s && !s.done && (o = a.return) && o.call(a);
                } finally {
                  if (i) throw i.error;
                }
              }
            }
          });
        }),
        (t.prototype.error = function (r) {
          var n = this;
          Z3.errorContext(function () {
            if ((n._throwIfClosed(), !n.isStopped)) {
              (n.hasError = n.isStopped = !0), (n.thrownError = r);
              for (var i = n.observers; i.length; ) i.shift().error(r);
            }
          });
        }),
        (t.prototype.complete = function () {
          var r = this;
          Z3.errorContext(function () {
            if ((r._throwIfClosed(), !r.isStopped)) {
              r.isStopped = !0;
              for (var n = r.observers; n.length; ) n.shift().complete();
            }
          });
        }),
        (t.prototype.unsubscribe = function () {
          (this.isStopped = this.closed = !0),
            (this.observers = this.currentObservers = null);
        }),
        Object.defineProperty(t.prototype, "observed", {
          get: function () {
            var r;
            return (
              ((r = this.observers) === null || r === void 0
                ? void 0
                : r.length) > 0
            );
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype._trySubscribe = function (r) {
          return this._throwIfClosed(), e.prototype._trySubscribe.call(this, r);
        }),
        (t.prototype._subscribe = function (r) {
          return (
            this._throwIfClosed(),
            this._checkFinalizedStatuses(r),
            this._innerSubscribe(r)
          );
        }),
        (t.prototype._innerSubscribe = function (r) {
          var n = this,
            i = this,
            o = i.hasError,
            a = i.isStopped,
            s = i.observers;
          return o || a
            ? eG.EMPTY_SUBSCRIPTION
            : ((this.currentObservers = null),
              s.push(r),
              new eG.Subscription(function () {
                (n.currentObservers = null), vot.arrRemove(s, r);
              }));
        }),
        (t.prototype._checkFinalizedStatuses = function (r) {
          var n = this,
            i = n.hasError,
            o = n.thrownError,
            a = n.isStopped;
          i ? r.error(o) : a && r.complete();
        }),
        (t.prototype.asObservable = function () {
          var r = new Jie.Observable();
          return (r.source = this), r;
        }),
        (t.create = function (r, n) {
          return new tG(r, n);
        }),
        t
      );
    })(Jie.Observable);
  vc.Subject = eoe;
  var tG = (function (e) {
    Zie(t, e);
    function t(r, n) {
      var i = e.call(this) || this;
      return (i.destination = r), (i.source = n), i;
    }
    return (
      (t.prototype.next = function (r) {
        var n, i;
        (i =
          (n = this.destination) === null || n === void 0 ? void 0 : n.next) ===
          null ||
          i === void 0 ||
          i.call(n, r);
      }),
      (t.prototype.error = function (r) {
        var n, i;
        (i =
          (n = this.destination) === null || n === void 0
            ? void 0
            : n.error) === null ||
          i === void 0 ||
          i.call(n, r);
      }),
      (t.prototype.complete = function () {
        var r, n;
        (n =
          (r = this.destination) === null || r === void 0
            ? void 0
            : r.complete) === null ||
          n === void 0 ||
          n.call(r);
      }),
      (t.prototype._subscribe = function (r) {
        var n, i;
        return (i =
          (n = this.source) === null || n === void 0
            ? void 0
            : n.subscribe(r)) !== null && i !== void 0
          ? i
          : eG.EMPTY_SUBSCRIPTION;
      }),
      t
    );
  })(eoe);
  vc.AnonymousSubject = tG;
});
var rG = g((iv) => {
  "use strict";
  c();
  var yot =
    (iv && iv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(iv, "__esModule", { value: !0 });
  iv.BehaviorSubject = void 0;
  var _ot = gi(),
    Eot = (function (e) {
      yot(t, e);
      function t(r) {
        var n = e.call(this) || this;
        return (n._value = r), n;
      }
      return (
        Object.defineProperty(t.prototype, "value", {
          get: function () {
            return this.getValue();
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype._subscribe = function (r) {
          var n = e.prototype._subscribe.call(this, r);
          return !n.closed && r.next(this._value), n;
        }),
        (t.prototype.getValue = function () {
          var r = this,
            n = r.hasError,
            i = r.thrownError,
            o = r._value;
          if (n) throw i;
          return this._throwIfClosed(), o;
        }),
        (t.prototype.next = function (r) {
          e.prototype.next.call(this, (this._value = r));
        }),
        t
      );
    })(_ot.Subject);
  iv.BehaviorSubject = Eot;
});
var WA = g((PS) => {
  "use strict";
  c();
  Object.defineProperty(PS, "__esModule", { value: !0 });
  PS.dateTimestampProvider = void 0;
  PS.dateTimestampProvider = {
    now: function () {
      return (PS.dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0,
  };
});
var QA = g((ov) => {
  "use strict";
  c();
  var bot =
    (ov && ov.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(ov, "__esModule", { value: !0 });
  ov.ReplaySubject = void 0;
  var Sot = gi(),
    Cot = WA(),
    wot = (function (e) {
      bot(t, e);
      function t(r, n, i) {
        r === void 0 && (r = 1 / 0),
          n === void 0 && (n = 1 / 0),
          i === void 0 && (i = Cot.dateTimestampProvider);
        var o = e.call(this) || this;
        return (
          (o._bufferSize = r),
          (o._windowTime = n),
          (o._timestampProvider = i),
          (o._buffer = []),
          (o._infiniteTimeWindow = !0),
          (o._infiniteTimeWindow = n === 1 / 0),
          (o._bufferSize = Math.max(1, r)),
          (o._windowTime = Math.max(1, n)),
          o
        );
      }
      return (
        (t.prototype.next = function (r) {
          var n = this,
            i = n.isStopped,
            o = n._buffer,
            a = n._infiniteTimeWindow,
            s = n._timestampProvider,
            u = n._windowTime;
          i || (o.push(r), !a && o.push(s.now() + u)),
            this._trimBuffer(),
            e.prototype.next.call(this, r);
        }),
        (t.prototype._subscribe = function (r) {
          this._throwIfClosed(), this._trimBuffer();
          for (
            var n = this._innerSubscribe(r),
              i = this,
              o = i._infiniteTimeWindow,
              a = i._buffer,
              s = a.slice(),
              u = 0;
            u < s.length && !r.closed;
            u += o ? 1 : 2
          )
            r.next(s[u]);
          return this._checkFinalizedStatuses(r), n;
        }),
        (t.prototype._trimBuffer = function () {
          var r = this,
            n = r._bufferSize,
            i = r._timestampProvider,
            o = r._buffer,
            a = r._infiniteTimeWindow,
            s = (a ? 1 : 2) * n;
          if ((n < 1 / 0 && s < o.length && o.splice(0, o.length - s), !a)) {
            for (
              var u = i.now(), l = 0, d = 1;
              d < o.length && o[d] <= u;
              d += 2
            )
              l = d;
            l && o.splice(0, l + 1);
          }
        }),
        t
      );
    })(Sot.Subject);
  ov.ReplaySubject = wot;
});
var YA = g((av) => {
  "use strict";
  c();
  var Oot =
    (av && av.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(av, "__esModule", { value: !0 });
  av.AsyncSubject = void 0;
  var Tot = gi(),
    Aot = (function (e) {
      Oot(t, e);
      function t() {
        var r = (e !== null && e.apply(this, arguments)) || this;
        return (r._value = null), (r._hasValue = !1), (r._isComplete = !1), r;
      }
      return (
        (t.prototype._checkFinalizedStatuses = function (r) {
          var n = this,
            i = n.hasError,
            o = n._hasValue,
            a = n._value,
            s = n.thrownError,
            u = n.isStopped,
            l = n._isComplete;
          i ? r.error(s) : (u || l) && (o && r.next(a), r.complete());
        }),
        (t.prototype.next = function (r) {
          this.isStopped || ((this._value = r), (this._hasValue = !0));
        }),
        (t.prototype.complete = function () {
          var r = this,
            n = r._hasValue,
            i = r._value,
            o = r._isComplete;
          o ||
            ((this._isComplete = !0),
            n && e.prototype.next.call(this, i),
            e.prototype.complete.call(this));
        }),
        t
      );
    })(Tot.Subject);
  av.AsyncSubject = Aot;
});
var toe = g((sv) => {
  "use strict";
  c();
  var Pot =
    (sv && sv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(sv, "__esModule", { value: !0 });
  sv.Action = void 0;
  var Rot = Jo(),
    Iot = (function (e) {
      Pot(t, e);
      function t(r, n) {
        return e.call(this) || this;
      }
      return (
        (t.prototype.schedule = function (r, n) {
          return n === void 0 && (n = 0), this;
        }),
        t
      );
    })(Rot.Subscription);
  sv.Action = Iot;
});
var ioe = g((yc) => {
  "use strict";
  c();
  var roe =
      (yc && yc.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    noe =
      (yc && yc.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(yc, "__esModule", { value: !0 });
  yc.intervalProvider = void 0;
  yc.intervalProvider = {
    setInterval: function (e, t) {
      for (var r = [], n = 2; n < arguments.length; n++)
        r[n - 2] = arguments[n];
      var i = yc.intervalProvider.delegate;
      return i?.setInterval
        ? i.setInterval.apply(i, noe([e, t], roe(r)))
        : setInterval.apply(void 0, noe([e, t], roe(r)));
    },
    clearInterval: function (e) {
      var t = yc.intervalProvider.delegate;
      return (t?.clearInterval || clearInterval)(e);
    },
    delegate: void 0,
  };
});
var uv = g((cv) => {
  "use strict";
  c();
  var xot =
    (cv && cv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(cv, "__esModule", { value: !0 });
  cv.AsyncAction = void 0;
  var Not = toe(),
    ooe = ioe(),
    kot = Fu(),
    Dot = (function (e) {
      xot(t, e);
      function t(r, n) {
        var i = e.call(this, r, n) || this;
        return (i.scheduler = r), (i.work = n), (i.pending = !1), i;
      }
      return (
        (t.prototype.schedule = function (r, n) {
          var i;
          if ((n === void 0 && (n = 0), this.closed)) return this;
          this.state = r;
          var o = this.id,
            a = this.scheduler;
          return (
            o != null && (this.id = this.recycleAsyncId(a, o, n)),
            (this.pending = !0),
            (this.delay = n),
            (this.id =
              (i = this.id) !== null && i !== void 0
                ? i
                : this.requestAsyncId(a, this.id, n)),
            this
          );
        }),
        (t.prototype.requestAsyncId = function (r, n, i) {
          return (
            i === void 0 && (i = 0),
            ooe.intervalProvider.setInterval(r.flush.bind(r, this), i)
          );
        }),
        (t.prototype.recycleAsyncId = function (r, n, i) {
          if (
            (i === void 0 && (i = 0),
            i != null && this.delay === i && this.pending === !1)
          )
            return n;
          n != null && ooe.intervalProvider.clearInterval(n);
        }),
        (t.prototype.execute = function (r, n) {
          if (this.closed) return new Error("executing a cancelled action");
          this.pending = !1;
          var i = this._execute(r, n);
          if (i) return i;
          this.pending === !1 &&
            this.id != null &&
            (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }),
        (t.prototype._execute = function (r, n) {
          var i = !1,
            o;
          try {
            this.work(r);
          } catch (a) {
            (i = !0),
              (o = a || new Error("Scheduled action threw falsy error"));
          }
          if (i) return this.unsubscribe(), o;
        }),
        (t.prototype.unsubscribe = function () {
          if (!this.closed) {
            var r = this,
              n = r.id,
              i = r.scheduler,
              o = i.actions;
            (this.work = this.state = this.scheduler = null),
              (this.pending = !1),
              kot.arrRemove(o, this),
              n != null && (this.id = this.recycleAsyncId(i, n, null)),
              (this.delay = null),
              e.prototype.unsubscribe.call(this);
          }
        }),
        t
      );
    })(Not.Action);
  cv.AsyncAction = Dot;
});
var soe = g((lv) => {
  "use strict";
  c();
  Object.defineProperty(lv, "__esModule", { value: !0 });
  lv.TestTools = lv.Immediate = void 0;
  var Lot = 1,
    nG,
    XA = {};
  function aoe(e) {
    return e in XA ? (delete XA[e], !0) : !1;
  }
  lv.Immediate = {
    setImmediate: function (e) {
      var t = Lot++;
      return (
        (XA[t] = !0),
        nG || (nG = Promise.resolve()),
        nG.then(function () {
          return aoe(t) && e();
        }),
        t
      );
    },
    clearImmediate: function (e) {
      aoe(e);
    },
  };
  lv.TestTools = {
    pending: function () {
      return Object.keys(XA).length;
    },
  };
});
var uoe = g((_c) => {
  "use strict";
  c();
  var Mot =
      (_c && _c.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    qot =
      (_c && _c.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(_c, "__esModule", { value: !0 });
  _c.immediateProvider = void 0;
  var coe = soe(),
    jot = coe.Immediate.setImmediate,
    Fot = coe.Immediate.clearImmediate;
  _c.immediateProvider = {
    setImmediate: function () {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      var r = _c.immediateProvider.delegate;
      return (r?.setImmediate || jot).apply(void 0, qot([], Mot(e)));
    },
    clearImmediate: function (e) {
      var t = _c.immediateProvider.delegate;
      return (t?.clearImmediate || Fot)(e);
    },
    delegate: void 0,
  };
});
var doe = g((dv) => {
  "use strict";
  c();
  var Bot =
    (dv && dv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(dv, "__esModule", { value: !0 });
  dv.AsapAction = void 0;
  var Uot = uv(),
    loe = uoe(),
    Hot = (function (e) {
      Bot(t, e);
      function t(r, n) {
        var i = e.call(this, r, n) || this;
        return (i.scheduler = r), (i.work = n), i;
      }
      return (
        (t.prototype.requestAsyncId = function (r, n, i) {
          return (
            i === void 0 && (i = 0),
            i !== null && i > 0
              ? e.prototype.requestAsyncId.call(this, r, n, i)
              : (r.actions.push(this),
                r._scheduled ||
                  (r._scheduled = loe.immediateProvider.setImmediate(
                    r.flush.bind(r, void 0),
                  )))
          );
        }),
        (t.prototype.recycleAsyncId = function (r, n, i) {
          var o;
          if ((i === void 0 && (i = 0), i != null ? i > 0 : this.delay > 0))
            return e.prototype.recycleAsyncId.call(this, r, n, i);
          var a = r.actions;
          n != null &&
            ((o = a[a.length - 1]) === null || o === void 0 ? void 0 : o.id) !==
              n &&
            (loe.immediateProvider.clearImmediate(n),
            r._scheduled === n && (r._scheduled = void 0));
        }),
        t
      );
    })(Uot.AsyncAction);
  dv.AsapAction = Hot;
});
var iG = g((JA) => {
  "use strict";
  c();
  Object.defineProperty(JA, "__esModule", { value: !0 });
  JA.Scheduler = void 0;
  var Got = WA(),
    Vot = (function () {
      function e(t, r) {
        r === void 0 && (r = e.now),
          (this.schedulerActionCtor = t),
          (this.now = r);
      }
      return (
        (e.prototype.schedule = function (t, r, n) {
          return (
            r === void 0 && (r = 0),
            new this.schedulerActionCtor(this, t).schedule(n, r)
          );
        }),
        (e.now = Got.dateTimestampProvider.now),
        e
      );
    })();
  JA.Scheduler = Vot;
});
var pv = g((fv) => {
  "use strict";
  c();
  var $ot =
    (fv && fv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(fv, "__esModule", { value: !0 });
  fv.AsyncScheduler = void 0;
  var foe = iG(),
    zot = (function (e) {
      $ot(t, e);
      function t(r, n) {
        n === void 0 && (n = foe.Scheduler.now);
        var i = e.call(this, r, n) || this;
        return (i.actions = []), (i._active = !1), i;
      }
      return (
        (t.prototype.flush = function (r) {
          var n = this.actions;
          if (this._active) {
            n.push(r);
            return;
          }
          var i;
          this._active = !0;
          do if ((i = r.execute(r.state, r.delay))) break;
          while ((r = n.shift()));
          if (((this._active = !1), i)) {
            for (; (r = n.shift()); ) r.unsubscribe();
            throw i;
          }
        }),
        t
      );
    })(foe.Scheduler);
  fv.AsyncScheduler = zot;
});
var poe = g((mv) => {
  "use strict";
  c();
  var Kot =
    (mv && mv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(mv, "__esModule", { value: !0 });
  mv.AsapScheduler = void 0;
  var Wot = pv(),
    Qot = (function (e) {
      Kot(t, e);
      function t() {
        return (e !== null && e.apply(this, arguments)) || this;
      }
      return (
        (t.prototype.flush = function (r) {
          this._active = !0;
          var n = this._scheduled;
          this._scheduled = void 0;
          var i = this.actions,
            o;
          r = r || i.shift();
          do if ((o = r.execute(r.state, r.delay))) break;
          while ((r = i[0]) && r.id === n && i.shift());
          if (((this._active = !1), o)) {
            for (; (r = i[0]) && r.id === n && i.shift(); ) r.unsubscribe();
            throw o;
          }
        }),
        t
      );
    })(Wot.AsyncScheduler);
  mv.AsapScheduler = Qot;
});
var moe = g((Kp) => {
  "use strict";
  c();
  Object.defineProperty(Kp, "__esModule", { value: !0 });
  Kp.asap = Kp.asapScheduler = void 0;
  var Yot = doe(),
    Xot = poe();
  Kp.asapScheduler = new Xot.AsapScheduler(Yot.AsapAction);
  Kp.asap = Kp.asapScheduler;
});
var yo = g((Wp) => {
  "use strict";
  c();
  Object.defineProperty(Wp, "__esModule", { value: !0 });
  Wp.async = Wp.asyncScheduler = void 0;
  var Jot = uv(),
    Zot = pv();
  Wp.asyncScheduler = new Zot.AsyncScheduler(Jot.AsyncAction);
  Wp.async = Wp.asyncScheduler;
});
var hoe = g((hv) => {
  "use strict";
  c();
  var eat =
    (hv && hv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(hv, "__esModule", { value: !0 });
  hv.QueueAction = void 0;
  var tat = uv(),
    rat = (function (e) {
      eat(t, e);
      function t(r, n) {
        var i = e.call(this, r, n) || this;
        return (i.scheduler = r), (i.work = n), i;
      }
      return (
        (t.prototype.schedule = function (r, n) {
          return (
            n === void 0 && (n = 0),
            n > 0
              ? e.prototype.schedule.call(this, r, n)
              : ((this.delay = n),
                (this.state = r),
                this.scheduler.flush(this),
                this)
          );
        }),
        (t.prototype.execute = function (r, n) {
          return n > 0 || this.closed
            ? e.prototype.execute.call(this, r, n)
            : this._execute(r, n);
        }),
        (t.prototype.requestAsyncId = function (r, n, i) {
          return (
            i === void 0 && (i = 0),
            (i != null && i > 0) || (i == null && this.delay > 0)
              ? e.prototype.requestAsyncId.call(this, r, n, i)
              : (r.flush(this), 0)
          );
        }),
        t
      );
    })(tat.AsyncAction);
  hv.QueueAction = rat;
});
var goe = g((gv) => {
  "use strict";
  c();
  var nat =
    (gv && gv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(gv, "__esModule", { value: !0 });
  gv.QueueScheduler = void 0;
  var iat = pv(),
    oat = (function (e) {
      nat(t, e);
      function t() {
        return (e !== null && e.apply(this, arguments)) || this;
      }
      return t;
    })(iat.AsyncScheduler);
  gv.QueueScheduler = oat;
});
var voe = g((Qp) => {
  "use strict";
  c();
  Object.defineProperty(Qp, "__esModule", { value: !0 });
  Qp.queue = Qp.queueScheduler = void 0;
  var aat = hoe(),
    sat = goe();
  Qp.queueScheduler = new sat.QueueScheduler(aat.QueueAction);
  Qp.queue = Qp.queueScheduler;
});
var _oe = g((vv) => {
  "use strict";
  c();
  var cat =
    (vv && vv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(vv, "__esModule", { value: !0 });
  vv.AnimationFrameAction = void 0;
  var uat = uv(),
    yoe = X3(),
    lat = (function (e) {
      cat(t, e);
      function t(r, n) {
        var i = e.call(this, r, n) || this;
        return (i.scheduler = r), (i.work = n), i;
      }
      return (
        (t.prototype.requestAsyncId = function (r, n, i) {
          return (
            i === void 0 && (i = 0),
            i !== null && i > 0
              ? e.prototype.requestAsyncId.call(this, r, n, i)
              : (r.actions.push(this),
                r._scheduled ||
                  (r._scheduled =
                    yoe.animationFrameProvider.requestAnimationFrame(
                      function () {
                        return r.flush(void 0);
                      },
                    )))
          );
        }),
        (t.prototype.recycleAsyncId = function (r, n, i) {
          var o;
          if ((i === void 0 && (i = 0), i != null ? i > 0 : this.delay > 0))
            return e.prototype.recycleAsyncId.call(this, r, n, i);
          var a = r.actions;
          n != null &&
            n === r._scheduled &&
            ((o = a[a.length - 1]) === null || o === void 0 ? void 0 : o.id) !==
              n &&
            (yoe.animationFrameProvider.cancelAnimationFrame(n),
            (r._scheduled = void 0));
        }),
        t
      );
    })(uat.AsyncAction);
  vv.AnimationFrameAction = lat;
});
var Eoe = g((yv) => {
  "use strict";
  c();
  var dat =
    (yv && yv.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(yv, "__esModule", { value: !0 });
  yv.AnimationFrameScheduler = void 0;
  var fat = pv(),
    pat = (function (e) {
      dat(t, e);
      function t() {
        return (e !== null && e.apply(this, arguments)) || this;
      }
      return (
        (t.prototype.flush = function (r) {
          this._active = !0;
          var n;
          r ? (n = r.id) : ((n = this._scheduled), (this._scheduled = void 0));
          var i = this.actions,
            o;
          r = r || i.shift();
          do if ((o = r.execute(r.state, r.delay))) break;
          while ((r = i[0]) && r.id === n && i.shift());
          if (((this._active = !1), o)) {
            for (; (r = i[0]) && r.id === n && i.shift(); ) r.unsubscribe();
            throw o;
          }
        }),
        t
      );
    })(fat.AsyncScheduler);
  yv.AnimationFrameScheduler = pat;
});
var boe = g((Yp) => {
  "use strict";
  c();
  Object.defineProperty(Yp, "__esModule", { value: !0 });
  Yp.animationFrame = Yp.animationFrameScheduler = void 0;
  var mat = _oe(),
    hat = Eoe();
  Yp.animationFrameScheduler = new hat.AnimationFrameScheduler(
    mat.AnimationFrameAction,
  );
  Yp.animationFrame = Yp.animationFrameScheduler;
});
var woe = g((fd) => {
  "use strict";
  c();
  var Soe =
    (fd && fd.__extends) ||
    (function () {
      var e = function (t, r) {
        return (
          (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i;
              }) ||
            function (n, i) {
              for (var o in i)
                Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
            }),
          e(t, r)
        );
      };
      return function (t, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " +
              String(r) +
              " is not a constructor or null",
          );
        e(t, r);
        function n() {
          this.constructor = t;
        }
        t.prototype =
          r === null
            ? Object.create(r)
            : ((n.prototype = r.prototype), new n());
      };
    })();
  Object.defineProperty(fd, "__esModule", { value: !0 });
  fd.VirtualAction = fd.VirtualTimeScheduler = void 0;
  var gat = uv(),
    vat = Jo(),
    yat = pv(),
    _at = (function (e) {
      Soe(t, e);
      function t(r, n) {
        r === void 0 && (r = Coe), n === void 0 && (n = 1 / 0);
        var i =
          e.call(this, r, function () {
            return i.frame;
          }) || this;
        return (i.maxFrames = n), (i.frame = 0), (i.index = -1), i;
      }
      return (
        (t.prototype.flush = function () {
          for (
            var r = this, n = r.actions, i = r.maxFrames, o, a;
            (a = n[0]) &&
            a.delay <= i &&
            (n.shift(),
            (this.frame = a.delay),
            !(o = a.execute(a.state, a.delay)));

          );
          if (o) {
            for (; (a = n.shift()); ) a.unsubscribe();
            throw o;
          }
        }),
        (t.frameTimeFactor = 10),
        t
      );
    })(yat.AsyncScheduler);
  fd.VirtualTimeScheduler = _at;
  var Coe = (function (e) {
    Soe(t, e);
    function t(r, n, i) {
      i === void 0 && (i = r.index += 1);
      var o = e.call(this, r, n) || this;
      return (
        (o.scheduler = r),
        (o.work = n),
        (o.index = i),
        (o.active = !0),
        (o.index = r.index = i),
        o
      );
    }
    return (
      (t.prototype.schedule = function (r, n) {
        if ((n === void 0 && (n = 0), Number.isFinite(n))) {
          if (!this.id) return e.prototype.schedule.call(this, r, n);
          this.active = !1;
          var i = new t(this.scheduler, this.work);
          return this.add(i), i.schedule(r, n);
        } else return vat.Subscription.EMPTY;
      }),
      (t.prototype.requestAsyncId = function (r, n, i) {
        i === void 0 && (i = 0), (this.delay = r.frame + i);
        var o = r.actions;
        return o.push(this), o.sort(t.sortActions), 1;
      }),
      (t.prototype.recycleAsyncId = function (r, n, i) {
        i === void 0 && (i = 0);
      }),
      (t.prototype._execute = function (r, n) {
        if (this.active === !0) return e.prototype._execute.call(this, r, n);
      }),
      (t.sortActions = function (r, n) {
        return r.delay === n.delay
          ? r.index === n.index
            ? 0
            : r.index > n.index
              ? 1
              : -1
          : r.delay > n.delay
            ? 1
            : -1;
      }),
      t
    );
  })(gat.AsyncAction);
  fd.VirtualAction = Coe;
});
var Is = g((Xp) => {
  "use strict";
  c();
  Object.defineProperty(Xp, "__esModule", { value: !0 });
  Xp.empty = Xp.EMPTY = void 0;
  var Ooe = ar();
  Xp.EMPTY = new Ooe.Observable(function (e) {
    return e.complete();
  });
  function Eat(e) {
    return e ? bat(e) : Xp.EMPTY;
  }
  Xp.empty = Eat;
  function bat(e) {
    return new Ooe.Observable(function (t) {
      return e.schedule(function () {
        return t.complete();
      });
    });
  }
});
var RS = g((ZA) => {
  "use strict";
  c();
  Object.defineProperty(ZA, "__esModule", { value: !0 });
  ZA.isScheduler = void 0;
  var Sat = Jt();
  function Cat(e) {
    return e && Sat.isFunction(e.schedule);
  }
  ZA.isScheduler = Cat;
});
var _o = g((pd) => {
  "use strict";
  c();
  Object.defineProperty(pd, "__esModule", { value: !0 });
  pd.popNumber = pd.popScheduler = pd.popResultSelector = void 0;
  var wat = Jt(),
    Oat = RS();
  function oG(e) {
    return e[e.length - 1];
  }
  function Tat(e) {
    return wat.isFunction(oG(e)) ? e.pop() : void 0;
  }
  pd.popResultSelector = Tat;
  function Aat(e) {
    return Oat.isScheduler(oG(e)) ? e.pop() : void 0;
  }
  pd.popScheduler = Aat;
  function Pat(e, t) {
    return typeof oG(e) == "number" ? e.pop() : t;
  }
  pd.popNumber = Pat;
});
var tP = g((eP) => {
  "use strict";
  c();
  Object.defineProperty(eP, "__esModule", { value: !0 });
  eP.isArrayLike = void 0;
  eP.isArrayLike = function (e) {
    return e && typeof e.length == "number" && typeof e != "function";
  };
});
var aG = g((rP) => {
  "use strict";
  c();
  Object.defineProperty(rP, "__esModule", { value: !0 });
  rP.isPromise = void 0;
  var Rat = Jt();
  function Iat(e) {
    return Rat.isFunction(e?.then);
  }
  rP.isPromise = Iat;
});
var sG = g((nP) => {
  "use strict";
  c();
  Object.defineProperty(nP, "__esModule", { value: !0 });
  nP.isInteropObservable = void 0;
  var xat = wS(),
    Nat = Jt();
  function kat(e) {
    return Nat.isFunction(e[xat.observable]);
  }
  nP.isInteropObservable = kat;
});
var cG = g((iP) => {
  "use strict";
  c();
  Object.defineProperty(iP, "__esModule", { value: !0 });
  iP.isAsyncIterable = void 0;
  var Dat = Jt();
  function Lat(e) {
    return Symbol.asyncIterator && Dat.isFunction(e?.[Symbol.asyncIterator]);
  }
  iP.isAsyncIterable = Lat;
});
var uG = g((oP) => {
  "use strict";
  c();
  Object.defineProperty(oP, "__esModule", { value: !0 });
  oP.createInvalidObservableTypeError = void 0;
  function Mat(e) {
    return new TypeError(
      "You provided " +
        (e !== null && typeof e == "object"
          ? "an invalid object"
          : "'" + e + "'") +
        " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.",
    );
  }
  oP.createInvalidObservableTypeError = Mat;
});
var lG = g((_v) => {
  "use strict";
  c();
  Object.defineProperty(_v, "__esModule", { value: !0 });
  _v.iterator = _v.getSymbolIterator = void 0;
  function Toe() {
    return typeof Symbol != "function" || !Symbol.iterator
      ? "@@iterator"
      : Symbol.iterator;
  }
  _v.getSymbolIterator = Toe;
  _v.iterator = Toe();
});
var dG = g((aP) => {
  "use strict";
  c();
  Object.defineProperty(aP, "__esModule", { value: !0 });
  aP.isIterable = void 0;
  var qat = lG(),
    jat = Jt();
  function Fat(e) {
    return jat.isFunction(e?.[qat.iterator]);
  }
  aP.isIterable = Fat;
});
var sP = g((Oa) => {
  "use strict";
  c();
  var Bat =
      (Oa && Oa.__generator) ||
      function (e, t) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1];
              return o[1];
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          a;
        return (
          (a = { next: s(0), throw: s(1), return: s(2) }),
          typeof Symbol == "function" &&
            (a[Symbol.iterator] = function () {
              return this;
            }),
          a
        );
        function s(l) {
          return function (d) {
            return u([l, d]);
          };
        }
        function u(l) {
          if (n) throw new TypeError("Generator is already executing.");
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o =
                    l[0] & 2
                      ? i.return
                      : l[0]
                        ? i.throw || ((o = i.return) && o.call(i), 0)
                        : i.next) &&
                  !(o = o.call(i, l[1])).done)
              )
                return o;
              switch (((i = 0), o && (l = [l[0] & 2, o.value]), l[0])) {
                case 0:
                case 1:
                  o = l;
                  break;
                case 4:
                  return r.label++, { value: l[1], done: !1 };
                case 5:
                  r.label++, (i = l[1]), (l = [0]);
                  continue;
                case 7:
                  (l = r.ops.pop()), r.trys.pop();
                  continue;
                default:
                  if (
                    ((o = r.trys),
                    !(o = o.length > 0 && o[o.length - 1]) &&
                      (l[0] === 6 || l[0] === 2))
                  ) {
                    r = 0;
                    continue;
                  }
                  if (l[0] === 3 && (!o || (l[1] > o[0] && l[1] < o[3]))) {
                    r.label = l[1];
                    break;
                  }
                  if (l[0] === 6 && r.label < o[1]) {
                    (r.label = o[1]), (o = l);
                    break;
                  }
                  if (o && r.label < o[2]) {
                    (r.label = o[2]), r.ops.push(l);
                    break;
                  }
                  o[2] && r.ops.pop(), r.trys.pop();
                  continue;
              }
              l = t.call(e, r);
            } catch (d) {
              (l = [6, d]), (i = 0);
            } finally {
              n = o = 0;
            }
          if (l[0] & 5) throw l[1];
          return { value: l[0] ? l[1] : void 0, done: !0 };
        }
      },
    Ev =
      (Oa && Oa.__await) ||
      function (e) {
        return this instanceof Ev ? ((this.v = e), this) : new Ev(e);
      },
    Uat =
      (Oa && Oa.__asyncGenerator) ||
      function (e, t, r) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var n = r.apply(e, t || []),
          i,
          o = [];
        return (
          (i = {}),
          a("next"),
          a("throw"),
          a("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function a(m) {
          n[m] &&
            (i[m] = function (h) {
              return new Promise(function (y, _) {
                o.push([m, h, y, _]) > 1 || s(m, h);
              });
            });
        }
        function s(m, h) {
          try {
            u(n[m](h));
          } catch (y) {
            f(o[0][3], y);
          }
        }
        function u(m) {
          m.value instanceof Ev
            ? Promise.resolve(m.value.v).then(l, d)
            : f(o[0][2], m);
        }
        function l(m) {
          s("next", m);
        }
        function d(m) {
          s("throw", m);
        }
        function f(m, h) {
          m(h), o.shift(), o.length && s(o[0][0], o[0][1]);
        }
      };
  Object.defineProperty(Oa, "__esModule", { value: !0 });
  Oa.isReadableStreamLike = Oa.readableStreamLikeToAsyncGenerator = void 0;
  var Hat = Jt();
  function Gat(e) {
    return Uat(this, arguments, function () {
      var r, n, i, o;
      return Bat(this, function (a) {
        switch (a.label) {
          case 0:
            (r = e.getReader()), (a.label = 1);
          case 1:
            a.trys.push([1, , 9, 10]), (a.label = 2);
          case 2:
            return [4, Ev(r.read())];
          case 3:
            return (
              (n = a.sent()),
              (i = n.value),
              (o = n.done),
              o ? [4, Ev(void 0)] : [3, 5]
            );
          case 4:
            return [2, a.sent()];
          case 5:
            return [4, Ev(i)];
          case 6:
            return [4, a.sent()];
          case 7:
            return a.sent(), [3, 2];
          case 8:
            return [3, 10];
          case 9:
            return r.releaseLock(), [7];
          case 10:
            return [2];
        }
      });
    });
  }
  Oa.readableStreamLikeToAsyncGenerator = Gat;
  function Vat(e) {
    return Hat.isFunction(e?.getReader);
  }
  Oa.isReadableStreamLike = Vat;
});
var Je = g((Ur) => {
  "use strict";
  c();
  var $at =
      (Ur && Ur.__awaiter) ||
      function (e, t, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (a) {
                a(o);
              });
        }
        return new (r || (r = Promise))(function (o, a) {
          function s(d) {
            try {
              l(n.next(d));
            } catch (f) {
              a(f);
            }
          }
          function u(d) {
            try {
              l(n.throw(d));
            } catch (f) {
              a(f);
            }
          }
          function l(d) {
            d.done ? o(d.value) : i(d.value).then(s, u);
          }
          l((n = n.apply(e, t || [])).next());
        });
      },
    zat =
      (Ur && Ur.__generator) ||
      function (e, t) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1];
              return o[1];
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          a;
        return (
          (a = { next: s(0), throw: s(1), return: s(2) }),
          typeof Symbol == "function" &&
            (a[Symbol.iterator] = function () {
              return this;
            }),
          a
        );
        function s(l) {
          return function (d) {
            return u([l, d]);
          };
        }
        function u(l) {
          if (n) throw new TypeError("Generator is already executing.");
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o =
                    l[0] & 2
                      ? i.return
                      : l[0]
                        ? i.throw || ((o = i.return) && o.call(i), 0)
                        : i.next) &&
                  !(o = o.call(i, l[1])).done)
              )
                return o;
              switch (((i = 0), o && (l = [l[0] & 2, o.value]), l[0])) {
                case 0:
                case 1:
                  o = l;
                  break;
                case 4:
                  return r.label++, { value: l[1], done: !1 };
                case 5:
                  r.label++, (i = l[1]), (l = [0]);
                  continue;
                case 7:
                  (l = r.ops.pop()), r.trys.pop();
                  continue;
                default:
                  if (
                    ((o = r.trys),
                    !(o = o.length > 0 && o[o.length - 1]) &&
                      (l[0] === 6 || l[0] === 2))
                  ) {
                    r = 0;
                    continue;
                  }
                  if (l[0] === 3 && (!o || (l[1] > o[0] && l[1] < o[3]))) {
                    r.label = l[1];
                    break;
                  }
                  if (l[0] === 6 && r.label < o[1]) {
                    (r.label = o[1]), (o = l);
                    break;
                  }
                  if (o && r.label < o[2]) {
                    (r.label = o[2]), r.ops.push(l);
                    break;
                  }
                  o[2] && r.ops.pop(), r.trys.pop();
                  continue;
              }
              l = t.call(e, r);
            } catch (d) {
              (l = [6, d]), (i = 0);
            } finally {
              n = o = 0;
            }
          if (l[0] & 5) throw l[1];
          return { value: l[0] ? l[1] : void 0, done: !0 };
        }
      },
    Kat =
      (Ur && Ur.__asyncValues) ||
      function (e) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var t = e[Symbol.asyncIterator],
          r;
        return t
          ? t.call(e)
          : ((e = typeof fG == "function" ? fG(e) : e[Symbol.iterator]()),
            (r = {}),
            n("next"),
            n("throw"),
            n("return"),
            (r[Symbol.asyncIterator] = function () {
              return this;
            }),
            r);
        function n(o) {
          r[o] =
            e[o] &&
            function (a) {
              return new Promise(function (s, u) {
                (a = e[o](a)), i(s, u, a.done, a.value);
              });
            };
        }
        function i(o, a, s, u) {
          Promise.resolve(u).then(function (l) {
            o({ value: l, done: s });
          }, a);
        }
      },
    fG =
      (Ur && Ur.__values) ||
      function (e) {
        var t = typeof Symbol == "function" && Symbol.iterator,
          r = t && e[t],
          n = 0;
        if (r) return r.call(e);
        if (e && typeof e.length == "number")
          return {
            next: function () {
              return (
                e && n >= e.length && (e = void 0),
                { value: e && e[n++], done: !e }
              );
            },
          };
        throw new TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined.",
        );
      };
  Object.defineProperty(Ur, "__esModule", { value: !0 });
  Ur.fromReadableStreamLike =
    Ur.fromAsyncIterable =
    Ur.fromIterable =
    Ur.fromPromise =
    Ur.fromArrayLike =
    Ur.fromInteropObservable =
    Ur.innerFrom =
      void 0;
  var Wat = tP(),
    Qat = aG(),
    bv = ar(),
    Yat = sG(),
    Xat = cG(),
    Jat = uG(),
    Zat = dG(),
    Aoe = sP(),
    est = Jt(),
    tst = G3(),
    rst = wS();
  function nst(e) {
    if (e instanceof bv.Observable) return e;
    if (e != null) {
      if (Yat.isInteropObservable(e)) return Poe(e);
      if (Wat.isArrayLike(e)) return Roe(e);
      if (Qat.isPromise(e)) return Ioe(e);
      if (Xat.isAsyncIterable(e)) return pG(e);
      if (Zat.isIterable(e)) return xoe(e);
      if (Aoe.isReadableStreamLike(e)) return Noe(e);
    }
    throw Jat.createInvalidObservableTypeError(e);
  }
  Ur.innerFrom = nst;
  function Poe(e) {
    return new bv.Observable(function (t) {
      var r = e[rst.observable]();
      if (est.isFunction(r.subscribe)) return r.subscribe(t);
      throw new TypeError(
        "Provided object does not correctly implement Symbol.observable",
      );
    });
  }
  Ur.fromInteropObservable = Poe;
  function Roe(e) {
    return new bv.Observable(function (t) {
      for (var r = 0; r < e.length && !t.closed; r++) t.next(e[r]);
      t.complete();
    });
  }
  Ur.fromArrayLike = Roe;
  function Ioe(e) {
    return new bv.Observable(function (t) {
      e.then(
        function (r) {
          t.closed || (t.next(r), t.complete());
        },
        function (r) {
          return t.error(r);
        },
      ).then(null, tst.reportUnhandledError);
    });
  }
  Ur.fromPromise = Ioe;
  function xoe(e) {
    return new bv.Observable(function (t) {
      var r, n;
      try {
        for (var i = fG(e), o = i.next(); !o.done; o = i.next()) {
          var a = o.value;
          if ((t.next(a), t.closed)) return;
        }
      } catch (s) {
        r = { error: s };
      } finally {
        try {
          o && !o.done && (n = i.return) && n.call(i);
        } finally {
          if (r) throw r.error;
        }
      }
      t.complete();
    });
  }
  Ur.fromIterable = xoe;
  function pG(e) {
    return new bv.Observable(function (t) {
      ist(e, t).catch(function (r) {
        return t.error(r);
      });
    });
  }
  Ur.fromAsyncIterable = pG;
  function Noe(e) {
    return pG(Aoe.readableStreamLikeToAsyncGenerator(e));
  }
  Ur.fromReadableStreamLike = Noe;
  function ist(e, t) {
    var r, n, i, o;
    return $at(this, void 0, void 0, function () {
      var a, s;
      return zat(this, function (u) {
        switch (u.label) {
          case 0:
            u.trys.push([0, 5, 6, 11]), (r = Kat(e)), (u.label = 1);
          case 1:
            return [4, r.next()];
          case 2:
            if (((n = u.sent()), !!n.done)) return [3, 4];
            if (((a = n.value), t.next(a), t.closed)) return [2];
            u.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            return (s = u.sent()), (i = { error: s }), [3, 11];
          case 6:
            return (
              u.trys.push([6, , 9, 10]),
              n && !n.done && (o = r.return) ? [4, o.call(r)] : [3, 8]
            );
          case 7:
            u.sent(), (u.label = 8);
          case 8:
            return [3, 10];
          case 9:
            if (i) throw i.error;
            return [7];
          case 10:
            return [7];
          case 11:
            return t.complete(), [2];
        }
      });
    });
  }
});
var Bu = g((cP) => {
  "use strict";
  c();
  Object.defineProperty(cP, "__esModule", { value: !0 });
  cP.executeSchedule = void 0;
  function ost(e, t, r, n, i) {
    n === void 0 && (n = 0), i === void 0 && (i = !1);
    var o = t.schedule(function () {
      r(), i ? e.add(this.schedule(null, n)) : this.unsubscribe();
    }, n);
    if ((e.add(o), !i)) return o;
  }
  cP.executeSchedule = ost;
});
var IS = g((uP) => {
  "use strict";
  c();
  Object.defineProperty(uP, "__esModule", { value: !0 });
  uP.observeOn = void 0;
  var mG = Bu(),
    ast = ve(),
    sst = ke();
  function cst(e, t) {
    return (
      t === void 0 && (t = 0),
      ast.operate(function (r, n) {
        r.subscribe(
          sst.createOperatorSubscriber(
            n,
            function (i) {
              return mG.executeSchedule(
                n,
                e,
                function () {
                  return n.next(i);
                },
                t,
              );
            },
            function () {
              return mG.executeSchedule(
                n,
                e,
                function () {
                  return n.complete();
                },
                t,
              );
            },
            function (i) {
              return mG.executeSchedule(
                n,
                e,
                function () {
                  return n.error(i);
                },
                t,
              );
            },
          ),
        );
      })
    );
  }
  uP.observeOn = cst;
});
var xS = g((lP) => {
  "use strict";
  c();
  Object.defineProperty(lP, "__esModule", { value: !0 });
  lP.subscribeOn = void 0;
  var ust = ve();
  function lst(e, t) {
    return (
      t === void 0 && (t = 0),
      ust.operate(function (r, n) {
        n.add(
          e.schedule(function () {
            return r.subscribe(n);
          }, t),
        );
      })
    );
  }
  lP.subscribeOn = lst;
});
var koe = g((dP) => {
  "use strict";
  c();
  Object.defineProperty(dP, "__esModule", { value: !0 });
  dP.scheduleObservable = void 0;
  var dst = Je(),
    fst = IS(),
    pst = xS();
  function mst(e, t) {
    return dst.innerFrom(e).pipe(pst.subscribeOn(t), fst.observeOn(t));
  }
  dP.scheduleObservable = mst;
});
var Doe = g((fP) => {
  "use strict";
  c();
  Object.defineProperty(fP, "__esModule", { value: !0 });
  fP.schedulePromise = void 0;
  var hst = Je(),
    gst = IS(),
    vst = xS();
  function yst(e, t) {
    return hst.innerFrom(e).pipe(vst.subscribeOn(t), gst.observeOn(t));
  }
  fP.schedulePromise = yst;
});
var Loe = g((pP) => {
  "use strict";
  c();
  Object.defineProperty(pP, "__esModule", { value: !0 });
  pP.scheduleArray = void 0;
  var _st = ar();
  function Est(e, t) {
    return new _st.Observable(function (r) {
      var n = 0;
      return t.schedule(function () {
        n === e.length
          ? r.complete()
          : (r.next(e[n++]), r.closed || this.schedule());
      });
    });
  }
  pP.scheduleArray = Est;
});
var hG = g((mP) => {
  "use strict";
  c();
  Object.defineProperty(mP, "__esModule", { value: !0 });
  mP.scheduleIterable = void 0;
  var bst = ar(),
    Sst = lG(),
    Cst = Jt(),
    Moe = Bu();
  function wst(e, t) {
    return new bst.Observable(function (r) {
      var n;
      return (
        Moe.executeSchedule(r, t, function () {
          (n = e[Sst.iterator]()),
            Moe.executeSchedule(
              r,
              t,
              function () {
                var i, o, a;
                try {
                  (i = n.next()), (o = i.value), (a = i.done);
                } catch (s) {
                  r.error(s);
                  return;
                }
                a ? r.complete() : r.next(o);
              },
              0,
              !0,
            );
        }),
        function () {
          return Cst.isFunction(n?.return) && n.return();
        }
      );
    });
  }
  mP.scheduleIterable = wst;
});
var gG = g((hP) => {
  "use strict";
  c();
  Object.defineProperty(hP, "__esModule", { value: !0 });
  hP.scheduleAsyncIterable = void 0;
  var Ost = ar(),
    qoe = Bu();
  function Tst(e, t) {
    if (!e) throw new Error("Iterable cannot be null");
    return new Ost.Observable(function (r) {
      qoe.executeSchedule(r, t, function () {
        var n = e[Symbol.asyncIterator]();
        qoe.executeSchedule(
          r,
          t,
          function () {
            n.next().then(function (i) {
              i.done ? r.complete() : r.next(i.value);
            });
          },
          0,
          !0,
        );
      });
    });
  }
  hP.scheduleAsyncIterable = Tst;
});
var joe = g((gP) => {
  "use strict";
  c();
  Object.defineProperty(gP, "__esModule", { value: !0 });
  gP.scheduleReadableStreamLike = void 0;
  var Ast = gG(),
    Pst = sP();
  function Rst(e, t) {
    return Ast.scheduleAsyncIterable(
      Pst.readableStreamLikeToAsyncGenerator(e),
      t,
    );
  }
  gP.scheduleReadableStreamLike = Rst;
});
var vG = g((vP) => {
  "use strict";
  c();
  Object.defineProperty(vP, "__esModule", { value: !0 });
  vP.scheduled = void 0;
  var Ist = koe(),
    xst = Doe(),
    Nst = Loe(),
    kst = hG(),
    Dst = gG(),
    Lst = sG(),
    Mst = aG(),
    qst = tP(),
    jst = dG(),
    Fst = cG(),
    Bst = uG(),
    Ust = sP(),
    Hst = joe();
  function Gst(e, t) {
    if (e != null) {
      if (Lst.isInteropObservable(e)) return Ist.scheduleObservable(e, t);
      if (qst.isArrayLike(e)) return Nst.scheduleArray(e, t);
      if (Mst.isPromise(e)) return xst.schedulePromise(e, t);
      if (Fst.isAsyncIterable(e)) return Dst.scheduleAsyncIterable(e, t);
      if (jst.isIterable(e)) return kst.scheduleIterable(e, t);
      if (Ust.isReadableStreamLike(e))
        return Hst.scheduleReadableStreamLike(e, t);
    }
    throw Bst.createInvalidObservableTypeError(e);
  }
  vP.scheduled = Gst;
});
var Uu = g((yP) => {
  "use strict";
  c();
  Object.defineProperty(yP, "__esModule", { value: !0 });
  yP.from = void 0;
  var Vst = vG(),
    $st = Je();
  function zst(e, t) {
    return t ? Vst.scheduled(e, t) : $st.innerFrom(e);
  }
  yP.from = zst;
});
var EP = g((_P) => {
  "use strict";
  c();
  Object.defineProperty(_P, "__esModule", { value: !0 });
  _P.of = void 0;
  var Kst = _o(),
    Wst = Uu();
  function Qst() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = Kst.popScheduler(e);
    return Wst.from(e, r);
  }
  _P.of = Qst;
});
var yG = g((bP) => {
  "use strict";
  c();
  Object.defineProperty(bP, "__esModule", { value: !0 });
  bP.throwError = void 0;
  var Yst = ar(),
    Xst = Jt();
  function Jst(e, t) {
    var r = Xst.isFunction(e)
        ? e
        : function () {
            return e;
          },
      n = function (i) {
        return i.error(r());
      };
    return new Yst.Observable(
      t
        ? function (i) {
            return t.schedule(n, 0, i);
          }
        : n,
    );
  }
  bP.throwError = Jst;
});
var SP = g((Hu) => {
  "use strict";
  c();
  Object.defineProperty(Hu, "__esModule", { value: !0 });
  Hu.observeNotification = Hu.Notification = Hu.NotificationKind = void 0;
  var Zst = Is(),
    ect = EP(),
    tct = yG(),
    rct = Jt(),
    nct;
  (function (e) {
    (e.NEXT = "N"), (e.ERROR = "E"), (e.COMPLETE = "C");
  })((nct = Hu.NotificationKind || (Hu.NotificationKind = {})));
  var ict = (function () {
    function e(t, r, n) {
      (this.kind = t),
        (this.value = r),
        (this.error = n),
        (this.hasValue = t === "N");
    }
    return (
      (e.prototype.observe = function (t) {
        return Foe(this, t);
      }),
      (e.prototype.do = function (t, r, n) {
        var i = this,
          o = i.kind,
          a = i.value,
          s = i.error;
        return o === "N" ? t?.(a) : o === "E" ? r?.(s) : n?.();
      }),
      (e.prototype.accept = function (t, r, n) {
        var i;
        return rct.isFunction(
          (i = t) === null || i === void 0 ? void 0 : i.next,
        )
          ? this.observe(t)
          : this.do(t, r, n);
      }),
      (e.prototype.toObservable = function () {
        var t = this,
          r = t.kind,
          n = t.value,
          i = t.error,
          o =
            r === "N"
              ? ect.of(n)
              : r === "E"
                ? tct.throwError(function () {
                    return i;
                  })
                : r === "C"
                  ? Zst.EMPTY
                  : 0;
        if (!o) throw new TypeError("Unexpected notification kind " + r);
        return o;
      }),
      (e.createNext = function (t) {
        return new e("N", t);
      }),
      (e.createError = function (t) {
        return new e("E", void 0, t);
      }),
      (e.createComplete = function () {
        return e.completeNotification;
      }),
      (e.completeNotification = new e("C")),
      e
    );
  })();
  Hu.Notification = ict;
  function Foe(e, t) {
    var r,
      n,
      i,
      o = e,
      a = o.kind,
      s = o.value,
      u = o.error;
    if (typeof a != "string")
      throw new TypeError('Invalid notification, missing "kind"');
    a === "N"
      ? (r = t.next) === null || r === void 0 || r.call(t, s)
      : a === "E"
        ? (n = t.error) === null || n === void 0 || n.call(t, u)
        : (i = t.complete) === null || i === void 0 || i.call(t);
  }
  Hu.observeNotification = Foe;
});
var Uoe = g((CP) => {
  "use strict";
  c();
  Object.defineProperty(CP, "__esModule", { value: !0 });
  CP.isObservable = void 0;
  var oct = ar(),
    Boe = Jt();
  function act(e) {
    return (
      !!e &&
      (e instanceof oct.Observable ||
        (Boe.isFunction(e.lift) && Boe.isFunction(e.subscribe)))
    );
  }
  CP.isObservable = act;
});
var md = g((wP) => {
  "use strict";
  c();
  Object.defineProperty(wP, "__esModule", { value: !0 });
  wP.EmptyError = void 0;
  var sct = ld();
  wP.EmptyError = sct.createErrorClass(function (e) {
    return function () {
      e(this),
        (this.name = "EmptyError"),
        (this.message = "no elements in sequence");
    };
  });
});
var Hoe = g((OP) => {
  "use strict";
  c();
  Object.defineProperty(OP, "__esModule", { value: !0 });
  OP.lastValueFrom = void 0;
  var cct = md();
  function uct(e, t) {
    var r = typeof t == "object";
    return new Promise(function (n, i) {
      var o = !1,
        a;
      e.subscribe({
        next: function (s) {
          (a = s), (o = !0);
        },
        error: i,
        complete: function () {
          o ? n(a) : r ? n(t.defaultValue) : i(new cct.EmptyError());
        },
      });
    });
  }
  OP.lastValueFrom = uct;
});
var Goe = g((TP) => {
  "use strict";
  c();
  Object.defineProperty(TP, "__esModule", { value: !0 });
  TP.firstValueFrom = void 0;
  var lct = md(),
    dct = ev();
  function fct(e, t) {
    var r = typeof t == "object";
    return new Promise(function (n, i) {
      var o = new dct.SafeSubscriber({
        next: function (a) {
          n(a), o.unsubscribe();
        },
        error: i,
        complete: function () {
          r ? n(t.defaultValue) : i(new lct.EmptyError());
        },
      });
      e.subscribe(o);
    });
  }
  TP.firstValueFrom = fct;
});
var _G = g((AP) => {
  "use strict";
  c();
  Object.defineProperty(AP, "__esModule", { value: !0 });
  AP.ArgumentOutOfRangeError = void 0;
  var pct = ld();
  AP.ArgumentOutOfRangeError = pct.createErrorClass(function (e) {
    return function () {
      e(this),
        (this.name = "ArgumentOutOfRangeError"),
        (this.message = "argument out of range");
    };
  });
});
var EG = g((PP) => {
  "use strict";
  c();
  Object.defineProperty(PP, "__esModule", { value: !0 });
  PP.NotFoundError = void 0;
  var mct = ld();
  PP.NotFoundError = mct.createErrorClass(function (e) {
    return function (r) {
      e(this), (this.name = "NotFoundError"), (this.message = r);
    };
  });
});
var bG = g((RP) => {
  "use strict";
  c();
  Object.defineProperty(RP, "__esModule", { value: !0 });
  RP.SequenceError = void 0;
  var hct = ld();
  RP.SequenceError = hct.createErrorClass(function (e) {
    return function (r) {
      e(this), (this.name = "SequenceError"), (this.message = r);
    };
  });
});
var xP = g((IP) => {
  "use strict";
  c();
  Object.defineProperty(IP, "__esModule", { value: !0 });
  IP.isValidDate = void 0;
  function gct(e) {
    return e instanceof Date && !isNaN(e);
  }
  IP.isValidDate = gct;
});
var NP = g((Jp) => {
  "use strict";
  c();
  Object.defineProperty(Jp, "__esModule", { value: !0 });
  Jp.timeout = Jp.TimeoutError = void 0;
  var vct = yo(),
    yct = xP(),
    _ct = ve(),
    Ect = Je(),
    bct = ld(),
    Sct = ke(),
    Cct = Bu();
  Jp.TimeoutError = bct.createErrorClass(function (e) {
    return function (r) {
      r === void 0 && (r = null),
        e(this),
        (this.message = "Timeout has occurred"),
        (this.name = "TimeoutError"),
        (this.info = r);
    };
  });
  function wct(e, t) {
    var r = yct.isValidDate(e)
        ? { first: e }
        : typeof e == "number"
          ? { each: e }
          : e,
      n = r.first,
      i = r.each,
      o = r.with,
      a = o === void 0 ? Oct : o,
      s = r.scheduler,
      u = s === void 0 ? (t ?? vct.asyncScheduler) : s,
      l = r.meta,
      d = l === void 0 ? null : l;
    if (n == null && i == null) throw new TypeError("No timeout provided.");
    return _ct.operate(function (f, m) {
      var h,
        y,
        _ = null,
        E = 0,
        b = function (O) {
          y = Cct.executeSchedule(
            m,
            u,
            function () {
              try {
                h.unsubscribe(),
                  Ect.innerFrom(
                    a({ meta: d, lastValue: _, seen: E }),
                  ).subscribe(m);
              } catch (C) {
                m.error(C);
              }
            },
            O,
          );
        };
      (h = f.subscribe(
        Sct.createOperatorSubscriber(
          m,
          function (O) {
            y?.unsubscribe(), E++, m.next((_ = O)), i > 0 && b(i);
          },
          void 0,
          void 0,
          function () {
            y?.closed || y?.unsubscribe(), (_ = null);
          },
        ),
      )),
        !E && b(n != null ? (typeof n == "number" ? n : +n - u.now()) : i);
    });
  }
  Jp.timeout = wct;
  function Oct(e) {
    throw new Jp.TimeoutError(e);
  }
});
var hd = g((kP) => {
  "use strict";
  c();
  Object.defineProperty(kP, "__esModule", { value: !0 });
  kP.map = void 0;
  var Tct = ve(),
    Act = ke();
  function Pct(e, t) {
    return Tct.operate(function (r, n) {
      var i = 0;
      r.subscribe(
        Act.createOperatorSubscriber(n, function (o) {
          n.next(e.call(t, o, i++));
        }),
      );
    });
  }
  kP.map = Pct;
});
var vd = g((gd) => {
  "use strict";
  c();
  var Rct =
      (gd && gd.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Ict =
      (gd && gd.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(gd, "__esModule", { value: !0 });
  gd.mapOneOrManyArgs = void 0;
  var xct = hd(),
    Nct = Array.isArray;
  function kct(e, t) {
    return Nct(t) ? e.apply(void 0, Ict([], Rct(t))) : e(t);
  }
  function Dct(e) {
    return xct.map(function (t) {
      return kct(e, t);
    });
  }
  gd.mapOneOrManyArgs = Dct;
});
var CG = g((yd) => {
  "use strict";
  c();
  var Lct =
      (yd && yd.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Voe =
      (yd && yd.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(yd, "__esModule", { value: !0 });
  yd.bindCallbackInternals = void 0;
  var Mct = RS(),
    qct = ar(),
    jct = xS(),
    Fct = vd(),
    Bct = IS(),
    Uct = YA();
  function SG(e, t, r, n) {
    if (r)
      if (Mct.isScheduler(r)) n = r;
      else
        return function () {
          for (var i = [], o = 0; o < arguments.length; o++)
            i[o] = arguments[o];
          return SG(e, t, n).apply(this, i).pipe(Fct.mapOneOrManyArgs(r));
        };
    return n
      ? function () {
          for (var i = [], o = 0; o < arguments.length; o++)
            i[o] = arguments[o];
          return SG(e, t)
            .apply(this, i)
            .pipe(jct.subscribeOn(n), Bct.observeOn(n));
        }
      : function () {
          for (var i = this, o = [], a = 0; a < arguments.length; a++)
            o[a] = arguments[a];
          var s = new Uct.AsyncSubject(),
            u = !0;
          return new qct.Observable(function (l) {
            var d = s.subscribe(l);
            if (u) {
              u = !1;
              var f = !1,
                m = !1;
              t.apply(
                i,
                Voe(Voe([], Lct(o)), [
                  function () {
                    for (var h = [], y = 0; y < arguments.length; y++)
                      h[y] = arguments[y];
                    if (e) {
                      var _ = h.shift();
                      if (_ != null) {
                        s.error(_);
                        return;
                      }
                    }
                    s.next(1 < h.length ? h : h[0]),
                      (m = !0),
                      f && s.complete();
                  },
                ]),
              ),
                m && s.complete(),
                (f = !0);
            }
            return d;
          });
        };
  }
  yd.bindCallbackInternals = SG;
});
var $oe = g((DP) => {
  "use strict";
  c();
  Object.defineProperty(DP, "__esModule", { value: !0 });
  DP.bindCallback = void 0;
  var Hct = CG();
  function Gct(e, t, r) {
    return Hct.bindCallbackInternals(!1, e, t, r);
  }
  DP.bindCallback = Gct;
});
var zoe = g((LP) => {
  "use strict";
  c();
  Object.defineProperty(LP, "__esModule", { value: !0 });
  LP.bindNodeCallback = void 0;
  var Vct = CG();
  function $ct(e, t, r) {
    return Vct.bindCallbackInternals(!0, e, t, r);
  }
  LP.bindNodeCallback = $ct;
});
var wG = g((MP) => {
  "use strict";
  c();
  Object.defineProperty(MP, "__esModule", { value: !0 });
  MP.argsArgArrayOrObject = void 0;
  var zct = Array.isArray,
    Kct = Object.getPrototypeOf,
    Wct = Object.prototype,
    Qct = Object.keys;
  function Yct(e) {
    if (e.length === 1) {
      var t = e[0];
      if (zct(t)) return { args: t, keys: null };
      if (Xct(t)) {
        var r = Qct(t);
        return {
          args: r.map(function (n) {
            return t[n];
          }),
          keys: r,
        };
      }
    }
    return { args: e, keys: null };
  }
  MP.argsArgArrayOrObject = Yct;
  function Xct(e) {
    return e && typeof e == "object" && Kct(e) === Wct;
  }
});
var OG = g((qP) => {
  "use strict";
  c();
  Object.defineProperty(qP, "__esModule", { value: !0 });
  qP.createObject = void 0;
  function Jct(e, t) {
    return e.reduce(function (r, n, i) {
      return (r[n] = t[i]), r;
    }, {});
  }
  qP.createObject = Jct;
});
var jP = g((Sv) => {
  "use strict";
  c();
  Object.defineProperty(Sv, "__esModule", { value: !0 });
  Sv.combineLatestInit = Sv.combineLatest = void 0;
  var Zct = ar(),
    eut = wG(),
    Qoe = Uu(),
    Yoe = hi(),
    tut = vd(),
    Koe = _o(),
    rut = OG(),
    nut = ke(),
    iut = Bu();
  function out() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = Koe.popScheduler(e),
      n = Koe.popResultSelector(e),
      i = eut.argsArgArrayOrObject(e),
      o = i.args,
      a = i.keys;
    if (o.length === 0) return Qoe.from([], r);
    var s = new Zct.Observable(
      Xoe(
        o,
        r,
        a
          ? function (u) {
              return rut.createObject(a, u);
            }
          : Yoe.identity,
      ),
    );
    return n ? s.pipe(tut.mapOneOrManyArgs(n)) : s;
  }
  Sv.combineLatest = out;
  function Xoe(e, t, r) {
    return (
      r === void 0 && (r = Yoe.identity),
      function (n) {
        Woe(
          t,
          function () {
            for (
              var i = e.length,
                o = new Array(i),
                a = i,
                s = i,
                u = function (d) {
                  Woe(
                    t,
                    function () {
                      var f = Qoe.from(e[d], t),
                        m = !1;
                      f.subscribe(
                        nut.createOperatorSubscriber(
                          n,
                          function (h) {
                            (o[d] = h),
                              m || ((m = !0), s--),
                              s || n.next(r(o.slice()));
                          },
                          function () {
                            --a || n.complete();
                          },
                        ),
                      );
                    },
                    n,
                  );
                },
                l = 0;
              l < i;
              l++
            )
              u(l);
          },
          n,
        );
      }
    );
  }
  Sv.combineLatestInit = Xoe;
  function Woe(e, t, r) {
    e ? iut.executeSchedule(r, e, t) : t();
  }
});
var BP = g((FP) => {
  "use strict";
  c();
  Object.defineProperty(FP, "__esModule", { value: !0 });
  FP.mergeInternals = void 0;
  var aut = Je(),
    sut = Bu(),
    Joe = ke();
  function cut(e, t, r, n, i, o, a, s) {
    var u = [],
      l = 0,
      d = 0,
      f = !1,
      m = function () {
        f && !u.length && !l && t.complete();
      },
      h = function (_) {
        return l < n ? y(_) : u.push(_);
      },
      y = function (_) {
        o && t.next(_), l++;
        var E = !1;
        aut.innerFrom(r(_, d++)).subscribe(
          Joe.createOperatorSubscriber(
            t,
            function (b) {
              i?.(b), o ? h(b) : t.next(b);
            },
            function () {
              E = !0;
            },
            void 0,
            function () {
              if (E)
                try {
                  l--;
                  for (
                    var b = function () {
                      var O = u.shift();
                      a
                        ? sut.executeSchedule(t, a, function () {
                            return y(O);
                          })
                        : y(O);
                    };
                    u.length && l < n;

                  )
                    b();
                  m();
                } catch (O) {
                  t.error(O);
                }
            },
          ),
        );
      };
    return (
      e.subscribe(
        Joe.createOperatorSubscriber(t, h, function () {
          (f = !0), m();
        }),
      ),
      function () {
        s?.();
      }
    );
  }
  FP.mergeInternals = cut;
});
var Gu = g((UP) => {
  "use strict";
  c();
  Object.defineProperty(UP, "__esModule", { value: !0 });
  UP.mergeMap = void 0;
  var uut = hd(),
    lut = Je(),
    dut = ve(),
    fut = BP(),
    put = Jt();
  function Zoe(e, t, r) {
    return (
      r === void 0 && (r = 1 / 0),
      put.isFunction(t)
        ? Zoe(function (n, i) {
            return uut.map(function (o, a) {
              return t(n, o, i, a);
            })(lut.innerFrom(e(n, i)));
          }, r)
        : (typeof t == "number" && (r = t),
          dut.operate(function (n, i) {
            return fut.mergeInternals(n, i, e, r);
          }))
    );
  }
  UP.mergeMap = Zoe;
});
var NS = g((HP) => {
  "use strict";
  c();
  Object.defineProperty(HP, "__esModule", { value: !0 });
  HP.mergeAll = void 0;
  var mut = Gu(),
    hut = hi();
  function gut(e) {
    return e === void 0 && (e = 1 / 0), mut.mergeMap(hut.identity, e);
  }
  HP.mergeAll = gut;
});
var VP = g((GP) => {
  "use strict";
  c();
  Object.defineProperty(GP, "__esModule", { value: !0 });
  GP.concatAll = void 0;
  var vut = NS();
  function yut() {
    return vut.mergeAll(1);
  }
  GP.concatAll = yut;
});
var kS = g(($P) => {
  "use strict";
  c();
  Object.defineProperty($P, "__esModule", { value: !0 });
  $P.concat = void 0;
  var _ut = VP(),
    Eut = _o(),
    but = Uu();
  function Sut() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return _ut.concatAll()(but.from(e, Eut.popScheduler(e)));
  }
  $P.concat = Sut;
});
var DS = g((zP) => {
  "use strict";
  c();
  Object.defineProperty(zP, "__esModule", { value: !0 });
  zP.defer = void 0;
  var Cut = ar(),
    wut = Je();
  function Out(e) {
    return new Cut.Observable(function (t) {
      wut.innerFrom(e()).subscribe(t);
    });
  }
  zP.defer = Out;
});
var eae = g((KP) => {
  "use strict";
  c();
  Object.defineProperty(KP, "__esModule", { value: !0 });
  KP.connectable = void 0;
  var Tut = gi(),
    Aut = ar(),
    Put = DS(),
    Rut = {
      connector: function () {
        return new Tut.Subject();
      },
      resetOnDisconnect: !0,
    };
  function Iut(e, t) {
    t === void 0 && (t = Rut);
    var r = null,
      n = t.connector,
      i = t.resetOnDisconnect,
      o = i === void 0 ? !0 : i,
      a = n(),
      s = new Aut.Observable(function (u) {
        return a.subscribe(u);
      });
    return (
      (s.connect = function () {
        return (
          (!r || r.closed) &&
            ((r = Put.defer(function () {
              return e;
            }).subscribe(a)),
            o &&
              r.add(function () {
                return (a = n());
              })),
          r
        );
      }),
      s
    );
  }
  KP.connectable = Iut;
});
var tae = g((WP) => {
  "use strict";
  c();
  Object.defineProperty(WP, "__esModule", { value: !0 });
  WP.forkJoin = void 0;
  var xut = ar(),
    Nut = wG(),
    kut = Je(),
    Dut = _o(),
    Lut = ke(),
    Mut = vd(),
    qut = OG();
  function jut() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = Dut.popResultSelector(e),
      n = Nut.argsArgArrayOrObject(e),
      i = n.args,
      o = n.keys,
      a = new xut.Observable(function (s) {
        var u = i.length;
        if (!u) {
          s.complete();
          return;
        }
        for (
          var l = new Array(u),
            d = u,
            f = u,
            m = function (y) {
              var _ = !1;
              kut.innerFrom(i[y]).subscribe(
                Lut.createOperatorSubscriber(
                  s,
                  function (E) {
                    _ || ((_ = !0), f--), (l[y] = E);
                  },
                  function () {
                    return d--;
                  },
                  void 0,
                  function () {
                    (!d || !_) &&
                      (f || s.next(o ? qut.createObject(o, l) : l),
                      s.complete());
                  },
                ),
              );
            },
            h = 0;
          h < u;
          h++
        )
          m(h);
      });
    return r ? a.pipe(Mut.mapOneOrManyArgs(r)) : a;
  }
  WP.forkJoin = jut;
});
var nae = g((Cv) => {
  "use strict";
  c();
  var Fut =
    (Cv && Cv.__read) ||
    function (e, t) {
      var r = typeof Symbol == "function" && e[Symbol.iterator];
      if (!r) return e;
      var n = r.call(e),
        i,
        o = [],
        a;
      try {
        for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
          o.push(i.value);
      } catch (s) {
        a = { error: s };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (a) throw a.error;
        }
      }
      return o;
    };
  Object.defineProperty(Cv, "__esModule", { value: !0 });
  Cv.fromEvent = void 0;
  var But = Je(),
    Uut = ar(),
    Hut = Gu(),
    Gut = tP(),
    Zp = Jt(),
    Vut = vd(),
    $ut = ["addListener", "removeListener"],
    zut = ["addEventListener", "removeEventListener"],
    Kut = ["on", "off"];
  function TG(e, t, r, n) {
    if ((Zp.isFunction(r) && ((n = r), (r = void 0)), n))
      return TG(e, t, r).pipe(Vut.mapOneOrManyArgs(n));
    var i = Fut(
        Yut(e)
          ? zut.map(function (s) {
              return function (u) {
                return e[s](t, u, r);
              };
            })
          : Wut(e)
            ? $ut.map(rae(e, t))
            : Qut(e)
              ? Kut.map(rae(e, t))
              : [],
        2,
      ),
      o = i[0],
      a = i[1];
    if (!o && Gut.isArrayLike(e))
      return Hut.mergeMap(function (s) {
        return TG(s, t, r);
      })(But.innerFrom(e));
    if (!o) throw new TypeError("Invalid event target");
    return new Uut.Observable(function (s) {
      var u = function () {
        for (var l = [], d = 0; d < arguments.length; d++) l[d] = arguments[d];
        return s.next(1 < l.length ? l : l[0]);
      };
      return (
        o(u),
        function () {
          return a(u);
        }
      );
    });
  }
  Cv.fromEvent = TG;
  function rae(e, t) {
    return function (r) {
      return function (n) {
        return e[r](t, n);
      };
    };
  }
  function Wut(e) {
    return Zp.isFunction(e.addListener) && Zp.isFunction(e.removeListener);
  }
  function Qut(e) {
    return Zp.isFunction(e.on) && Zp.isFunction(e.off);
  }
  function Yut(e) {
    return (
      Zp.isFunction(e.addEventListener) && Zp.isFunction(e.removeEventListener)
    );
  }
});
var oae = g((QP) => {
  "use strict";
  c();
  Object.defineProperty(QP, "__esModule", { value: !0 });
  QP.fromEventPattern = void 0;
  var Xut = ar(),
    Jut = Jt(),
    Zut = vd();
  function iae(e, t, r) {
    return r
      ? iae(e, t).pipe(Zut.mapOneOrManyArgs(r))
      : new Xut.Observable(function (n) {
          var i = function () {
              for (var a = [], s = 0; s < arguments.length; s++)
                a[s] = arguments[s];
              return n.next(a.length === 1 ? a[0] : a);
            },
            o = e(i);
          return Jut.isFunction(t)
            ? function () {
                return t(i, o);
              }
            : void 0;
        });
  }
  QP.fromEventPattern = iae;
});
var sae = g((wv) => {
  "use strict";
  c();
  var elt =
    (wv && wv.__generator) ||
    function (e, t) {
      var r = {
          label: 0,
          sent: function () {
            if (o[0] & 1) throw o[1];
            return o[1];
          },
          trys: [],
          ops: [],
        },
        n,
        i,
        o,
        a;
      return (
        (a = { next: s(0), throw: s(1), return: s(2) }),
        typeof Symbol == "function" &&
          (a[Symbol.iterator] = function () {
            return this;
          }),
        a
      );
      function s(l) {
        return function (d) {
          return u([l, d]);
        };
      }
      function u(l) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r; )
          try {
            if (
              ((n = 1),
              i &&
                (o =
                  l[0] & 2
                    ? i.return
                    : l[0]
                      ? i.throw || ((o = i.return) && o.call(i), 0)
                      : i.next) &&
                !(o = o.call(i, l[1])).done)
            )
              return o;
            switch (((i = 0), o && (l = [l[0] & 2, o.value]), l[0])) {
              case 0:
              case 1:
                o = l;
                break;
              case 4:
                return r.label++, { value: l[1], done: !1 };
              case 5:
                r.label++, (i = l[1]), (l = [0]);
                continue;
              case 7:
                (l = r.ops.pop()), r.trys.pop();
                continue;
              default:
                if (
                  ((o = r.trys),
                  !(o = o.length > 0 && o[o.length - 1]) &&
                    (l[0] === 6 || l[0] === 2))
                ) {
                  r = 0;
                  continue;
                }
                if (l[0] === 3 && (!o || (l[1] > o[0] && l[1] < o[3]))) {
                  r.label = l[1];
                  break;
                }
                if (l[0] === 6 && r.label < o[1]) {
                  (r.label = o[1]), (o = l);
                  break;
                }
                if (o && r.label < o[2]) {
                  (r.label = o[2]), r.ops.push(l);
                  break;
                }
                o[2] && r.ops.pop(), r.trys.pop();
                continue;
            }
            l = t.call(e, r);
          } catch (d) {
            (l = [6, d]), (i = 0);
          } finally {
            n = o = 0;
          }
        if (l[0] & 5) throw l[1];
        return { value: l[0] ? l[1] : void 0, done: !0 };
      }
    };
  Object.defineProperty(wv, "__esModule", { value: !0 });
  wv.generate = void 0;
  var aae = hi(),
    tlt = RS(),
    rlt = DS(),
    nlt = hG();
  function ilt(e, t, r, n, i) {
    var o, a, s, u;
    arguments.length === 1
      ? ((o = e),
        (u = o.initialState),
        (t = o.condition),
        (r = o.iterate),
        (a = o.resultSelector),
        (s = a === void 0 ? aae.identity : a),
        (i = o.scheduler))
      : ((u = e),
        !n || tlt.isScheduler(n) ? ((s = aae.identity), (i = n)) : (s = n));
    function l() {
      var d;
      return elt(this, function (f) {
        switch (f.label) {
          case 0:
            (d = u), (f.label = 1);
          case 1:
            return !t || t(d) ? [4, s(d)] : [3, 4];
          case 2:
            f.sent(), (f.label = 3);
          case 3:
            return (d = r(d)), [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return rlt.defer(
      i
        ? function () {
            return nlt.scheduleIterable(l(), i);
          }
        : l,
    );
  }
  wv.generate = ilt;
});
var cae = g((YP) => {
  "use strict";
  c();
  Object.defineProperty(YP, "__esModule", { value: !0 });
  YP.iif = void 0;
  var olt = DS();
  function alt(e, t, r) {
    return olt.defer(function () {
      return e() ? t : r;
    });
  }
  YP.iif = alt;
});
var _d = g((XP) => {
  "use strict";
  c();
  Object.defineProperty(XP, "__esModule", { value: !0 });
  XP.timer = void 0;
  var slt = ar(),
    clt = yo(),
    ult = RS(),
    llt = xP();
  function dlt(e, t, r) {
    e === void 0 && (e = 0), r === void 0 && (r = clt.async);
    var n = -1;
    return (
      t != null && (ult.isScheduler(t) ? (r = t) : (n = t)),
      new slt.Observable(function (i) {
        var o = llt.isValidDate(e) ? +e - r.now() : e;
        o < 0 && (o = 0);
        var a = 0;
        return r.schedule(function () {
          i.closed ||
            (i.next(a++), 0 <= n ? this.schedule(void 0, n) : i.complete());
        }, o);
      })
    );
  }
  XP.timer = dlt;
});
var AG = g((JP) => {
  "use strict";
  c();
  Object.defineProperty(JP, "__esModule", { value: !0 });
  JP.interval = void 0;
  var flt = yo(),
    plt = _d();
  function mlt(e, t) {
    return (
      e === void 0 && (e = 0),
      t === void 0 && (t = flt.asyncScheduler),
      e < 0 && (e = 0),
      plt.timer(e, e, t)
    );
  }
  JP.interval = mlt;
});
var lae = g((ZP) => {
  "use strict";
  c();
  Object.defineProperty(ZP, "__esModule", { value: !0 });
  ZP.merge = void 0;
  var hlt = NS(),
    glt = Je(),
    vlt = Is(),
    uae = _o(),
    ylt = Uu();
  function _lt() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = uae.popScheduler(e),
      n = uae.popNumber(e, 1 / 0),
      i = e;
    return i.length
      ? i.length === 1
        ? glt.innerFrom(i[0])
        : hlt.mergeAll(n)(ylt.from(i, r))
      : vlt.EMPTY;
  }
  ZP.merge = _lt;
});
var PG = g((em) => {
  "use strict";
  c();
  Object.defineProperty(em, "__esModule", { value: !0 });
  em.never = em.NEVER = void 0;
  var Elt = ar(),
    blt = mi();
  em.NEVER = new Elt.Observable(blt.noop);
  function Slt() {
    return em.NEVER;
  }
  em.never = Slt;
});
var Ov = g((eR) => {
  "use strict";
  c();
  Object.defineProperty(eR, "__esModule", { value: !0 });
  eR.argsOrArgArray = void 0;
  var Clt = Array.isArray;
  function wlt(e) {
    return e.length === 1 && Clt(e[0]) ? e[0] : e;
  }
  eR.argsOrArgArray = wlt;
});
var RG = g((tR) => {
  "use strict";
  c();
  Object.defineProperty(tR, "__esModule", { value: !0 });
  tR.onErrorResumeNext = void 0;
  var Olt = ar(),
    Tlt = Ov(),
    Alt = ke(),
    dae = mi(),
    Plt = Je();
  function Rlt() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = Tlt.argsOrArgArray(e);
    return new Olt.Observable(function (n) {
      var i = 0,
        o = function () {
          if (i < r.length) {
            var a = void 0;
            try {
              a = Plt.innerFrom(r[i++]);
            } catch {
              o();
              return;
            }
            var s = new Alt.OperatorSubscriber(n, void 0, dae.noop, dae.noop);
            a.subscribe(s), s.add(o);
          } else n.complete();
        };
      o();
    });
  }
  tR.onErrorResumeNext = Rlt;
});
var fae = g((rR) => {
  "use strict";
  c();
  Object.defineProperty(rR, "__esModule", { value: !0 });
  rR.pairs = void 0;
  var Ilt = Uu();
  function xlt(e, t) {
    return Ilt.from(Object.entries(e), t);
  }
  rR.pairs = xlt;
});
var pae = g((nR) => {
  "use strict";
  c();
  Object.defineProperty(nR, "__esModule", { value: !0 });
  nR.not = void 0;
  function Nlt(e, t) {
    return function (r, n) {
      return !e.call(t, r, n);
    };
  }
  nR.not = Nlt;
});
var tm = g((iR) => {
  "use strict";
  c();
  Object.defineProperty(iR, "__esModule", { value: !0 });
  iR.filter = void 0;
  var klt = ve(),
    Dlt = ke();
  function Llt(e, t) {
    return klt.operate(function (r, n) {
      var i = 0;
      r.subscribe(
        Dlt.createOperatorSubscriber(n, function (o) {
          return e.call(t, o, i++) && n.next(o);
        }),
      );
    });
  }
  iR.filter = Llt;
});
var gae = g((oR) => {
  "use strict";
  c();
  Object.defineProperty(oR, "__esModule", { value: !0 });
  oR.partition = void 0;
  var Mlt = pae(),
    mae = tm(),
    hae = Je();
  function qlt(e, t, r) {
    return [
      mae.filter(t, r)(hae.innerFrom(e)),
      mae.filter(Mlt.not(t, r))(hae.innerFrom(e)),
    ];
  }
  oR.partition = qlt;
});
var IG = g((Tv) => {
  "use strict";
  c();
  Object.defineProperty(Tv, "__esModule", { value: !0 });
  Tv.raceInit = Tv.race = void 0;
  var jlt = ar(),
    vae = Je(),
    Flt = Ov(),
    Blt = ke();
  function Ult() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return (
      (e = Flt.argsOrArgArray(e)),
      e.length === 1 ? vae.innerFrom(e[0]) : new jlt.Observable(yae(e))
    );
  }
  Tv.race = Ult;
  function yae(e) {
    return function (t) {
      for (
        var r = [],
          n = function (o) {
            r.push(
              vae.innerFrom(e[o]).subscribe(
                Blt.createOperatorSubscriber(t, function (a) {
                  if (r) {
                    for (var s = 0; s < r.length; s++)
                      s !== o && r[s].unsubscribe();
                    r = null;
                  }
                  t.next(a);
                }),
              ),
            );
          },
          i = 0;
        r && !t.closed && i < e.length;
        i++
      )
        n(i);
    };
  }
  Tv.raceInit = yae;
});
var _ae = g((aR) => {
  "use strict";
  c();
  Object.defineProperty(aR, "__esModule", { value: !0 });
  aR.range = void 0;
  var Hlt = ar(),
    Glt = Is();
  function Vlt(e, t, r) {
    if ((t == null && ((t = e), (e = 0)), t <= 0)) return Glt.EMPTY;
    var n = t + e;
    return new Hlt.Observable(
      r
        ? function (i) {
            var o = e;
            return r.schedule(function () {
              o < n ? (i.next(o++), this.schedule()) : i.complete();
            });
          }
        : function (i) {
            for (var o = e; o < n && !i.closed; ) i.next(o++);
            i.complete();
          },
    );
  }
  aR.range = Vlt;
});
var Eae = g((sR) => {
  "use strict";
  c();
  Object.defineProperty(sR, "__esModule", { value: !0 });
  sR.using = void 0;
  var $lt = ar(),
    zlt = Je(),
    Klt = Is();
  function Wlt(e, t) {
    return new $lt.Observable(function (r) {
      var n = e(),
        i = t(n),
        o = i ? zlt.innerFrom(i) : Klt.EMPTY;
      return (
        o.subscribe(r),
        function () {
          n && n.unsubscribe();
        }
      );
    });
  }
  sR.using = Wlt;
});
var cR = g((Ed) => {
  "use strict";
  c();
  var Qlt =
      (Ed && Ed.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Ylt =
      (Ed && Ed.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Ed, "__esModule", { value: !0 });
  Ed.zip = void 0;
  var Xlt = ar(),
    Jlt = Je(),
    Zlt = Ov(),
    edt = Is(),
    tdt = ke(),
    rdt = _o();
  function ndt() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = rdt.popResultSelector(e),
      n = Zlt.argsOrArgArray(e);
    return n.length
      ? new Xlt.Observable(function (i) {
          var o = n.map(function () {
              return [];
            }),
            a = n.map(function () {
              return !1;
            });
          i.add(function () {
            o = a = null;
          });
          for (
            var s = function (l) {
                Jlt.innerFrom(n[l]).subscribe(
                  tdt.createOperatorSubscriber(
                    i,
                    function (d) {
                      if (
                        (o[l].push(d),
                        o.every(function (m) {
                          return m.length;
                        }))
                      ) {
                        var f = o.map(function (m) {
                          return m.shift();
                        });
                        i.next(r ? r.apply(void 0, Ylt([], Qlt(f))) : f),
                          o.some(function (m, h) {
                            return !m.length && a[h];
                          }) && i.complete();
                      }
                    },
                    function () {
                      (a[l] = !0), !o[l].length && i.complete();
                    },
                  ),
                );
              },
              u = 0;
            !i.closed && u < n.length;
            u++
          )
            s(u);
          return function () {
            o = a = null;
          };
        })
      : edt.EMPTY;
  }
  Ed.zip = ndt;
});
var Sae = g((bae) => {
  "use strict";
  c();
  Object.defineProperty(bae, "__esModule", { value: !0 });
});
var xG = g((uR) => {
  "use strict";
  c();
  Object.defineProperty(uR, "__esModule", { value: !0 });
  uR.audit = void 0;
  var idt = ve(),
    odt = Je(),
    Cae = ke();
  function adt(e) {
    return idt.operate(function (t, r) {
      var n = !1,
        i = null,
        o = null,
        a = !1,
        s = function () {
          if ((o?.unsubscribe(), (o = null), n)) {
            n = !1;
            var l = i;
            (i = null), r.next(l);
          }
          a && r.complete();
        },
        u = function () {
          (o = null), a && r.complete();
        };
      t.subscribe(
        Cae.createOperatorSubscriber(
          r,
          function (l) {
            (n = !0),
              (i = l),
              o ||
                odt
                  .innerFrom(e(l))
                  .subscribe((o = Cae.createOperatorSubscriber(r, s, u)));
          },
          function () {
            (a = !0), (!n || !o || o.closed) && r.complete();
          },
        ),
      );
    });
  }
  uR.audit = adt;
});
var wae = g((lR) => {
  "use strict";
  c();
  Object.defineProperty(lR, "__esModule", { value: !0 });
  lR.auditTime = void 0;
  var sdt = yo(),
    cdt = xG(),
    udt = _d();
  function ldt(e, t) {
    return (
      t === void 0 && (t = sdt.asyncScheduler),
      cdt.audit(function () {
        return udt.timer(e, t);
      })
    );
  }
  lR.auditTime = ldt;
});
var Tae = g((dR) => {
  "use strict";
  c();
  Object.defineProperty(dR, "__esModule", { value: !0 });
  dR.buffer = void 0;
  var ddt = ve(),
    fdt = mi(),
    Oae = ke(),
    pdt = Je();
  function mdt(e) {
    return ddt.operate(function (t, r) {
      var n = [];
      return (
        t.subscribe(
          Oae.createOperatorSubscriber(
            r,
            function (i) {
              return n.push(i);
            },
            function () {
              r.next(n), r.complete();
            },
          ),
        ),
        pdt.innerFrom(e).subscribe(
          Oae.createOperatorSubscriber(
            r,
            function () {
              var i = n;
              (n = []), r.next(i);
            },
            fdt.noop,
          ),
        ),
        function () {
          n = null;
        }
      );
    });
  }
  dR.buffer = mdt;
});
var Aae = g((Av) => {
  "use strict";
  c();
  var NG =
    (Av && Av.__values) ||
    function (e) {
      var t = typeof Symbol == "function" && Symbol.iterator,
        r = t && e[t],
        n = 0;
      if (r) return r.call(e);
      if (e && typeof e.length == "number")
        return {
          next: function () {
            return (
              e && n >= e.length && (e = void 0),
              { value: e && e[n++], done: !e }
            );
          },
        };
      throw new TypeError(
        t ? "Object is not iterable." : "Symbol.iterator is not defined.",
      );
    };
  Object.defineProperty(Av, "__esModule", { value: !0 });
  Av.bufferCount = void 0;
  var hdt = ve(),
    gdt = ke(),
    vdt = Fu();
  function ydt(e, t) {
    return (
      t === void 0 && (t = null),
      (t = t ?? e),
      hdt.operate(function (r, n) {
        var i = [],
          o = 0;
        r.subscribe(
          gdt.createOperatorSubscriber(
            n,
            function (a) {
              var s,
                u,
                l,
                d,
                f = null;
              o++ % t === 0 && i.push([]);
              try {
                for (var m = NG(i), h = m.next(); !h.done; h = m.next()) {
                  var y = h.value;
                  y.push(a), e <= y.length && ((f = f ?? []), f.push(y));
                }
              } catch (b) {
                s = { error: b };
              } finally {
                try {
                  h && !h.done && (u = m.return) && u.call(m);
                } finally {
                  if (s) throw s.error;
                }
              }
              if (f)
                try {
                  for (var _ = NG(f), E = _.next(); !E.done; E = _.next()) {
                    var y = E.value;
                    vdt.arrRemove(i, y), n.next(y);
                  }
                } catch (b) {
                  l = { error: b };
                } finally {
                  try {
                    E && !E.done && (d = _.return) && d.call(_);
                  } finally {
                    if (l) throw l.error;
                  }
                }
            },
            function () {
              var a, s;
              try {
                for (var u = NG(i), l = u.next(); !l.done; l = u.next()) {
                  var d = l.value;
                  n.next(d);
                }
              } catch (f) {
                a = { error: f };
              } finally {
                try {
                  l && !l.done && (s = u.return) && s.call(u);
                } finally {
                  if (a) throw a.error;
                }
              }
              n.complete();
            },
            void 0,
            function () {
              i = null;
            },
          ),
        );
      })
    );
  }
  Av.bufferCount = ydt;
});
var Rae = g((Pv) => {
  "use strict";
  c();
  var _dt =
    (Pv && Pv.__values) ||
    function (e) {
      var t = typeof Symbol == "function" && Symbol.iterator,
        r = t && e[t],
        n = 0;
      if (r) return r.call(e);
      if (e && typeof e.length == "number")
        return {
          next: function () {
            return (
              e && n >= e.length && (e = void 0),
              { value: e && e[n++], done: !e }
            );
          },
        };
      throw new TypeError(
        t ? "Object is not iterable." : "Symbol.iterator is not defined.",
      );
    };
  Object.defineProperty(Pv, "__esModule", { value: !0 });
  Pv.bufferTime = void 0;
  var Edt = Jo(),
    bdt = ve(),
    Sdt = ke(),
    Cdt = Fu(),
    wdt = yo(),
    Odt = _o(),
    Pae = Bu();
  function Tdt(e) {
    for (var t, r, n = [], i = 1; i < arguments.length; i++)
      n[i - 1] = arguments[i];
    var o =
        (t = Odt.popScheduler(n)) !== null && t !== void 0
          ? t
          : wdt.asyncScheduler,
      a = (r = n[0]) !== null && r !== void 0 ? r : null,
      s = n[1] || 1 / 0;
    return bdt.operate(function (u, l) {
      var d = [],
        f = !1,
        m = function (_) {
          var E = _.buffer,
            b = _.subs;
          b.unsubscribe(), Cdt.arrRemove(d, _), l.next(E), f && h();
        },
        h = function () {
          if (d) {
            var _ = new Edt.Subscription();
            l.add(_);
            var E = [],
              b = { buffer: E, subs: _ };
            d.push(b),
              Pae.executeSchedule(
                _,
                o,
                function () {
                  return m(b);
                },
                e,
              );
          }
        };
      a !== null && a >= 0 ? Pae.executeSchedule(l, o, h, a, !0) : (f = !0),
        h();
      var y = Sdt.createOperatorSubscriber(
        l,
        function (_) {
          var E,
            b,
            O = d.slice();
          try {
            for (var C = _dt(O), P = C.next(); !P.done; P = C.next()) {
              var k = P.value,
                H = k.buffer;
              H.push(_), s <= H.length && m(k);
            }
          } catch (B) {
            E = { error: B };
          } finally {
            try {
              P && !P.done && (b = C.return) && b.call(C);
            } finally {
              if (E) throw E.error;
            }
          }
        },
        function () {
          for (; d?.length; ) l.next(d.shift().buffer);
          y?.unsubscribe(), l.complete(), l.unsubscribe();
        },
        void 0,
        function () {
          return (d = null);
        },
      );
      u.subscribe(y);
    });
  }
  Pv.bufferTime = Tdt;
});
var Nae = g((Rv) => {
  "use strict";
  c();
  var Adt =
    (Rv && Rv.__values) ||
    function (e) {
      var t = typeof Symbol == "function" && Symbol.iterator,
        r = t && e[t],
        n = 0;
      if (r) return r.call(e);
      if (e && typeof e.length == "number")
        return {
          next: function () {
            return (
              e && n >= e.length && (e = void 0),
              { value: e && e[n++], done: !e }
            );
          },
        };
      throw new TypeError(
        t ? "Object is not iterable." : "Symbol.iterator is not defined.",
      );
    };
  Object.defineProperty(Rv, "__esModule", { value: !0 });
  Rv.bufferToggle = void 0;
  var Pdt = Jo(),
    Rdt = ve(),
    Iae = Je(),
    kG = ke(),
    xae = mi(),
    Idt = Fu();
  function xdt(e, t) {
    return Rdt.operate(function (r, n) {
      var i = [];
      Iae.innerFrom(e).subscribe(
        kG.createOperatorSubscriber(
          n,
          function (o) {
            var a = [];
            i.push(a);
            var s = new Pdt.Subscription(),
              u = function () {
                Idt.arrRemove(i, a), n.next(a), s.unsubscribe();
              };
            s.add(
              Iae.innerFrom(t(o)).subscribe(
                kG.createOperatorSubscriber(n, u, xae.noop),
              ),
            );
          },
          xae.noop,
        ),
      ),
        r.subscribe(
          kG.createOperatorSubscriber(
            n,
            function (o) {
              var a, s;
              try {
                for (var u = Adt(i), l = u.next(); !l.done; l = u.next()) {
                  var d = l.value;
                  d.push(o);
                }
              } catch (f) {
                a = { error: f };
              } finally {
                try {
                  l && !l.done && (s = u.return) && s.call(u);
                } finally {
                  if (a) throw a.error;
                }
              }
            },
            function () {
              for (; i.length > 0; ) n.next(i.shift());
              n.complete();
            },
          ),
        );
    });
  }
  Rv.bufferToggle = xdt;
});
var Dae = g((fR) => {
  "use strict";
  c();
  Object.defineProperty(fR, "__esModule", { value: !0 });
  fR.bufferWhen = void 0;
  var Ndt = ve(),
    kdt = mi(),
    kae = ke(),
    Ddt = Je();
  function Ldt(e) {
    return Ndt.operate(function (t, r) {
      var n = null,
        i = null,
        o = function () {
          i?.unsubscribe();
          var a = n;
          (n = []),
            a && r.next(a),
            Ddt.innerFrom(e()).subscribe(
              (i = kae.createOperatorSubscriber(r, o, kdt.noop)),
            );
        };
      o(),
        t.subscribe(
          kae.createOperatorSubscriber(
            r,
            function (a) {
              return n?.push(a);
            },
            function () {
              n && r.next(n), r.complete();
            },
            void 0,
            function () {
              return (n = i = null);
            },
          ),
        );
    });
  }
  fR.bufferWhen = Ldt;
});
var Mae = g((pR) => {
  "use strict";
  c();
  Object.defineProperty(pR, "__esModule", { value: !0 });
  pR.catchError = void 0;
  var Mdt = Je(),
    qdt = ke(),
    jdt = ve();
  function Lae(e) {
    return jdt.operate(function (t, r) {
      var n = null,
        i = !1,
        o;
      (n = t.subscribe(
        qdt.createOperatorSubscriber(r, void 0, void 0, function (a) {
          (o = Mdt.innerFrom(e(a, Lae(e)(t)))),
            n ? (n.unsubscribe(), (n = null), o.subscribe(r)) : (i = !0);
        }),
      )),
        i && (n.unsubscribe(), (n = null), o.subscribe(r));
    });
  }
  pR.catchError = Lae;
});
var DG = g((mR) => {
  "use strict";
  c();
  Object.defineProperty(mR, "__esModule", { value: !0 });
  mR.scanInternals = void 0;
  var Fdt = ke();
  function Bdt(e, t, r, n, i) {
    return function (o, a) {
      var s = r,
        u = t,
        l = 0;
      o.subscribe(
        Fdt.createOperatorSubscriber(
          a,
          function (d) {
            var f = l++;
            (u = s ? e(u, d, f) : ((s = !0), d)), n && a.next(u);
          },
          i &&
            function () {
              s && a.next(u), a.complete();
            },
        ),
      );
    };
  }
  mR.scanInternals = Bdt;
});
var Iv = g((hR) => {
  "use strict";
  c();
  Object.defineProperty(hR, "__esModule", { value: !0 });
  hR.reduce = void 0;
  var Udt = DG(),
    Hdt = ve();
  function Gdt(e, t) {
    return Hdt.operate(Udt.scanInternals(e, t, arguments.length >= 2, !1, !0));
  }
  hR.reduce = Gdt;
});
var LG = g((gR) => {
  "use strict";
  c();
  Object.defineProperty(gR, "__esModule", { value: !0 });
  gR.toArray = void 0;
  var Vdt = Iv(),
    $dt = ve(),
    zdt = function (e, t) {
      return e.push(t), e;
    };
  function Kdt() {
    return $dt.operate(function (e, t) {
      Vdt.reduce(zdt, [])(e).subscribe(t);
    });
  }
  gR.toArray = Kdt;
});
var MG = g((vR) => {
  "use strict";
  c();
  Object.defineProperty(vR, "__esModule", { value: !0 });
  vR.joinAllInternals = void 0;
  var Wdt = hi(),
    Qdt = vd(),
    Ydt = OS(),
    Xdt = Gu(),
    Jdt = LG();
  function Zdt(e, t) {
    return Ydt.pipe(
      Jdt.toArray(),
      Xdt.mergeMap(function (r) {
        return e(r);
      }),
      t ? Qdt.mapOneOrManyArgs(t) : Wdt.identity,
    );
  }
  vR.joinAllInternals = Zdt;
});
var qG = g((yR) => {
  "use strict";
  c();
  Object.defineProperty(yR, "__esModule", { value: !0 });
  yR.combineLatestAll = void 0;
  var eft = jP(),
    tft = MG();
  function rft(e) {
    return tft.joinAllInternals(eft.combineLatest, e);
  }
  yR.combineLatestAll = rft;
});
var qae = g((_R) => {
  "use strict";
  c();
  Object.defineProperty(_R, "__esModule", { value: !0 });
  _R.combineAll = void 0;
  var nft = qG();
  _R.combineAll = nft.combineLatestAll;
});
var Uae = g((bd) => {
  "use strict";
  c();
  var jae =
      (bd && bd.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Fae =
      (bd && bd.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(bd, "__esModule", { value: !0 });
  bd.combineLatest = void 0;
  var ift = jP(),
    oft = ve(),
    aft = Ov(),
    sft = vd(),
    cft = OS(),
    uft = _o();
  function Bae() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = uft.popResultSelector(e);
    return r
      ? cft.pipe(Bae.apply(void 0, Fae([], jae(e))), sft.mapOneOrManyArgs(r))
      : oft.operate(function (n, i) {
          ift.combineLatestInit(Fae([n], jae(aft.argsOrArgArray(e))))(i);
        });
  }
  bd.combineLatest = Bae;
});
var Hae = g((Sd) => {
  "use strict";
  c();
  var lft =
      (Sd && Sd.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    dft =
      (Sd && Sd.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Sd, "__esModule", { value: !0 });
  Sd.combineLatestWith = void 0;
  var fft = Uae();
  function pft() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return fft.combineLatest.apply(void 0, dft([], lft(e)));
  }
  Sd.combineLatestWith = pft;
});
var jG = g((ER) => {
  "use strict";
  c();
  Object.defineProperty(ER, "__esModule", { value: !0 });
  ER.concatMap = void 0;
  var Gae = Gu(),
    mft = Jt();
  function hft(e, t) {
    return mft.isFunction(t) ? Gae.mergeMap(e, t, 1) : Gae.mergeMap(e, 1);
  }
  ER.concatMap = hft;
});
var $ae = g((bR) => {
  "use strict";
  c();
  Object.defineProperty(bR, "__esModule", { value: !0 });
  bR.concatMapTo = void 0;
  var Vae = jG(),
    gft = Jt();
  function vft(e, t) {
    return gft.isFunction(t)
      ? Vae.concatMap(function () {
          return e;
        }, t)
      : Vae.concatMap(function () {
          return e;
        });
  }
  bR.concatMapTo = vft;
});
var zae = g((Cd) => {
  "use strict";
  c();
  var yft =
      (Cd && Cd.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    _ft =
      (Cd && Cd.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Cd, "__esModule", { value: !0 });
  Cd.concat = void 0;
  var Eft = ve(),
    bft = VP(),
    Sft = _o(),
    Cft = Uu();
  function wft() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = Sft.popScheduler(e);
    return Eft.operate(function (n, i) {
      bft
        .concatAll()(Cft.from(_ft([n], yft(e)), r))
        .subscribe(i);
    });
  }
  Cd.concat = wft;
});
var Kae = g((wd) => {
  "use strict";
  c();
  var Oft =
      (wd && wd.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Tft =
      (wd && wd.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(wd, "__esModule", { value: !0 });
  wd.concatWith = void 0;
  var Aft = zae();
  function Pft() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return Aft.concat.apply(void 0, Tft([], Oft(e)));
  }
  wd.concatWith = Pft;
});
var Wae = g((SR) => {
  "use strict";
  c();
  Object.defineProperty(SR, "__esModule", { value: !0 });
  SR.fromSubscribable = void 0;
  var Rft = ar();
  function Ift(e) {
    return new Rft.Observable(function (t) {
      return e.subscribe(t);
    });
  }
  SR.fromSubscribable = Ift;
});
var wR = g((CR) => {
  "use strict";
  c();
  Object.defineProperty(CR, "__esModule", { value: !0 });
  CR.connect = void 0;
  var xft = gi(),
    Nft = Je(),
    kft = ve(),
    Dft = Wae(),
    Lft = {
      connector: function () {
        return new xft.Subject();
      },
    };
  function Mft(e, t) {
    t === void 0 && (t = Lft);
    var r = t.connector;
    return kft.operate(function (n, i) {
      var o = r();
      Nft.innerFrom(e(Dft.fromSubscribable(o))).subscribe(i),
        i.add(n.subscribe(o));
    });
  }
  CR.connect = Mft;
});
var Qae = g((OR) => {
  "use strict";
  c();
  Object.defineProperty(OR, "__esModule", { value: !0 });
  OR.count = void 0;
  var qft = Iv();
  function jft(e) {
    return qft.reduce(function (t, r, n) {
      return !e || e(r, n) ? t + 1 : t;
    }, 0);
  }
  OR.count = jft;
});
var Xae = g((TR) => {
  "use strict";
  c();
  Object.defineProperty(TR, "__esModule", { value: !0 });
  TR.debounce = void 0;
  var Fft = ve(),
    Bft = mi(),
    Yae = ke(),
    Uft = Je();
  function Hft(e) {
    return Fft.operate(function (t, r) {
      var n = !1,
        i = null,
        o = null,
        a = function () {
          if ((o?.unsubscribe(), (o = null), n)) {
            n = !1;
            var s = i;
            (i = null), r.next(s);
          }
        };
      t.subscribe(
        Yae.createOperatorSubscriber(
          r,
          function (s) {
            o?.unsubscribe(),
              (n = !0),
              (i = s),
              (o = Yae.createOperatorSubscriber(r, a, Bft.noop)),
              Uft.innerFrom(e(s)).subscribe(o);
          },
          function () {
            a(), r.complete();
          },
          void 0,
          function () {
            i = o = null;
          },
        ),
      );
    });
  }
  TR.debounce = Hft;
});
var Jae = g((AR) => {
  "use strict";
  c();
  Object.defineProperty(AR, "__esModule", { value: !0 });
  AR.debounceTime = void 0;
  var Gft = yo(),
    Vft = ve(),
    $ft = ke();
  function zft(e, t) {
    return (
      t === void 0 && (t = Gft.asyncScheduler),
      Vft.operate(function (r, n) {
        var i = null,
          o = null,
          a = null,
          s = function () {
            if (i) {
              i.unsubscribe(), (i = null);
              var l = o;
              (o = null), n.next(l);
            }
          };
        function u() {
          var l = a + e,
            d = t.now();
          if (d < l) {
            (i = this.schedule(void 0, l - d)), n.add(i);
            return;
          }
          s();
        }
        r.subscribe(
          $ft.createOperatorSubscriber(
            n,
            function (l) {
              (o = l), (a = t.now()), i || ((i = t.schedule(u, e)), n.add(i));
            },
            function () {
              s(), n.complete();
            },
            void 0,
            function () {
              o = i = null;
            },
          ),
        );
      })
    );
  }
  AR.debounceTime = zft;
});
var LS = g((PR) => {
  "use strict";
  c();
  Object.defineProperty(PR, "__esModule", { value: !0 });
  PR.defaultIfEmpty = void 0;
  var Kft = ve(),
    Wft = ke();
  function Qft(e) {
    return Kft.operate(function (t, r) {
      var n = !1;
      t.subscribe(
        Wft.createOperatorSubscriber(
          r,
          function (i) {
            (n = !0), r.next(i);
          },
          function () {
            n || r.next(e), r.complete();
          },
        ),
      );
    });
  }
  PR.defaultIfEmpty = Qft;
});
var MS = g((RR) => {
  "use strict";
  c();
  Object.defineProperty(RR, "__esModule", { value: !0 });
  RR.take = void 0;
  var Yft = Is(),
    Xft = ve(),
    Jft = ke();
  function Zft(e) {
    return e <= 0
      ? function () {
          return Yft.EMPTY;
        }
      : Xft.operate(function (t, r) {
          var n = 0;
          t.subscribe(
            Jft.createOperatorSubscriber(r, function (i) {
              ++n <= e && (r.next(i), e <= n && r.complete());
            }),
          );
        });
  }
  RR.take = Zft;
});
var FG = g((IR) => {
  "use strict";
  c();
  Object.defineProperty(IR, "__esModule", { value: !0 });
  IR.ignoreElements = void 0;
  var ept = ve(),
    tpt = ke(),
    rpt = mi();
  function npt() {
    return ept.operate(function (e, t) {
      e.subscribe(tpt.createOperatorSubscriber(t, rpt.noop));
    });
  }
  IR.ignoreElements = npt;
});
var BG = g((xR) => {
  "use strict";
  c();
  Object.defineProperty(xR, "__esModule", { value: !0 });
  xR.mapTo = void 0;
  var ipt = hd();
  function opt(e) {
    return ipt.map(function () {
      return e;
    });
  }
  xR.mapTo = opt;
});
var UG = g((NR) => {
  "use strict";
  c();
  Object.defineProperty(NR, "__esModule", { value: !0 });
  NR.delayWhen = void 0;
  var apt = kS(),
    Zae = MS(),
    spt = FG(),
    cpt = BG(),
    upt = Gu(),
    lpt = Je();
  function ese(e, t) {
    return t
      ? function (r) {
          return apt.concat(
            t.pipe(Zae.take(1), spt.ignoreElements()),
            r.pipe(ese(e)),
          );
        }
      : upt.mergeMap(function (r, n) {
          return lpt.innerFrom(e(r, n)).pipe(Zae.take(1), cpt.mapTo(r));
        });
  }
  NR.delayWhen = ese;
});
var tse = g((kR) => {
  "use strict";
  c();
  Object.defineProperty(kR, "__esModule", { value: !0 });
  kR.delay = void 0;
  var dpt = yo(),
    fpt = UG(),
    ppt = _d();
  function mpt(e, t) {
    t === void 0 && (t = dpt.asyncScheduler);
    var r = ppt.timer(e, t);
    return fpt.delayWhen(function () {
      return r;
    });
  }
  kR.delay = mpt;
});
var rse = g((DR) => {
  "use strict";
  c();
  Object.defineProperty(DR, "__esModule", { value: !0 });
  DR.dematerialize = void 0;
  var hpt = SP(),
    gpt = ve(),
    vpt = ke();
  function ypt() {
    return gpt.operate(function (e, t) {
      e.subscribe(
        vpt.createOperatorSubscriber(t, function (r) {
          return hpt.observeNotification(r, t);
        }),
      );
    });
  }
  DR.dematerialize = ypt;
});
var ise = g((LR) => {
  "use strict";
  c();
  Object.defineProperty(LR, "__esModule", { value: !0 });
  LR.distinct = void 0;
  var _pt = ve(),
    nse = ke(),
    Ept = mi(),
    bpt = Je();
  function Spt(e, t) {
    return _pt.operate(function (r, n) {
      var i = new Set();
      r.subscribe(
        nse.createOperatorSubscriber(n, function (o) {
          var a = e ? e(o) : o;
          i.has(a) || (i.add(a), n.next(o));
        }),
      ),
        t &&
          bpt.innerFrom(t).subscribe(
            nse.createOperatorSubscriber(
              n,
              function () {
                return i.clear();
              },
              Ept.noop,
            ),
          );
    });
  }
  LR.distinct = Spt;
});
var HG = g((MR) => {
  "use strict";
  c();
  Object.defineProperty(MR, "__esModule", { value: !0 });
  MR.distinctUntilChanged = void 0;
  var Cpt = hi(),
    wpt = ve(),
    Opt = ke();
  function Tpt(e, t) {
    return (
      t === void 0 && (t = Cpt.identity),
      (e = e ?? Apt),
      wpt.operate(function (r, n) {
        var i,
          o = !0;
        r.subscribe(
          Opt.createOperatorSubscriber(n, function (a) {
            var s = t(a);
            (o || !e(i, s)) && ((o = !1), (i = s), n.next(a));
          }),
        );
      })
    );
  }
  MR.distinctUntilChanged = Tpt;
  function Apt(e, t) {
    return e === t;
  }
});
var ose = g((qR) => {
  "use strict";
  c();
  Object.defineProperty(qR, "__esModule", { value: !0 });
  qR.distinctUntilKeyChanged = void 0;
  var Ppt = HG();
  function Rpt(e, t) {
    return Ppt.distinctUntilChanged(function (r, n) {
      return t ? t(r[e], n[e]) : r[e] === n[e];
    });
  }
  qR.distinctUntilKeyChanged = Rpt;
});
var qS = g((jR) => {
  "use strict";
  c();
  Object.defineProperty(jR, "__esModule", { value: !0 });
  jR.throwIfEmpty = void 0;
  var Ipt = md(),
    xpt = ve(),
    Npt = ke();
  function kpt(e) {
    return (
      e === void 0 && (e = Dpt),
      xpt.operate(function (t, r) {
        var n = !1;
        t.subscribe(
          Npt.createOperatorSubscriber(
            r,
            function (i) {
              (n = !0), r.next(i);
            },
            function () {
              return n ? r.complete() : r.error(e());
            },
          ),
        );
      })
    );
  }
  jR.throwIfEmpty = kpt;
  function Dpt() {
    return new Ipt.EmptyError();
  }
});
var sse = g((FR) => {
  "use strict";
  c();
  Object.defineProperty(FR, "__esModule", { value: !0 });
  FR.elementAt = void 0;
  var ase = _G(),
    Lpt = tm(),
    Mpt = qS(),
    qpt = LS(),
    jpt = MS();
  function Fpt(e, t) {
    if (e < 0) throw new ase.ArgumentOutOfRangeError();
    var r = arguments.length >= 2;
    return function (n) {
      return n.pipe(
        Lpt.filter(function (i, o) {
          return o === e;
        }),
        jpt.take(1),
        r
          ? qpt.defaultIfEmpty(t)
          : Mpt.throwIfEmpty(function () {
              return new ase.ArgumentOutOfRangeError();
            }),
      );
    };
  }
  FR.elementAt = Fpt;
});
var cse = g((Od) => {
  "use strict";
  c();
  var Bpt =
      (Od && Od.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Upt =
      (Od && Od.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Od, "__esModule", { value: !0 });
  Od.endWith = void 0;
  var Hpt = kS(),
    Gpt = EP();
  function Vpt() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return function (r) {
      return Hpt.concat(r, Gpt.of.apply(void 0, Upt([], Bpt(e))));
    };
  }
  Od.endWith = Vpt;
});
var use = g((BR) => {
  "use strict";
  c();
  Object.defineProperty(BR, "__esModule", { value: !0 });
  BR.every = void 0;
  var $pt = ve(),
    zpt = ke();
  function Kpt(e, t) {
    return $pt.operate(function (r, n) {
      var i = 0;
      r.subscribe(
        zpt.createOperatorSubscriber(
          n,
          function (o) {
            e.call(t, o, i++, r) || (n.next(!1), n.complete());
          },
          function () {
            n.next(!0), n.complete();
          },
        ),
      );
    });
  }
  BR.every = Kpt;
});
var GG = g((UR) => {
  "use strict";
  c();
  Object.defineProperty(UR, "__esModule", { value: !0 });
  UR.exhaustMap = void 0;
  var Wpt = hd(),
    lse = Je(),
    Qpt = ve(),
    dse = ke();
  function fse(e, t) {
    return t
      ? function (r) {
          return r.pipe(
            fse(function (n, i) {
              return lse.innerFrom(e(n, i)).pipe(
                Wpt.map(function (o, a) {
                  return t(n, o, i, a);
                }),
              );
            }),
          );
        }
      : Qpt.operate(function (r, n) {
          var i = 0,
            o = null,
            a = !1;
          r.subscribe(
            dse.createOperatorSubscriber(
              n,
              function (s) {
                o ||
                  ((o = dse.createOperatorSubscriber(n, void 0, function () {
                    (o = null), a && n.complete();
                  })),
                  lse.innerFrom(e(s, i++)).subscribe(o));
              },
              function () {
                (a = !0), !o && n.complete();
              },
            ),
          );
        });
  }
  UR.exhaustMap = fse;
});
var VG = g((HR) => {
  "use strict";
  c();
  Object.defineProperty(HR, "__esModule", { value: !0 });
  HR.exhaustAll = void 0;
  var Ypt = GG(),
    Xpt = hi();
  function Jpt() {
    return Ypt.exhaustMap(Xpt.identity);
  }
  HR.exhaustAll = Jpt;
});
var pse = g((GR) => {
  "use strict";
  c();
  Object.defineProperty(GR, "__esModule", { value: !0 });
  GR.exhaust = void 0;
  var Zpt = VG();
  GR.exhaust = Zpt.exhaustAll;
});
var mse = g((VR) => {
  "use strict";
  c();
  Object.defineProperty(VR, "__esModule", { value: !0 });
  VR.expand = void 0;
  var emt = ve(),
    tmt = BP();
  function rmt(e, t, r) {
    return (
      t === void 0 && (t = 1 / 0),
      (t = (t || 0) < 1 ? 1 / 0 : t),
      emt.operate(function (n, i) {
        return tmt.mergeInternals(n, i, e, t, void 0, !0, r);
      })
    );
  }
  VR.expand = rmt;
});
var hse = g(($R) => {
  "use strict";
  c();
  Object.defineProperty($R, "__esModule", { value: !0 });
  $R.finalize = void 0;
  var nmt = ve();
  function imt(e) {
    return nmt.operate(function (t, r) {
      try {
        t.subscribe(r);
      } finally {
        r.add(e);
      }
    });
  }
  $R.finalize = imt;
});
var $G = g((xv) => {
  "use strict";
  c();
  Object.defineProperty(xv, "__esModule", { value: !0 });
  xv.createFind = xv.find = void 0;
  var omt = ve(),
    amt = ke();
  function smt(e, t) {
    return omt.operate(gse(e, t, "value"));
  }
  xv.find = smt;
  function gse(e, t, r) {
    var n = r === "index";
    return function (i, o) {
      var a = 0;
      i.subscribe(
        amt.createOperatorSubscriber(
          o,
          function (s) {
            var u = a++;
            e.call(t, s, u, i) && (o.next(n ? u : s), o.complete());
          },
          function () {
            o.next(n ? -1 : void 0), o.complete();
          },
        ),
      );
    };
  }
  xv.createFind = gse;
});
var vse = g((zR) => {
  "use strict";
  c();
  Object.defineProperty(zR, "__esModule", { value: !0 });
  zR.findIndex = void 0;
  var cmt = ve(),
    umt = $G();
  function lmt(e, t) {
    return cmt.operate(umt.createFind(e, t, "index"));
  }
  zR.findIndex = lmt;
});
var yse = g((KR) => {
  "use strict";
  c();
  Object.defineProperty(KR, "__esModule", { value: !0 });
  KR.first = void 0;
  var dmt = md(),
    fmt = tm(),
    pmt = MS(),
    mmt = LS(),
    hmt = qS(),
    gmt = hi();
  function vmt(e, t) {
    var r = arguments.length >= 2;
    return function (n) {
      return n.pipe(
        e
          ? fmt.filter(function (i, o) {
              return e(i, o, n);
            })
          : gmt.identity,
        pmt.take(1),
        r
          ? mmt.defaultIfEmpty(t)
          : hmt.throwIfEmpty(function () {
              return new dmt.EmptyError();
            }),
      );
    };
  }
  KR.first = vmt;
});
var Ese = g((WR) => {
  "use strict";
  c();
  Object.defineProperty(WR, "__esModule", { value: !0 });
  WR.groupBy = void 0;
  var ymt = ar(),
    _mt = Je(),
    Emt = gi(),
    bmt = ve(),
    _se = ke();
  function Smt(e, t, r, n) {
    return bmt.operate(function (i, o) {
      var a;
      !t || typeof t == "function"
        ? (a = t)
        : ((r = t.duration), (a = t.element), (n = t.connector));
      var s = new Map(),
        u = function (y) {
          s.forEach(y), y(o);
        },
        l = function (y) {
          return u(function (_) {
            return _.error(y);
          });
        },
        d = 0,
        f = !1,
        m = new _se.OperatorSubscriber(
          o,
          function (y) {
            try {
              var _ = e(y),
                E = s.get(_);
              if (!E) {
                s.set(_, (E = n ? n() : new Emt.Subject()));
                var b = h(_, E);
                if ((o.next(b), r)) {
                  var O = _se.createOperatorSubscriber(
                    E,
                    function () {
                      E.complete(), O?.unsubscribe();
                    },
                    void 0,
                    void 0,
                    function () {
                      return s.delete(_);
                    },
                  );
                  m.add(_mt.innerFrom(r(b)).subscribe(O));
                }
              }
              E.next(a ? a(y) : y);
            } catch (C) {
              l(C);
            }
          },
          function () {
            return u(function (y) {
              return y.complete();
            });
          },
          l,
          function () {
            return s.clear();
          },
          function () {
            return (f = !0), d === 0;
          },
        );
      i.subscribe(m);
      function h(y, _) {
        var E = new ymt.Observable(function (b) {
          d++;
          var O = _.subscribe(b);
          return function () {
            O.unsubscribe(), --d === 0 && f && m.unsubscribe();
          };
        });
        return (E.key = y), E;
      }
    });
  }
  WR.groupBy = Smt;
});
var bse = g((QR) => {
  "use strict";
  c();
  Object.defineProperty(QR, "__esModule", { value: !0 });
  QR.isEmpty = void 0;
  var Cmt = ve(),
    wmt = ke();
  function Omt() {
    return Cmt.operate(function (e, t) {
      e.subscribe(
        wmt.createOperatorSubscriber(
          t,
          function () {
            t.next(!1), t.complete();
          },
          function () {
            t.next(!0), t.complete();
          },
        ),
      );
    });
  }
  QR.isEmpty = Omt;
});
var zG = g((Nv) => {
  "use strict";
  c();
  var Tmt =
    (Nv && Nv.__values) ||
    function (e) {
      var t = typeof Symbol == "function" && Symbol.iterator,
        r = t && e[t],
        n = 0;
      if (r) return r.call(e);
      if (e && typeof e.length == "number")
        return {
          next: function () {
            return (
              e && n >= e.length && (e = void 0),
              { value: e && e[n++], done: !e }
            );
          },
        };
      throw new TypeError(
        t ? "Object is not iterable." : "Symbol.iterator is not defined.",
      );
    };
  Object.defineProperty(Nv, "__esModule", { value: !0 });
  Nv.takeLast = void 0;
  var Amt = Is(),
    Pmt = ve(),
    Rmt = ke();
  function Imt(e) {
    return e <= 0
      ? function () {
          return Amt.EMPTY;
        }
      : Pmt.operate(function (t, r) {
          var n = [];
          t.subscribe(
            Rmt.createOperatorSubscriber(
              r,
              function (i) {
                n.push(i), e < n.length && n.shift();
              },
              function () {
                var i, o;
                try {
                  for (var a = Tmt(n), s = a.next(); !s.done; s = a.next()) {
                    var u = s.value;
                    r.next(u);
                  }
                } catch (l) {
                  i = { error: l };
                } finally {
                  try {
                    s && !s.done && (o = a.return) && o.call(a);
                  } finally {
                    if (i) throw i.error;
                  }
                }
                r.complete();
              },
              void 0,
              function () {
                n = null;
              },
            ),
          );
        });
  }
  Nv.takeLast = Imt;
});
var Sse = g((YR) => {
  "use strict";
  c();
  Object.defineProperty(YR, "__esModule", { value: !0 });
  YR.last = void 0;
  var xmt = md(),
    Nmt = tm(),
    kmt = zG(),
    Dmt = qS(),
    Lmt = LS(),
    Mmt = hi();
  function qmt(e, t) {
    var r = arguments.length >= 2;
    return function (n) {
      return n.pipe(
        e
          ? Nmt.filter(function (i, o) {
              return e(i, o, n);
            })
          : Mmt.identity,
        kmt.takeLast(1),
        r
          ? Lmt.defaultIfEmpty(t)
          : Dmt.throwIfEmpty(function () {
              return new xmt.EmptyError();
            }),
      );
    };
  }
  YR.last = qmt;
});
var Cse = g((XR) => {
  "use strict";
  c();
  Object.defineProperty(XR, "__esModule", { value: !0 });
  XR.materialize = void 0;
  var KG = SP(),
    jmt = ve(),
    Fmt = ke();
  function Bmt() {
    return jmt.operate(function (e, t) {
      e.subscribe(
        Fmt.createOperatorSubscriber(
          t,
          function (r) {
            t.next(KG.Notification.createNext(r));
          },
          function () {
            t.next(KG.Notification.createComplete()), t.complete();
          },
          function (r) {
            t.next(KG.Notification.createError(r)), t.complete();
          },
        ),
      );
    });
  }
  XR.materialize = Bmt;
});
var wse = g((JR) => {
  "use strict";
  c();
  Object.defineProperty(JR, "__esModule", { value: !0 });
  JR.max = void 0;
  var Umt = Iv(),
    Hmt = Jt();
  function Gmt(e) {
    return Umt.reduce(
      Hmt.isFunction(e)
        ? function (t, r) {
            return e(t, r) > 0 ? t : r;
          }
        : function (t, r) {
            return t > r ? t : r;
          },
    );
  }
  JR.max = Gmt;
});
var Ose = g((ZR) => {
  "use strict";
  c();
  Object.defineProperty(ZR, "__esModule", { value: !0 });
  ZR.flatMap = void 0;
  var Vmt = Gu();
  ZR.flatMap = Vmt.mergeMap;
});
var Ase = g((eI) => {
  "use strict";
  c();
  Object.defineProperty(eI, "__esModule", { value: !0 });
  eI.mergeMapTo = void 0;
  var Tse = Gu(),
    $mt = Jt();
  function zmt(e, t, r) {
    return (
      r === void 0 && (r = 1 / 0),
      $mt.isFunction(t)
        ? Tse.mergeMap(
            function () {
              return e;
            },
            t,
            r,
          )
        : (typeof t == "number" && (r = t),
          Tse.mergeMap(function () {
            return e;
          }, r))
    );
  }
  eI.mergeMapTo = zmt;
});
var Pse = g((tI) => {
  "use strict";
  c();
  Object.defineProperty(tI, "__esModule", { value: !0 });
  tI.mergeScan = void 0;
  var Kmt = ve(),
    Wmt = BP();
  function Qmt(e, t, r) {
    return (
      r === void 0 && (r = 1 / 0),
      Kmt.operate(function (n, i) {
        var o = t;
        return Wmt.mergeInternals(
          n,
          i,
          function (a, s) {
            return e(o, a, s);
          },
          r,
          function (a) {
            o = a;
          },
          !1,
          void 0,
          function () {
            return (o = null);
          },
        );
      })
    );
  }
  tI.mergeScan = Qmt;
});
var Ise = g((Td) => {
  "use strict";
  c();
  var Ymt =
      (Td && Td.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Xmt =
      (Td && Td.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Td, "__esModule", { value: !0 });
  Td.merge = void 0;
  var Jmt = ve(),
    Zmt = NS(),
    Rse = _o(),
    eht = Uu();
  function tht() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = Rse.popScheduler(e),
      n = Rse.popNumber(e, 1 / 0);
    return Jmt.operate(function (i, o) {
      Zmt.mergeAll(n)(eht.from(Xmt([i], Ymt(e)), r)).subscribe(o);
    });
  }
  Td.merge = tht;
});
var xse = g((Ad) => {
  "use strict";
  c();
  var rht =
      (Ad && Ad.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    nht =
      (Ad && Ad.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Ad, "__esModule", { value: !0 });
  Ad.mergeWith = void 0;
  var iht = Ise();
  function oht() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return iht.merge.apply(void 0, nht([], rht(e)));
  }
  Ad.mergeWith = oht;
});
var Nse = g((rI) => {
  "use strict";
  c();
  Object.defineProperty(rI, "__esModule", { value: !0 });
  rI.min = void 0;
  var aht = Iv(),
    sht = Jt();
  function cht(e) {
    return aht.reduce(
      sht.isFunction(e)
        ? function (t, r) {
            return e(t, r) < 0 ? t : r;
          }
        : function (t, r) {
            return t < r ? t : r;
          },
    );
  }
  rI.min = cht;
});
var iI = g((nI) => {
  "use strict";
  c();
  Object.defineProperty(nI, "__esModule", { value: !0 });
  nI.multicast = void 0;
  var uht = TS(),
    kse = Jt(),
    lht = wR();
  function dht(e, t) {
    var r = kse.isFunction(e)
      ? e
      : function () {
          return e;
        };
    return kse.isFunction(t)
      ? lht.connect(t, { connector: r })
      : function (n) {
          return new uht.ConnectableObservable(n, r);
        };
  }
  nI.multicast = dht;
});
var Lse = g((Ec) => {
  "use strict";
  c();
  var fht =
      (Ec && Ec.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    pht =
      (Ec && Ec.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Ec, "__esModule", { value: !0 });
  Ec.onErrorResumeNext = Ec.onErrorResumeNextWith = void 0;
  var mht = Ov(),
    hht = RG();
  function Dse() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = mht.argsOrArgArray(e);
    return function (n) {
      return hht.onErrorResumeNext.apply(void 0, pht([n], fht(r)));
    };
  }
  Ec.onErrorResumeNextWith = Dse;
  Ec.onErrorResumeNext = Dse;
});
var Mse = g((oI) => {
  "use strict";
  c();
  Object.defineProperty(oI, "__esModule", { value: !0 });
  oI.pairwise = void 0;
  var ght = ve(),
    vht = ke();
  function yht() {
    return ght.operate(function (e, t) {
      var r,
        n = !1;
      e.subscribe(
        vht.createOperatorSubscriber(t, function (i) {
          var o = r;
          (r = i), n && t.next([o, i]), (n = !0);
        }),
      );
    });
  }
  oI.pairwise = yht;
});
var qse = g((aI) => {
  "use strict";
  c();
  Object.defineProperty(aI, "__esModule", { value: !0 });
  aI.pluck = void 0;
  var _ht = hd();
  function Eht() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = e.length;
    if (r === 0) throw new Error("list of properties cannot be empty.");
    return _ht.map(function (n) {
      for (var i = n, o = 0; o < r; o++) {
        var a = i?.[e[o]];
        if (typeof a < "u") i = a;
        else return;
      }
      return i;
    });
  }
  aI.pluck = Eht;
});
var jse = g((sI) => {
  "use strict";
  c();
  Object.defineProperty(sI, "__esModule", { value: !0 });
  sI.publish = void 0;
  var bht = gi(),
    Sht = iI(),
    Cht = wR();
  function wht(e) {
    return e
      ? function (t) {
          return Cht.connect(e)(t);
        }
      : function (t) {
          return Sht.multicast(new bht.Subject())(t);
        };
  }
  sI.publish = wht;
});
var Fse = g((cI) => {
  "use strict";
  c();
  Object.defineProperty(cI, "__esModule", { value: !0 });
  cI.publishBehavior = void 0;
  var Oht = rG(),
    Tht = TS();
  function Aht(e) {
    return function (t) {
      var r = new Oht.BehaviorSubject(e);
      return new Tht.ConnectableObservable(t, function () {
        return r;
      });
    };
  }
  cI.publishBehavior = Aht;
});
var Bse = g((uI) => {
  "use strict";
  c();
  Object.defineProperty(uI, "__esModule", { value: !0 });
  uI.publishLast = void 0;
  var Pht = YA(),
    Rht = TS();
  function Iht() {
    return function (e) {
      var t = new Pht.AsyncSubject();
      return new Rht.ConnectableObservable(e, function () {
        return t;
      });
    };
  }
  uI.publishLast = Iht;
});
var Hse = g((lI) => {
  "use strict";
  c();
  Object.defineProperty(lI, "__esModule", { value: !0 });
  lI.publishReplay = void 0;
  var xht = QA(),
    Nht = iI(),
    Use = Jt();
  function kht(e, t, r, n) {
    r && !Use.isFunction(r) && (n = r);
    var i = Use.isFunction(r) ? r : void 0;
    return function (o) {
      return Nht.multicast(new xht.ReplaySubject(e, t, n), i)(o);
    };
  }
  lI.publishReplay = kht;
});
var Gse = g((Pd) => {
  "use strict";
  c();
  var Dht =
      (Pd && Pd.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Lht =
      (Pd && Pd.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Pd, "__esModule", { value: !0 });
  Pd.raceWith = void 0;
  var Mht = IG(),
    qht = ve(),
    jht = hi();
  function Fht() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return e.length
      ? qht.operate(function (r, n) {
          Mht.raceInit(Lht([r], Dht(e)))(n);
        })
      : jht.identity;
  }
  Pd.raceWith = Fht;
});
var $se = g((dI) => {
  "use strict";
  c();
  Object.defineProperty(dI, "__esModule", { value: !0 });
  dI.repeat = void 0;
  var Bht = Is(),
    Uht = ve(),
    Vse = ke(),
    Hht = Je(),
    Ght = _d();
  function Vht(e) {
    var t,
      r = 1 / 0,
      n;
    return (
      e != null &&
        (typeof e == "object"
          ? ((t = e.count), (r = t === void 0 ? 1 / 0 : t), (n = e.delay))
          : (r = e)),
      r <= 0
        ? function () {
            return Bht.EMPTY;
          }
        : Uht.operate(function (i, o) {
            var a = 0,
              s,
              u = function () {
                if ((s?.unsubscribe(), (s = null), n != null)) {
                  var d =
                      typeof n == "number" ? Ght.timer(n) : Hht.innerFrom(n(a)),
                    f = Vse.createOperatorSubscriber(o, function () {
                      f.unsubscribe(), l();
                    });
                  d.subscribe(f);
                } else l();
              },
              l = function () {
                var d = !1;
                (s = i.subscribe(
                  Vse.createOperatorSubscriber(o, void 0, function () {
                    ++a < r ? (s ? u() : (d = !0)) : o.complete();
                  }),
                )),
                  d && u();
              };
            l();
          })
    );
  }
  dI.repeat = Vht;
});
var Kse = g((fI) => {
  "use strict";
  c();
  Object.defineProperty(fI, "__esModule", { value: !0 });
  fI.repeatWhen = void 0;
  var $ht = Je(),
    zht = gi(),
    Kht = ve(),
    zse = ke();
  function Wht(e) {
    return Kht.operate(function (t, r) {
      var n,
        i = !1,
        o,
        a = !1,
        s = !1,
        u = function () {
          return s && a && (r.complete(), !0);
        },
        l = function () {
          return (
            o ||
              ((o = new zht.Subject()),
              $ht.innerFrom(e(o)).subscribe(
                zse.createOperatorSubscriber(
                  r,
                  function () {
                    n ? d() : (i = !0);
                  },
                  function () {
                    (a = !0), u();
                  },
                ),
              )),
            o
          );
        },
        d = function () {
          (s = !1),
            (n = t.subscribe(
              zse.createOperatorSubscriber(r, void 0, function () {
                (s = !0), !u() && l().next();
              }),
            )),
            i && (n.unsubscribe(), (n = null), (i = !1), d());
        };
      d();
    });
  }
  fI.repeatWhen = Wht;
});
var Qse = g((pI) => {
  "use strict";
  c();
  Object.defineProperty(pI, "__esModule", { value: !0 });
  pI.retry = void 0;
  var Qht = ve(),
    Wse = ke(),
    Yht = hi(),
    Xht = _d(),
    Jht = Je();
  function Zht(e) {
    e === void 0 && (e = 1 / 0);
    var t;
    e && typeof e == "object" ? (t = e) : (t = { count: e });
    var r = t.count,
      n = r === void 0 ? 1 / 0 : r,
      i = t.delay,
      o = t.resetOnSuccess,
      a = o === void 0 ? !1 : o;
    return n <= 0
      ? Yht.identity
      : Qht.operate(function (s, u) {
          var l = 0,
            d,
            f = function () {
              var m = !1;
              (d = s.subscribe(
                Wse.createOperatorSubscriber(
                  u,
                  function (h) {
                    a && (l = 0), u.next(h);
                  },
                  void 0,
                  function (h) {
                    if (l++ < n) {
                      var y = function () {
                        d ? (d.unsubscribe(), (d = null), f()) : (m = !0);
                      };
                      if (i != null) {
                        var _ =
                            typeof i == "number"
                              ? Xht.timer(i)
                              : Jht.innerFrom(i(h, l)),
                          E = Wse.createOperatorSubscriber(
                            u,
                            function () {
                              E.unsubscribe(), y();
                            },
                            function () {
                              u.complete();
                            },
                          );
                        _.subscribe(E);
                      } else y();
                    } else u.error(h);
                  },
                ),
              )),
                m && (d.unsubscribe(), (d = null), f());
            };
          f();
        });
  }
  pI.retry = Zht;
});
var Xse = g((mI) => {
  "use strict";
  c();
  Object.defineProperty(mI, "__esModule", { value: !0 });
  mI.retryWhen = void 0;
  var egt = Je(),
    tgt = gi(),
    rgt = ve(),
    Yse = ke();
  function ngt(e) {
    return rgt.operate(function (t, r) {
      var n,
        i = !1,
        o,
        a = function () {
          (n = t.subscribe(
            Yse.createOperatorSubscriber(r, void 0, void 0, function (s) {
              o ||
                ((o = new tgt.Subject()),
                egt.innerFrom(e(o)).subscribe(
                  Yse.createOperatorSubscriber(r, function () {
                    return n ? a() : (i = !0);
                  }),
                )),
                o && o.next(s);
            }),
          )),
            i && (n.unsubscribe(), (n = null), (i = !1), a());
        };
      a();
    });
  }
  mI.retryWhen = ngt;
});
var WG = g((hI) => {
  "use strict";
  c();
  Object.defineProperty(hI, "__esModule", { value: !0 });
  hI.sample = void 0;
  var igt = Je(),
    ogt = ve(),
    agt = mi(),
    Jse = ke();
  function sgt(e) {
    return ogt.operate(function (t, r) {
      var n = !1,
        i = null;
      t.subscribe(
        Jse.createOperatorSubscriber(r, function (o) {
          (n = !0), (i = o);
        }),
      ),
        igt.innerFrom(e).subscribe(
          Jse.createOperatorSubscriber(
            r,
            function () {
              if (n) {
                n = !1;
                var o = i;
                (i = null), r.next(o);
              }
            },
            agt.noop,
          ),
        );
    });
  }
  hI.sample = sgt;
});
var Zse = g((gI) => {
  "use strict";
  c();
  Object.defineProperty(gI, "__esModule", { value: !0 });
  gI.sampleTime = void 0;
  var cgt = yo(),
    ugt = WG(),
    lgt = AG();
  function dgt(e, t) {
    return (
      t === void 0 && (t = cgt.asyncScheduler), ugt.sample(lgt.interval(e, t))
    );
  }
  gI.sampleTime = dgt;
});
var ece = g((vI) => {
  "use strict";
  c();
  Object.defineProperty(vI, "__esModule", { value: !0 });
  vI.scan = void 0;
  var fgt = ve(),
    pgt = DG();
  function mgt(e, t) {
    return fgt.operate(pgt.scanInternals(e, t, arguments.length >= 2, !0));
  }
  vI.scan = mgt;
});
var rce = g((yI) => {
  "use strict";
  c();
  Object.defineProperty(yI, "__esModule", { value: !0 });
  yI.sequenceEqual = void 0;
  var hgt = ve(),
    ggt = ke(),
    vgt = Je();
  function ygt(e, t) {
    return (
      t === void 0 &&
        (t = function (r, n) {
          return r === n;
        }),
      hgt.operate(function (r, n) {
        var i = tce(),
          o = tce(),
          a = function (u) {
            n.next(u), n.complete();
          },
          s = function (u, l) {
            var d = ggt.createOperatorSubscriber(
              n,
              function (f) {
                var m = l.buffer,
                  h = l.complete;
                m.length === 0
                  ? h
                    ? a(!1)
                    : u.buffer.push(f)
                  : !t(f, m.shift()) && a(!1);
              },
              function () {
                u.complete = !0;
                var f = l.complete,
                  m = l.buffer;
                f && a(m.length === 0), d?.unsubscribe();
              },
            );
            return d;
          };
        r.subscribe(s(i, o)), vgt.innerFrom(e).subscribe(s(o, i));
      })
    );
  }
  yI.sequenceEqual = ygt;
  function tce() {
    return { buffer: [], complete: !1 };
  }
});
var YG = g((Rd) => {
  "use strict";
  c();
  var _gt =
      (Rd && Rd.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Egt =
      (Rd && Rd.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Rd, "__esModule", { value: !0 });
  Rd.share = void 0;
  var nce = Je(),
    bgt = gi(),
    ice = ev(),
    Sgt = ve();
  function Cgt(e) {
    e === void 0 && (e = {});
    var t = e.connector,
      r =
        t === void 0
          ? function () {
              return new bgt.Subject();
            }
          : t,
      n = e.resetOnError,
      i = n === void 0 ? !0 : n,
      o = e.resetOnComplete,
      a = o === void 0 ? !0 : o,
      s = e.resetOnRefCountZero,
      u = s === void 0 ? !0 : s;
    return function (l) {
      var d,
        f,
        m,
        h = 0,
        y = !1,
        _ = !1,
        E = function () {
          f?.unsubscribe(), (f = void 0);
        },
        b = function () {
          E(), (d = m = void 0), (y = _ = !1);
        },
        O = function () {
          var C = d;
          b(), C?.unsubscribe();
        };
      return Sgt.operate(function (C, P) {
        h++, !_ && !y && E();
        var k = (m = m ?? r());
        P.add(function () {
          h--, h === 0 && !_ && !y && (f = QG(O, u));
        }),
          k.subscribe(P),
          !d &&
            h > 0 &&
            ((d = new ice.SafeSubscriber({
              next: function (H) {
                return k.next(H);
              },
              error: function (H) {
                (_ = !0), E(), (f = QG(b, i, H)), k.error(H);
              },
              complete: function () {
                (y = !0), E(), (f = QG(b, a)), k.complete();
              },
            })),
            nce.innerFrom(C).subscribe(d));
      })(l);
    };
  }
  Rd.share = Cgt;
  function QG(e, t) {
    for (var r = [], n = 2; n < arguments.length; n++) r[n - 2] = arguments[n];
    if (t === !0) {
      e();
      return;
    }
    if (t !== !1) {
      var i = new ice.SafeSubscriber({
        next: function () {
          i.unsubscribe(), e();
        },
      });
      return nce.innerFrom(t.apply(void 0, Egt([], _gt(r)))).subscribe(i);
    }
  }
});
var oce = g((_I) => {
  "use strict";
  c();
  Object.defineProperty(_I, "__esModule", { value: !0 });
  _I.shareReplay = void 0;
  var wgt = QA(),
    Ogt = YG();
  function Tgt(e, t, r) {
    var n,
      i,
      o,
      a,
      s = !1;
    return (
      e && typeof e == "object"
        ? ((n = e.bufferSize),
          (a = n === void 0 ? 1 / 0 : n),
          (i = e.windowTime),
          (t = i === void 0 ? 1 / 0 : i),
          (o = e.refCount),
          (s = o === void 0 ? !1 : o),
          (r = e.scheduler))
        : (a = e ?? 1 / 0),
      Ogt.share({
        connector: function () {
          return new wgt.ReplaySubject(a, t, r);
        },
        resetOnError: !0,
        resetOnComplete: !1,
        resetOnRefCountZero: s,
      })
    );
  }
  _I.shareReplay = Tgt;
});
var ace = g((EI) => {
  "use strict";
  c();
  Object.defineProperty(EI, "__esModule", { value: !0 });
  EI.single = void 0;
  var Agt = md(),
    Pgt = bG(),
    Rgt = EG(),
    Igt = ve(),
    xgt = ke();
  function Ngt(e) {
    return Igt.operate(function (t, r) {
      var n = !1,
        i,
        o = !1,
        a = 0;
      t.subscribe(
        xgt.createOperatorSubscriber(
          r,
          function (s) {
            (o = !0),
              (!e || e(s, a++, t)) &&
                (n &&
                  r.error(new Pgt.SequenceError("Too many matching values")),
                (n = !0),
                (i = s));
          },
          function () {
            n
              ? (r.next(i), r.complete())
              : r.error(
                  o
                    ? new Rgt.NotFoundError("No matching values")
                    : new Agt.EmptyError(),
                );
          },
        ),
      );
    });
  }
  EI.single = Ngt;
});
var sce = g((bI) => {
  "use strict";
  c();
  Object.defineProperty(bI, "__esModule", { value: !0 });
  bI.skip = void 0;
  var kgt = tm();
  function Dgt(e) {
    return kgt.filter(function (t, r) {
      return e <= r;
    });
  }
  bI.skip = Dgt;
});
var cce = g((SI) => {
  "use strict";
  c();
  Object.defineProperty(SI, "__esModule", { value: !0 });
  SI.skipLast = void 0;
  var Lgt = hi(),
    Mgt = ve(),
    qgt = ke();
  function jgt(e) {
    return e <= 0
      ? Lgt.identity
      : Mgt.operate(function (t, r) {
          var n = new Array(e),
            i = 0;
          return (
            t.subscribe(
              qgt.createOperatorSubscriber(r, function (o) {
                var a = i++;
                if (a < e) n[a] = o;
                else {
                  var s = a % e,
                    u = n[s];
                  (n[s] = o), r.next(u);
                }
              }),
            ),
            function () {
              n = null;
            }
          );
        });
  }
  SI.skipLast = jgt;
});
var lce = g((CI) => {
  "use strict";
  c();
  Object.defineProperty(CI, "__esModule", { value: !0 });
  CI.skipUntil = void 0;
  var Fgt = ve(),
    uce = ke(),
    Bgt = Je(),
    Ugt = mi();
  function Hgt(e) {
    return Fgt.operate(function (t, r) {
      var n = !1,
        i = uce.createOperatorSubscriber(
          r,
          function () {
            i?.unsubscribe(), (n = !0);
          },
          Ugt.noop,
        );
      Bgt.innerFrom(e).subscribe(i),
        t.subscribe(
          uce.createOperatorSubscriber(r, function (o) {
            return n && r.next(o);
          }),
        );
    });
  }
  CI.skipUntil = Hgt;
});
var dce = g((wI) => {
  "use strict";
  c();
  Object.defineProperty(wI, "__esModule", { value: !0 });
  wI.skipWhile = void 0;
  var Ggt = ve(),
    Vgt = ke();
  function $gt(e) {
    return Ggt.operate(function (t, r) {
      var n = !1,
        i = 0;
      t.subscribe(
        Vgt.createOperatorSubscriber(r, function (o) {
          return (n || (n = !e(o, i++))) && r.next(o);
        }),
      );
    });
  }
  wI.skipWhile = $gt;
});
var pce = g((OI) => {
  "use strict";
  c();
  Object.defineProperty(OI, "__esModule", { value: !0 });
  OI.startWith = void 0;
  var fce = kS(),
    zgt = _o(),
    Kgt = ve();
  function Wgt() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = zgt.popScheduler(e);
    return Kgt.operate(function (n, i) {
      (r ? fce.concat(e, n, r) : fce.concat(e, n)).subscribe(i);
    });
  }
  OI.startWith = Wgt;
});
var jS = g((TI) => {
  "use strict";
  c();
  Object.defineProperty(TI, "__esModule", { value: !0 });
  TI.switchMap = void 0;
  var Qgt = Je(),
    Ygt = ve(),
    mce = ke();
  function Xgt(e, t) {
    return Ygt.operate(function (r, n) {
      var i = null,
        o = 0,
        a = !1,
        s = function () {
          return a && !i && n.complete();
        };
      r.subscribe(
        mce.createOperatorSubscriber(
          n,
          function (u) {
            i?.unsubscribe();
            var l = 0,
              d = o++;
            Qgt.innerFrom(e(u, d)).subscribe(
              (i = mce.createOperatorSubscriber(
                n,
                function (f) {
                  return n.next(t ? t(u, f, d, l++) : f);
                },
                function () {
                  (i = null), s();
                },
              )),
            );
          },
          function () {
            (a = !0), s();
          },
        ),
      );
    });
  }
  TI.switchMap = Xgt;
});
var hce = g((AI) => {
  "use strict";
  c();
  Object.defineProperty(AI, "__esModule", { value: !0 });
  AI.switchAll = void 0;
  var Jgt = jS(),
    Zgt = hi();
  function evt() {
    return Jgt.switchMap(Zgt.identity);
  }
  AI.switchAll = evt;
});
var vce = g((PI) => {
  "use strict";
  c();
  Object.defineProperty(PI, "__esModule", { value: !0 });
  PI.switchMapTo = void 0;
  var gce = jS(),
    tvt = Jt();
  function rvt(e, t) {
    return tvt.isFunction(t)
      ? gce.switchMap(function () {
          return e;
        }, t)
      : gce.switchMap(function () {
          return e;
        });
  }
  PI.switchMapTo = rvt;
});
var yce = g((RI) => {
  "use strict";
  c();
  Object.defineProperty(RI, "__esModule", { value: !0 });
  RI.switchScan = void 0;
  var nvt = jS(),
    ivt = ve();
  function ovt(e, t) {
    return ivt.operate(function (r, n) {
      var i = t;
      return (
        nvt
          .switchMap(
            function (o, a) {
              return e(i, o, a);
            },
            function (o, a) {
              return (i = a), a;
            },
          )(r)
          .subscribe(n),
        function () {
          i = null;
        }
      );
    });
  }
  RI.switchScan = ovt;
});
var _ce = g((II) => {
  "use strict";
  c();
  Object.defineProperty(II, "__esModule", { value: !0 });
  II.takeUntil = void 0;
  var avt = ve(),
    svt = ke(),
    cvt = Je(),
    uvt = mi();
  function lvt(e) {
    return avt.operate(function (t, r) {
      cvt.innerFrom(e).subscribe(
        svt.createOperatorSubscriber(
          r,
          function () {
            return r.complete();
          },
          uvt.noop,
        ),
      ),
        !r.closed && t.subscribe(r);
    });
  }
  II.takeUntil = lvt;
});
var Ece = g((xI) => {
  "use strict";
  c();
  Object.defineProperty(xI, "__esModule", { value: !0 });
  xI.takeWhile = void 0;
  var dvt = ve(),
    fvt = ke();
  function pvt(e, t) {
    return (
      t === void 0 && (t = !1),
      dvt.operate(function (r, n) {
        var i = 0;
        r.subscribe(
          fvt.createOperatorSubscriber(n, function (o) {
            var a = e(o, i++);
            (a || t) && n.next(o), !a && n.complete();
          }),
        );
      })
    );
  }
  xI.takeWhile = pvt;
});
var bce = g((NI) => {
  "use strict";
  c();
  Object.defineProperty(NI, "__esModule", { value: !0 });
  NI.tap = void 0;
  var mvt = Jt(),
    hvt = ve(),
    gvt = ke(),
    vvt = hi();
  function yvt(e, t, r) {
    var n =
      mvt.isFunction(e) || t || r ? { next: e, error: t, complete: r } : e;
    return n
      ? hvt.operate(function (i, o) {
          var a;
          (a = n.subscribe) === null || a === void 0 || a.call(n);
          var s = !0;
          i.subscribe(
            gvt.createOperatorSubscriber(
              o,
              function (u) {
                var l;
                (l = n.next) === null || l === void 0 || l.call(n, u),
                  o.next(u);
              },
              function () {
                var u;
                (s = !1),
                  (u = n.complete) === null || u === void 0 || u.call(n),
                  o.complete();
              },
              function (u) {
                var l;
                (s = !1),
                  (l = n.error) === null || l === void 0 || l.call(n, u),
                  o.error(u);
              },
              function () {
                var u, l;
                s &&
                  ((u = n.unsubscribe) === null || u === void 0 || u.call(n)),
                  (l = n.finalize) === null || l === void 0 || l.call(n);
              },
            ),
          );
        })
      : vvt.identity;
  }
  NI.tap = yvt;
});
var XG = g((kI) => {
  "use strict";
  c();
  Object.defineProperty(kI, "__esModule", { value: !0 });
  kI.throttle = void 0;
  var _vt = ve(),
    Sce = ke(),
    Evt = Je();
  function bvt(e, t) {
    return _vt.operate(function (r, n) {
      var i = t ?? {},
        o = i.leading,
        a = o === void 0 ? !0 : o,
        s = i.trailing,
        u = s === void 0 ? !1 : s,
        l = !1,
        d = null,
        f = null,
        m = !1,
        h = function () {
          f?.unsubscribe(), (f = null), u && (E(), m && n.complete());
        },
        y = function () {
          (f = null), m && n.complete();
        },
        _ = function (b) {
          return (f = Evt.innerFrom(e(b)).subscribe(
            Sce.createOperatorSubscriber(n, h, y),
          ));
        },
        E = function () {
          if (l) {
            l = !1;
            var b = d;
            (d = null), n.next(b), !m && _(b);
          }
        };
      r.subscribe(
        Sce.createOperatorSubscriber(
          n,
          function (b) {
            (l = !0), (d = b), !(f && !f.closed) && (a ? E() : _(b));
          },
          function () {
            (m = !0), !(u && l && f && !f.closed) && n.complete();
          },
        ),
      );
    });
  }
  kI.throttle = bvt;
});
var Cce = g((DI) => {
  "use strict";
  c();
  Object.defineProperty(DI, "__esModule", { value: !0 });
  DI.throttleTime = void 0;
  var Svt = yo(),
    Cvt = XG(),
    wvt = _d();
  function Ovt(e, t, r) {
    t === void 0 && (t = Svt.asyncScheduler);
    var n = wvt.timer(e, t);
    return Cvt.throttle(function () {
      return n;
    }, r);
  }
  DI.throttleTime = Ovt;
});
var Oce = g((kv) => {
  "use strict";
  c();
  Object.defineProperty(kv, "__esModule", { value: !0 });
  kv.TimeInterval = kv.timeInterval = void 0;
  var Tvt = yo(),
    Avt = ve(),
    Pvt = ke();
  function Rvt(e) {
    return (
      e === void 0 && (e = Tvt.asyncScheduler),
      Avt.operate(function (t, r) {
        var n = e.now();
        t.subscribe(
          Pvt.createOperatorSubscriber(r, function (i) {
            var o = e.now(),
              a = o - n;
            (n = o), r.next(new wce(i, a));
          }),
        );
      })
    );
  }
  kv.timeInterval = Rvt;
  var wce = (function () {
    function e(t, r) {
      (this.value = t), (this.interval = r);
    }
    return e;
  })();
  kv.TimeInterval = wce;
});
var Tce = g((LI) => {
  "use strict";
  c();
  Object.defineProperty(LI, "__esModule", { value: !0 });
  LI.timeoutWith = void 0;
  var Ivt = yo(),
    xvt = xP(),
    Nvt = NP();
  function kvt(e, t, r) {
    var n, i, o;
    if (
      ((r = r ?? Ivt.async),
      xvt.isValidDate(e) ? (n = e) : typeof e == "number" && (i = e),
      t)
    )
      o = function () {
        return t;
      };
    else throw new TypeError("No observable provided to switch to");
    if (n == null && i == null) throw new TypeError("No timeout provided.");
    return Nvt.timeout({ first: n, each: i, scheduler: r, with: o });
  }
  LI.timeoutWith = kvt;
});
var Ace = g((MI) => {
  "use strict";
  c();
  Object.defineProperty(MI, "__esModule", { value: !0 });
  MI.timestamp = void 0;
  var Dvt = WA(),
    Lvt = hd();
  function Mvt(e) {
    return (
      e === void 0 && (e = Dvt.dateTimestampProvider),
      Lvt.map(function (t) {
        return { value: t, timestamp: e.now() };
      })
    );
  }
  MI.timestamp = Mvt;
});
var Ice = g((qI) => {
  "use strict";
  c();
  Object.defineProperty(qI, "__esModule", { value: !0 });
  qI.window = void 0;
  var Pce = gi(),
    qvt = ve(),
    Rce = ke(),
    jvt = mi(),
    Fvt = Je();
  function Bvt(e) {
    return qvt.operate(function (t, r) {
      var n = new Pce.Subject();
      r.next(n.asObservable());
      var i = function (o) {
        n.error(o), r.error(o);
      };
      return (
        t.subscribe(
          Rce.createOperatorSubscriber(
            r,
            function (o) {
              return n?.next(o);
            },
            function () {
              n.complete(), r.complete();
            },
            i,
          ),
        ),
        Fvt.innerFrom(e).subscribe(
          Rce.createOperatorSubscriber(
            r,
            function () {
              n.complete(), r.next((n = new Pce.Subject()));
            },
            jvt.noop,
            i,
          ),
        ),
        function () {
          n?.unsubscribe(), (n = null);
        }
      );
    });
  }
  qI.window = Bvt;
});
var Nce = g((Dv) => {
  "use strict";
  c();
  var Uvt =
    (Dv && Dv.__values) ||
    function (e) {
      var t = typeof Symbol == "function" && Symbol.iterator,
        r = t && e[t],
        n = 0;
      if (r) return r.call(e);
      if (e && typeof e.length == "number")
        return {
          next: function () {
            return (
              e && n >= e.length && (e = void 0),
              { value: e && e[n++], done: !e }
            );
          },
        };
      throw new TypeError(
        t ? "Object is not iterable." : "Symbol.iterator is not defined.",
      );
    };
  Object.defineProperty(Dv, "__esModule", { value: !0 });
  Dv.windowCount = void 0;
  var xce = gi(),
    Hvt = ve(),
    Gvt = ke();
  function Vvt(e, t) {
    t === void 0 && (t = 0);
    var r = t > 0 ? t : e;
    return Hvt.operate(function (n, i) {
      var o = [new xce.Subject()],
        a = [],
        s = 0;
      i.next(o[0].asObservable()),
        n.subscribe(
          Gvt.createOperatorSubscriber(
            i,
            function (u) {
              var l, d;
              try {
                for (var f = Uvt(o), m = f.next(); !m.done; m = f.next()) {
                  var h = m.value;
                  h.next(u);
                }
              } catch (E) {
                l = { error: E };
              } finally {
                try {
                  m && !m.done && (d = f.return) && d.call(f);
                } finally {
                  if (l) throw l.error;
                }
              }
              var y = s - e + 1;
              if (
                (y >= 0 && y % r === 0 && o.shift().complete(), ++s % r === 0)
              ) {
                var _ = new xce.Subject();
                o.push(_), i.next(_.asObservable());
              }
            },
            function () {
              for (; o.length > 0; ) o.shift().complete();
              i.complete();
            },
            function (u) {
              for (; o.length > 0; ) o.shift().error(u);
              i.error(u);
            },
            function () {
              (a = null), (o = null);
            },
          ),
        );
    });
  }
  Dv.windowCount = Vvt;
});
var Dce = g((jI) => {
  "use strict";
  c();
  Object.defineProperty(jI, "__esModule", { value: !0 });
  jI.windowTime = void 0;
  var $vt = gi(),
    zvt = yo(),
    Kvt = Jo(),
    Wvt = ve(),
    Qvt = ke(),
    Yvt = Fu(),
    Xvt = _o(),
    kce = Bu();
  function Jvt(e) {
    for (var t, r, n = [], i = 1; i < arguments.length; i++)
      n[i - 1] = arguments[i];
    var o =
        (t = Xvt.popScheduler(n)) !== null && t !== void 0
          ? t
          : zvt.asyncScheduler,
      a = (r = n[0]) !== null && r !== void 0 ? r : null,
      s = n[1] || 1 / 0;
    return Wvt.operate(function (u, l) {
      var d = [],
        f = !1,
        m = function (E) {
          var b = E.window,
            O = E.subs;
          b.complete(), O.unsubscribe(), Yvt.arrRemove(d, E), f && h();
        },
        h = function () {
          if (d) {
            var E = new Kvt.Subscription();
            l.add(E);
            var b = new $vt.Subject(),
              O = { window: b, subs: E, seen: 0 };
            d.push(O),
              l.next(b.asObservable()),
              kce.executeSchedule(
                E,
                o,
                function () {
                  return m(O);
                },
                e,
              );
          }
        };
      a !== null && a >= 0 ? kce.executeSchedule(l, o, h, a, !0) : (f = !0),
        h();
      var y = function (E) {
          return d.slice().forEach(E);
        },
        _ = function (E) {
          y(function (b) {
            var O = b.window;
            return E(O);
          }),
            E(l),
            l.unsubscribe();
        };
      return (
        u.subscribe(
          Qvt.createOperatorSubscriber(
            l,
            function (E) {
              y(function (b) {
                b.window.next(E), s <= ++b.seen && m(b);
              });
            },
            function () {
              return _(function (E) {
                return E.complete();
              });
            },
            function (E) {
              return _(function (b) {
                return b.error(E);
              });
            },
          ),
        ),
        function () {
          d = null;
        }
      );
    });
  }
  jI.windowTime = Jvt;
});
var qce = g((Lv) => {
  "use strict";
  c();
  var Zvt =
    (Lv && Lv.__values) ||
    function (e) {
      var t = typeof Symbol == "function" && Symbol.iterator,
        r = t && e[t],
        n = 0;
      if (r) return r.call(e);
      if (e && typeof e.length == "number")
        return {
          next: function () {
            return (
              e && n >= e.length && (e = void 0),
              { value: e && e[n++], done: !e }
            );
          },
        };
      throw new TypeError(
        t ? "Object is not iterable." : "Symbol.iterator is not defined.",
      );
    };
  Object.defineProperty(Lv, "__esModule", { value: !0 });
  Lv.windowToggle = void 0;
  var eyt = gi(),
    tyt = Jo(),
    ryt = ve(),
    Lce = Je(),
    JG = ke(),
    Mce = mi(),
    nyt = Fu();
  function iyt(e, t) {
    return ryt.operate(function (r, n) {
      var i = [],
        o = function (a) {
          for (; 0 < i.length; ) i.shift().error(a);
          n.error(a);
        };
      Lce.innerFrom(e).subscribe(
        JG.createOperatorSubscriber(
          n,
          function (a) {
            var s = new eyt.Subject();
            i.push(s);
            var u = new tyt.Subscription(),
              l = function () {
                nyt.arrRemove(i, s), s.complete(), u.unsubscribe();
              },
              d;
            try {
              d = Lce.innerFrom(t(a));
            } catch (f) {
              o(f);
              return;
            }
            n.next(s.asObservable()),
              u.add(
                d.subscribe(JG.createOperatorSubscriber(n, l, Mce.noop, o)),
              );
          },
          Mce.noop,
        ),
      ),
        r.subscribe(
          JG.createOperatorSubscriber(
            n,
            function (a) {
              var s,
                u,
                l = i.slice();
              try {
                for (var d = Zvt(l), f = d.next(); !f.done; f = d.next()) {
                  var m = f.value;
                  m.next(a);
                }
              } catch (h) {
                s = { error: h };
              } finally {
                try {
                  f && !f.done && (u = d.return) && u.call(d);
                } finally {
                  if (s) throw s.error;
                }
              }
            },
            function () {
              for (; 0 < i.length; ) i.shift().complete();
              n.complete();
            },
            o,
            function () {
              for (; 0 < i.length; ) i.shift().unsubscribe();
            },
          ),
        );
    });
  }
  Lv.windowToggle = iyt;
});
var Fce = g((FI) => {
  "use strict";
  c();
  Object.defineProperty(FI, "__esModule", { value: !0 });
  FI.windowWhen = void 0;
  var oyt = gi(),
    ayt = ve(),
    jce = ke(),
    syt = Je();
  function cyt(e) {
    return ayt.operate(function (t, r) {
      var n,
        i,
        o = function (s) {
          n.error(s), r.error(s);
        },
        a = function () {
          i?.unsubscribe(),
            n?.complete(),
            (n = new oyt.Subject()),
            r.next(n.asObservable());
          var s;
          try {
            s = syt.innerFrom(e());
          } catch (u) {
            o(u);
            return;
          }
          s.subscribe((i = jce.createOperatorSubscriber(r, a, a, o)));
        };
      a(),
        t.subscribe(
          jce.createOperatorSubscriber(
            r,
            function (s) {
              return n.next(s);
            },
            function () {
              n.complete(), r.complete();
            },
            o,
            function () {
              i?.unsubscribe(), (n = null);
            },
          ),
        );
    });
  }
  FI.windowWhen = cyt;
});
var Gce = g((Id) => {
  "use strict";
  c();
  var Bce =
      (Id && Id.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    Uce =
      (Id && Id.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Id, "__esModule", { value: !0 });
  Id.withLatestFrom = void 0;
  var uyt = ve(),
    Hce = ke(),
    lyt = Je(),
    dyt = hi(),
    fyt = mi(),
    pyt = _o();
  function myt() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var r = pyt.popResultSelector(e);
    return uyt.operate(function (n, i) {
      for (
        var o = e.length,
          a = new Array(o),
          s = e.map(function () {
            return !1;
          }),
          u = !1,
          l = function (f) {
            lyt.innerFrom(e[f]).subscribe(
              Hce.createOperatorSubscriber(
                i,
                function (m) {
                  (a[f] = m),
                    !u &&
                      !s[f] &&
                      ((s[f] = !0), (u = s.every(dyt.identity)) && (s = null));
                },
                fyt.noop,
              ),
            );
          },
          d = 0;
        d < o;
        d++
      )
        l(d);
      n.subscribe(
        Hce.createOperatorSubscriber(i, function (f) {
          if (u) {
            var m = Uce([f], Bce(a));
            i.next(r ? r.apply(void 0, Uce([], Bce(m))) : m);
          }
        }),
      );
    });
  }
  Id.withLatestFrom = myt;
});
var Vce = g((BI) => {
  "use strict";
  c();
  Object.defineProperty(BI, "__esModule", { value: !0 });
  BI.zipAll = void 0;
  var hyt = cR(),
    gyt = MG();
  function vyt(e) {
    return gyt.joinAllInternals(hyt.zip, e);
  }
  BI.zipAll = vyt;
});
var $ce = g((xd) => {
  "use strict";
  c();
  var yyt =
      (xd && xd.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    _yt =
      (xd && xd.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(xd, "__esModule", { value: !0 });
  xd.zip = void 0;
  var Eyt = cR(),
    byt = ve();
  function Syt() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return byt.operate(function (r, n) {
      Eyt.zip.apply(void 0, _yt([r], yyt(e))).subscribe(n);
    });
  }
  xd.zip = Syt;
});
var zce = g((Nd) => {
  "use strict";
  c();
  var Cyt =
      (Nd && Nd.__read) ||
      function (e, t) {
        var r = typeof Symbol == "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          i,
          o = [],
          a;
        try {
          for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; )
            o.push(i.value);
        } catch (s) {
          a = { error: s };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (a) throw a.error;
          }
        }
        return o;
      },
    wyt =
      (Nd && Nd.__spreadArray) ||
      function (e, t) {
        for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
          e[i] = t[r];
        return e;
      };
  Object.defineProperty(Nd, "__esModule", { value: !0 });
  Nd.zipWith = void 0;
  var Oyt = $ce();
  function Tyt() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return Oyt.zip.apply(void 0, wyt([], Cyt(e)));
  }
  Nd.zipWith = Tyt;
});
var kd = g((S) => {
  "use strict";
  c();
  var Ayt =
      (S && S.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(e, n, {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              });
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    Pyt =
      (S && S.__exportStar) ||
      function (e, t) {
        for (var r in e)
          r !== "default" &&
            !Object.prototype.hasOwnProperty.call(t, r) &&
            Ayt(t, e, r);
      };
  Object.defineProperty(S, "__esModule", { value: !0 });
  S.interval =
    S.iif =
    S.generate =
    S.fromEventPattern =
    S.fromEvent =
    S.from =
    S.forkJoin =
    S.empty =
    S.defer =
    S.connectable =
    S.concat =
    S.combineLatest =
    S.bindNodeCallback =
    S.bindCallback =
    S.UnsubscriptionError =
    S.TimeoutError =
    S.SequenceError =
    S.ObjectUnsubscribedError =
    S.NotFoundError =
    S.EmptyError =
    S.ArgumentOutOfRangeError =
    S.firstValueFrom =
    S.lastValueFrom =
    S.isObservable =
    S.identity =
    S.noop =
    S.pipe =
    S.NotificationKind =
    S.Notification =
    S.Subscriber =
    S.Subscription =
    S.Scheduler =
    S.VirtualAction =
    S.VirtualTimeScheduler =
    S.animationFrameScheduler =
    S.animationFrame =
    S.queueScheduler =
    S.queue =
    S.asyncScheduler =
    S.async =
    S.asapScheduler =
    S.asap =
    S.AsyncSubject =
    S.ReplaySubject =
    S.BehaviorSubject =
    S.Subject =
    S.animationFrames =
    S.observable =
    S.ConnectableObservable =
    S.Observable =
      void 0;
  S.filter =
    S.expand =
    S.exhaustMap =
    S.exhaustAll =
    S.exhaust =
    S.every =
    S.endWith =
    S.elementAt =
    S.distinctUntilKeyChanged =
    S.distinctUntilChanged =
    S.distinct =
    S.dematerialize =
    S.delayWhen =
    S.delay =
    S.defaultIfEmpty =
    S.debounceTime =
    S.debounce =
    S.count =
    S.connect =
    S.concatWith =
    S.concatMapTo =
    S.concatMap =
    S.concatAll =
    S.combineLatestWith =
    S.combineLatestAll =
    S.combineAll =
    S.catchError =
    S.bufferWhen =
    S.bufferToggle =
    S.bufferTime =
    S.bufferCount =
    S.buffer =
    S.auditTime =
    S.audit =
    S.config =
    S.NEVER =
    S.EMPTY =
    S.scheduled =
    S.zip =
    S.using =
    S.timer =
    S.throwError =
    S.range =
    S.race =
    S.partition =
    S.pairs =
    S.onErrorResumeNext =
    S.of =
    S.never =
    S.merge =
      void 0;
  S.switchMap =
    S.switchAll =
    S.subscribeOn =
    S.startWith =
    S.skipWhile =
    S.skipUntil =
    S.skipLast =
    S.skip =
    S.single =
    S.shareReplay =
    S.share =
    S.sequenceEqual =
    S.scan =
    S.sampleTime =
    S.sample =
    S.refCount =
    S.retryWhen =
    S.retry =
    S.repeatWhen =
    S.repeat =
    S.reduce =
    S.raceWith =
    S.publishReplay =
    S.publishLast =
    S.publishBehavior =
    S.publish =
    S.pluck =
    S.pairwise =
    S.onErrorResumeNextWith =
    S.observeOn =
    S.multicast =
    S.min =
    S.mergeWith =
    S.mergeScan =
    S.mergeMapTo =
    S.mergeMap =
    S.flatMap =
    S.mergeAll =
    S.max =
    S.materialize =
    S.mapTo =
    S.map =
    S.last =
    S.isEmpty =
    S.ignoreElements =
    S.groupBy =
    S.first =
    S.findIndex =
    S.find =
    S.finalize =
      void 0;
  S.zipWith =
    S.zipAll =
    S.withLatestFrom =
    S.windowWhen =
    S.windowToggle =
    S.windowTime =
    S.windowCount =
    S.window =
    S.toArray =
    S.timestamp =
    S.timeoutWith =
    S.timeout =
    S.timeInterval =
    S.throwIfEmpty =
    S.throttleTime =
    S.throttle =
    S.tap =
    S.takeWhile =
    S.takeUntil =
    S.takeLast =
    S.take =
    S.switchScan =
    S.switchMapTo =
      void 0;
  var Ryt = ar();
  Object.defineProperty(S, "Observable", {
    enumerable: !0,
    get: function () {
      return Ryt.Observable;
    },
  });
  var Iyt = TS();
  Object.defineProperty(S, "ConnectableObservable", {
    enumerable: !0,
    get: function () {
      return Iyt.ConnectableObservable;
    },
  });
  var xyt = wS();
  Object.defineProperty(S, "observable", {
    enumerable: !0,
    get: function () {
      return xyt.observable;
    },
  });
  var Nyt = Xie();
  Object.defineProperty(S, "animationFrames", {
    enumerable: !0,
    get: function () {
      return Nyt.animationFrames;
    },
  });
  var kyt = gi();
  Object.defineProperty(S, "Subject", {
    enumerable: !0,
    get: function () {
      return kyt.Subject;
    },
  });
  var Dyt = rG();
  Object.defineProperty(S, "BehaviorSubject", {
    enumerable: !0,
    get: function () {
      return Dyt.BehaviorSubject;
    },
  });
  var Lyt = QA();
  Object.defineProperty(S, "ReplaySubject", {
    enumerable: !0,
    get: function () {
      return Lyt.ReplaySubject;
    },
  });
  var Myt = YA();
  Object.defineProperty(S, "AsyncSubject", {
    enumerable: !0,
    get: function () {
      return Myt.AsyncSubject;
    },
  });
  var Kce = moe();
  Object.defineProperty(S, "asap", {
    enumerable: !0,
    get: function () {
      return Kce.asap;
    },
  });
  Object.defineProperty(S, "asapScheduler", {
    enumerable: !0,
    get: function () {
      return Kce.asapScheduler;
    },
  });
  var Wce = yo();
  Object.defineProperty(S, "async", {
    enumerable: !0,
    get: function () {
      return Wce.async;
    },
  });
  Object.defineProperty(S, "asyncScheduler", {
    enumerable: !0,
    get: function () {
      return Wce.asyncScheduler;
    },
  });
  var Qce = voe();
  Object.defineProperty(S, "queue", {
    enumerable: !0,
    get: function () {
      return Qce.queue;
    },
  });
  Object.defineProperty(S, "queueScheduler", {
    enumerable: !0,
    get: function () {
      return Qce.queueScheduler;
    },
  });
  var Yce = boe();
  Object.defineProperty(S, "animationFrame", {
    enumerable: !0,
    get: function () {
      return Yce.animationFrame;
    },
  });
  Object.defineProperty(S, "animationFrameScheduler", {
    enumerable: !0,
    get: function () {
      return Yce.animationFrameScheduler;
    },
  });
  var Xce = woe();
  Object.defineProperty(S, "VirtualTimeScheduler", {
    enumerable: !0,
    get: function () {
      return Xce.VirtualTimeScheduler;
    },
  });
  Object.defineProperty(S, "VirtualAction", {
    enumerable: !0,
    get: function () {
      return Xce.VirtualAction;
    },
  });
  var qyt = iG();
  Object.defineProperty(S, "Scheduler", {
    enumerable: !0,
    get: function () {
      return qyt.Scheduler;
    },
  });
  var jyt = Jo();
  Object.defineProperty(S, "Subscription", {
    enumerable: !0,
    get: function () {
      return jyt.Subscription;
    },
  });
  var Fyt = ev();
  Object.defineProperty(S, "Subscriber", {
    enumerable: !0,
    get: function () {
      return Fyt.Subscriber;
    },
  });
  var Jce = SP();
  Object.defineProperty(S, "Notification", {
    enumerable: !0,
    get: function () {
      return Jce.Notification;
    },
  });
  Object.defineProperty(S, "NotificationKind", {
    enumerable: !0,
    get: function () {
      return Jce.NotificationKind;
    },
  });
  var Byt = OS();
  Object.defineProperty(S, "pipe", {
    enumerable: !0,
    get: function () {
      return Byt.pipe;
    },
  });
  var Uyt = mi();
  Object.defineProperty(S, "noop", {
    enumerable: !0,
    get: function () {
      return Uyt.noop;
    },
  });
  var Hyt = hi();
  Object.defineProperty(S, "identity", {
    enumerable: !0,
    get: function () {
      return Hyt.identity;
    },
  });
  var Gyt = Uoe();
  Object.defineProperty(S, "isObservable", {
    enumerable: !0,
    get: function () {
      return Gyt.isObservable;
    },
  });
  var Vyt = Hoe();
  Object.defineProperty(S, "lastValueFrom", {
    enumerable: !0,
    get: function () {
      return Vyt.lastValueFrom;
    },
  });
  var $yt = Goe();
  Object.defineProperty(S, "firstValueFrom", {
    enumerable: !0,
    get: function () {
      return $yt.firstValueFrom;
    },
  });
  var zyt = _G();
  Object.defineProperty(S, "ArgumentOutOfRangeError", {
    enumerable: !0,
    get: function () {
      return zyt.ArgumentOutOfRangeError;
    },
  });
  var Kyt = md();
  Object.defineProperty(S, "EmptyError", {
    enumerable: !0,
    get: function () {
      return Kyt.EmptyError;
    },
  });
  var Wyt = EG();
  Object.defineProperty(S, "NotFoundError", {
    enumerable: !0,
    get: function () {
      return Wyt.NotFoundError;
    },
  });
  var Qyt = J3();
  Object.defineProperty(S, "ObjectUnsubscribedError", {
    enumerable: !0,
    get: function () {
      return Qyt.ObjectUnsubscribedError;
    },
  });
  var Yyt = bG();
  Object.defineProperty(S, "SequenceError", {
    enumerable: !0,
    get: function () {
      return Yyt.SequenceError;
    },
  });
  var Xyt = NP();
  Object.defineProperty(S, "TimeoutError", {
    enumerable: !0,
    get: function () {
      return Xyt.TimeoutError;
    },
  });
  var Jyt = F3();
  Object.defineProperty(S, "UnsubscriptionError", {
    enumerable: !0,
    get: function () {
      return Jyt.UnsubscriptionError;
    },
  });
  var Zyt = $oe();
  Object.defineProperty(S, "bindCallback", {
    enumerable: !0,
    get: function () {
      return Zyt.bindCallback;
    },
  });
  var e_t = zoe();
  Object.defineProperty(S, "bindNodeCallback", {
    enumerable: !0,
    get: function () {
      return e_t.bindNodeCallback;
    },
  });
  var t_t = jP();
  Object.defineProperty(S, "combineLatest", {
    enumerable: !0,
    get: function () {
      return t_t.combineLatest;
    },
  });
  var r_t = kS();
  Object.defineProperty(S, "concat", {
    enumerable: !0,
    get: function () {
      return r_t.concat;
    },
  });
  var n_t = eae();
  Object.defineProperty(S, "connectable", {
    enumerable: !0,
    get: function () {
      return n_t.connectable;
    },
  });
  var i_t = DS();
  Object.defineProperty(S, "defer", {
    enumerable: !0,
    get: function () {
      return i_t.defer;
    },
  });
  var o_t = Is();
  Object.defineProperty(S, "empty", {
    enumerable: !0,
    get: function () {
      return o_t.empty;
    },
  });
  var a_t = tae();
  Object.defineProperty(S, "forkJoin", {
    enumerable: !0,
    get: function () {
      return a_t.forkJoin;
    },
  });
  var s_t = Uu();
  Object.defineProperty(S, "from", {
    enumerable: !0,
    get: function () {
      return s_t.from;
    },
  });
  var c_t = nae();
  Object.defineProperty(S, "fromEvent", {
    enumerable: !0,
    get: function () {
      return c_t.fromEvent;
    },
  });
  var u_t = oae();
  Object.defineProperty(S, "fromEventPattern", {
    enumerable: !0,
    get: function () {
      return u_t.fromEventPattern;
    },
  });
  var l_t = sae();
  Object.defineProperty(S, "generate", {
    enumerable: !0,
    get: function () {
      return l_t.generate;
    },
  });
  var d_t = cae();
  Object.defineProperty(S, "iif", {
    enumerable: !0,
    get: function () {
      return d_t.iif;
    },
  });
  var f_t = AG();
  Object.defineProperty(S, "interval", {
    enumerable: !0,
    get: function () {
      return f_t.interval;
    },
  });
  var p_t = lae();
  Object.defineProperty(S, "merge", {
    enumerable: !0,
    get: function () {
      return p_t.merge;
    },
  });
  var m_t = PG();
  Object.defineProperty(S, "never", {
    enumerable: !0,
    get: function () {
      return m_t.never;
    },
  });
  var h_t = EP();
  Object.defineProperty(S, "of", {
    enumerable: !0,
    get: function () {
      return h_t.of;
    },
  });
  var g_t = RG();
  Object.defineProperty(S, "onErrorResumeNext", {
    enumerable: !0,
    get: function () {
      return g_t.onErrorResumeNext;
    },
  });
  var v_t = fae();
  Object.defineProperty(S, "pairs", {
    enumerable: !0,
    get: function () {
      return v_t.pairs;
    },
  });
  var y_t = gae();
  Object.defineProperty(S, "partition", {
    enumerable: !0,
    get: function () {
      return y_t.partition;
    },
  });
  var __t = IG();
  Object.defineProperty(S, "race", {
    enumerable: !0,
    get: function () {
      return __t.race;
    },
  });
  var E_t = _ae();
  Object.defineProperty(S, "range", {
    enumerable: !0,
    get: function () {
      return E_t.range;
    },
  });
  var b_t = yG();
  Object.defineProperty(S, "throwError", {
    enumerable: !0,
    get: function () {
      return b_t.throwError;
    },
  });
  var S_t = _d();
  Object.defineProperty(S, "timer", {
    enumerable: !0,
    get: function () {
      return S_t.timer;
    },
  });
  var C_t = Eae();
  Object.defineProperty(S, "using", {
    enumerable: !0,
    get: function () {
      return C_t.using;
    },
  });
  var w_t = cR();
  Object.defineProperty(S, "zip", {
    enumerable: !0,
    get: function () {
      return w_t.zip;
    },
  });
  var O_t = vG();
  Object.defineProperty(S, "scheduled", {
    enumerable: !0,
    get: function () {
      return O_t.scheduled;
    },
  });
  var T_t = Is();
  Object.defineProperty(S, "EMPTY", {
    enumerable: !0,
    get: function () {
      return T_t.EMPTY;
    },
  });
  var A_t = PG();
  Object.defineProperty(S, "NEVER", {
    enumerable: !0,
    get: function () {
      return A_t.NEVER;
    },
  });
  Pyt(Sae(), S);
  var P_t = Jg();
  Object.defineProperty(S, "config", {
    enumerable: !0,
    get: function () {
      return P_t.config;
    },
  });
  var R_t = xG();
  Object.defineProperty(S, "audit", {
    enumerable: !0,
    get: function () {
      return R_t.audit;
    },
  });
  var I_t = wae();
  Object.defineProperty(S, "auditTime", {
    enumerable: !0,
    get: function () {
      return I_t.auditTime;
    },
  });
  var x_t = Tae();
  Object.defineProperty(S, "buffer", {
    enumerable: !0,
    get: function () {
      return x_t.buffer;
    },
  });
  var N_t = Aae();
  Object.defineProperty(S, "bufferCount", {
    enumerable: !0,
    get: function () {
      return N_t.bufferCount;
    },
  });
  var k_t = Rae();
  Object.defineProperty(S, "bufferTime", {
    enumerable: !0,
    get: function () {
      return k_t.bufferTime;
    },
  });
  var D_t = Nae();
  Object.defineProperty(S, "bufferToggle", {
    enumerable: !0,
    get: function () {
      return D_t.bufferToggle;
    },
  });
  var L_t = Dae();
  Object.defineProperty(S, "bufferWhen", {
    enumerable: !0,
    get: function () {
      return L_t.bufferWhen;
    },
  });
  var M_t = Mae();
  Object.defineProperty(S, "catchError", {
    enumerable: !0,
    get: function () {
      return M_t.catchError;
    },
  });
  var q_t = qae();
  Object.defineProperty(S, "combineAll", {
    enumerable: !0,
    get: function () {
      return q_t.combineAll;
    },
  });
  var j_t = qG();
  Object.defineProperty(S, "combineLatestAll", {
    enumerable: !0,
    get: function () {
      return j_t.combineLatestAll;
    },
  });
  var F_t = Hae();
  Object.defineProperty(S, "combineLatestWith", {
    enumerable: !0,
    get: function () {
      return F_t.combineLatestWith;
    },
  });
  var B_t = VP();
  Object.defineProperty(S, "concatAll", {
    enumerable: !0,
    get: function () {
      return B_t.concatAll;
    },
  });
  var U_t = jG();
  Object.defineProperty(S, "concatMap", {
    enumerable: !0,
    get: function () {
      return U_t.concatMap;
    },
  });
  var H_t = $ae();
  Object.defineProperty(S, "concatMapTo", {
    enumerable: !0,
    get: function () {
      return H_t.concatMapTo;
    },
  });
  var G_t = Kae();
  Object.defineProperty(S, "concatWith", {
    enumerable: !0,
    get: function () {
      return G_t.concatWith;
    },
  });
  var V_t = wR();
  Object.defineProperty(S, "connect", {
    enumerable: !0,
    get: function () {
      return V_t.connect;
    },
  });
  var $_t = Qae();
  Object.defineProperty(S, "count", {
    enumerable: !0,
    get: function () {
      return $_t.count;
    },
  });
  var z_t = Xae();
  Object.defineProperty(S, "debounce", {
    enumerable: !0,
    get: function () {
      return z_t.debounce;
    },
  });
  var K_t = Jae();
  Object.defineProperty(S, "debounceTime", {
    enumerable: !0,
    get: function () {
      return K_t.debounceTime;
    },
  });
  var W_t = LS();
  Object.defineProperty(S, "defaultIfEmpty", {
    enumerable: !0,
    get: function () {
      return W_t.defaultIfEmpty;
    },
  });
  var Q_t = tse();
  Object.defineProperty(S, "delay", {
    enumerable: !0,
    get: function () {
      return Q_t.delay;
    },
  });
  var Y_t = UG();
  Object.defineProperty(S, "delayWhen", {
    enumerable: !0,
    get: function () {
      return Y_t.delayWhen;
    },
  });
  var X_t = rse();
  Object.defineProperty(S, "dematerialize", {
    enumerable: !0,
    get: function () {
      return X_t.dematerialize;
    },
  });
  var J_t = ise();
  Object.defineProperty(S, "distinct", {
    enumerable: !0,
    get: function () {
      return J_t.distinct;
    },
  });
  var Z_t = HG();
  Object.defineProperty(S, "distinctUntilChanged", {
    enumerable: !0,
    get: function () {
      return Z_t.distinctUntilChanged;
    },
  });
  var eEt = ose();
  Object.defineProperty(S, "distinctUntilKeyChanged", {
    enumerable: !0,
    get: function () {
      return eEt.distinctUntilKeyChanged;
    },
  });
  var tEt = sse();
  Object.defineProperty(S, "elementAt", {
    enumerable: !0,
    get: function () {
      return tEt.elementAt;
    },
  });
  var rEt = cse();
  Object.defineProperty(S, "endWith", {
    enumerable: !0,
    get: function () {
      return rEt.endWith;
    },
  });
  var nEt = use();
  Object.defineProperty(S, "every", {
    enumerable: !0,
    get: function () {
      return nEt.every;
    },
  });
  var iEt = pse();
  Object.defineProperty(S, "exhaust", {
    enumerable: !0,
    get: function () {
      return iEt.exhaust;
    },
  });
  var oEt = VG();
  Object.defineProperty(S, "exhaustAll", {
    enumerable: !0,
    get: function () {
      return oEt.exhaustAll;
    },
  });
  var aEt = GG();
  Object.defineProperty(S, "exhaustMap", {
    enumerable: !0,
    get: function () {
      return aEt.exhaustMap;
    },
  });
  var sEt = mse();
  Object.defineProperty(S, "expand", {
    enumerable: !0,
    get: function () {
      return sEt.expand;
    },
  });
  var cEt = tm();
  Object.defineProperty(S, "filter", {
    enumerable: !0,
    get: function () {
      return cEt.filter;
    },
  });
  var uEt = hse();
  Object.defineProperty(S, "finalize", {
    enumerable: !0,
    get: function () {
      return uEt.finalize;
    },
  });
  var lEt = $G();
  Object.defineProperty(S, "find", {
    enumerable: !0,
    get: function () {
      return lEt.find;
    },
  });
  var dEt = vse();
  Object.defineProperty(S, "findIndex", {
    enumerable: !0,
    get: function () {
      return dEt.findIndex;
    },
  });
  var fEt = yse();
  Object.defineProperty(S, "first", {
    enumerable: !0,
    get: function () {
      return fEt.first;
    },
  });
  var pEt = Ese();
  Object.defineProperty(S, "groupBy", {
    enumerable: !0,
    get: function () {
      return pEt.groupBy;
    },
  });
  var mEt = FG();
  Object.defineProperty(S, "ignoreElements", {
    enumerable: !0,
    get: function () {
      return mEt.ignoreElements;
    },
  });
  var hEt = bse();
  Object.defineProperty(S, "isEmpty", {
    enumerable: !0,
    get: function () {
      return hEt.isEmpty;
    },
  });
  var gEt = Sse();
  Object.defineProperty(S, "last", {
    enumerable: !0,
    get: function () {
      return gEt.last;
    },
  });
  var vEt = hd();
  Object.defineProperty(S, "map", {
    enumerable: !0,
    get: function () {
      return vEt.map;
    },
  });
  var yEt = BG();
  Object.defineProperty(S, "mapTo", {
    enumerable: !0,
    get: function () {
      return yEt.mapTo;
    },
  });
  var _Et = Cse();
  Object.defineProperty(S, "materialize", {
    enumerable: !0,
    get: function () {
      return _Et.materialize;
    },
  });
  var EEt = wse();
  Object.defineProperty(S, "max", {
    enumerable: !0,
    get: function () {
      return EEt.max;
    },
  });
  var bEt = NS();
  Object.defineProperty(S, "mergeAll", {
    enumerable: !0,
    get: function () {
      return bEt.mergeAll;
    },
  });
  var SEt = Ose();
  Object.defineProperty(S, "flatMap", {
    enumerable: !0,
    get: function () {
      return SEt.flatMap;
    },
  });
  var CEt = Gu();
  Object.defineProperty(S, "mergeMap", {
    enumerable: !0,
    get: function () {
      return CEt.mergeMap;
    },
  });
  var wEt = Ase();
  Object.defineProperty(S, "mergeMapTo", {
    enumerable: !0,
    get: function () {
      return wEt.mergeMapTo;
    },
  });
  var OEt = Pse();
  Object.defineProperty(S, "mergeScan", {
    enumerable: !0,
    get: function () {
      return OEt.mergeScan;
    },
  });
  var TEt = xse();
  Object.defineProperty(S, "mergeWith", {
    enumerable: !0,
    get: function () {
      return TEt.mergeWith;
    },
  });
  var AEt = Nse();
  Object.defineProperty(S, "min", {
    enumerable: !0,
    get: function () {
      return AEt.min;
    },
  });
  var PEt = iI();
  Object.defineProperty(S, "multicast", {
    enumerable: !0,
    get: function () {
      return PEt.multicast;
    },
  });
  var REt = IS();
  Object.defineProperty(S, "observeOn", {
    enumerable: !0,
    get: function () {
      return REt.observeOn;
    },
  });
  var IEt = Lse();
  Object.defineProperty(S, "onErrorResumeNextWith", {
    enumerable: !0,
    get: function () {
      return IEt.onErrorResumeNextWith;
    },
  });
  var xEt = Mse();
  Object.defineProperty(S, "pairwise", {
    enumerable: !0,
    get: function () {
      return xEt.pairwise;
    },
  });
  var NEt = qse();
  Object.defineProperty(S, "pluck", {
    enumerable: !0,
    get: function () {
      return NEt.pluck;
    },
  });
  var kEt = jse();
  Object.defineProperty(S, "publish", {
    enumerable: !0,
    get: function () {
      return kEt.publish;
    },
  });
  var DEt = Fse();
  Object.defineProperty(S, "publishBehavior", {
    enumerable: !0,
    get: function () {
      return DEt.publishBehavior;
    },
  });
  var LEt = Bse();
  Object.defineProperty(S, "publishLast", {
    enumerable: !0,
    get: function () {
      return LEt.publishLast;
    },
  });
  var MEt = Hse();
  Object.defineProperty(S, "publishReplay", {
    enumerable: !0,
    get: function () {
      return MEt.publishReplay;
    },
  });
  var qEt = Gse();
  Object.defineProperty(S, "raceWith", {
    enumerable: !0,
    get: function () {
      return qEt.raceWith;
    },
  });
  var jEt = Iv();
  Object.defineProperty(S, "reduce", {
    enumerable: !0,
    get: function () {
      return jEt.reduce;
    },
  });
  var FEt = $se();
  Object.defineProperty(S, "repeat", {
    enumerable: !0,
    get: function () {
      return FEt.repeat;
    },
  });
  var BEt = Kse();
  Object.defineProperty(S, "repeatWhen", {
    enumerable: !0,
    get: function () {
      return BEt.repeatWhen;
    },
  });
  var UEt = Qse();
  Object.defineProperty(S, "retry", {
    enumerable: !0,
    get: function () {
      return UEt.retry;
    },
  });
  var HEt = Xse();
  Object.defineProperty(S, "retryWhen", {
    enumerable: !0,
    get: function () {
      return HEt.retryWhen;
    },
  });
  var GEt = Y3();
  Object.defineProperty(S, "refCount", {
    enumerable: !0,
    get: function () {
      return GEt.refCount;
    },
  });
  var VEt = WG();
  Object.defineProperty(S, "sample", {
    enumerable: !0,
    get: function () {
      return VEt.sample;
    },
  });
  var $Et = Zse();
  Object.defineProperty(S, "sampleTime", {
    enumerable: !0,
    get: function () {
      return $Et.sampleTime;
    },
  });
  var zEt = ece();
  Object.defineProperty(S, "scan", {
    enumerable: !0,
    get: function () {
      return zEt.scan;
    },
  });
  var KEt = rce();
  Object.defineProperty(S, "sequenceEqual", {
    enumerable: !0,
    get: function () {
      return KEt.sequenceEqual;
    },
  });
  var WEt = YG();
  Object.defineProperty(S, "share", {
    enumerable: !0,
    get: function () {
      return WEt.share;
    },
  });
  var QEt = oce();
  Object.defineProperty(S, "shareReplay", {
    enumerable: !0,
    get: function () {
      return QEt.shareReplay;
    },
  });
  var YEt = ace();
  Object.defineProperty(S, "single", {
    enumerable: !0,
    get: function () {
      return YEt.single;
    },
  });
  var XEt = sce();
  Object.defineProperty(S, "skip", {
    enumerable: !0,
    get: function () {
      return XEt.skip;
    },
  });
  var JEt = cce();
  Object.defineProperty(S, "skipLast", {
    enumerable: !0,
    get: function () {
      return JEt.skipLast;
    },
  });
  var ZEt = lce();
  Object.defineProperty(S, "skipUntil", {
    enumerable: !0,
    get: function () {
      return ZEt.skipUntil;
    },
  });
  var ebt = dce();
  Object.defineProperty(S, "skipWhile", {
    enumerable: !0,
    get: function () {
      return ebt.skipWhile;
    },
  });
  var tbt = pce();
  Object.defineProperty(S, "startWith", {
    enumerable: !0,
    get: function () {
      return tbt.startWith;
    },
  });
  var rbt = xS();
  Object.defineProperty(S, "subscribeOn", {
    enumerable: !0,
    get: function () {
      return rbt.subscribeOn;
    },
  });
  var nbt = hce();
  Object.defineProperty(S, "switchAll", {
    enumerable: !0,
    get: function () {
      return nbt.switchAll;
    },
  });
  var ibt = jS();
  Object.defineProperty(S, "switchMap", {
    enumerable: !0,
    get: function () {
      return ibt.switchMap;
    },
  });
  var obt = vce();
  Object.defineProperty(S, "switchMapTo", {
    enumerable: !0,
    get: function () {
      return obt.switchMapTo;
    },
  });
  var abt = yce();
  Object.defineProperty(S, "switchScan", {
    enumerable: !0,
    get: function () {
      return abt.switchScan;
    },
  });
  var sbt = MS();
  Object.defineProperty(S, "take", {
    enumerable: !0,
    get: function () {
      return sbt.take;
    },
  });
  var cbt = zG();
  Object.defineProperty(S, "takeLast", {
    enumerable: !0,
    get: function () {
      return cbt.takeLast;
    },
  });
  var ubt = _ce();
  Object.defineProperty(S, "takeUntil", {
    enumerable: !0,
    get: function () {
      return ubt.takeUntil;
    },
  });
  var lbt = Ece();
  Object.defineProperty(S, "takeWhile", {
    enumerable: !0,
    get: function () {
      return lbt.takeWhile;
    },
  });
  var dbt = bce();
  Object.defineProperty(S, "tap", {
    enumerable: !0,
    get: function () {
      return dbt.tap;
    },
  });
  var fbt = XG();
  Object.defineProperty(S, "throttle", {
    enumerable: !0,
    get: function () {
      return fbt.throttle;
    },
  });
  var pbt = Cce();
  Object.defineProperty(S, "throttleTime", {
    enumerable: !0,
    get: function () {
      return pbt.throttleTime;
    },
  });
  var mbt = qS();
  Object.defineProperty(S, "throwIfEmpty", {
    enumerable: !0,
    get: function () {
      return mbt.throwIfEmpty;
    },
  });
  var hbt = Oce();
  Object.defineProperty(S, "timeInterval", {
    enumerable: !0,
    get: function () {
      return hbt.timeInterval;
    },
  });
  var gbt = NP();
  Object.defineProperty(S, "timeout", {
    enumerable: !0,
    get: function () {
      return gbt.timeout;
    },
  });
  var vbt = Tce();
  Object.defineProperty(S, "timeoutWith", {
    enumerable: !0,
    get: function () {
      return vbt.timeoutWith;
    },
  });
  var ybt = Ace();
  Object.defineProperty(S, "timestamp", {
    enumerable: !0,
    get: function () {
      return ybt.timestamp;
    },
  });
  var _bt = LG();
  Object.defineProperty(S, "toArray", {
    enumerable: !0,
    get: function () {
      return _bt.toArray;
    },
  });
  var Ebt = Ice();
  Object.defineProperty(S, "window", {
    enumerable: !0,
    get: function () {
      return Ebt.window;
    },
  });
  var bbt = Nce();
  Object.defineProperty(S, "windowCount", {
    enumerable: !0,
    get: function () {
      return bbt.windowCount;
    },
  });
  var Sbt = Dce();
  Object.defineProperty(S, "windowTime", {
    enumerable: !0,
    get: function () {
      return Sbt.windowTime;
    },
  });
  var Cbt = qce();
  Object.defineProperty(S, "windowToggle", {
    enumerable: !0,
    get: function () {
      return Cbt.windowToggle;
    },
  });
  var wbt = Fce();
  Object.defineProperty(S, "windowWhen", {
    enumerable: !0,
    get: function () {
      return wbt.windowWhen;
    },
  });
  var Obt = Gce();
  Object.defineProperty(S, "withLatestFrom", {
    enumerable: !0,
    get: function () {
      return Obt.withLatestFrom;
    },
  });
  var Tbt = Vce();
  Object.defineProperty(S, "zipAll", {
    enumerable: !0,
    get: function () {
      return Tbt.zipAll;
    },
  });
  var Abt = zce();
  Object.defineProperty(S, "zipWith", {
    enumerable: !0,
    get: function () {
      return Abt.zipWith;
    },
  });
});
var yle = g((Uv) => {
  "use strict";
  c();
  Object.defineProperty(Uv, "__esModule", { value: !0 });
  Uv.versionInfo = Uv.version = void 0;
  var USt = "15.8.0";
  Uv.version = USt;
  var HSt = Object.freeze({
    major: 15,
    minor: 8,
    patch: 0,
    preReleaseTag: null,
  });
  Uv.versionInfo = HSt;
});
var Ox = g((gV) => {
  "use strict";
  c();
  Object.defineProperty(gV, "__esModule", { value: !0 });
  gV.default = GSt;
  function GSt(e) {
    return typeof e?.then == "function";
  }
});
var wc = g((vV) => {
  "use strict";
  c();
  Object.defineProperty(vV, "__esModule", { value: !0 });
  vV.default = VSt;
  function Tx(e) {
    "@babel/helpers - typeof";
    return (
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? (Tx = function (r) {
            return typeof r;
          })
        : (Tx = function (r) {
            return r &&
              typeof Symbol == "function" &&
              r.constructor === Symbol &&
              r !== Symbol.prototype
              ? "symbol"
              : typeof r;
          }),
      Tx(e)
    );
  }
  function VSt(e) {
    return Tx(e) == "object" && e !== null;
  }
});
var Oc = g((Fd) => {
  "use strict";
  c();
  Object.defineProperty(Fd, "__esModule", { value: !0 });
  Fd.SYMBOL_TO_STRING_TAG =
    Fd.SYMBOL_ASYNC_ITERATOR =
    Fd.SYMBOL_ITERATOR =
      void 0;
  var $St =
    typeof Symbol == "function" && Symbol.iterator != null
      ? Symbol.iterator
      : "@@iterator";
  Fd.SYMBOL_ITERATOR = $St;
  var zSt =
    typeof Symbol == "function" && Symbol.asyncIterator != null
      ? Symbol.asyncIterator
      : "@@asyncIterator";
  Fd.SYMBOL_ASYNC_ITERATOR = zSt;
  var KSt =
    typeof Symbol == "function" && Symbol.toStringTag != null
      ? Symbol.toStringTag
      : "@@toStringTag";
  Fd.SYMBOL_TO_STRING_TAG = KSt;
});
var Ax = g((yV) => {
  "use strict";
  c();
  Object.defineProperty(yV, "__esModule", { value: !0 });
  yV.getLocation = WSt;
  function WSt(e, t) {
    for (
      var r = /\r\n|[\n\r]/g, n = 1, i = t + 1, o;
      (o = r.exec(e.body)) && o.index < t;

    )
      (n += 1), (i = t + 1 - (o.index + o[0].length));
    return { line: n, column: i };
  }
});
var _V = g((Rx) => {
  "use strict";
  c();
  Object.defineProperty(Rx, "__esModule", { value: !0 });
  Rx.printLocation = YSt;
  Rx.printSourceLocation = Ele;
  var QSt = Ax();
  function YSt(e) {
    return Ele(e.source, (0, QSt.getLocation)(e.source, e.start));
  }
  function Ele(e, t) {
    var r = e.locationOffset.column - 1,
      n = Px(r) + e.body,
      i = t.line - 1,
      o = e.locationOffset.line - 1,
      a = t.line + o,
      s = t.line === 1 ? r : 0,
      u = t.column + s,
      l = ""
        .concat(e.name, ":")
        .concat(a, ":")
        .concat(
          u,
          `
`,
        ),
      d = n.split(/\r\n|[\n\r]/g),
      f = d[i];
    if (f.length > 120) {
      for (
        var m = Math.floor(u / 80), h = u % 80, y = [], _ = 0;
        _ < f.length;
        _ += 80
      )
        y.push(f.slice(_, _ + 80));
      return (
        l +
        _le(
          [["".concat(a), y[0]]].concat(
            y.slice(1, m + 1).map(function (E) {
              return ["", E];
            }),
            [
              [" ", Px(h - 1) + "^"],
              ["", y[m + 1]],
            ],
          ),
        )
      );
    }
    return (
      l +
      _le([
        ["".concat(a - 1), d[i - 1]],
        ["".concat(a), f],
        ["", Px(u - 1) + "^"],
        ["".concat(a + 1), d[i + 1]],
      ])
    );
  }
  function _le(e) {
    var t = e.filter(function (n) {
        var i = n[0],
          o = n[1];
        return o !== void 0;
      }),
      r = Math.max.apply(
        Math,
        t.map(function (n) {
          var i = n[0];
          return i.length;
        }),
      );
    return t.map(function (n) {
      var i = n[0],
        o = n[1];
      return XSt(r, i) + (o ? " | " + o : " |");
    }).join(`
`);
  }
  function Px(e) {
    return Array(e + 1).join(" ");
  }
  function XSt(e, t) {
    return Px(e - t.length) + t;
  }
});
var Ue = g((r0) => {
  "use strict";
  c();
  function Ix(e) {
    "@babel/helpers - typeof";
    return (
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? (Ix = function (r) {
            return typeof r;
          })
        : (Ix = function (r) {
            return r &&
              typeof Symbol == "function" &&
              r.constructor === Symbol &&
              r !== Symbol.prototype
              ? "symbol"
              : typeof r;
          }),
      Ix(e)
    );
  }
  Object.defineProperty(r0, "__esModule", { value: !0 });
  r0.printError = Ple;
  r0.GraphQLError = void 0;
  var JSt = e0t(wc()),
    ZSt = Oc(),
    ble = Ax(),
    Sle = _V();
  function e0t(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Cle(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function (i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function t0t(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2
        ? Cle(Object(r), !0).forEach(function (n) {
            r0t(e, n, r[n]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : Cle(Object(r)).forEach(function (n) {
              Object.defineProperty(
                e,
                n,
                Object.getOwnPropertyDescriptor(r, n),
              );
            });
    }
    return e;
  }
  function r0t(e, t, r) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = r),
      e
    );
  }
  function n0t(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  function wle(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      (n.enumerable = n.enumerable || !1),
        (n.configurable = !0),
        "value" in n && (n.writable = !0),
        Object.defineProperty(e, n.key, n);
    }
  }
  function i0t(e, t, r) {
    return t && wle(e.prototype, t), r && wle(e, r), e;
  }
  function o0t(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    (e.prototype = Object.create(t && t.prototype, {
      constructor: { value: e, writable: !0, configurable: !0 },
    })),
      t && e0(e, t);
  }
  function a0t(e) {
    var t = Ale();
    return function () {
      var n = t0(e),
        i;
      if (t) {
        var o = t0(this).constructor;
        i = Reflect.construct(n, arguments, o);
      } else i = n.apply(this, arguments);
      return Tle(this, i);
    };
  }
  function Tle(e, t) {
    return t && (Ix(t) === "object" || typeof t == "function") ? t : ZS(e);
  }
  function ZS(e) {
    if (e === void 0)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called",
      );
    return e;
  }
  function EV(e) {
    var t = typeof Map == "function" ? new Map() : void 0;
    return (
      (EV = function (n) {
        if (n === null || !s0t(n)) return n;
        if (typeof n != "function")
          throw new TypeError(
            "Super expression must either be null or a function",
          );
        if (typeof t < "u") {
          if (t.has(n)) return t.get(n);
          t.set(n, i);
        }
        function i() {
          return xx(n, arguments, t0(this).constructor);
        }
        return (
          (i.prototype = Object.create(n.prototype, {
            constructor: {
              value: i,
              enumerable: !1,
              writable: !0,
              configurable: !0,
            },
          })),
          e0(i, n)
        );
      }),
      EV(e)
    );
  }
  function xx(e, t, r) {
    return (
      Ale()
        ? (xx = Reflect.construct)
        : (xx = function (i, o, a) {
            var s = [null];
            s.push.apply(s, o);
            var u = Function.bind.apply(i, s),
              l = new u();
            return a && e0(l, a.prototype), l;
          }),
      xx.apply(null, arguments)
    );
  }
  function Ale() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return (
        Date.prototype.toString.call(
          Reflect.construct(Date, [], function () {}),
        ),
        !0
      );
    } catch {
      return !1;
    }
  }
  function s0t(e) {
    return Function.toString.call(e).indexOf("[native code]") !== -1;
  }
  function e0(e, t) {
    return (
      (e0 =
        Object.setPrototypeOf ||
        function (n, i) {
          return (n.__proto__ = i), n;
        }),
      e0(e, t)
    );
  }
  function t0(e) {
    return (
      (t0 = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (r) {
            return r.__proto__ || Object.getPrototypeOf(r);
          }),
      t0(e)
    );
  }
  var c0t = (function (e) {
    o0t(r, e);
    var t = a0t(r);
    function r(n, i, o, a, s, u, l) {
      var d, f, m, h;
      n0t(this, r),
        (h = t.call(this, n)),
        (h.name = "GraphQLError"),
        (h.originalError = u ?? void 0),
        (h.nodes = Ole(Array.isArray(i) ? i : i ? [i] : void 0));
      for (
        var y = [], _ = 0, E = (b = h.nodes) !== null && b !== void 0 ? b : [];
        _ < E.length;
        _++
      ) {
        var b,
          O = E[_],
          C = O.loc;
        C != null && y.push(C);
      }
      (y = Ole(y)),
        (h.source =
          o ?? ((d = y) === null || d === void 0 ? void 0 : d[0].source)),
        (h.positions =
          a ??
          ((f = y) === null || f === void 0
            ? void 0
            : f.map(function (k) {
                return k.start;
              }))),
        (h.locations =
          a && o
            ? a.map(function (k) {
                return (0, ble.getLocation)(o, k);
              })
            : (m = y) === null || m === void 0
              ? void 0
              : m.map(function (k) {
                  return (0, ble.getLocation)(k.source, k.start);
                })),
        (h.path = s ?? void 0);
      var P = u?.extensions;
      return (
        l == null && (0, JSt.default)(P)
          ? (h.extensions = t0t({}, P))
          : (h.extensions = l ?? {}),
        Object.defineProperties(ZS(h), {
          message: { enumerable: !0 },
          locations: { enumerable: h.locations != null },
          path: { enumerable: h.path != null },
          extensions: {
            enumerable:
              h.extensions != null && Object.keys(h.extensions).length > 0,
          },
          name: { enumerable: !1 },
          nodes: { enumerable: !1 },
          source: { enumerable: !1 },
          positions: { enumerable: !1 },
          originalError: { enumerable: !1 },
        }),
        u != null && u.stack
          ? (Object.defineProperty(ZS(h), "stack", {
              value: u.stack,
              writable: !0,
              configurable: !0,
            }),
            Tle(h))
          : (Error.captureStackTrace
              ? Error.captureStackTrace(ZS(h), r)
              : Object.defineProperty(ZS(h), "stack", {
                  value: Error().stack,
                  writable: !0,
                  configurable: !0,
                }),
            h)
      );
    }
    return (
      i0t(r, [
        {
          key: "toString",
          value: function () {
            return Ple(this);
          },
        },
        {
          key: ZSt.SYMBOL_TO_STRING_TAG,
          get: function () {
            return "Object";
          },
        },
      ]),
      r
    );
  })(EV(Error));
  r0.GraphQLError = c0t;
  function Ole(e) {
    return e === void 0 || e.length === 0 ? void 0 : e;
  }
  function Ple(e) {
    var t = e.message;
    if (e.nodes)
      for (var r = 0, n = e.nodes; r < n.length; r++) {
        var i = n[r];
        i.loc &&
          (t +=
            `

` + (0, Sle.printLocation)(i.loc));
      }
    else if (e.source && e.locations)
      for (var o = 0, a = e.locations; o < a.length; o++) {
        var s = a[o];
        t +=
          `

` + (0, Sle.printSourceLocation)(e.source, s);
      }
    return t;
  }
});
var Nx = g((bV) => {
  "use strict";
  c();
  Object.defineProperty(bV, "__esModule", { value: !0 });
  bV.syntaxError = l0t;
  var u0t = Ue();
  function l0t(e, t, r) {
    return new u0t.GraphQLError("Syntax Error: ".concat(r), void 0, e, [t]);
  }
});
var lr = g((kx) => {
  "use strict";
  c();
  Object.defineProperty(kx, "__esModule", { value: !0 });
  kx.Kind = void 0;
  var d0t = Object.freeze({
    NAME: "Name",
    DOCUMENT: "Document",
    OPERATION_DEFINITION: "OperationDefinition",
    VARIABLE_DEFINITION: "VariableDefinition",
    SELECTION_SET: "SelectionSet",
    FIELD: "Field",
    ARGUMENT: "Argument",
    FRAGMENT_SPREAD: "FragmentSpread",
    INLINE_FRAGMENT: "InlineFragment",
    FRAGMENT_DEFINITION: "FragmentDefinition",
    VARIABLE: "Variable",
    INT: "IntValue",
    FLOAT: "FloatValue",
    STRING: "StringValue",
    BOOLEAN: "BooleanValue",
    NULL: "NullValue",
    ENUM: "EnumValue",
    LIST: "ListValue",
    OBJECT: "ObjectValue",
    OBJECT_FIELD: "ObjectField",
    DIRECTIVE: "Directive",
    NAMED_TYPE: "NamedType",
    LIST_TYPE: "ListType",
    NON_NULL_TYPE: "NonNullType",
    SCHEMA_DEFINITION: "SchemaDefinition",
    OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
    SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
    OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
    FIELD_DEFINITION: "FieldDefinition",
    INPUT_VALUE_DEFINITION: "InputValueDefinition",
    INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
    UNION_TYPE_DEFINITION: "UnionTypeDefinition",
    ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
    ENUM_VALUE_DEFINITION: "EnumValueDefinition",
    INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
    DIRECTIVE_DEFINITION: "DirectiveDefinition",
    SCHEMA_EXTENSION: "SchemaExtension",
    SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
    OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
    INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
    UNION_TYPE_EXTENSION: "UnionTypeExtension",
    ENUM_TYPE_EXTENSION: "EnumTypeExtension",
    INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension",
  });
  kx.Kind = d0t;
});
var vi = g((SV) => {
  "use strict";
  c();
  Object.defineProperty(SV, "__esModule", { value: !0 });
  SV.default = f0t;
  function f0t(e, t) {
    var r = !!e;
    if (!r) throw new Error(t ?? "Unexpected invariant triggered.");
  }
});
var CV = g((Dx) => {
  "use strict";
  c();
  Object.defineProperty(Dx, "__esModule", { value: !0 });
  Dx.default = void 0;
  var p0t =
      typeof Symbol == "function" && typeof Symbol.for == "function"
        ? Symbol.for("nodejs.util.inspect.custom")
        : void 0,
    m0t = p0t;
  Dx.default = m0t;
});
var Lx = g((wV) => {
  "use strict";
  c();
  Object.defineProperty(wV, "__esModule", { value: !0 });
  wV.default = g0t;
  var h0t = Ile(vi()),
    Rle = Ile(CV());
  function Ile(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function g0t(e) {
    var t = e.prototype.toJSON;
    typeof t == "function" || (0, h0t.default)(0),
      (e.prototype.inspect = t),
      Rle.default && (e.prototype[Rle.default] = t);
  }
});
var Hv = g((mm) => {
  "use strict";
  c();
  Object.defineProperty(mm, "__esModule", { value: !0 });
  mm.isNode = y0t;
  mm.Token = mm.Location = void 0;
  var xle = v0t(Lx());
  function v0t(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var Nle = (function () {
    function e(r, n, i) {
      (this.start = r.start),
        (this.end = n.end),
        (this.startToken = r),
        (this.endToken = n),
        (this.source = i);
    }
    var t = e.prototype;
    return (
      (t.toJSON = function () {
        return { start: this.start, end: this.end };
      }),
      e
    );
  })();
  mm.Location = Nle;
  (0, xle.default)(Nle);
  var kle = (function () {
    function e(r, n, i, o, a, s, u) {
      (this.kind = r),
        (this.start = n),
        (this.end = i),
        (this.line = o),
        (this.column = a),
        (this.value = u),
        (this.prev = s),
        (this.next = null);
    }
    var t = e.prototype;
    return (
      (t.toJSON = function () {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column,
        };
      }),
      e
    );
  })();
  mm.Token = kle;
  (0, xle.default)(kle);
  function y0t(e) {
    return e != null && typeof e.kind == "string";
  }
});
var Gv = g((Mx) => {
  "use strict";
  c();
  Object.defineProperty(Mx, "__esModule", { value: !0 });
  Mx.TokenKind = void 0;
  var _0t = Object.freeze({
    SOF: "<SOF>",
    EOF: "<EOF>",
    BANG: "!",
    DOLLAR: "$",
    AMP: "&",
    PAREN_L: "(",
    PAREN_R: ")",
    SPREAD: "...",
    COLON: ":",
    EQUALS: "=",
    AT: "@",
    BRACKET_L: "[",
    BRACKET_R: "]",
    BRACE_L: "{",
    PIPE: "|",
    BRACE_R: "}",
    NAME: "Name",
    INT: "Int",
    FLOAT: "Float",
    STRING: "String",
    BLOCK_STRING: "BlockString",
    COMMENT: "Comment",
  });
  Mx.TokenKind = _0t;
});
var Lt = g((OV) => {
  "use strict";
  c();
  Object.defineProperty(OV, "__esModule", { value: !0 });
  OV.default = C0t;
  var E0t = b0t(CV());
  function b0t(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function qx(e) {
    "@babel/helpers - typeof";
    return (
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? (qx = function (r) {
            return typeof r;
          })
        : (qx = function (r) {
            return r &&
              typeof Symbol == "function" &&
              r.constructor === Symbol &&
              r !== Symbol.prototype
              ? "symbol"
              : typeof r;
          }),
      qx(e)
    );
  }
  var S0t = 10,
    Dle = 2;
  function C0t(e) {
    return jx(e, []);
  }
  function jx(e, t) {
    switch (qx(e)) {
      case "string":
        return JSON.stringify(e);
      case "function":
        return e.name ? "[function ".concat(e.name, "]") : "[function]";
      case "object":
        return e === null ? "null" : w0t(e, t);
      default:
        return String(e);
    }
  }
  function w0t(e, t) {
    if (t.indexOf(e) !== -1) return "[Circular]";
    var r = [].concat(t, [e]),
      n = A0t(e);
    if (n !== void 0) {
      var i = n.call(e);
      if (i !== e) return typeof i == "string" ? i : jx(i, r);
    } else if (Array.isArray(e)) return T0t(e, r);
    return O0t(e, r);
  }
  function O0t(e, t) {
    var r = Object.keys(e);
    if (r.length === 0) return "{}";
    if (t.length > Dle) return "[" + P0t(e) + "]";
    var n = r.map(function (i) {
      var o = jx(e[i], t);
      return i + ": " + o;
    });
    return "{ " + n.join(", ") + " }";
  }
  function T0t(e, t) {
    if (e.length === 0) return "[]";
    if (t.length > Dle) return "[Array]";
    for (
      var r = Math.min(S0t, e.length), n = e.length - r, i = [], o = 0;
      o < r;
      ++o
    )
      i.push(jx(e[o], t));
    return (
      n === 1
        ? i.push("... 1 more item")
        : n > 1 && i.push("... ".concat(n, " more items")),
      "[" + i.join(", ") + "]"
    );
  }
  function A0t(e) {
    var t = e[String(E0t.default)];
    if (typeof t == "function") return t;
    if (typeof e.inspect == "function") return e.inspect;
  }
  function P0t(e) {
    var t = Object.prototype.toString
      .call(e)
      .replace(/^\[object /, "")
      .replace(/]$/, "");
    if (t === "Object" && typeof e.constructor == "function") {
      var r = e.constructor.name;
      if (typeof r == "string" && r !== "") return r;
    }
    return t;
  }
});
var Ta = g((TV) => {
  "use strict";
  c();
  Object.defineProperty(TV, "__esModule", { value: !0 });
  TV.default = R0t;
  function R0t(e, t) {
    var r = !!e;
    if (!r) throw new Error(t);
  }
});
var n0 = g((Bx) => {
  "use strict";
  c();
  Object.defineProperty(Bx, "__esModule", { value: !0 });
  Bx.default = void 0;
  var I0t = x0t(Lt());
  function x0t(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Fx(e) {
    "@babel/helpers - typeof";
    return (
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? (Fx = function (r) {
            return typeof r;
          })
        : (Fx = function (r) {
            return r &&
              typeof Symbol == "function" &&
              r.constructor === Symbol &&
              r !== Symbol.prototype
              ? "symbol"
              : typeof r;
          }),
      Fx(e)
    );
  }
  var N0t =
    process.env.NODE_ENV === "production"
      ? function (t, r) {
          return t instanceof r;
        }
      : function (t, r) {
          if (t instanceof r) return !0;
          if (Fx(t) === "object" && t !== null) {
            var n,
              i = r.prototype[Symbol.toStringTag],
              o =
                Symbol.toStringTag in t
                  ? t[Symbol.toStringTag]
                  : (n = t.constructor) === null || n === void 0
                    ? void 0
                    : n.name;
            if (i === o) {
              var a = (0, I0t.default)(t);
              throw new Error(
                "Cannot use ".concat(i, ' "').concat(
                  a,
                  `" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`,
                ),
              );
            }
          }
          return !1;
        };
  Bx.default = N0t;
});
var Ux = g((i0) => {
  "use strict";
  c();
  Object.defineProperty(i0, "__esModule", { value: !0 });
  i0.isSource = q0t;
  i0.Source = void 0;
  var k0t = Oc(),
    D0t = PV(Lt()),
    AV = PV(Ta()),
    L0t = PV(n0());
  function PV(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Lle(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      (n.enumerable = n.enumerable || !1),
        (n.configurable = !0),
        "value" in n && (n.writable = !0),
        Object.defineProperty(e, n.key, n);
    }
  }
  function M0t(e, t, r) {
    return t && Lle(e.prototype, t), r && Lle(e, r), e;
  }
  var Mle = (function () {
    function e(t) {
      var r =
          arguments.length > 1 && arguments[1] !== void 0
            ? arguments[1]
            : "GraphQL request",
        n =
          arguments.length > 2 && arguments[2] !== void 0
            ? arguments[2]
            : { line: 1, column: 1 };
      typeof t == "string" ||
        (0, AV.default)(
          0,
          "Body must be a string. Received: ".concat((0, D0t.default)(t), "."),
        ),
        (this.body = t),
        (this.name = r),
        (this.locationOffset = n),
        this.locationOffset.line > 0 ||
          (0, AV.default)(
            0,
            "line in locationOffset is 1-indexed and must be positive.",
          ),
        this.locationOffset.column > 0 ||
          (0, AV.default)(
            0,
            "column in locationOffset is 1-indexed and must be positive.",
          );
    }
    return (
      M0t(e, [
        {
          key: k0t.SYMBOL_TO_STRING_TAG,
          get: function () {
            return "Source";
          },
        },
      ]),
      e
    );
  })();
  i0.Source = Mle;
  function q0t(e) {
    return (0, L0t.default)(e, Mle);
  }
});
var Vv = g((Hx) => {
  "use strict";
  c();
  Object.defineProperty(Hx, "__esModule", { value: !0 });
  Hx.DirectiveLocation = void 0;
  var j0t = Object.freeze({
    QUERY: "QUERY",
    MUTATION: "MUTATION",
    SUBSCRIPTION: "SUBSCRIPTION",
    FIELD: "FIELD",
    FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
    FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
    INLINE_FRAGMENT: "INLINE_FRAGMENT",
    VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
    SCHEMA: "SCHEMA",
    SCALAR: "SCALAR",
    OBJECT: "OBJECT",
    FIELD_DEFINITION: "FIELD_DEFINITION",
    ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
    INTERFACE: "INTERFACE",
    UNION: "UNION",
    ENUM: "ENUM",
    ENUM_VALUE: "ENUM_VALUE",
    INPUT_OBJECT: "INPUT_OBJECT",
    INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION",
  });
  Hx.DirectiveLocation = j0t;
});
var $v = g((o0) => {
  "use strict";
  c();
  Object.defineProperty(o0, "__esModule", { value: !0 });
  o0.dedentBlockStringValue = F0t;
  o0.getBlockStringIndentation = jle;
  o0.printBlockString = B0t;
  function F0t(e) {
    var t = e.split(/\r\n|[\n\r]/g),
      r = jle(e);
    if (r !== 0) for (var n = 1; n < t.length; n++) t[n] = t[n].slice(r);
    for (var i = 0; i < t.length && qle(t[i]); ) ++i;
    for (var o = t.length; o > i && qle(t[o - 1]); ) --o;
    return t.slice(i, o).join(`
`);
  }
  function qle(e) {
    for (var t = 0; t < e.length; ++t)
      if (e[t] !== " " && e[t] !== "	") return !1;
    return !0;
  }
  function jle(e) {
    for (var t, r = !0, n = !0, i = 0, o = null, a = 0; a < e.length; ++a)
      switch (e.charCodeAt(a)) {
        case 13:
          e.charCodeAt(a + 1) === 10 && ++a;
        case 10:
          (r = !1), (n = !0), (i = 0);
          break;
        case 9:
        case 32:
          ++i;
          break;
        default:
          n && !r && (o === null || i < o) && (o = i), (n = !1);
      }
    return (t = o) !== null && t !== void 0 ? t : 0;
  }
  function B0t(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "",
      r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
      n =
        e.indexOf(`
`) === -1,
      i = e[0] === " " || e[0] === "	",
      o = e[e.length - 1] === '"',
      a = e[e.length - 1] === "\\",
      s = !n || o || a || r,
      u = "";
    return (
      s &&
        !(n && i) &&
        (u +=
          `
` + t),
      (u += t
        ? e.replace(
            /\n/g,
            `
` + t,
          )
        : e),
      s &&
        (u += `
`),
      '"""' + u.replace(/"""/g, '\\"""') + '"""'
    );
  }
});
var Vx = g((a0) => {
  "use strict";
  c();
  Object.defineProperty(a0, "__esModule", { value: !0 });
  a0.isPunctuatorTokenKind = G0t;
  a0.Lexer = void 0;
  var Tc = Nx(),
    pn = Hv(),
    pt = Gv(),
    U0t = $v(),
    H0t = (function () {
      function e(r) {
        var n = new pn.Token(pt.TokenKind.SOF, 0, 0, 0, 0, null);
        (this.source = r),
          (this.lastToken = n),
          (this.token = n),
          (this.line = 1),
          (this.lineStart = 0);
      }
      var t = e.prototype;
      return (
        (t.advance = function () {
          this.lastToken = this.token;
          var n = (this.token = this.lookahead());
          return n;
        }),
        (t.lookahead = function () {
          var n = this.token;
          if (n.kind !== pt.TokenKind.EOF)
            do {
              var i;
              n =
                (i = n.next) !== null && i !== void 0
                  ? i
                  : (n.next = V0t(this, n));
            } while (n.kind === pt.TokenKind.COMMENT);
          return n;
        }),
        e
      );
    })();
  a0.Lexer = H0t;
  function G0t(e) {
    return (
      e === pt.TokenKind.BANG ||
      e === pt.TokenKind.DOLLAR ||
      e === pt.TokenKind.AMP ||
      e === pt.TokenKind.PAREN_L ||
      e === pt.TokenKind.PAREN_R ||
      e === pt.TokenKind.SPREAD ||
      e === pt.TokenKind.COLON ||
      e === pt.TokenKind.EQUALS ||
      e === pt.TokenKind.AT ||
      e === pt.TokenKind.BRACKET_L ||
      e === pt.TokenKind.BRACKET_R ||
      e === pt.TokenKind.BRACE_L ||
      e === pt.TokenKind.PIPE ||
      e === pt.TokenKind.BRACE_R
    );
  }
  function hm(e) {
    return isNaN(e)
      ? pt.TokenKind.EOF
      : e < 127
        ? JSON.stringify(String.fromCharCode(e))
        : '"\\u'.concat(("00" + e.toString(16).toUpperCase()).slice(-4), '"');
  }
  function V0t(e, t) {
    for (var r = e.source, n = r.body, i = n.length, o = t.end; o < i; ) {
      var a = n.charCodeAt(o),
        s = e.line,
        u = 1 + o - e.lineStart;
      switch (a) {
        case 65279:
        case 9:
        case 32:
        case 44:
          ++o;
          continue;
        case 10:
          ++o, ++e.line, (e.lineStart = o);
          continue;
        case 13:
          n.charCodeAt(o + 1) === 10 ? (o += 2) : ++o,
            ++e.line,
            (e.lineStart = o);
          continue;
        case 33:
          return new pn.Token(pt.TokenKind.BANG, o, o + 1, s, u, t);
        case 35:
          return z0t(r, o, s, u, t);
        case 36:
          return new pn.Token(pt.TokenKind.DOLLAR, o, o + 1, s, u, t);
        case 38:
          return new pn.Token(pt.TokenKind.AMP, o, o + 1, s, u, t);
        case 40:
          return new pn.Token(pt.TokenKind.PAREN_L, o, o + 1, s, u, t);
        case 41:
          return new pn.Token(pt.TokenKind.PAREN_R, o, o + 1, s, u, t);
        case 46:
          if (n.charCodeAt(o + 1) === 46 && n.charCodeAt(o + 2) === 46)
            return new pn.Token(pt.TokenKind.SPREAD, o, o + 3, s, u, t);
          break;
        case 58:
          return new pn.Token(pt.TokenKind.COLON, o, o + 1, s, u, t);
        case 61:
          return new pn.Token(pt.TokenKind.EQUALS, o, o + 1, s, u, t);
        case 64:
          return new pn.Token(pt.TokenKind.AT, o, o + 1, s, u, t);
        case 91:
          return new pn.Token(pt.TokenKind.BRACKET_L, o, o + 1, s, u, t);
        case 93:
          return new pn.Token(pt.TokenKind.BRACKET_R, o, o + 1, s, u, t);
        case 123:
          return new pn.Token(pt.TokenKind.BRACE_L, o, o + 1, s, u, t);
        case 124:
          return new pn.Token(pt.TokenKind.PIPE, o, o + 1, s, u, t);
        case 125:
          return new pn.Token(pt.TokenKind.BRACE_R, o, o + 1, s, u, t);
        case 34:
          return n.charCodeAt(o + 1) === 34 && n.charCodeAt(o + 2) === 34
            ? Q0t(r, o, s, u, t, e)
            : W0t(r, o, s, u, t);
        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return K0t(r, o, a, s, u, t);
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 95:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          return X0t(r, o, s, u, t);
      }
      throw (0, Tc.syntaxError)(r, o, $0t(a));
    }
    var l = e.line,
      d = 1 + o - e.lineStart;
    return new pn.Token(pt.TokenKind.EOF, i, i, l, d, t);
  }
  function $0t(e) {
    return e < 32 && e !== 9 && e !== 10 && e !== 13
      ? "Cannot contain the invalid character ".concat(hm(e), ".")
      : e === 39
        ? `Unexpected single quote character ('), did you mean to use a double quote (")?`
        : "Cannot parse the unexpected character ".concat(hm(e), ".");
  }
  function z0t(e, t, r, n, i) {
    var o = e.body,
      a,
      s = t;
    do a = o.charCodeAt(++s);
    while (!isNaN(a) && (a > 31 || a === 9));
    return new pn.Token(pt.TokenKind.COMMENT, t, s, r, n, i, o.slice(t + 1, s));
  }
  function K0t(e, t, r, n, i, o) {
    var a = e.body,
      s = r,
      u = t,
      l = !1;
    if ((s === 45 && (s = a.charCodeAt(++u)), s === 48)) {
      if (((s = a.charCodeAt(++u)), s >= 48 && s <= 57))
        throw (0, Tc.syntaxError)(
          e,
          u,
          "Invalid number, unexpected digit after 0: ".concat(hm(s), "."),
        );
    } else (u = RV(e, u, s)), (s = a.charCodeAt(u));
    if (
      (s === 46 &&
        ((l = !0),
        (s = a.charCodeAt(++u)),
        (u = RV(e, u, s)),
        (s = a.charCodeAt(u))),
      (s === 69 || s === 101) &&
        ((l = !0),
        (s = a.charCodeAt(++u)),
        (s === 43 || s === 45) && (s = a.charCodeAt(++u)),
        (u = RV(e, u, s)),
        (s = a.charCodeAt(u))),
      s === 46 || J0t(s))
    )
      throw (0, Tc.syntaxError)(
        e,
        u,
        "Invalid number, expected digit but got: ".concat(hm(s), "."),
      );
    return new pn.Token(
      l ? pt.TokenKind.FLOAT : pt.TokenKind.INT,
      t,
      u,
      n,
      i,
      o,
      a.slice(t, u),
    );
  }
  function RV(e, t, r) {
    var n = e.body,
      i = t,
      o = r;
    if (o >= 48 && o <= 57) {
      do o = n.charCodeAt(++i);
      while (o >= 48 && o <= 57);
      return i;
    }
    throw (0, Tc.syntaxError)(
      e,
      i,
      "Invalid number, expected digit but got: ".concat(hm(o), "."),
    );
  }
  function W0t(e, t, r, n, i) {
    for (
      var o = e.body, a = t + 1, s = a, u = 0, l = "";
      a < o.length && !isNaN((u = o.charCodeAt(a))) && u !== 10 && u !== 13;

    ) {
      if (u === 34)
        return (
          (l += o.slice(s, a)),
          new pn.Token(pt.TokenKind.STRING, t, a + 1, r, n, i, l)
        );
      if (u < 32 && u !== 9)
        throw (0, Tc.syntaxError)(
          e,
          a,
          "Invalid character within String: ".concat(hm(u), "."),
        );
      if ((++a, u === 92)) {
        switch (((l += o.slice(s, a - 1)), (u = o.charCodeAt(a)), u)) {
          case 34:
            l += '"';
            break;
          case 47:
            l += "/";
            break;
          case 92:
            l += "\\";
            break;
          case 98:
            l += "\b";
            break;
          case 102:
            l += "\f";
            break;
          case 110:
            l += `
`;
            break;
          case 114:
            l += "\r";
            break;
          case 116:
            l += "	";
            break;
          case 117: {
            var d = Y0t(
              o.charCodeAt(a + 1),
              o.charCodeAt(a + 2),
              o.charCodeAt(a + 3),
              o.charCodeAt(a + 4),
            );
            if (d < 0) {
              var f = o.slice(a + 1, a + 5);
              throw (0, Tc.syntaxError)(
                e,
                a,
                "Invalid character escape sequence: \\u".concat(f, "."),
              );
            }
            (l += String.fromCharCode(d)), (a += 4);
            break;
          }
          default:
            throw (0, Tc.syntaxError)(
              e,
              a,
              "Invalid character escape sequence: \\".concat(
                String.fromCharCode(u),
                ".",
              ),
            );
        }
        ++a, (s = a);
      }
    }
    throw (0, Tc.syntaxError)(e, a, "Unterminated string.");
  }
  function Q0t(e, t, r, n, i, o) {
    for (
      var a = e.body, s = t + 3, u = s, l = 0, d = "";
      s < a.length && !isNaN((l = a.charCodeAt(s)));

    ) {
      if (l === 34 && a.charCodeAt(s + 1) === 34 && a.charCodeAt(s + 2) === 34)
        return (
          (d += a.slice(u, s)),
          new pn.Token(
            pt.TokenKind.BLOCK_STRING,
            t,
            s + 3,
            r,
            n,
            i,
            (0, U0t.dedentBlockStringValue)(d),
          )
        );
      if (l < 32 && l !== 9 && l !== 10 && l !== 13)
        throw (0, Tc.syntaxError)(
          e,
          s,
          "Invalid character within String: ".concat(hm(l), "."),
        );
      l === 10
        ? (++s, ++o.line, (o.lineStart = s))
        : l === 13
          ? (a.charCodeAt(s + 1) === 10 ? (s += 2) : ++s,
            ++o.line,
            (o.lineStart = s))
          : l === 92 &&
              a.charCodeAt(s + 1) === 34 &&
              a.charCodeAt(s + 2) === 34 &&
              a.charCodeAt(s + 3) === 34
            ? ((d += a.slice(u, s) + '"""'), (s += 4), (u = s))
            : ++s;
    }
    throw (0, Tc.syntaxError)(e, s, "Unterminated string.");
  }
  function Y0t(e, t, r, n) {
    return (Gx(e) << 12) | (Gx(t) << 8) | (Gx(r) << 4) | Gx(n);
  }
  function Gx(e) {
    return e >= 48 && e <= 57
      ? e - 48
      : e >= 65 && e <= 70
        ? e - 55
        : e >= 97 && e <= 102
          ? e - 87
          : -1;
  }
  function X0t(e, t, r, n, i) {
    for (
      var o = e.body, a = o.length, s = t + 1, u = 0;
      s !== a &&
      !isNaN((u = o.charCodeAt(s))) &&
      (u === 95 ||
        (u >= 48 && u <= 57) ||
        (u >= 65 && u <= 90) ||
        (u >= 97 && u <= 122));

    )
      ++s;
    return new pn.Token(pt.TokenKind.NAME, t, s, r, n, i, o.slice(t, s));
  }
  function J0t(e) {
    return e === 95 || (e >= 65 && e <= 90) || (e >= 97 && e <= 122);
  }
});
var zv = g((gm) => {
  "use strict";
  c();
  Object.defineProperty(gm, "__esModule", { value: !0 });
  gm.parse = tCt;
  gm.parseValue = rCt;
  gm.parseType = nCt;
  gm.Parser = void 0;
  var IV = Nx(),
    Ge = lr(),
    Z0t = Hv(),
    se = Gv(),
    Fle = Ux(),
    eCt = Vv(),
    Ble = Vx();
  function tCt(e, t) {
    var r = new $x(e, t);
    return r.parseDocument();
  }
  function rCt(e, t) {
    var r = new $x(e, t);
    r.expectToken(se.TokenKind.SOF);
    var n = r.parseValueLiteral(!1);
    return r.expectToken(se.TokenKind.EOF), n;
  }
  function nCt(e, t) {
    var r = new $x(e, t);
    r.expectToken(se.TokenKind.SOF);
    var n = r.parseTypeReference();
    return r.expectToken(se.TokenKind.EOF), n;
  }
  var $x = (function () {
    function e(r, n) {
      var i = (0, Fle.isSource)(r) ? r : new Fle.Source(r);
      (this._lexer = new Ble.Lexer(i)), (this._options = n);
    }
    var t = e.prototype;
    return (
      (t.parseName = function () {
        var n = this.expectToken(se.TokenKind.NAME);
        return { kind: Ge.Kind.NAME, value: n.value, loc: this.loc(n) };
      }),
      (t.parseDocument = function () {
        var n = this._lexer.token;
        return {
          kind: Ge.Kind.DOCUMENT,
          definitions: this.many(
            se.TokenKind.SOF,
            this.parseDefinition,
            se.TokenKind.EOF,
          ),
          loc: this.loc(n),
        };
      }),
      (t.parseDefinition = function () {
        if (this.peek(se.TokenKind.NAME))
          switch (this._lexer.token.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "schema":
            case "scalar":
            case "type":
            case "interface":
            case "union":
            case "enum":
            case "input":
            case "directive":
              return this.parseTypeSystemDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        else {
          if (this.peek(se.TokenKind.BRACE_L))
            return this.parseOperationDefinition();
          if (this.peekDescription()) return this.parseTypeSystemDefinition();
        }
        throw this.unexpected();
      }),
      (t.parseOperationDefinition = function () {
        var n = this._lexer.token;
        if (this.peek(se.TokenKind.BRACE_L))
          return {
            kind: Ge.Kind.OPERATION_DEFINITION,
            operation: "query",
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(n),
          };
        var i = this.parseOperationType(),
          o;
        return (
          this.peek(se.TokenKind.NAME) && (o = this.parseName()),
          {
            kind: Ge.Kind.OPERATION_DEFINITION,
            operation: i,
            name: o,
            variableDefinitions: this.parseVariableDefinitions(),
            directives: this.parseDirectives(!1),
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(n),
          }
        );
      }),
      (t.parseOperationType = function () {
        var n = this.expectToken(se.TokenKind.NAME);
        switch (n.value) {
          case "query":
            return "query";
          case "mutation":
            return "mutation";
          case "subscription":
            return "subscription";
        }
        throw this.unexpected(n);
      }),
      (t.parseVariableDefinitions = function () {
        return this.optionalMany(
          se.TokenKind.PAREN_L,
          this.parseVariableDefinition,
          se.TokenKind.PAREN_R,
        );
      }),
      (t.parseVariableDefinition = function () {
        var n = this._lexer.token;
        return {
          kind: Ge.Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type:
            (this.expectToken(se.TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(se.TokenKind.EQUALS)
            ? this.parseValueLiteral(!0)
            : void 0,
          directives: this.parseDirectives(!0),
          loc: this.loc(n),
        };
      }),
      (t.parseVariable = function () {
        var n = this._lexer.token;
        return (
          this.expectToken(se.TokenKind.DOLLAR),
          { kind: Ge.Kind.VARIABLE, name: this.parseName(), loc: this.loc(n) }
        );
      }),
      (t.parseSelectionSet = function () {
        var n = this._lexer.token;
        return {
          kind: Ge.Kind.SELECTION_SET,
          selections: this.many(
            se.TokenKind.BRACE_L,
            this.parseSelection,
            se.TokenKind.BRACE_R,
          ),
          loc: this.loc(n),
        };
      }),
      (t.parseSelection = function () {
        return this.peek(se.TokenKind.SPREAD)
          ? this.parseFragment()
          : this.parseField();
      }),
      (t.parseField = function () {
        var n = this._lexer.token,
          i = this.parseName(),
          o,
          a;
        return (
          this.expectOptionalToken(se.TokenKind.COLON)
            ? ((o = i), (a = this.parseName()))
            : (a = i),
          {
            kind: Ge.Kind.FIELD,
            alias: o,
            name: a,
            arguments: this.parseArguments(!1),
            directives: this.parseDirectives(!1),
            selectionSet: this.peek(se.TokenKind.BRACE_L)
              ? this.parseSelectionSet()
              : void 0,
            loc: this.loc(n),
          }
        );
      }),
      (t.parseArguments = function (n) {
        var i = n ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(se.TokenKind.PAREN_L, i, se.TokenKind.PAREN_R);
      }),
      (t.parseArgument = function () {
        var n = this._lexer.token,
          i = this.parseName();
        return (
          this.expectToken(se.TokenKind.COLON),
          {
            kind: Ge.Kind.ARGUMENT,
            name: i,
            value: this.parseValueLiteral(!1),
            loc: this.loc(n),
          }
        );
      }),
      (t.parseConstArgument = function () {
        var n = this._lexer.token;
        return {
          kind: Ge.Kind.ARGUMENT,
          name: this.parseName(),
          value:
            (this.expectToken(se.TokenKind.COLON), this.parseValueLiteral(!0)),
          loc: this.loc(n),
        };
      }),
      (t.parseFragment = function () {
        var n = this._lexer.token;
        this.expectToken(se.TokenKind.SPREAD);
        var i = this.expectOptionalKeyword("on");
        return !i && this.peek(se.TokenKind.NAME)
          ? {
              kind: Ge.Kind.FRAGMENT_SPREAD,
              name: this.parseFragmentName(),
              directives: this.parseDirectives(!1),
              loc: this.loc(n),
            }
          : {
              kind: Ge.Kind.INLINE_FRAGMENT,
              typeCondition: i ? this.parseNamedType() : void 0,
              directives: this.parseDirectives(!1),
              selectionSet: this.parseSelectionSet(),
              loc: this.loc(n),
            };
      }),
      (t.parseFragmentDefinition = function () {
        var n,
          i = this._lexer.token;
        return (
          this.expectKeyword("fragment"),
          ((n = this._options) === null || n === void 0
            ? void 0
            : n.experimentalFragmentVariables) === !0
            ? {
                kind: Ge.Kind.FRAGMENT_DEFINITION,
                name: this.parseFragmentName(),
                variableDefinitions: this.parseVariableDefinitions(),
                typeCondition:
                  (this.expectKeyword("on"), this.parseNamedType()),
                directives: this.parseDirectives(!1),
                selectionSet: this.parseSelectionSet(),
                loc: this.loc(i),
              }
            : {
                kind: Ge.Kind.FRAGMENT_DEFINITION,
                name: this.parseFragmentName(),
                typeCondition:
                  (this.expectKeyword("on"), this.parseNamedType()),
                directives: this.parseDirectives(!1),
                selectionSet: this.parseSelectionSet(),
                loc: this.loc(i),
              }
        );
      }),
      (t.parseFragmentName = function () {
        if (this._lexer.token.value === "on") throw this.unexpected();
        return this.parseName();
      }),
      (t.parseValueLiteral = function (n) {
        var i = this._lexer.token;
        switch (i.kind) {
          case se.TokenKind.BRACKET_L:
            return this.parseList(n);
          case se.TokenKind.BRACE_L:
            return this.parseObject(n);
          case se.TokenKind.INT:
            return (
              this._lexer.advance(),
              { kind: Ge.Kind.INT, value: i.value, loc: this.loc(i) }
            );
          case se.TokenKind.FLOAT:
            return (
              this._lexer.advance(),
              { kind: Ge.Kind.FLOAT, value: i.value, loc: this.loc(i) }
            );
          case se.TokenKind.STRING:
          case se.TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case se.TokenKind.NAME:
            switch ((this._lexer.advance(), i.value)) {
              case "true":
                return { kind: Ge.Kind.BOOLEAN, value: !0, loc: this.loc(i) };
              case "false":
                return { kind: Ge.Kind.BOOLEAN, value: !1, loc: this.loc(i) };
              case "null":
                return { kind: Ge.Kind.NULL, loc: this.loc(i) };
              default:
                return { kind: Ge.Kind.ENUM, value: i.value, loc: this.loc(i) };
            }
          case se.TokenKind.DOLLAR:
            if (!n) return this.parseVariable();
            break;
        }
        throw this.unexpected();
      }),
      (t.parseStringLiteral = function () {
        var n = this._lexer.token;
        return (
          this._lexer.advance(),
          {
            kind: Ge.Kind.STRING,
            value: n.value,
            block: n.kind === se.TokenKind.BLOCK_STRING,
            loc: this.loc(n),
          }
        );
      }),
      (t.parseList = function (n) {
        var i = this,
          o = this._lexer.token,
          a = function () {
            return i.parseValueLiteral(n);
          };
        return {
          kind: Ge.Kind.LIST,
          values: this.any(se.TokenKind.BRACKET_L, a, se.TokenKind.BRACKET_R),
          loc: this.loc(o),
        };
      }),
      (t.parseObject = function (n) {
        var i = this,
          o = this._lexer.token,
          a = function () {
            return i.parseObjectField(n);
          };
        return {
          kind: Ge.Kind.OBJECT,
          fields: this.any(se.TokenKind.BRACE_L, a, se.TokenKind.BRACE_R),
          loc: this.loc(o),
        };
      }),
      (t.parseObjectField = function (n) {
        var i = this._lexer.token,
          o = this.parseName();
        return (
          this.expectToken(se.TokenKind.COLON),
          {
            kind: Ge.Kind.OBJECT_FIELD,
            name: o,
            value: this.parseValueLiteral(n),
            loc: this.loc(i),
          }
        );
      }),
      (t.parseDirectives = function (n) {
        for (var i = []; this.peek(se.TokenKind.AT); )
          i.push(this.parseDirective(n));
        return i;
      }),
      (t.parseDirective = function (n) {
        var i = this._lexer.token;
        return (
          this.expectToken(se.TokenKind.AT),
          {
            kind: Ge.Kind.DIRECTIVE,
            name: this.parseName(),
            arguments: this.parseArguments(n),
            loc: this.loc(i),
          }
        );
      }),
      (t.parseTypeReference = function () {
        var n = this._lexer.token,
          i;
        return (
          this.expectOptionalToken(se.TokenKind.BRACKET_L)
            ? ((i = this.parseTypeReference()),
              this.expectToken(se.TokenKind.BRACKET_R),
              (i = { kind: Ge.Kind.LIST_TYPE, type: i, loc: this.loc(n) }))
            : (i = this.parseNamedType()),
          this.expectOptionalToken(se.TokenKind.BANG)
            ? { kind: Ge.Kind.NON_NULL_TYPE, type: i, loc: this.loc(n) }
            : i
        );
      }),
      (t.parseNamedType = function () {
        var n = this._lexer.token;
        return {
          kind: Ge.Kind.NAMED_TYPE,
          name: this.parseName(),
          loc: this.loc(n),
        };
      }),
      (t.parseTypeSystemDefinition = function () {
        var n = this.peekDescription()
          ? this._lexer.lookahead()
          : this._lexer.token;
        if (n.kind === se.TokenKind.NAME)
          switch (n.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
        throw this.unexpected(n);
      }),
      (t.peekDescription = function () {
        return (
          this.peek(se.TokenKind.STRING) || this.peek(se.TokenKind.BLOCK_STRING)
        );
      }),
      (t.parseDescription = function () {
        if (this.peekDescription()) return this.parseStringLiteral();
      }),
      (t.parseSchemaDefinition = function () {
        var n = this._lexer.token,
          i = this.parseDescription();
        this.expectKeyword("schema");
        var o = this.parseDirectives(!0),
          a = this.many(
            se.TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            se.TokenKind.BRACE_R,
          );
        return {
          kind: Ge.Kind.SCHEMA_DEFINITION,
          description: i,
          directives: o,
          operationTypes: a,
          loc: this.loc(n),
        };
      }),
      (t.parseOperationTypeDefinition = function () {
        var n = this._lexer.token,
          i = this.parseOperationType();
        this.expectToken(se.TokenKind.COLON);
        var o = this.parseNamedType();
        return {
          kind: Ge.Kind.OPERATION_TYPE_DEFINITION,
          operation: i,
          type: o,
          loc: this.loc(n),
        };
      }),
      (t.parseScalarTypeDefinition = function () {
        var n = this._lexer.token,
          i = this.parseDescription();
        this.expectKeyword("scalar");
        var o = this.parseName(),
          a = this.parseDirectives(!0);
        return {
          kind: Ge.Kind.SCALAR_TYPE_DEFINITION,
          description: i,
          name: o,
          directives: a,
          loc: this.loc(n),
        };
      }),
      (t.parseObjectTypeDefinition = function () {
        var n = this._lexer.token,
          i = this.parseDescription();
        this.expectKeyword("type");
        var o = this.parseName(),
          a = this.parseImplementsInterfaces(),
          s = this.parseDirectives(!0),
          u = this.parseFieldsDefinition();
        return {
          kind: Ge.Kind.OBJECT_TYPE_DEFINITION,
          description: i,
          name: o,
          interfaces: a,
          directives: s,
          fields: u,
          loc: this.loc(n),
        };
      }),
      (t.parseImplementsInterfaces = function () {
        var n;
        if (!this.expectOptionalKeyword("implements")) return [];
        if (
          ((n = this._options) === null || n === void 0
            ? void 0
            : n.allowLegacySDLImplementsInterfaces) === !0
        ) {
          var i = [];
          this.expectOptionalToken(se.TokenKind.AMP);
          do i.push(this.parseNamedType());
          while (
            this.expectOptionalToken(se.TokenKind.AMP) ||
            this.peek(se.TokenKind.NAME)
          );
          return i;
        }
        return this.delimitedMany(se.TokenKind.AMP, this.parseNamedType);
      }),
      (t.parseFieldsDefinition = function () {
        var n;
        return ((n = this._options) === null || n === void 0
          ? void 0
          : n.allowLegacySDLEmptyFields) === !0 &&
          this.peek(se.TokenKind.BRACE_L) &&
          this._lexer.lookahead().kind === se.TokenKind.BRACE_R
          ? (this._lexer.advance(), this._lexer.advance(), [])
          : this.optionalMany(
              se.TokenKind.BRACE_L,
              this.parseFieldDefinition,
              se.TokenKind.BRACE_R,
            );
      }),
      (t.parseFieldDefinition = function () {
        var n = this._lexer.token,
          i = this.parseDescription(),
          o = this.parseName(),
          a = this.parseArgumentDefs();
        this.expectToken(se.TokenKind.COLON);
        var s = this.parseTypeReference(),
          u = this.parseDirectives(!0);
        return {
          kind: Ge.Kind.FIELD_DEFINITION,
          description: i,
          name: o,
          arguments: a,
          type: s,
          directives: u,
          loc: this.loc(n),
        };
      }),
      (t.parseArgumentDefs = function () {
        return this.optionalMany(
          se.TokenKind.PAREN_L,
          this.parseInputValueDef,
          se.TokenKind.PAREN_R,
        );
      }),
      (t.parseInputValueDef = function () {
        var n = this._lexer.token,
          i = this.parseDescription(),
          o = this.parseName();
        this.expectToken(se.TokenKind.COLON);
        var a = this.parseTypeReference(),
          s;
        this.expectOptionalToken(se.TokenKind.EQUALS) &&
          (s = this.parseValueLiteral(!0));
        var u = this.parseDirectives(!0);
        return {
          kind: Ge.Kind.INPUT_VALUE_DEFINITION,
          description: i,
          name: o,
          type: a,
          defaultValue: s,
          directives: u,
          loc: this.loc(n),
        };
      }),
      (t.parseInterfaceTypeDefinition = function () {
        var n = this._lexer.token,
          i = this.parseDescription();
        this.expectKeyword("interface");
        var o = this.parseName(),
          a = this.parseImplementsInterfaces(),
          s = this.parseDirectives(!0),
          u = this.parseFieldsDefinition();
        return {
          kind: Ge.Kind.INTERFACE_TYPE_DEFINITION,
          description: i,
          name: o,
          interfaces: a,
          directives: s,
          fields: u,
          loc: this.loc(n),
        };
      }),
      (t.parseUnionTypeDefinition = function () {
        var n = this._lexer.token,
          i = this.parseDescription();
        this.expectKeyword("union");
        var o = this.parseName(),
          a = this.parseDirectives(!0),
          s = this.parseUnionMemberTypes();
        return {
          kind: Ge.Kind.UNION_TYPE_DEFINITION,
          description: i,
          name: o,
          directives: a,
          types: s,
          loc: this.loc(n),
        };
      }),
      (t.parseUnionMemberTypes = function () {
        return this.expectOptionalToken(se.TokenKind.EQUALS)
          ? this.delimitedMany(se.TokenKind.PIPE, this.parseNamedType)
          : [];
      }),
      (t.parseEnumTypeDefinition = function () {
        var n = this._lexer.token,
          i = this.parseDescription();
        this.expectKeyword("enum");
        var o = this.parseName(),
          a = this.parseDirectives(!0),
          s = this.parseEnumValuesDefinition();
        return {
          kind: Ge.Kind.ENUM_TYPE_DEFINITION,
          description: i,
          name: o,
          directives: a,
          values: s,
          loc: this.loc(n),
        };
      }),
      (t.parseEnumValuesDefinition = function () {
        return this.optionalMany(
          se.TokenKind.BRACE_L,
          this.parseEnumValueDefinition,
          se.TokenKind.BRACE_R,
        );
      }),
      (t.parseEnumValueDefinition = function () {
        var n = this._lexer.token,
          i = this.parseDescription(),
          o = this.parseName(),
          a = this.parseDirectives(!0);
        return {
          kind: Ge.Kind.ENUM_VALUE_DEFINITION,
          description: i,
          name: o,
          directives: a,
          loc: this.loc(n),
        };
      }),
      (t.parseInputObjectTypeDefinition = function () {
        var n = this._lexer.token,
          i = this.parseDescription();
        this.expectKeyword("input");
        var o = this.parseName(),
          a = this.parseDirectives(!0),
          s = this.parseInputFieldsDefinition();
        return {
          kind: Ge.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description: i,
          name: o,
          directives: a,
          fields: s,
          loc: this.loc(n),
        };
      }),
      (t.parseInputFieldsDefinition = function () {
        return this.optionalMany(
          se.TokenKind.BRACE_L,
          this.parseInputValueDef,
          se.TokenKind.BRACE_R,
        );
      }),
      (t.parseTypeSystemExtension = function () {
        var n = this._lexer.lookahead();
        if (n.kind === se.TokenKind.NAME)
          switch (n.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        throw this.unexpected(n);
      }),
      (t.parseSchemaExtension = function () {
        var n = this._lexer.token;
        this.expectKeyword("extend"), this.expectKeyword("schema");
        var i = this.parseDirectives(!0),
          o = this.optionalMany(
            se.TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            se.TokenKind.BRACE_R,
          );
        if (i.length === 0 && o.length === 0) throw this.unexpected();
        return {
          kind: Ge.Kind.SCHEMA_EXTENSION,
          directives: i,
          operationTypes: o,
          loc: this.loc(n),
        };
      }),
      (t.parseScalarTypeExtension = function () {
        var n = this._lexer.token;
        this.expectKeyword("extend"), this.expectKeyword("scalar");
        var i = this.parseName(),
          o = this.parseDirectives(!0);
        if (o.length === 0) throw this.unexpected();
        return {
          kind: Ge.Kind.SCALAR_TYPE_EXTENSION,
          name: i,
          directives: o,
          loc: this.loc(n),
        };
      }),
      (t.parseObjectTypeExtension = function () {
        var n = this._lexer.token;
        this.expectKeyword("extend"), this.expectKeyword("type");
        var i = this.parseName(),
          o = this.parseImplementsInterfaces(),
          a = this.parseDirectives(!0),
          s = this.parseFieldsDefinition();
        if (o.length === 0 && a.length === 0 && s.length === 0)
          throw this.unexpected();
        return {
          kind: Ge.Kind.OBJECT_TYPE_EXTENSION,
          name: i,
          interfaces: o,
          directives: a,
          fields: s,
          loc: this.loc(n),
        };
      }),
      (t.parseInterfaceTypeExtension = function () {
        var n = this._lexer.token;
        this.expectKeyword("extend"), this.expectKeyword("interface");
        var i = this.parseName(),
          o = this.parseImplementsInterfaces(),
          a = this.parseDirectives(!0),
          s = this.parseFieldsDefinition();
        if (o.length === 0 && a.length === 0 && s.length === 0)
          throw this.unexpected();
        return {
          kind: Ge.Kind.INTERFACE_TYPE_EXTENSION,
          name: i,
          interfaces: o,
          directives: a,
          fields: s,
          loc: this.loc(n),
        };
      }),
      (t.parseUnionTypeExtension = function () {
        var n = this._lexer.token;
        this.expectKeyword("extend"), this.expectKeyword("union");
        var i = this.parseName(),
          o = this.parseDirectives(!0),
          a = this.parseUnionMemberTypes();
        if (o.length === 0 && a.length === 0) throw this.unexpected();
        return {
          kind: Ge.Kind.UNION_TYPE_EXTENSION,
          name: i,
          directives: o,
          types: a,
          loc: this.loc(n),
        };
      }),
      (t.parseEnumTypeExtension = function () {
        var n = this._lexer.token;
        this.expectKeyword("extend"), this.expectKeyword("enum");
        var i = this.parseName(),
          o = this.parseDirectives(!0),
          a = this.parseEnumValuesDefinition();
        if (o.length === 0 && a.length === 0) throw this.unexpected();
        return {
          kind: Ge.Kind.ENUM_TYPE_EXTENSION,
          name: i,
          directives: o,
          values: a,
          loc: this.loc(n),
        };
      }),
      (t.parseInputObjectTypeExtension = function () {
        var n = this._lexer.token;
        this.expectKeyword("extend"), this.expectKeyword("input");
        var i = this.parseName(),
          o = this.parseDirectives(!0),
          a = this.parseInputFieldsDefinition();
        if (o.length === 0 && a.length === 0) throw this.unexpected();
        return {
          kind: Ge.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name: i,
          directives: o,
          fields: a,
          loc: this.loc(n),
        };
      }),
      (t.parseDirectiveDefinition = function () {
        var n = this._lexer.token,
          i = this.parseDescription();
        this.expectKeyword("directive"), this.expectToken(se.TokenKind.AT);
        var o = this.parseName(),
          a = this.parseArgumentDefs(),
          s = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        var u = this.parseDirectiveLocations();
        return {
          kind: Ge.Kind.DIRECTIVE_DEFINITION,
          description: i,
          name: o,
          arguments: a,
          repeatable: s,
          locations: u,
          loc: this.loc(n),
        };
      }),
      (t.parseDirectiveLocations = function () {
        return this.delimitedMany(
          se.TokenKind.PIPE,
          this.parseDirectiveLocation,
        );
      }),
      (t.parseDirectiveLocation = function () {
        var n = this._lexer.token,
          i = this.parseName();
        if (eCt.DirectiveLocation[i.value] !== void 0) return i;
        throw this.unexpected(n);
      }),
      (t.loc = function (n) {
        var i;
        if (
          ((i = this._options) === null || i === void 0
            ? void 0
            : i.noLocation) !== !0
        )
          return new Z0t.Location(n, this._lexer.lastToken, this._lexer.source);
      }),
      (t.peek = function (n) {
        return this._lexer.token.kind === n;
      }),
      (t.expectToken = function (n) {
        var i = this._lexer.token;
        if (i.kind === n) return this._lexer.advance(), i;
        throw (0, IV.syntaxError)(
          this._lexer.source,
          i.start,
          "Expected ".concat(Ule(n), ", found ").concat(xV(i), "."),
        );
      }),
      (t.expectOptionalToken = function (n) {
        var i = this._lexer.token;
        if (i.kind === n) return this._lexer.advance(), i;
      }),
      (t.expectKeyword = function (n) {
        var i = this._lexer.token;
        if (i.kind === se.TokenKind.NAME && i.value === n)
          this._lexer.advance();
        else
          throw (0, IV.syntaxError)(
            this._lexer.source,
            i.start,
            'Expected "'.concat(n, '", found ').concat(xV(i), "."),
          );
      }),
      (t.expectOptionalKeyword = function (n) {
        var i = this._lexer.token;
        return i.kind === se.TokenKind.NAME && i.value === n
          ? (this._lexer.advance(), !0)
          : !1;
      }),
      (t.unexpected = function (n) {
        var i = n ?? this._lexer.token;
        return (0, IV.syntaxError)(
          this._lexer.source,
          i.start,
          "Unexpected ".concat(xV(i), "."),
        );
      }),
      (t.any = function (n, i, o) {
        this.expectToken(n);
        for (var a = []; !this.expectOptionalToken(o); ) a.push(i.call(this));
        return a;
      }),
      (t.optionalMany = function (n, i, o) {
        if (this.expectOptionalToken(n)) {
          var a = [];
          do a.push(i.call(this));
          while (!this.expectOptionalToken(o));
          return a;
        }
        return [];
      }),
      (t.many = function (n, i, o) {
        this.expectToken(n);
        var a = [];
        do a.push(i.call(this));
        while (!this.expectOptionalToken(o));
        return a;
      }),
      (t.delimitedMany = function (n, i) {
        this.expectOptionalToken(n);
        var o = [];
        do o.push(i.call(this));
        while (this.expectOptionalToken(n));
        return o;
      }),
      e
    );
  })();
  gm.Parser = $x;
  function xV(e) {
    var t = e.value;
    return Ule(e.kind) + (t != null ? ' "'.concat(t, '"') : "");
  }
  function Ule(e) {
    return (0, Ble.isPunctuatorTokenKind)(e) ? '"'.concat(e, '"') : e;
  }
});
var Bd = g((Wu) => {
  "use strict";
  c();
  Object.defineProperty(Wu, "__esModule", { value: !0 });
  Wu.visit = aCt;
  Wu.visitInParallel = sCt;
  Wu.getVisitFn = zx;
  Wu.BREAK = Wu.QueryDocumentKeys = void 0;
  var iCt = oCt(Lt()),
    Hle = Hv();
  function oCt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var Gle = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet",
    ],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet",
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields",
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives",
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields",
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"],
  };
  Wu.QueryDocumentKeys = Gle;
  var Kv = Object.freeze({});
  Wu.BREAK = Kv;
  function aCt(e, t) {
    var r =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Gle,
      n = void 0,
      i = Array.isArray(e),
      o = [e],
      a = -1,
      s = [],
      u = void 0,
      l = void 0,
      d = void 0,
      f = [],
      m = [],
      h = e;
    do {
      a++;
      var y = a === o.length,
        _ = y && s.length !== 0;
      if (y) {
        if (
          ((l = m.length === 0 ? void 0 : f[f.length - 1]),
          (u = d),
          (d = m.pop()),
          _)
        ) {
          if (i) u = u.slice();
          else {
            for (var E = {}, b = 0, O = Object.keys(u); b < O.length; b++) {
              var C = O[b];
              E[C] = u[C];
            }
            u = E;
          }
          for (var P = 0, k = 0; k < s.length; k++) {
            var H = s[k][0],
              B = s[k][1];
            i && (H -= P), i && B === null ? (u.splice(H, 1), P++) : (u[H] = B);
          }
        }
        (a = n.index),
          (o = n.keys),
          (s = n.edits),
          (i = n.inArray),
          (n = n.prev);
      } else {
        if (((l = d ? (i ? a : o[a]) : void 0), (u = d ? d[l] : h), u == null))
          continue;
        d && f.push(l);
      }
      var L = void 0;
      if (!Array.isArray(u)) {
        if (!(0, Hle.isNode)(u))
          throw new Error(
            "Invalid AST Node: ".concat((0, iCt.default)(u), "."),
          );
        var Z = zx(t, u.kind, y);
        if (Z) {
          if (((L = Z.call(t, u, l, d, f, m)), L === Kv)) break;
          if (L === !1) {
            if (!y) {
              f.pop();
              continue;
            }
          } else if (L !== void 0 && (s.push([l, L]), !y))
            if ((0, Hle.isNode)(L)) u = L;
            else {
              f.pop();
              continue;
            }
        }
      }
      if ((L === void 0 && _ && s.push([l, u]), y)) f.pop();
      else {
        var ft;
        (n = { inArray: i, index: a, keys: o, edits: s, prev: n }),
          (i = Array.isArray(u)),
          (o = i ? u : (ft = r[u.kind]) !== null && ft !== void 0 ? ft : []),
          (a = -1),
          (s = []),
          d && m.push(d),
          (d = u);
      }
    } while (n !== void 0);
    return s.length !== 0 && (h = s[s.length - 1][1]), h;
  }
  function sCt(e) {
    var t = new Array(e.length);
    return {
      enter: function (n) {
        for (var i = 0; i < e.length; i++)
          if (t[i] == null) {
            var o = zx(e[i], n.kind, !1);
            if (o) {
              var a = o.apply(e[i], arguments);
              if (a === !1) t[i] = n;
              else if (a === Kv) t[i] = Kv;
              else if (a !== void 0) return a;
            }
          }
      },
      leave: function (n) {
        for (var i = 0; i < e.length; i++)
          if (t[i] == null) {
            var o = zx(e[i], n.kind, !0);
            if (o) {
              var a = o.apply(e[i], arguments);
              if (a === Kv) t[i] = Kv;
              else if (a !== void 0 && a !== !1) return a;
            }
          } else t[i] === n && (t[i] = null);
      },
    };
  }
  function zx(e, t, r) {
    var n = e[t];
    if (n) {
      if (!r && typeof n == "function") return n;
      var i = r ? n.leave : n.enter;
      if (typeof i == "function") return i;
    } else {
      var o = r ? e.leave : e.enter;
      if (o) {
        if (typeof o == "function") return o;
        var a = o[t];
        if (typeof a == "function") return a;
      }
    }
  }
});
var Wv = g((Kx) => {
  "use strict";
  c();
  Object.defineProperty(Kx, "__esModule", { value: !0 });
  Kx.default = void 0;
  var cCt = Array.prototype.find
      ? function (e, t) {
          return Array.prototype.find.call(e, t);
        }
      : function (e, t) {
          for (var r = 0; r < e.length; r++) {
            var n = e[r];
            if (t(n)) return n;
          }
        },
    uCt = cCt;
  Kx.default = uCt;
});
var ea = g((Wx) => {
  "use strict";
  c();
  Object.defineProperty(Wx, "__esModule", { value: !0 });
  Wx.default = void 0;
  var lCt =
      Object.values ||
      function (e) {
        return Object.keys(e).map(function (t) {
          return e[t];
        });
      },
    dCt = lCt;
  Wx.default = dCt;
});
var s0 = g((NV) => {
  "use strict";
  c();
  Object.defineProperty(NV, "__esModule", { value: !0 });
  NV.locatedError = hCt;
  var fCt = mCt(Lt()),
    pCt = Ue();
  function mCt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function hCt(e, t, r) {
    var n,
      i =
        e instanceof Error
          ? e
          : new Error("Unexpected error value: " + (0, fCt.default)(e));
    return Array.isArray(i.path)
      ? i
      : new pCt.GraphQLError(
          i.message,
          (n = i.nodes) !== null && n !== void 0 ? n : t,
          i.source,
          i.positions,
          r,
          i,
        );
  }
});
var kV = g((Qx) => {
  "use strict";
  c();
  Object.defineProperty(Qx, "__esModule", { value: !0 });
  Qx.assertValidName = _Ct;
  Qx.isValidNameError = $le;
  var gCt = vCt(Ta()),
    Vle = Ue();
  function vCt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var yCt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
  function _Ct(e) {
    var t = $le(e);
    if (t) throw t;
    return e;
  }
  function $le(e) {
    if (
      (typeof e == "string" ||
        (0, gCt.default)(0, "Expected name to be a string."),
      e.length > 1 && e[0] === "_" && e[1] === "_")
    )
      return new Vle.GraphQLError(
        'Name "'.concat(
          e,
          '" must not begin with "__", which is reserved by GraphQL introspection.',
        ),
      );
    if (!yCt.test(e))
      return new Vle.GraphQLError(
        'Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "'.concat(
          e,
          '" does not.',
        ),
      );
  }
});
var Qv = g((Yx) => {
  "use strict";
  c();
  Object.defineProperty(Yx, "__esModule", { value: !0 });
  Yx.default = void 0;
  var ECt =
      Object.entries ||
      function (e) {
        return Object.keys(e).map(function (t) {
          return [t, e[t]];
        });
      },
    bCt = ECt;
  Yx.default = bCt;
});
var Ud = g((DV) => {
  "use strict";
  c();
  Object.defineProperty(DV, "__esModule", { value: !0 });
  DV.default = SCt;
  function SCt(e, t) {
    return e.reduce(function (r, n) {
      return (r[t(n)] = n), r;
    }, Object.create(null));
  }
});
var MV = g((LV) => {
  "use strict";
  c();
  Object.defineProperty(LV, "__esModule", { value: !0 });
  LV.default = OCt;
  var CCt = wCt(Qv());
  function wCt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function OCt(e, t) {
    for (
      var r = Object.create(null), n = 0, i = (0, CCt.default)(e);
      n < i.length;
      n++
    ) {
      var o = i[n],
        a = o[0],
        s = o[1];
      r[a] = t(s, a);
    }
    return r;
  }
});
var Xx = g((qV) => {
  "use strict";
  c();
  Object.defineProperty(qV, "__esModule", { value: !0 });
  qV.default = PCt;
  var TCt = ACt(Qv());
  function ACt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function PCt(e) {
    if (Object.getPrototypeOf(e) === null) return e;
    for (
      var t = Object.create(null), r = 0, n = (0, TCt.default)(e);
      r < n.length;
      r++
    ) {
      var i = n[r],
        o = i[0],
        a = i[1];
      t[o] = a;
    }
    return t;
  }
});
var c0 = g((jV) => {
  "use strict";
  c();
  Object.defineProperty(jV, "__esModule", { value: !0 });
  jV.default = RCt;
  function RCt(e, t, r) {
    return e.reduce(function (n, i) {
      return (n[t(i)] = r(i)), n;
    }, Object.create(null));
  }
});
var Hd = g((FV) => {
  "use strict";
  c();
  Object.defineProperty(FV, "__esModule", { value: !0 });
  FV.default = xCt;
  var ICt = 5;
  function xCt(e, t) {
    var r = typeof e == "string" ? [e, t] : [void 0, e],
      n = r[0],
      i = r[1],
      o = " Did you mean ";
    n && (o += n + " ");
    var a = i.map(function (l) {
      return '"'.concat(l, '"');
    });
    switch (a.length) {
      case 0:
        return "";
      case 1:
        return o + a[0] + "?";
      case 2:
        return o + a[0] + " or " + a[1] + "?";
    }
    var s = a.slice(0, ICt),
      u = s.pop();
    return o + s.join(", ") + ", or " + u + "?";
  }
});
var zle = g((BV) => {
  "use strict";
  c();
  Object.defineProperty(BV, "__esModule", { value: !0 });
  BV.default = NCt;
  function NCt(e) {
    return e;
  }
});
var u0 = g((HV) => {
  "use strict";
  c();
  Object.defineProperty(HV, "__esModule", { value: !0 });
  HV.default = kCt;
  function kCt(e, t) {
    for (var r = 0, n = 0; r < e.length && n < t.length; ) {
      var i = e.charCodeAt(r),
        o = t.charCodeAt(n);
      if (Jx(i) && Jx(o)) {
        var a = 0;
        do ++r, (a = a * 10 + i - UV), (i = e.charCodeAt(r));
        while (Jx(i) && a > 0);
        var s = 0;
        do ++n, (s = s * 10 + o - UV), (o = t.charCodeAt(n));
        while (Jx(o) && s > 0);
        if (a < s) return -1;
        if (a > s) return 1;
      } else {
        if (i < o) return -1;
        if (i > o) return 1;
        ++r, ++n;
      }
    }
    return e.length - t.length;
  }
  var UV = 48,
    DCt = 57;
  function Jx(e) {
    return !isNaN(e) && UV <= e && e <= DCt;
  }
});
var Gd = g((GV) => {
  "use strict";
  c();
  Object.defineProperty(GV, "__esModule", { value: !0 });
  GV.default = qCt;
  var LCt = MCt(u0());
  function MCt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function qCt(e, t) {
    for (
      var r = Object.create(null),
        n = new jCt(e),
        i = Math.floor(e.length * 0.4) + 1,
        o = 0;
      o < t.length;
      o++
    ) {
      var a = t[o],
        s = n.measure(a, i);
      s !== void 0 && (r[a] = s);
    }
    return Object.keys(r).sort(function (u, l) {
      var d = r[u] - r[l];
      return d !== 0 ? d : (0, LCt.default)(u, l);
    });
  }
  var jCt = (function () {
    function e(r) {
      (this._input = r),
        (this._inputLowerCase = r.toLowerCase()),
        (this._inputArray = Kle(this._inputLowerCase)),
        (this._rows = [
          new Array(r.length + 1).fill(0),
          new Array(r.length + 1).fill(0),
          new Array(r.length + 1).fill(0),
        ]);
    }
    var t = e.prototype;
    return (
      (t.measure = function (n, i) {
        if (this._input === n) return 0;
        var o = n.toLowerCase();
        if (this._inputLowerCase === o) return 1;
        var a = Kle(o),
          s = this._inputArray;
        if (a.length < s.length) {
          var u = a;
          (a = s), (s = u);
        }
        var l = a.length,
          d = s.length;
        if (!(l - d > i)) {
          for (var f = this._rows, m = 0; m <= d; m++) f[0][m] = m;
          for (var h = 1; h <= l; h++) {
            for (
              var y = f[(h - 1) % 3], _ = f[h % 3], E = (_[0] = h), b = 1;
              b <= d;
              b++
            ) {
              var O = a[h - 1] === s[b - 1] ? 0 : 1,
                C = Math.min(y[b] + 1, _[b - 1] + 1, y[b - 1] + O);
              if (
                h > 1 &&
                b > 1 &&
                a[h - 1] === s[b - 2] &&
                a[h - 2] === s[b - 1]
              ) {
                var P = f[(h - 2) % 3][b - 2];
                C = Math.min(C, P + 1);
              }
              C < E && (E = C), (_[b] = C);
            }
            if (E > i) return;
          }
          var k = f[l % 3][d];
          return k <= i ? k : void 0;
        }
      }),
      e
    );
  })();
  function Kle(e) {
    for (var t = e.length, r = new Array(t), n = 0; n < t; ++n)
      r[n] = e.charCodeAt(n);
    return r;
  }
});
var ta = g((VV) => {
  "use strict";
  c();
  Object.defineProperty(VV, "__esModule", { value: !0 });
  VV.print = UCt;
  var FCt = Bd(),
    BCt = $v();
  function UCt(e) {
    return (0, FCt.visit)(e, { leave: GCt });
  }
  var HCt = 80,
    GCt = {
      Name: function (t) {
        return t.value;
      },
      Variable: function (t) {
        return "$" + t.name;
      },
      Document: function (t) {
        return (
          Pe(
            t.definitions,
            `

`,
          ) +
          `
`
        );
      },
      OperationDefinition: function (t) {
        var r = t.operation,
          n = t.name,
          i = Xr("(", Pe(t.variableDefinitions, ", "), ")"),
          o = Pe(t.directives, " "),
          a = t.selectionSet;
        return !n && !o && !i && r === "query"
          ? a
          : Pe([r, Pe([n, i]), o, a], " ");
      },
      VariableDefinition: function (t) {
        var r = t.variable,
          n = t.type,
          i = t.defaultValue,
          o = t.directives;
        return r + ": " + n + Xr(" = ", i) + Xr(" ", Pe(o, " "));
      },
      SelectionSet: function (t) {
        var r = t.selections;
        return Ds(r);
      },
      Field: function (t) {
        var r = t.alias,
          n = t.name,
          i = t.arguments,
          o = t.directives,
          a = t.selectionSet,
          s = Xr("", r, ": ") + n,
          u = s + Xr("(", Pe(i, ", "), ")");
        return (
          u.length > HCt &&
            (u =
              s +
              Xr(
                `(
`,
                Zx(
                  Pe(
                    i,
                    `
`,
                  ),
                ),
                `
)`,
              )),
          Pe([u, Pe(o, " "), a], " ")
        );
      },
      Argument: function (t) {
        var r = t.name,
          n = t.value;
        return r + ": " + n;
      },
      FragmentSpread: function (t) {
        var r = t.name,
          n = t.directives;
        return "..." + r + Xr(" ", Pe(n, " "));
      },
      InlineFragment: function (t) {
        var r = t.typeCondition,
          n = t.directives,
          i = t.selectionSet;
        return Pe(["...", Xr("on ", r), Pe(n, " "), i], " ");
      },
      FragmentDefinition: function (t) {
        var r = t.name,
          n = t.typeCondition,
          i = t.variableDefinitions,
          o = t.directives,
          a = t.selectionSet;
        return (
          "fragment ".concat(r).concat(Xr("(", Pe(i, ", "), ")"), " ") +
          "on ".concat(n, " ").concat(Xr("", Pe(o, " "), " ")) +
          a
        );
      },
      IntValue: function (t) {
        var r = t.value;
        return r;
      },
      FloatValue: function (t) {
        var r = t.value;
        return r;
      },
      StringValue: function (t, r) {
        var n = t.value,
          i = t.block;
        return i
          ? (0, BCt.printBlockString)(n, r === "description" ? "" : "  ")
          : JSON.stringify(n);
      },
      BooleanValue: function (t) {
        var r = t.value;
        return r ? "true" : "false";
      },
      NullValue: function () {
        return "null";
      },
      EnumValue: function (t) {
        var r = t.value;
        return r;
      },
      ListValue: function (t) {
        var r = t.values;
        return "[" + Pe(r, ", ") + "]";
      },
      ObjectValue: function (t) {
        var r = t.fields;
        return "{" + Pe(r, ", ") + "}";
      },
      ObjectField: function (t) {
        var r = t.name,
          n = t.value;
        return r + ": " + n;
      },
      Directive: function (t) {
        var r = t.name,
          n = t.arguments;
        return "@" + r + Xr("(", Pe(n, ", "), ")");
      },
      NamedType: function (t) {
        var r = t.name;
        return r;
      },
      ListType: function (t) {
        var r = t.type;
        return "[" + r + "]";
      },
      NonNullType: function (t) {
        var r = t.type;
        return r + "!";
      },
      SchemaDefinition: ks(function (e) {
        var t = e.directives,
          r = e.operationTypes;
        return Pe(["schema", Pe(t, " "), Ds(r)], " ");
      }),
      OperationTypeDefinition: function (t) {
        var r = t.operation,
          n = t.type;
        return r + ": " + n;
      },
      ScalarTypeDefinition: ks(function (e) {
        var t = e.name,
          r = e.directives;
        return Pe(["scalar", t, Pe(r, " ")], " ");
      }),
      ObjectTypeDefinition: ks(function (e) {
        var t = e.name,
          r = e.interfaces,
          n = e.directives,
          i = e.fields;
        return Pe(
          ["type", t, Xr("implements ", Pe(r, " & ")), Pe(n, " "), Ds(i)],
          " ",
        );
      }),
      FieldDefinition: ks(function (e) {
        var t = e.name,
          r = e.arguments,
          n = e.type,
          i = e.directives;
        return (
          t +
          (Wle(r)
            ? Xr(
                `(
`,
                Zx(
                  Pe(
                    r,
                    `
`,
                  ),
                ),
                `
)`,
              )
            : Xr("(", Pe(r, ", "), ")")) +
          ": " +
          n +
          Xr(" ", Pe(i, " "))
        );
      }),
      InputValueDefinition: ks(function (e) {
        var t = e.name,
          r = e.type,
          n = e.defaultValue,
          i = e.directives;
        return Pe([t + ": " + r, Xr("= ", n), Pe(i, " ")], " ");
      }),
      InterfaceTypeDefinition: ks(function (e) {
        var t = e.name,
          r = e.interfaces,
          n = e.directives,
          i = e.fields;
        return Pe(
          ["interface", t, Xr("implements ", Pe(r, " & ")), Pe(n, " "), Ds(i)],
          " ",
        );
      }),
      UnionTypeDefinition: ks(function (e) {
        var t = e.name,
          r = e.directives,
          n = e.types;
        return Pe(
          [
            "union",
            t,
            Pe(r, " "),
            n && n.length !== 0 ? "= " + Pe(n, " | ") : "",
          ],
          " ",
        );
      }),
      EnumTypeDefinition: ks(function (e) {
        var t = e.name,
          r = e.directives,
          n = e.values;
        return Pe(["enum", t, Pe(r, " "), Ds(n)], " ");
      }),
      EnumValueDefinition: ks(function (e) {
        var t = e.name,
          r = e.directives;
        return Pe([t, Pe(r, " ")], " ");
      }),
      InputObjectTypeDefinition: ks(function (e) {
        var t = e.name,
          r = e.directives,
          n = e.fields;
        return Pe(["input", t, Pe(r, " "), Ds(n)], " ");
      }),
      DirectiveDefinition: ks(function (e) {
        var t = e.name,
          r = e.arguments,
          n = e.repeatable,
          i = e.locations;
        return (
          "directive @" +
          t +
          (Wle(r)
            ? Xr(
                `(
`,
                Zx(
                  Pe(
                    r,
                    `
`,
                  ),
                ),
                `
)`,
              )
            : Xr("(", Pe(r, ", "), ")")) +
          (n ? " repeatable" : "") +
          " on " +
          Pe(i, " | ")
        );
      }),
      SchemaExtension: function (t) {
        var r = t.directives,
          n = t.operationTypes;
        return Pe(["extend schema", Pe(r, " "), Ds(n)], " ");
      },
      ScalarTypeExtension: function (t) {
        var r = t.name,
          n = t.directives;
        return Pe(["extend scalar", r, Pe(n, " ")], " ");
      },
      ObjectTypeExtension: function (t) {
        var r = t.name,
          n = t.interfaces,
          i = t.directives,
          o = t.fields;
        return Pe(
          [
            "extend type",
            r,
            Xr("implements ", Pe(n, " & ")),
            Pe(i, " "),
            Ds(o),
          ],
          " ",
        );
      },
      InterfaceTypeExtension: function (t) {
        var r = t.name,
          n = t.interfaces,
          i = t.directives,
          o = t.fields;
        return Pe(
          [
            "extend interface",
            r,
            Xr("implements ", Pe(n, " & ")),
            Pe(i, " "),
            Ds(o),
          ],
          " ",
        );
      },
      UnionTypeExtension: function (t) {
        var r = t.name,
          n = t.directives,
          i = t.types;
        return Pe(
          [
            "extend union",
            r,
            Pe(n, " "),
            i && i.length !== 0 ? "= " + Pe(i, " | ") : "",
          ],
          " ",
        );
      },
      EnumTypeExtension: function (t) {
        var r = t.name,
          n = t.directives,
          i = t.values;
        return Pe(["extend enum", r, Pe(n, " "), Ds(i)], " ");
      },
      InputObjectTypeExtension: function (t) {
        var r = t.name,
          n = t.directives,
          i = t.fields;
        return Pe(["extend input", r, Pe(n, " "), Ds(i)], " ");
      },
    };
  function ks(e) {
    return function (t) {
      return Pe(
        [t.description, e(t)],
        `
`,
      );
    };
  }
  function Pe(e) {
    var t,
      r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return (t = e
      ?.filter(function (n) {
        return n;
      })
      .join(r)) !== null && t !== void 0
      ? t
      : "";
  }
  function Ds(e) {
    return Xr(
      `{
`,
      Zx(
        Pe(
          e,
          `
`,
        ),
      ),
      `
}`,
    );
  }
  function Xr(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    return t != null && t !== "" ? e + t + r : "";
  }
  function Zx(e) {
    return Xr(
      "  ",
      e.replace(
        /\n/g,
        `
  `,
      ),
    );
  }
  function VCt(e) {
    return (
      e.indexOf(`
`) !== -1
    );
  }
  function Wle(e) {
    return e != null && e.some(VCt);
  }
});
var WV = g((KV) => {
  "use strict";
  c();
  Object.defineProperty(KV, "__esModule", { value: !0 });
  KV.valueFromASTUntyped = $V;
  var $Ct = zV(Lt()),
    zCt = zV(vi()),
    KCt = zV(c0()),
    Qu = lr();
  function zV(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function $V(e, t) {
    switch (e.kind) {
      case Qu.Kind.NULL:
        return null;
      case Qu.Kind.INT:
        return parseInt(e.value, 10);
      case Qu.Kind.FLOAT:
        return parseFloat(e.value);
      case Qu.Kind.STRING:
      case Qu.Kind.ENUM:
      case Qu.Kind.BOOLEAN:
        return e.value;
      case Qu.Kind.LIST:
        return e.values.map(function (r) {
          return $V(r, t);
        });
      case Qu.Kind.OBJECT:
        return (0, KCt.default)(
          e.fields,
          function (r) {
            return r.name.value;
          },
          function (r) {
            return $V(r.value, t);
          },
        );
      case Qu.Kind.VARIABLE:
        return t?.[e.name.value];
    }
    (0, zCt.default)(0, "Unexpected value node: " + (0, $Ct.default)(e));
  }
});
var It = g((Me) => {
  "use strict";
  c();
  Object.defineProperty(Me, "__esModule", { value: !0 });
  Me.isType = QV;
  Me.assertType = ede;
  Me.isScalarType = vm;
  Me.assertScalarType = ewt;
  Me.isObjectType = Jv;
  Me.assertObjectType = twt;
  Me.isInterfaceType = ym;
  Me.assertInterfaceType = rwt;
  Me.isUnionType = _m;
  Me.assertUnionType = nwt;
  Me.isEnumType = Em;
  Me.assertEnumType = iwt;
  Me.isInputObjectType = d0;
  Me.assertInputObjectType = owt;
  Me.isListType = rN;
  Me.assertListType = awt;
  Me.isNonNullType = Qd;
  Me.assertNonNullType = swt;
  Me.isInputType = YV;
  Me.assertInputType = cwt;
  Me.isOutputType = XV;
  Me.assertOutputType = uwt;
  Me.isLeafType = tde;
  Me.assertLeafType = lwt;
  Me.isCompositeType = rde;
  Me.assertCompositeType = dwt;
  Me.isAbstractType = nde;
  Me.assertAbstractType = fwt;
  Me.GraphQLList = Vd;
  Me.GraphQLNonNull = $d;
  Me.isWrappingType = f0;
  Me.assertWrappingType = pwt;
  Me.isNullableType = ide;
  Me.assertNullableType = ode;
  Me.getNullableType = mwt;
  Me.isNamedType = ade;
  Me.assertNamedType = hwt;
  Me.getNamedType = gwt;
  Me.argsToArgsConfig = lde;
  Me.isRequiredArgument = vwt;
  Me.isRequiredInputField = bwt;
  Me.GraphQLInputObjectType =
    Me.GraphQLEnumType =
    Me.GraphQLUnionType =
    Me.GraphQLInterfaceType =
    Me.GraphQLObjectType =
    Me.GraphQLScalarType =
      void 0;
  var Jle = ra(Qv()),
    zd = Oc(),
    Lr = ra(Lt()),
    WCt = ra(Ud()),
    tN = ra(MV()),
    Ac = ra(Xx()),
    Hr = ra(Ta()),
    Zle = ra(c0()),
    Kd = ra(n0()),
    QCt = ra(Hd()),
    YCt = ra(wc()),
    Qle = ra(zle()),
    Wd = ra(Lx()),
    XCt = ra(Gd()),
    l0 = Ue(),
    JCt = lr(),
    Yle = ta(),
    ZCt = WV();
  function ra(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Xle(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      (n.enumerable = n.enumerable || !1),
        (n.configurable = !0),
        "value" in n && (n.writable = !0),
        Object.defineProperty(e, n.key, n);
    }
  }
  function Xv(e, t, r) {
    return t && Xle(e.prototype, t), r && Xle(e, r), e;
  }
  function QV(e) {
    return vm(e) || Jv(e) || ym(e) || _m(e) || Em(e) || d0(e) || rN(e) || Qd(e);
  }
  function ede(e) {
    if (!QV(e))
      throw new Error(
        "Expected ".concat((0, Lr.default)(e), " to be a GraphQL type."),
      );
    return e;
  }
  function vm(e) {
    return (0, Kd.default)(e, JV);
  }
  function ewt(e) {
    if (!vm(e))
      throw new Error(
        "Expected ".concat((0, Lr.default)(e), " to be a GraphQL Scalar type."),
      );
    return e;
  }
  function Jv(e) {
    return (0, Kd.default)(e, ZV);
  }
  function twt(e) {
    if (!Jv(e))
      throw new Error(
        "Expected ".concat((0, Lr.default)(e), " to be a GraphQL Object type."),
      );
    return e;
  }
  function ym(e) {
    return (0, Kd.default)(e, e$);
  }
  function rwt(e) {
    if (!ym(e))
      throw new Error(
        "Expected ".concat(
          (0, Lr.default)(e),
          " to be a GraphQL Interface type.",
        ),
      );
    return e;
  }
  function _m(e) {
    return (0, Kd.default)(e, t$);
  }
  function nwt(e) {
    if (!_m(e))
      throw new Error(
        "Expected ".concat((0, Lr.default)(e), " to be a GraphQL Union type."),
      );
    return e;
  }
  function Em(e) {
    return (0, Kd.default)(e, r$);
  }
  function iwt(e) {
    if (!Em(e))
      throw new Error(
        "Expected ".concat((0, Lr.default)(e), " to be a GraphQL Enum type."),
      );
    return e;
  }
  function d0(e) {
    return (0, Kd.default)(e, n$);
  }
  function owt(e) {
    if (!d0(e))
      throw new Error(
        "Expected ".concat(
          (0, Lr.default)(e),
          " to be a GraphQL Input Object type.",
        ),
      );
    return e;
  }
  function rN(e) {
    return (0, Kd.default)(e, Vd);
  }
  function awt(e) {
    if (!rN(e))
      throw new Error(
        "Expected ".concat((0, Lr.default)(e), " to be a GraphQL List type."),
      );
    return e;
  }
  function Qd(e) {
    return (0, Kd.default)(e, $d);
  }
  function swt(e) {
    if (!Qd(e))
      throw new Error(
        "Expected ".concat(
          (0, Lr.default)(e),
          " to be a GraphQL Non-Null type.",
        ),
      );
    return e;
  }
  function YV(e) {
    return vm(e) || Em(e) || d0(e) || (f0(e) && YV(e.ofType));
  }
  function cwt(e) {
    if (!YV(e))
      throw new Error(
        "Expected ".concat((0, Lr.default)(e), " to be a GraphQL input type."),
      );
    return e;
  }
  function XV(e) {
    return vm(e) || Jv(e) || ym(e) || _m(e) || Em(e) || (f0(e) && XV(e.ofType));
  }
  function uwt(e) {
    if (!XV(e))
      throw new Error(
        "Expected ".concat((0, Lr.default)(e), " to be a GraphQL output type."),
      );
    return e;
  }
  function tde(e) {
    return vm(e) || Em(e);
  }
  function lwt(e) {
    if (!tde(e))
      throw new Error(
        "Expected ".concat((0, Lr.default)(e), " to be a GraphQL leaf type."),
      );
    return e;
  }
  function rde(e) {
    return Jv(e) || ym(e) || _m(e);
  }
  function dwt(e) {
    if (!rde(e))
      throw new Error(
        "Expected ".concat(
          (0, Lr.default)(e),
          " to be a GraphQL composite type.",
        ),
      );
    return e;
  }
  function nde(e) {
    return ym(e) || _m(e);
  }
  function fwt(e) {
    if (!nde(e))
      throw new Error(
        "Expected ".concat(
          (0, Lr.default)(e),
          " to be a GraphQL abstract type.",
        ),
      );
    return e;
  }
  function Vd(e) {
    if (this instanceof Vd) this.ofType = ede(e);
    else return new Vd(e);
  }
  Vd.prototype.toString = function () {
    return "[" + String(this.ofType) + "]";
  };
  Vd.prototype.toJSON = function () {
    return this.toString();
  };
  Object.defineProperty(Vd.prototype, zd.SYMBOL_TO_STRING_TAG, {
    get: function () {
      return "GraphQLList";
    },
  });
  (0, Wd.default)(Vd);
  function $d(e) {
    if (this instanceof $d) this.ofType = ode(e);
    else return new $d(e);
  }
  $d.prototype.toString = function () {
    return String(this.ofType) + "!";
  };
  $d.prototype.toJSON = function () {
    return this.toString();
  };
  Object.defineProperty($d.prototype, zd.SYMBOL_TO_STRING_TAG, {
    get: function () {
      return "GraphQLNonNull";
    },
  });
  (0, Wd.default)($d);
  function f0(e) {
    return rN(e) || Qd(e);
  }
  function pwt(e) {
    if (!f0(e))
      throw new Error(
        "Expected ".concat(
          (0, Lr.default)(e),
          " to be a GraphQL wrapping type.",
        ),
      );
    return e;
  }
  function ide(e) {
    return QV(e) && !Qd(e);
  }
  function ode(e) {
    if (!ide(e))
      throw new Error(
        "Expected ".concat(
          (0, Lr.default)(e),
          " to be a GraphQL nullable type.",
        ),
      );
    return e;
  }
  function mwt(e) {
    if (e) return Qd(e) ? e.ofType : e;
  }
  function ade(e) {
    return vm(e) || Jv(e) || ym(e) || _m(e) || Em(e) || d0(e);
  }
  function hwt(e) {
    if (!ade(e))
      throw new Error(
        "Expected ".concat((0, Lr.default)(e), " to be a GraphQL named type."),
      );
    return e;
  }
  function gwt(e) {
    if (e) {
      for (var t = e; f0(t); ) t = t.ofType;
      return t;
    }
  }
  function nN(e) {
    return typeof e == "function" ? e() : e;
  }
  function Zv(e) {
    return e && e.length > 0 ? e : void 0;
  }
  var JV = (function () {
    function e(r) {
      var n,
        i,
        o,
        a = (n = r.parseValue) !== null && n !== void 0 ? n : Qle.default;
      (this.name = r.name),
        (this.description = r.description),
        (this.specifiedByUrl = r.specifiedByUrl),
        (this.serialize =
          (i = r.serialize) !== null && i !== void 0 ? i : Qle.default),
        (this.parseValue = a),
        (this.parseLiteral =
          (o = r.parseLiteral) !== null && o !== void 0
            ? o
            : function (s, u) {
                return a((0, ZCt.valueFromASTUntyped)(s, u));
              }),
        (this.extensions = r.extensions && (0, Ac.default)(r.extensions)),
        (this.astNode = r.astNode),
        (this.extensionASTNodes = Zv(r.extensionASTNodes)),
        typeof r.name == "string" || (0, Hr.default)(0, "Must provide name."),
        r.specifiedByUrl == null ||
          typeof r.specifiedByUrl == "string" ||
          (0, Hr.default)(
            0,
            "".concat(
              this.name,
              ' must provide "specifiedByUrl" as a string, ',
            ) + "but got: ".concat((0, Lr.default)(r.specifiedByUrl), "."),
          ),
        r.serialize == null ||
          typeof r.serialize == "function" ||
          (0, Hr.default)(
            0,
            "".concat(
              this.name,
              ' must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.',
            ),
          ),
        r.parseLiteral &&
          ((typeof r.parseValue == "function" &&
            typeof r.parseLiteral == "function") ||
            (0, Hr.default)(
              0,
              "".concat(
                this.name,
                ' must provide both "parseValue" and "parseLiteral" functions.',
              ),
            ));
    }
    var t = e.prototype;
    return (
      (t.toConfig = function () {
        var n;
        return {
          name: this.name,
          description: this.description,
          specifiedByUrl: this.specifiedByUrl,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes:
            (n = this.extensionASTNodes) !== null && n !== void 0 ? n : [],
        };
      }),
      (t.toString = function () {
        return this.name;
      }),
      (t.toJSON = function () {
        return this.toString();
      }),
      Xv(e, [
        {
          key: zd.SYMBOL_TO_STRING_TAG,
          get: function () {
            return "GraphQLScalarType";
          },
        },
      ]),
      e
    );
  })();
  Me.GraphQLScalarType = JV;
  (0, Wd.default)(JV);
  var ZV = (function () {
    function e(r) {
      (this.name = r.name),
        (this.description = r.description),
        (this.isTypeOf = r.isTypeOf),
        (this.extensions = r.extensions && (0, Ac.default)(r.extensions)),
        (this.astNode = r.astNode),
        (this.extensionASTNodes = Zv(r.extensionASTNodes)),
        (this._fields = cde.bind(void 0, r)),
        (this._interfaces = sde.bind(void 0, r)),
        typeof r.name == "string" || (0, Hr.default)(0, "Must provide name."),
        r.isTypeOf == null ||
          typeof r.isTypeOf == "function" ||
          (0, Hr.default)(
            0,
            "".concat(this.name, ' must provide "isTypeOf" as a function, ') +
              "but got: ".concat((0, Lr.default)(r.isTypeOf), "."),
          );
    }
    var t = e.prototype;
    return (
      (t.getFields = function () {
        return (
          typeof this._fields == "function" && (this._fields = this._fields()),
          this._fields
        );
      }),
      (t.getInterfaces = function () {
        return (
          typeof this._interfaces == "function" &&
            (this._interfaces = this._interfaces()),
          this._interfaces
        );
      }),
      (t.toConfig = function () {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: ude(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes || [],
        };
      }),
      (t.toString = function () {
        return this.name;
      }),
      (t.toJSON = function () {
        return this.toString();
      }),
      Xv(e, [
        {
          key: zd.SYMBOL_TO_STRING_TAG,
          get: function () {
            return "GraphQLObjectType";
          },
        },
      ]),
      e
    );
  })();
  Me.GraphQLObjectType = ZV;
  (0, Wd.default)(ZV);
  function sde(e) {
    var t,
      r = (t = nN(e.interfaces)) !== null && t !== void 0 ? t : [];
    return (
      Array.isArray(r) ||
        (0, Hr.default)(
          0,
          "".concat(
            e.name,
            " interfaces must be an Array or a function which returns an Array.",
          ),
        ),
      r
    );
  }
  function cde(e) {
    var t = nN(e.fields);
    return (
      Yv(t) ||
        (0, Hr.default)(
          0,
          "".concat(
            e.name,
            " fields must be an object with field names as keys or a function which returns such an object.",
          ),
        ),
      (0, tN.default)(t, function (r, n) {
        var i;
        Yv(r) ||
          (0, Hr.default)(
            0,
            ""
              .concat(e.name, ".")
              .concat(n, " field config must be an object."),
          ),
          !("isDeprecated" in r) ||
            (0, Hr.default)(
              0,
              ""
                .concat(e.name, ".")
                .concat(
                  n,
                  ' should provide "deprecationReason" instead of "isDeprecated".',
                ),
            ),
          r.resolve == null ||
            typeof r.resolve == "function" ||
            (0, Hr.default)(
              0,
              ""
                .concat(e.name, ".")
                .concat(n, " field resolver must be a function if ") +
                "provided, but got: ".concat((0, Lr.default)(r.resolve), "."),
            );
        var o = (i = r.args) !== null && i !== void 0 ? i : {};
        Yv(o) ||
          (0, Hr.default)(
            0,
            ""
              .concat(e.name, ".")
              .concat(
                n,
                " args must be an object with argument names as keys.",
              ),
          );
        var a = (0, Jle.default)(o).map(function (s) {
          var u = s[0],
            l = s[1];
          return {
            name: u,
            description: l.description,
            type: l.type,
            defaultValue: l.defaultValue,
            deprecationReason: l.deprecationReason,
            extensions: l.extensions && (0, Ac.default)(l.extensions),
            astNode: l.astNode,
          };
        });
        return {
          name: n,
          description: r.description,
          type: r.type,
          args: a,
          resolve: r.resolve,
          subscribe: r.subscribe,
          isDeprecated: r.deprecationReason != null,
          deprecationReason: r.deprecationReason,
          extensions: r.extensions && (0, Ac.default)(r.extensions),
          astNode: r.astNode,
        };
      })
    );
  }
  function Yv(e) {
    return (0, YCt.default)(e) && !Array.isArray(e);
  }
  function ude(e) {
    return (0, tN.default)(e, function (t) {
      return {
        description: t.description,
        type: t.type,
        args: lde(t.args),
        resolve: t.resolve,
        subscribe: t.subscribe,
        deprecationReason: t.deprecationReason,
        extensions: t.extensions,
        astNode: t.astNode,
      };
    });
  }
  function lde(e) {
    return (0, Zle.default)(
      e,
      function (t) {
        return t.name;
      },
      function (t) {
        return {
          description: t.description,
          type: t.type,
          defaultValue: t.defaultValue,
          deprecationReason: t.deprecationReason,
          extensions: t.extensions,
          astNode: t.astNode,
        };
      },
    );
  }
  function vwt(e) {
    return Qd(e.type) && e.defaultValue === void 0;
  }
  var e$ = (function () {
    function e(r) {
      (this.name = r.name),
        (this.description = r.description),
        (this.resolveType = r.resolveType),
        (this.extensions = r.extensions && (0, Ac.default)(r.extensions)),
        (this.astNode = r.astNode),
        (this.extensionASTNodes = Zv(r.extensionASTNodes)),
        (this._fields = cde.bind(void 0, r)),
        (this._interfaces = sde.bind(void 0, r)),
        typeof r.name == "string" || (0, Hr.default)(0, "Must provide name."),
        r.resolveType == null ||
          typeof r.resolveType == "function" ||
          (0, Hr.default)(
            0,
            "".concat(
              this.name,
              ' must provide "resolveType" as a function, ',
            ) + "but got: ".concat((0, Lr.default)(r.resolveType), "."),
          );
    }
    var t = e.prototype;
    return (
      (t.getFields = function () {
        return (
          typeof this._fields == "function" && (this._fields = this._fields()),
          this._fields
        );
      }),
      (t.getInterfaces = function () {
        return (
          typeof this._interfaces == "function" &&
            (this._interfaces = this._interfaces()),
          this._interfaces
        );
      }),
      (t.toConfig = function () {
        var n;
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: ude(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes:
            (n = this.extensionASTNodes) !== null && n !== void 0 ? n : [],
        };
      }),
      (t.toString = function () {
        return this.name;
      }),
      (t.toJSON = function () {
        return this.toString();
      }),
      Xv(e, [
        {
          key: zd.SYMBOL_TO_STRING_TAG,
          get: function () {
            return "GraphQLInterfaceType";
          },
        },
      ]),
      e
    );
  })();
  Me.GraphQLInterfaceType = e$;
  (0, Wd.default)(e$);
  var t$ = (function () {
    function e(r) {
      (this.name = r.name),
        (this.description = r.description),
        (this.resolveType = r.resolveType),
        (this.extensions = r.extensions && (0, Ac.default)(r.extensions)),
        (this.astNode = r.astNode),
        (this.extensionASTNodes = Zv(r.extensionASTNodes)),
        (this._types = ywt.bind(void 0, r)),
        typeof r.name == "string" || (0, Hr.default)(0, "Must provide name."),
        r.resolveType == null ||
          typeof r.resolveType == "function" ||
          (0, Hr.default)(
            0,
            "".concat(
              this.name,
              ' must provide "resolveType" as a function, ',
            ) + "but got: ".concat((0, Lr.default)(r.resolveType), "."),
          );
    }
    var t = e.prototype;
    return (
      (t.getTypes = function () {
        return (
          typeof this._types == "function" && (this._types = this._types()),
          this._types
        );
      }),
      (t.toConfig = function () {
        var n;
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes:
            (n = this.extensionASTNodes) !== null && n !== void 0 ? n : [],
        };
      }),
      (t.toString = function () {
        return this.name;
      }),
      (t.toJSON = function () {
        return this.toString();
      }),
      Xv(e, [
        {
          key: zd.SYMBOL_TO_STRING_TAG,
          get: function () {
            return "GraphQLUnionType";
          },
        },
      ]),
      e
    );
  })();
  Me.GraphQLUnionType = t$;
  (0, Wd.default)(t$);
  function ywt(e) {
    var t = nN(e.types);
    return (
      Array.isArray(t) ||
        (0, Hr.default)(
          0,
          "Must provide Array of types or a function which returns such an array for Union ".concat(
            e.name,
            ".",
          ),
        ),
      t
    );
  }
  var r$ = (function () {
    function e(r) {
      (this.name = r.name),
        (this.description = r.description),
        (this.extensions = r.extensions && (0, Ac.default)(r.extensions)),
        (this.astNode = r.astNode),
        (this.extensionASTNodes = Zv(r.extensionASTNodes)),
        (this._values = _wt(this.name, r.values)),
        (this._valueLookup = new Map(
          this._values.map(function (n) {
            return [n.value, n];
          }),
        )),
        (this._nameLookup = (0, WCt.default)(this._values, function (n) {
          return n.name;
        })),
        typeof r.name == "string" || (0, Hr.default)(0, "Must provide name.");
    }
    var t = e.prototype;
    return (
      (t.getValues = function () {
        return this._values;
      }),
      (t.getValue = function (n) {
        return this._nameLookup[n];
      }),
      (t.serialize = function (n) {
        var i = this._valueLookup.get(n);
        if (i === void 0)
          throw new l0.GraphQLError(
            'Enum "'
              .concat(this.name, '" cannot represent value: ')
              .concat((0, Lr.default)(n)),
          );
        return i.name;
      }),
      (t.parseValue = function (n) {
        if (typeof n != "string") {
          var i = (0, Lr.default)(n);
          throw new l0.GraphQLError(
            'Enum "'
              .concat(this.name, '" cannot represent non-string value: ')
              .concat(i, ".") + eN(this, i),
          );
        }
        var o = this.getValue(n);
        if (o == null)
          throw new l0.GraphQLError(
            'Value "'
              .concat(n, '" does not exist in "')
              .concat(this.name, '" enum.') + eN(this, n),
          );
        return o.value;
      }),
      (t.parseLiteral = function (n, i) {
        if (n.kind !== JCt.Kind.ENUM) {
          var o = (0, Yle.print)(n);
          throw new l0.GraphQLError(
            'Enum "'
              .concat(this.name, '" cannot represent non-enum value: ')
              .concat(o, ".") + eN(this, o),
            n,
          );
        }
        var a = this.getValue(n.value);
        if (a == null) {
          var s = (0, Yle.print)(n);
          throw new l0.GraphQLError(
            'Value "'
              .concat(s, '" does not exist in "')
              .concat(this.name, '" enum.') + eN(this, s),
            n,
          );
        }
        return a.value;
      }),
      (t.toConfig = function () {
        var n,
          i = (0, Zle.default)(
            this.getValues(),
            function (o) {
              return o.name;
            },
            function (o) {
              return {
                description: o.description,
                value: o.value,
                deprecationReason: o.deprecationReason,
                extensions: o.extensions,
                astNode: o.astNode,
              };
            },
          );
        return {
          name: this.name,
          description: this.description,
          values: i,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes:
            (n = this.extensionASTNodes) !== null && n !== void 0 ? n : [],
        };
      }),
      (t.toString = function () {
        return this.name;
      }),
      (t.toJSON = function () {
        return this.toString();
      }),
      Xv(e, [
        {
          key: zd.SYMBOL_TO_STRING_TAG,
          get: function () {
            return "GraphQLEnumType";
          },
        },
      ]),
      e
    );
  })();
  Me.GraphQLEnumType = r$;
  (0, Wd.default)(r$);
  function eN(e, t) {
    var r = e.getValues().map(function (i) {
        return i.name;
      }),
      n = (0, XCt.default)(t, r);
    return (0, QCt.default)("the enum value", n);
  }
  function _wt(e, t) {
    return (
      Yv(t) ||
        (0, Hr.default)(
          0,
          "".concat(e, " values must be an object with value names as keys."),
        ),
      (0, Jle.default)(t).map(function (r) {
        var n = r[0],
          i = r[1];
        return (
          Yv(i) ||
            (0, Hr.default)(
              0,
              ""
                .concat(e, ".")
                .concat(n, ' must refer to an object with a "value" key ') +
                "representing an internal value but got: ".concat(
                  (0, Lr.default)(i),
                  ".",
                ),
            ),
          !("isDeprecated" in i) ||
            (0, Hr.default)(
              0,
              ""
                .concat(e, ".")
                .concat(
                  n,
                  ' should provide "deprecationReason" instead of "isDeprecated".',
                ),
            ),
          {
            name: n,
            description: i.description,
            value: i.value !== void 0 ? i.value : n,
            isDeprecated: i.deprecationReason != null,
            deprecationReason: i.deprecationReason,
            extensions: i.extensions && (0, Ac.default)(i.extensions),
            astNode: i.astNode,
          }
        );
      })
    );
  }
  var n$ = (function () {
    function e(r) {
      (this.name = r.name),
        (this.description = r.description),
        (this.extensions = r.extensions && (0, Ac.default)(r.extensions)),
        (this.astNode = r.astNode),
        (this.extensionASTNodes = Zv(r.extensionASTNodes)),
        (this._fields = Ewt.bind(void 0, r)),
        typeof r.name == "string" || (0, Hr.default)(0, "Must provide name.");
    }
    var t = e.prototype;
    return (
      (t.getFields = function () {
        return (
          typeof this._fields == "function" && (this._fields = this._fields()),
          this._fields
        );
      }),
      (t.toConfig = function () {
        var n,
          i = (0, tN.default)(this.getFields(), function (o) {
            return {
              description: o.description,
              type: o.type,
              defaultValue: o.defaultValue,
              deprecationReason: o.deprecationReason,
              extensions: o.extensions,
              astNode: o.astNode,
            };
          });
        return {
          name: this.name,
          description: this.description,
          fields: i,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes:
            (n = this.extensionASTNodes) !== null && n !== void 0 ? n : [],
        };
      }),
      (t.toString = function () {
        return this.name;
      }),
      (t.toJSON = function () {
        return this.toString();
      }),
      Xv(e, [
        {
          key: zd.SYMBOL_TO_STRING_TAG,
          get: function () {
            return "GraphQLInputObjectType";
          },
        },
      ]),
      e
    );
  })();
  Me.GraphQLInputObjectType = n$;
  (0, Wd.default)(n$);
  function Ewt(e) {
    var t = nN(e.fields);
    return (
      Yv(t) ||
        (0, Hr.default)(
          0,
          "".concat(
            e.name,
            " fields must be an object with field names as keys or a function which returns such an object.",
          ),
        ),
      (0, tN.default)(t, function (r, n) {
        return (
          !("resolve" in r) ||
            (0, Hr.default)(
              0,
              ""
                .concat(e.name, ".")
                .concat(
                  n,
                  " field has a resolve property, but Input Types cannot define resolvers.",
                ),
            ),
          {
            name: n,
            description: r.description,
            type: r.type,
            defaultValue: r.defaultValue,
            deprecationReason: r.deprecationReason,
            extensions: r.extensions && (0, Ac.default)(r.extensions),
            astNode: r.astNode,
          }
        );
      })
    );
  }
  function bwt(e) {
    return Qd(e.type) && e.defaultValue === void 0;
  }
});
var m0 = g((p0) => {
  "use strict";
  c();
  Object.defineProperty(p0, "__esModule", { value: !0 });
  p0.isEqualType = i$;
  p0.isTypeSubTypeOf = iN;
  p0.doTypesOverlap = Swt;
  var ji = It();
  function i$(e, t) {
    return e === t
      ? !0
      : ((0, ji.isNonNullType)(e) && (0, ji.isNonNullType)(t)) ||
          ((0, ji.isListType)(e) && (0, ji.isListType)(t))
        ? i$(e.ofType, t.ofType)
        : !1;
  }
  function iN(e, t, r) {
    return t === r
      ? !0
      : (0, ji.isNonNullType)(r)
        ? (0, ji.isNonNullType)(t)
          ? iN(e, t.ofType, r.ofType)
          : !1
        : (0, ji.isNonNullType)(t)
          ? iN(e, t.ofType, r)
          : (0, ji.isListType)(r)
            ? (0, ji.isListType)(t)
              ? iN(e, t.ofType, r.ofType)
              : !1
            : (0, ji.isListType)(t)
              ? !1
              : (0, ji.isAbstractType)(r) &&
                ((0, ji.isInterfaceType)(t) || (0, ji.isObjectType)(t)) &&
                e.isSubType(r, t);
  }
  function Swt(e, t, r) {
    return t === r
      ? !0
      : (0, ji.isAbstractType)(t)
        ? (0, ji.isAbstractType)(r)
          ? e.getPossibleTypes(t).some(function (n) {
              return e.isSubType(r, n);
            })
          : e.isSubType(t, r)
        : (0, ji.isAbstractType)(r)
          ? e.isSubType(r, t)
          : !1;
  }
});
var o$ = g((oN) => {
  "use strict";
  c();
  Object.defineProperty(oN, "__esModule", { value: !0 });
  oN.default = void 0;
  var Cwt = Oc(),
    wwt =
      Array.from ||
      function (e, t, r) {
        if (e == null)
          throw new TypeError(
            "Array.from requires an array-like object - not null or undefined",
          );
        var n = e[Cwt.SYMBOL_ITERATOR];
        if (typeof n == "function") {
          for (var i = n.call(e), o = [], a, s = 0; !(a = i.next()).done; ++s)
            if ((o.push(t.call(r, a.value, s)), s > 9999999))
              throw new TypeError("Near-infinite iteration.");
          return o;
        }
        var u = e.length;
        if (typeof u == "number" && u >= 0 && u % 1 === 0) {
          for (var l = [], d = 0; d < u; ++d)
            Object.prototype.hasOwnProperty.call(e, d) &&
              l.push(t.call(r, e[d], d));
          return l;
        }
        return [];
      },
    Owt = wwt;
  oN.default = Owt;
});
var a$ = g((aN) => {
  "use strict";
  c();
  Object.defineProperty(aN, "__esModule", { value: !0 });
  aN.default = void 0;
  var Twt =
      Number.isFinite ||
      function (e) {
        return typeof e == "number" && isFinite(e);
      },
    Awt = Twt;
  aN.default = Awt;
});
var cN = g((s$) => {
  "use strict";
  c();
  Object.defineProperty(s$, "__esModule", { value: !0 });
  s$.default = Rwt;
  var Pwt = Oc();
  function sN(e) {
    "@babel/helpers - typeof";
    return (
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? (sN = function (r) {
            return typeof r;
          })
        : (sN = function (r) {
            return r &&
              typeof Symbol == "function" &&
              r.constructor === Symbol &&
              r !== Symbol.prototype
              ? "symbol"
              : typeof r;
          }),
      sN(e)
    );
  }
  function Rwt(e) {
    var t =
      arguments.length > 1 && arguments[1] !== void 0
        ? arguments[1]
        : function (d) {
            return d;
          };
    if (e == null || sN(e) !== "object") return null;
    if (Array.isArray(e)) return e.map(t);
    var r = e[Pwt.SYMBOL_ITERATOR];
    if (typeof r == "function") {
      for (var n = r.call(e), i = [], o, a = 0; !(o = n.next()).done; ++a)
        i.push(t(o.value, a));
      return i;
    }
    var s = e.length;
    if (typeof s == "number" && s >= 0 && s % 1 === 0) {
      for (var u = [], l = 0; l < s; ++l) {
        if (!Object.prototype.hasOwnProperty.call(e, l)) return null;
        u.push(t(e[String(l)], l));
      }
      return u;
    }
    return null;
  }
});
var dde = g((uN) => {
  "use strict";
  c();
  Object.defineProperty(uN, "__esModule", { value: !0 });
  uN.default = void 0;
  var Iwt =
      Number.isInteger ||
      function (e) {
        return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
      },
    xwt = Iwt;
  uN.default = xwt;
});
var Pc = g((Zi) => {
  "use strict";
  c();
  Object.defineProperty(Zi, "__esModule", { value: !0 });
  Zi.isSpecifiedScalarType = Hwt;
  Zi.specifiedScalarTypes =
    Zi.GraphQLID =
    Zi.GraphQLBoolean =
    Zi.GraphQLString =
    Zi.GraphQLFloat =
    Zi.GraphQLInt =
      void 0;
  var lN = fN(a$()),
    dN = fN(dde()),
    Ls = fN(Lt()),
    fde = fN(wc()),
    bm = lr(),
    h0 = ta(),
    Yn = Ue(),
    g0 = It();
  function fN(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var c$ = 2147483647,
    u$ = -2147483648;
  function Nwt(e) {
    var t = v0(e);
    if (typeof t == "boolean") return t ? 1 : 0;
    var r = t;
    if (
      (typeof t == "string" && t !== "" && (r = Number(t)), !(0, dN.default)(r))
    )
      throw new Yn.GraphQLError(
        "Int cannot represent non-integer value: ".concat((0, Ls.default)(t)),
      );
    if (r > c$ || r < u$)
      throw new Yn.GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " +
          (0, Ls.default)(t),
      );
    return r;
  }
  function kwt(e) {
    if (!(0, dN.default)(e))
      throw new Yn.GraphQLError(
        "Int cannot represent non-integer value: ".concat((0, Ls.default)(e)),
      );
    if (e > c$ || e < u$)
      throw new Yn.GraphQLError(
        "Int cannot represent non 32-bit signed integer value: ".concat(e),
      );
    return e;
  }
  var pde = new g0.GraphQLScalarType({
    name: "Int",
    description:
      "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
    serialize: Nwt,
    parseValue: kwt,
    parseLiteral: function (t) {
      if (t.kind !== bm.Kind.INT)
        throw new Yn.GraphQLError(
          "Int cannot represent non-integer value: ".concat((0, h0.print)(t)),
          t,
        );
      var r = parseInt(t.value, 10);
      if (r > c$ || r < u$)
        throw new Yn.GraphQLError(
          "Int cannot represent non 32-bit signed integer value: ".concat(
            t.value,
          ),
          t,
        );
      return r;
    },
  });
  Zi.GraphQLInt = pde;
  function Dwt(e) {
    var t = v0(e);
    if (typeof t == "boolean") return t ? 1 : 0;
    var r = t;
    if (
      (typeof t == "string" && t !== "" && (r = Number(t)), !(0, lN.default)(r))
    )
      throw new Yn.GraphQLError(
        "Float cannot represent non numeric value: ".concat((0, Ls.default)(t)),
      );
    return r;
  }
  function Lwt(e) {
    if (!(0, lN.default)(e))
      throw new Yn.GraphQLError(
        "Float cannot represent non numeric value: ".concat((0, Ls.default)(e)),
      );
    return e;
  }
  var mde = new g0.GraphQLScalarType({
    name: "Float",
    description:
      "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
    serialize: Dwt,
    parseValue: Lwt,
    parseLiteral: function (t) {
      if (t.kind !== bm.Kind.FLOAT && t.kind !== bm.Kind.INT)
        throw new Yn.GraphQLError(
          "Float cannot represent non numeric value: ".concat((0, h0.print)(t)),
          t,
        );
      return parseFloat(t.value);
    },
  });
  Zi.GraphQLFloat = mde;
  function v0(e) {
    if ((0, fde.default)(e)) {
      if (typeof e.valueOf == "function") {
        var t = e.valueOf();
        if (!(0, fde.default)(t)) return t;
      }
      if (typeof e.toJSON == "function") return e.toJSON();
    }
    return e;
  }
  function Mwt(e) {
    var t = v0(e);
    if (typeof t == "string") return t;
    if (typeof t == "boolean") return t ? "true" : "false";
    if ((0, lN.default)(t)) return t.toString();
    throw new Yn.GraphQLError(
      "String cannot represent value: ".concat((0, Ls.default)(e)),
    );
  }
  function qwt(e) {
    if (typeof e != "string")
      throw new Yn.GraphQLError(
        "String cannot represent a non string value: ".concat(
          (0, Ls.default)(e),
        ),
      );
    return e;
  }
  var hde = new g0.GraphQLScalarType({
    name: "String",
    description:
      "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
    serialize: Mwt,
    parseValue: qwt,
    parseLiteral: function (t) {
      if (t.kind !== bm.Kind.STRING)
        throw new Yn.GraphQLError(
          "String cannot represent a non string value: ".concat(
            (0, h0.print)(t),
          ),
          t,
        );
      return t.value;
    },
  });
  Zi.GraphQLString = hde;
  function jwt(e) {
    var t = v0(e);
    if (typeof t == "boolean") return t;
    if ((0, lN.default)(t)) return t !== 0;
    throw new Yn.GraphQLError(
      "Boolean cannot represent a non boolean value: ".concat(
        (0, Ls.default)(t),
      ),
    );
  }
  function Fwt(e) {
    if (typeof e != "boolean")
      throw new Yn.GraphQLError(
        "Boolean cannot represent a non boolean value: ".concat(
          (0, Ls.default)(e),
        ),
      );
    return e;
  }
  var gde = new g0.GraphQLScalarType({
    name: "Boolean",
    description: "The `Boolean` scalar type represents `true` or `false`.",
    serialize: jwt,
    parseValue: Fwt,
    parseLiteral: function (t) {
      if (t.kind !== bm.Kind.BOOLEAN)
        throw new Yn.GraphQLError(
          "Boolean cannot represent a non boolean value: ".concat(
            (0, h0.print)(t),
          ),
          t,
        );
      return t.value;
    },
  });
  Zi.GraphQLBoolean = gde;
  function Bwt(e) {
    var t = v0(e);
    if (typeof t == "string") return t;
    if ((0, dN.default)(t)) return String(t);
    throw new Yn.GraphQLError(
      "ID cannot represent value: ".concat((0, Ls.default)(e)),
    );
  }
  function Uwt(e) {
    if (typeof e == "string") return e;
    if ((0, dN.default)(e)) return e.toString();
    throw new Yn.GraphQLError(
      "ID cannot represent value: ".concat((0, Ls.default)(e)),
    );
  }
  var vde = new g0.GraphQLScalarType({
    name: "ID",
    description:
      'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
    serialize: Bwt,
    parseValue: Uwt,
    parseLiteral: function (t) {
      if (t.kind !== bm.Kind.STRING && t.kind !== bm.Kind.INT)
        throw new Yn.GraphQLError(
          "ID cannot represent a non-string and non-integer value: " +
            (0, h0.print)(t),
          t,
        );
      return t.value;
    },
  });
  Zi.GraphQLID = vde;
  var yde = Object.freeze([hde, pde, mde, gde, vde]);
  Zi.specifiedScalarTypes = yde;
  function Hwt(e) {
    return yde.some(function (t) {
      var r = t.name;
      return e.name === r;
    });
  }
});
var E0 = g((l$) => {
  "use strict";
  c();
  Object.defineProperty(l$, "__esModule", { value: !0 });
  l$.astFromValue = _0;
  var Gwt = ey(a$()),
    Vwt = ey(ea()),
    _de = ey(Lt()),
    $wt = ey(vi()),
    zwt = ey(wc()),
    Kwt = ey(cN()),
    Aa = lr(),
    Wwt = Pc(),
    y0 = It();
  function ey(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function _0(e, t) {
    if ((0, y0.isNonNullType)(t)) {
      var r = _0(e, t.ofType);
      return r?.kind === Aa.Kind.NULL ? null : r;
    }
    if (e === null) return { kind: Aa.Kind.NULL };
    if (e === void 0) return null;
    if ((0, y0.isListType)(t)) {
      var n = t.ofType,
        i = (0, Kwt.default)(e);
      if (i != null) {
        for (var o = [], a = 0; a < i.length; a++) {
          var s = i[a],
            u = _0(s, n);
          u != null && o.push(u);
        }
        return { kind: Aa.Kind.LIST, values: o };
      }
      return _0(e, n);
    }
    if ((0, y0.isInputObjectType)(t)) {
      if (!(0, zwt.default)(e)) return null;
      for (
        var l = [], d = 0, f = (0, Vwt.default)(t.getFields());
        d < f.length;
        d++
      ) {
        var m = f[d],
          h = _0(e[m.name], m.type);
        h &&
          l.push({
            kind: Aa.Kind.OBJECT_FIELD,
            name: { kind: Aa.Kind.NAME, value: m.name },
            value: h,
          });
      }
      return { kind: Aa.Kind.OBJECT, fields: l };
    }
    if ((0, y0.isLeafType)(t)) {
      var y = t.serialize(e);
      if (y == null) return null;
      if (typeof y == "boolean") return { kind: Aa.Kind.BOOLEAN, value: y };
      if (typeof y == "number" && (0, Gwt.default)(y)) {
        var _ = String(y);
        return Ede.test(_)
          ? { kind: Aa.Kind.INT, value: _ }
          : { kind: Aa.Kind.FLOAT, value: _ };
      }
      if (typeof y == "string")
        return (0, y0.isEnumType)(t)
          ? { kind: Aa.Kind.ENUM, value: y }
          : t === Wwt.GraphQLID && Ede.test(y)
            ? { kind: Aa.Kind.INT, value: y }
            : { kind: Aa.Kind.STRING, value: y };
      throw new TypeError(
        "Cannot convert value to AST: ".concat((0, _de.default)(y), "."),
      );
    }
    (0, $wt.default)(0, "Unexpected input type: " + (0, _de.default)(t));
  }
  var Ede = /^-?(?:0|[1-9][0-9]*)$/;
});
var Ra = g((Zt) => {
  "use strict";
  c();
  Object.defineProperty(Zt, "__esModule", { value: !0 });
  Zt.isIntrospectionType = rOt;
  Zt.introspectionTypes =
    Zt.TypeNameMetaFieldDef =
    Zt.TypeMetaFieldDef =
    Zt.SchemaMetaFieldDef =
    Zt.__TypeKind =
    Zt.TypeKind =
    Zt.__EnumValue =
    Zt.__InputValue =
    Zt.__Field =
    Zt.__Type =
    Zt.__DirectiveLocation =
    Zt.__Directive =
    Zt.__Schema =
      void 0;
  var d$ = f$(ea()),
    Qwt = f$(Lt()),
    Ywt = f$(vi()),
    Xwt = ta(),
    Bn = Vv(),
    Jwt = E0(),
    dr = Pc(),
    Re = It();
  function f$(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var p$ = new Re.GraphQLObjectType({
    name: "__Schema",
    description:
      "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
    fields: function () {
      return {
        description: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.description;
          },
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new Re.GraphQLNonNull(
            new Re.GraphQLList(new Re.GraphQLNonNull(Pa)),
          ),
          resolve: function (r) {
            return (0, d$.default)(r.getTypeMap());
          },
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new Re.GraphQLNonNull(Pa),
          resolve: function (r) {
            return r.getQueryType();
          },
        },
        mutationType: {
          description:
            "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: Pa,
          resolve: function (r) {
            return r.getMutationType();
          },
        },
        subscriptionType: {
          description:
            "If this server support subscription, the type that subscription operations will be rooted at.",
          type: Pa,
          resolve: function (r) {
            return r.getSubscriptionType();
          },
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new Re.GraphQLNonNull(
            new Re.GraphQLList(new Re.GraphQLNonNull(m$)),
          ),
          resolve: function (r) {
            return r.getDirectives();
          },
        },
      };
    },
  });
  Zt.__Schema = p$;
  var m$ = new Re.GraphQLObjectType({
    name: "__Directive",
    description: `A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.`,
    fields: function () {
      return {
        name: {
          type: new Re.GraphQLNonNull(dr.GraphQLString),
          resolve: function (r) {
            return r.name;
          },
        },
        description: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.description;
          },
        },
        isRepeatable: {
          type: new Re.GraphQLNonNull(dr.GraphQLBoolean),
          resolve: function (r) {
            return r.isRepeatable;
          },
        },
        locations: {
          type: new Re.GraphQLNonNull(
            new Re.GraphQLList(new Re.GraphQLNonNull(h$)),
          ),
          resolve: function (r) {
            return r.locations;
          },
        },
        args: {
          type: new Re.GraphQLNonNull(
            new Re.GraphQLList(new Re.GraphQLNonNull(b0)),
          ),
          args: {
            includeDeprecated: { type: dr.GraphQLBoolean, defaultValue: !1 },
          },
          resolve: function (r, n) {
            var i = n.includeDeprecated;
            return i
              ? r.args
              : r.args.filter(function (o) {
                  return o.deprecationReason == null;
                });
          },
        },
      };
    },
  });
  Zt.__Directive = m$;
  var h$ = new Re.GraphQLEnumType({
    name: "__DirectiveLocation",
    description:
      "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
    values: {
      QUERY: {
        value: Bn.DirectiveLocation.QUERY,
        description: "Location adjacent to a query operation.",
      },
      MUTATION: {
        value: Bn.DirectiveLocation.MUTATION,
        description: "Location adjacent to a mutation operation.",
      },
      SUBSCRIPTION: {
        value: Bn.DirectiveLocation.SUBSCRIPTION,
        description: "Location adjacent to a subscription operation.",
      },
      FIELD: {
        value: Bn.DirectiveLocation.FIELD,
        description: "Location adjacent to a field.",
      },
      FRAGMENT_DEFINITION: {
        value: Bn.DirectiveLocation.FRAGMENT_DEFINITION,
        description: "Location adjacent to a fragment definition.",
      },
      FRAGMENT_SPREAD: {
        value: Bn.DirectiveLocation.FRAGMENT_SPREAD,
        description: "Location adjacent to a fragment spread.",
      },
      INLINE_FRAGMENT: {
        value: Bn.DirectiveLocation.INLINE_FRAGMENT,
        description: "Location adjacent to an inline fragment.",
      },
      VARIABLE_DEFINITION: {
        value: Bn.DirectiveLocation.VARIABLE_DEFINITION,
        description: "Location adjacent to a variable definition.",
      },
      SCHEMA: {
        value: Bn.DirectiveLocation.SCHEMA,
        description: "Location adjacent to a schema definition.",
      },
      SCALAR: {
        value: Bn.DirectiveLocation.SCALAR,
        description: "Location adjacent to a scalar definition.",
      },
      OBJECT: {
        value: Bn.DirectiveLocation.OBJECT,
        description: "Location adjacent to an object type definition.",
      },
      FIELD_DEFINITION: {
        value: Bn.DirectiveLocation.FIELD_DEFINITION,
        description: "Location adjacent to a field definition.",
      },
      ARGUMENT_DEFINITION: {
        value: Bn.DirectiveLocation.ARGUMENT_DEFINITION,
        description: "Location adjacent to an argument definition.",
      },
      INTERFACE: {
        value: Bn.DirectiveLocation.INTERFACE,
        description: "Location adjacent to an interface definition.",
      },
      UNION: {
        value: Bn.DirectiveLocation.UNION,
        description: "Location adjacent to a union definition.",
      },
      ENUM: {
        value: Bn.DirectiveLocation.ENUM,
        description: "Location adjacent to an enum definition.",
      },
      ENUM_VALUE: {
        value: Bn.DirectiveLocation.ENUM_VALUE,
        description: "Location adjacent to an enum value definition.",
      },
      INPUT_OBJECT: {
        value: Bn.DirectiveLocation.INPUT_OBJECT,
        description: "Location adjacent to an input object type definition.",
      },
      INPUT_FIELD_DEFINITION: {
        value: Bn.DirectiveLocation.INPUT_FIELD_DEFINITION,
        description: "Location adjacent to an input object field definition.",
      },
    },
  });
  Zt.__DirectiveLocation = h$;
  var Pa = new Re.GraphQLObjectType({
    name: "__Type",
    description:
      "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByUrl`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
    fields: function () {
      return {
        kind: {
          type: new Re.GraphQLNonNull(y$),
          resolve: function (r) {
            if ((0, Re.isScalarType)(r)) return yi.SCALAR;
            if ((0, Re.isObjectType)(r)) return yi.OBJECT;
            if ((0, Re.isInterfaceType)(r)) return yi.INTERFACE;
            if ((0, Re.isUnionType)(r)) return yi.UNION;
            if ((0, Re.isEnumType)(r)) return yi.ENUM;
            if ((0, Re.isInputObjectType)(r)) return yi.INPUT_OBJECT;
            if ((0, Re.isListType)(r)) return yi.LIST;
            if ((0, Re.isNonNullType)(r)) return yi.NON_NULL;
            (0, Ywt.default)(
              0,
              'Unexpected type: "'.concat((0, Qwt.default)(r), '".'),
            );
          },
        },
        name: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.name !== void 0 ? r.name : void 0;
          },
        },
        description: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.description !== void 0 ? r.description : void 0;
          },
        },
        specifiedByUrl: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.specifiedByUrl !== void 0 ? r.specifiedByUrl : void 0;
          },
        },
        fields: {
          type: new Re.GraphQLList(new Re.GraphQLNonNull(g$)),
          args: {
            includeDeprecated: { type: dr.GraphQLBoolean, defaultValue: !1 },
          },
          resolve: function (r, n) {
            var i = n.includeDeprecated;
            if ((0, Re.isObjectType)(r) || (0, Re.isInterfaceType)(r)) {
              var o = (0, d$.default)(r.getFields());
              return i
                ? o
                : o.filter(function (a) {
                    return a.deprecationReason == null;
                  });
            }
          },
        },
        interfaces: {
          type: new Re.GraphQLList(new Re.GraphQLNonNull(Pa)),
          resolve: function (r) {
            if ((0, Re.isObjectType)(r) || (0, Re.isInterfaceType)(r))
              return r.getInterfaces();
          },
        },
        possibleTypes: {
          type: new Re.GraphQLList(new Re.GraphQLNonNull(Pa)),
          resolve: function (r, n, i, o) {
            var a = o.schema;
            if ((0, Re.isAbstractType)(r)) return a.getPossibleTypes(r);
          },
        },
        enumValues: {
          type: new Re.GraphQLList(new Re.GraphQLNonNull(v$)),
          args: {
            includeDeprecated: { type: dr.GraphQLBoolean, defaultValue: !1 },
          },
          resolve: function (r, n) {
            var i = n.includeDeprecated;
            if ((0, Re.isEnumType)(r)) {
              var o = r.getValues();
              return i
                ? o
                : o.filter(function (a) {
                    return a.deprecationReason == null;
                  });
            }
          },
        },
        inputFields: {
          type: new Re.GraphQLList(new Re.GraphQLNonNull(b0)),
          args: {
            includeDeprecated: { type: dr.GraphQLBoolean, defaultValue: !1 },
          },
          resolve: function (r, n) {
            var i = n.includeDeprecated;
            if ((0, Re.isInputObjectType)(r)) {
              var o = (0, d$.default)(r.getFields());
              return i
                ? o
                : o.filter(function (a) {
                    return a.deprecationReason == null;
                  });
            }
          },
        },
        ofType: {
          type: Pa,
          resolve: function (r) {
            return r.ofType !== void 0 ? r.ofType : void 0;
          },
        },
      };
    },
  });
  Zt.__Type = Pa;
  var g$ = new Re.GraphQLObjectType({
    name: "__Field",
    description:
      "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
    fields: function () {
      return {
        name: {
          type: new Re.GraphQLNonNull(dr.GraphQLString),
          resolve: function (r) {
            return r.name;
          },
        },
        description: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.description;
          },
        },
        args: {
          type: new Re.GraphQLNonNull(
            new Re.GraphQLList(new Re.GraphQLNonNull(b0)),
          ),
          args: {
            includeDeprecated: { type: dr.GraphQLBoolean, defaultValue: !1 },
          },
          resolve: function (r, n) {
            var i = n.includeDeprecated;
            return i
              ? r.args
              : r.args.filter(function (o) {
                  return o.deprecationReason == null;
                });
          },
        },
        type: {
          type: new Re.GraphQLNonNull(Pa),
          resolve: function (r) {
            return r.type;
          },
        },
        isDeprecated: {
          type: new Re.GraphQLNonNull(dr.GraphQLBoolean),
          resolve: function (r) {
            return r.deprecationReason != null;
          },
        },
        deprecationReason: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.deprecationReason;
          },
        },
      };
    },
  });
  Zt.__Field = g$;
  var b0 = new Re.GraphQLObjectType({
    name: "__InputValue",
    description:
      "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
    fields: function () {
      return {
        name: {
          type: new Re.GraphQLNonNull(dr.GraphQLString),
          resolve: function (r) {
            return r.name;
          },
        },
        description: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.description;
          },
        },
        type: {
          type: new Re.GraphQLNonNull(Pa),
          resolve: function (r) {
            return r.type;
          },
        },
        defaultValue: {
          type: dr.GraphQLString,
          description:
            "A GraphQL-formatted string representing the default value for this input value.",
          resolve: function (r) {
            var n = r.type,
              i = r.defaultValue,
              o = (0, Jwt.astFromValue)(i, n);
            return o ? (0, Xwt.print)(o) : null;
          },
        },
        isDeprecated: {
          type: new Re.GraphQLNonNull(dr.GraphQLBoolean),
          resolve: function (r) {
            return r.deprecationReason != null;
          },
        },
        deprecationReason: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.deprecationReason;
          },
        },
      };
    },
  });
  Zt.__InputValue = b0;
  var v$ = new Re.GraphQLObjectType({
    name: "__EnumValue",
    description:
      "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
    fields: function () {
      return {
        name: {
          type: new Re.GraphQLNonNull(dr.GraphQLString),
          resolve: function (r) {
            return r.name;
          },
        },
        description: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.description;
          },
        },
        isDeprecated: {
          type: new Re.GraphQLNonNull(dr.GraphQLBoolean),
          resolve: function (r) {
            return r.deprecationReason != null;
          },
        },
        deprecationReason: {
          type: dr.GraphQLString,
          resolve: function (r) {
            return r.deprecationReason;
          },
        },
      };
    },
  });
  Zt.__EnumValue = v$;
  var yi = Object.freeze({
    SCALAR: "SCALAR",
    OBJECT: "OBJECT",
    INTERFACE: "INTERFACE",
    UNION: "UNION",
    ENUM: "ENUM",
    INPUT_OBJECT: "INPUT_OBJECT",
    LIST: "LIST",
    NON_NULL: "NON_NULL",
  });
  Zt.TypeKind = yi;
  var y$ = new Re.GraphQLEnumType({
    name: "__TypeKind",
    description: "An enum describing what kind of type a given `__Type` is.",
    values: {
      SCALAR: {
        value: yi.SCALAR,
        description: "Indicates this type is a scalar.",
      },
      OBJECT: {
        value: yi.OBJECT,
        description:
          "Indicates this type is an object. `fields` and `interfaces` are valid fields.",
      },
      INTERFACE: {
        value: yi.INTERFACE,
        description:
          "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields.",
      },
      UNION: {
        value: yi.UNION,
        description:
          "Indicates this type is a union. `possibleTypes` is a valid field.",
      },
      ENUM: {
        value: yi.ENUM,
        description:
          "Indicates this type is an enum. `enumValues` is a valid field.",
      },
      INPUT_OBJECT: {
        value: yi.INPUT_OBJECT,
        description:
          "Indicates this type is an input object. `inputFields` is a valid field.",
      },
      LIST: {
        value: yi.LIST,
        description:
          "Indicates this type is a list. `ofType` is a valid field.",
      },
      NON_NULL: {
        value: yi.NON_NULL,
        description:
          "Indicates this type is a non-null. `ofType` is a valid field.",
      },
    },
  });
  Zt.__TypeKind = y$;
  var Zwt = {
    name: "__schema",
    type: new Re.GraphQLNonNull(p$),
    description: "Access the current type schema of this server.",
    args: [],
    resolve: function (t, r, n, i) {
      var o = i.schema;
      return o;
    },
    isDeprecated: !1,
    deprecationReason: void 0,
    extensions: void 0,
    astNode: void 0,
  };
  Zt.SchemaMetaFieldDef = Zwt;
  var eOt = {
    name: "__type",
    type: Pa,
    description: "Request the type information of a single type.",
    args: [
      {
        name: "name",
        description: void 0,
        type: new Re.GraphQLNonNull(dr.GraphQLString),
        defaultValue: void 0,
        deprecationReason: void 0,
        extensions: void 0,
        astNode: void 0,
      },
    ],
    resolve: function (t, r, n, i) {
      var o = r.name,
        a = i.schema;
      return a.getType(o);
    },
    isDeprecated: !1,
    deprecationReason: void 0,
    extensions: void 0,
    astNode: void 0,
  };
  Zt.TypeMetaFieldDef = eOt;
  var tOt = {
    name: "__typename",
    type: new Re.GraphQLNonNull(dr.GraphQLString),
    description: "The name of the current Object type at runtime.",
    args: [],
    resolve: function (t, r, n, i) {
      var o = i.parentType;
      return o.name;
    },
    isDeprecated: !1,
    deprecationReason: void 0,
    extensions: void 0,
    astNode: void 0,
  };
  Zt.TypeNameMetaFieldDef = tOt;
  var bde = Object.freeze([p$, m$, h$, Pa, g$, b0, v$, y$]);
  Zt.introspectionTypes = bde;
  function rOt(e) {
    return bde.some(function (t) {
      var r = t.name;
      return e.name === r;
    });
  }
});
var bo = g((Un) => {
  "use strict";
  c();
  Object.defineProperty(Un, "__esModule", { value: !0 });
  Un.isDirective = wde;
  Un.assertDirective = lOt;
  Un.isSpecifiedDirective = dOt;
  Un.specifiedDirectives =
    Un.GraphQLSpecifiedByDirective =
    Un.GraphQLDeprecatedDirective =
    Un.DEFAULT_DEPRECATION_REASON =
    Un.GraphQLSkipDirective =
    Un.GraphQLIncludeDirective =
    Un.GraphQLDirective =
      void 0;
  var nOt = Sm(Qv()),
    iOt = Oc(),
    oOt = Sm(Lt()),
    Sde = Sm(Xx()),
    _$ = Sm(Ta()),
    aOt = Sm(n0()),
    sOt = Sm(wc()),
    cOt = Sm(Lx()),
    Ms = Vv(),
    pN = Pc(),
    mN = It();
  function Sm(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Cde(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      (n.enumerable = n.enumerable || !1),
        (n.configurable = !0),
        "value" in n && (n.writable = !0),
        Object.defineProperty(e, n.key, n);
    }
  }
  function uOt(e, t, r) {
    return t && Cde(e.prototype, t), r && Cde(e, r), e;
  }
  function wde(e) {
    return (0, aOt.default)(e, Cm);
  }
  function lOt(e) {
    if (!wde(e))
      throw new Error(
        "Expected ".concat((0, oOt.default)(e), " to be a GraphQL directive."),
      );
    return e;
  }
  var Cm = (function () {
    function e(r) {
      var n, i;
      (this.name = r.name),
        (this.description = r.description),
        (this.locations = r.locations),
        (this.isRepeatable =
          (n = r.isRepeatable) !== null && n !== void 0 ? n : !1),
        (this.extensions = r.extensions && (0, Sde.default)(r.extensions)),
        (this.astNode = r.astNode),
        r.name || (0, _$.default)(0, "Directive must be named."),
        Array.isArray(r.locations) ||
          (0, _$.default)(
            0,
            "@".concat(r.name, " locations must be an Array."),
          );
      var o = (i = r.args) !== null && i !== void 0 ? i : {};
      ((0, sOt.default)(o) && !Array.isArray(o)) ||
        (0, _$.default)(
          0,
          "@".concat(
            r.name,
            " args must be an object with argument names as keys.",
          ),
        ),
        (this.args = (0, nOt.default)(o).map(function (a) {
          var s = a[0],
            u = a[1];
          return {
            name: s,
            description: u.description,
            type: u.type,
            defaultValue: u.defaultValue,
            deprecationReason: u.deprecationReason,
            extensions: u.extensions && (0, Sde.default)(u.extensions),
            astNode: u.astNode,
          };
        }));
    }
    var t = e.prototype;
    return (
      (t.toConfig = function () {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: (0, mN.argsToArgsConfig)(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode,
        };
      }),
      (t.toString = function () {
        return "@" + this.name;
      }),
      (t.toJSON = function () {
        return this.toString();
      }),
      uOt(e, [
        {
          key: iOt.SYMBOL_TO_STRING_TAG,
          get: function () {
            return "GraphQLDirective";
          },
        },
      ]),
      e
    );
  })();
  Un.GraphQLDirective = Cm;
  (0, cOt.default)(Cm);
  var Ode = new Cm({
    name: "include",
    description:
      "Directs the executor to include this field or fragment only when the `if` argument is true.",
    locations: [
      Ms.DirectiveLocation.FIELD,
      Ms.DirectiveLocation.FRAGMENT_SPREAD,
      Ms.DirectiveLocation.INLINE_FRAGMENT,
    ],
    args: {
      if: {
        type: new mN.GraphQLNonNull(pN.GraphQLBoolean),
        description: "Included when true.",
      },
    },
  });
  Un.GraphQLIncludeDirective = Ode;
  var Tde = new Cm({
    name: "skip",
    description:
      "Directs the executor to skip this field or fragment when the `if` argument is true.",
    locations: [
      Ms.DirectiveLocation.FIELD,
      Ms.DirectiveLocation.FRAGMENT_SPREAD,
      Ms.DirectiveLocation.INLINE_FRAGMENT,
    ],
    args: {
      if: {
        type: new mN.GraphQLNonNull(pN.GraphQLBoolean),
        description: "Skipped when true.",
      },
    },
  });
  Un.GraphQLSkipDirective = Tde;
  var Ade = "No longer supported";
  Un.DEFAULT_DEPRECATION_REASON = Ade;
  var Pde = new Cm({
    name: "deprecated",
    description: "Marks an element of a GraphQL schema as no longer supported.",
    locations: [
      Ms.DirectiveLocation.FIELD_DEFINITION,
      Ms.DirectiveLocation.ARGUMENT_DEFINITION,
      Ms.DirectiveLocation.INPUT_FIELD_DEFINITION,
      Ms.DirectiveLocation.ENUM_VALUE,
    ],
    args: {
      reason: {
        type: pN.GraphQLString,
        description:
          "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
        defaultValue: Ade,
      },
    },
  });
  Un.GraphQLDeprecatedDirective = Pde;
  var Rde = new Cm({
    name: "specifiedBy",
    description: "Exposes a URL that specifies the behaviour of this scalar.",
    locations: [Ms.DirectiveLocation.SCALAR],
    args: {
      url: {
        type: new mN.GraphQLNonNull(pN.GraphQLString),
        description: "The URL that specifies the behaviour of this scalar.",
      },
    },
  });
  Un.GraphQLSpecifiedByDirective = Rde;
  var Ide = Object.freeze([Ode, Tde, Pde, Rde]);
  Un.specifiedDirectives = Ide;
  function dOt(e) {
    return Ide.some(function (t) {
      var r = t.name;
      return r === e.name;
    });
  }
});
var wm = g((ty) => {
  "use strict";
  c();
  Object.defineProperty(ty, "__esModule", { value: !0 });
  ty.isSchema = kde;
  ty.assertSchema = EOt;
  ty.GraphQLSchema = void 0;
  var fOt = Yd(Wv()),
    pOt = Yd(o$()),
    E$ = Yd(ea()),
    mOt = Oc(),
    b$ = Yd(Lt()),
    hOt = Yd(Xx()),
    hN = Yd(Ta()),
    gOt = Yd(n0()),
    vOt = Yd(wc()),
    yOt = Ra(),
    xde = bo(),
    qs = It();
  function Yd(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Nde(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      (n.enumerable = n.enumerable || !1),
        (n.configurable = !0),
        "value" in n && (n.writable = !0),
        Object.defineProperty(e, n.key, n);
    }
  }
  function _Ot(e, t, r) {
    return t && Nde(e.prototype, t), r && Nde(e, r), e;
  }
  function kde(e) {
    return (0, gOt.default)(e, Dde);
  }
  function EOt(e) {
    if (!kde(e))
      throw new Error(
        "Expected ".concat((0, b$.default)(e), " to be a GraphQL schema."),
      );
    return e;
  }
  var Dde = (function () {
    function e(r) {
      var n;
      (this.__validationErrors = r.assumeValid === !0 ? [] : void 0),
        (0, vOt.default)(r) ||
          (0, hN.default)(0, "Must provide configuration object."),
        !r.types ||
          Array.isArray(r.types) ||
          (0, hN.default)(
            0,
            '"types" must be Array if provided but got: '.concat(
              (0, b$.default)(r.types),
              ".",
            ),
          ),
        !r.directives ||
          Array.isArray(r.directives) ||
          (0, hN.default)(
            0,
            '"directives" must be Array if provided but got: ' +
              "".concat((0, b$.default)(r.directives), "."),
          ),
        (this.description = r.description),
        (this.extensions = r.extensions && (0, hOt.default)(r.extensions)),
        (this.astNode = r.astNode),
        (this.extensionASTNodes = r.extensionASTNodes),
        (this._queryType = r.query),
        (this._mutationType = r.mutation),
        (this._subscriptionType = r.subscription),
        (this._directives =
          (n = r.directives) !== null && n !== void 0
            ? n
            : xde.specifiedDirectives);
      var i = new Set(r.types);
      if (r.types != null)
        for (var o = 0, a = r.types; o < a.length; o++) {
          var s = a[o];
          i.delete(s), js(s, i);
        }
      this._queryType != null && js(this._queryType, i),
        this._mutationType != null && js(this._mutationType, i),
        this._subscriptionType != null && js(this._subscriptionType, i);
      for (var u = 0, l = this._directives; u < l.length; u++) {
        var d = l[u];
        if ((0, xde.isDirective)(d))
          for (var f = 0, m = d.args; f < m.length; f++) {
            var h = m[f];
            js(h.type, i);
          }
      }
      js(yOt.__Schema, i),
        (this._typeMap = Object.create(null)),
        (this._subTypeMap = Object.create(null)),
        (this._implementationsMap = Object.create(null));
      for (var y = 0, _ = (0, pOt.default)(i); y < _.length; y++) {
        var E = _[y];
        if (E != null) {
          var b = E.name;
          if (
            (b ||
              (0, hN.default)(
                0,
                "One of the provided types for building the Schema is missing a name.",
              ),
            this._typeMap[b] !== void 0)
          )
            throw new Error(
              'Schema must contain uniquely named types but contains multiple types named "'.concat(
                b,
                '".',
              ),
            );
          if (((this._typeMap[b] = E), (0, qs.isInterfaceType)(E)))
            for (var O = 0, C = E.getInterfaces(); O < C.length; O++) {
              var P = C[O];
              if ((0, qs.isInterfaceType)(P)) {
                var k = this._implementationsMap[P.name];
                k === void 0 &&
                  (k = this._implementationsMap[P.name] =
                    { objects: [], interfaces: [] }),
                  k.interfaces.push(E);
              }
            }
          else if ((0, qs.isObjectType)(E))
            for (var H = 0, B = E.getInterfaces(); H < B.length; H++) {
              var L = B[H];
              if ((0, qs.isInterfaceType)(L)) {
                var Z = this._implementationsMap[L.name];
                Z === void 0 &&
                  (Z = this._implementationsMap[L.name] =
                    { objects: [], interfaces: [] }),
                  Z.objects.push(E);
              }
            }
        }
      }
    }
    var t = e.prototype;
    return (
      (t.getQueryType = function () {
        return this._queryType;
      }),
      (t.getMutationType = function () {
        return this._mutationType;
      }),
      (t.getSubscriptionType = function () {
        return this._subscriptionType;
      }),
      (t.getTypeMap = function () {
        return this._typeMap;
      }),
      (t.getType = function (n) {
        return this.getTypeMap()[n];
      }),
      (t.getPossibleTypes = function (n) {
        return (0, qs.isUnionType)(n)
          ? n.getTypes()
          : this.getImplementations(n).objects;
      }),
      (t.getImplementations = function (n) {
        var i = this._implementationsMap[n.name];
        return i ?? { objects: [], interfaces: [] };
      }),
      (t.isPossibleType = function (n, i) {
        return this.isSubType(n, i);
      }),
      (t.isSubType = function (n, i) {
        var o = this._subTypeMap[n.name];
        if (o === void 0) {
          if (((o = Object.create(null)), (0, qs.isUnionType)(n)))
            for (var a = 0, s = n.getTypes(); a < s.length; a++) {
              var u = s[a];
              o[u.name] = !0;
            }
          else {
            for (
              var l = this.getImplementations(n), d = 0, f = l.objects;
              d < f.length;
              d++
            ) {
              var m = f[d];
              o[m.name] = !0;
            }
            for (var h = 0, y = l.interfaces; h < y.length; h++) {
              var _ = y[h];
              o[_.name] = !0;
            }
          }
          this._subTypeMap[n.name] = o;
        }
        return o[i.name] !== void 0;
      }),
      (t.getDirectives = function () {
        return this._directives;
      }),
      (t.getDirective = function (n) {
        return (0, fOt.default)(this.getDirectives(), function (i) {
          return i.name === n;
        });
      }),
      (t.toConfig = function () {
        var n;
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: (0, E$.default)(this.getTypeMap()),
          directives: this.getDirectives().slice(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes:
            (n = this.extensionASTNodes) !== null && n !== void 0 ? n : [],
          assumeValid: this.__validationErrors !== void 0,
        };
      }),
      _Ot(e, [
        {
          key: mOt.SYMBOL_TO_STRING_TAG,
          get: function () {
            return "GraphQLSchema";
          },
        },
      ]),
      e
    );
  })();
  ty.GraphQLSchema = Dde;
  function js(e, t) {
    var r = (0, qs.getNamedType)(e);
    if (!t.has(r)) {
      if ((t.add(r), (0, qs.isUnionType)(r)))
        for (var n = 0, i = r.getTypes(); n < i.length; n++) {
          var o = i[n];
          js(o, t);
        }
      else if ((0, qs.isObjectType)(r) || (0, qs.isInterfaceType)(r)) {
        for (var a = 0, s = r.getInterfaces(); a < s.length; a++) {
          var u = s[a];
          js(u, t);
        }
        for (var l = 0, d = (0, E$.default)(r.getFields()); l < d.length; l++) {
          var f = d[l];
          js(f.type, t);
          for (var m = 0, h = f.args; m < h.length; m++) {
            var y = h[m];
            js(y.type, t);
          }
        }
      } else if ((0, qs.isInputObjectType)(r))
        for (var _ = 0, E = (0, E$.default)(r.getFields()); _ < E.length; _++) {
          var b = E[_];
          js(b.type, t);
        }
    }
    return t;
  }
});
var w0 = g((gN) => {
  "use strict";
  c();
  Object.defineProperty(gN, "__esModule", { value: !0 });
  gN.validateSchema = Ude;
  gN.assertValidSchema = TOt;
  var Lde = C$(Wv()),
    C0 = C$(ea()),
    Fi = C$(Lt()),
    bOt = Ue(),
    SOt = s0(),
    COt = kV(),
    Mde = m0(),
    wOt = wm(),
    OOt = Ra(),
    Bde = bo(),
    mn = It();
  function C$(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Ude(e) {
    if (((0, wOt.assertSchema)(e), e.__validationErrors))
      return e.__validationErrors;
    var t = new AOt(e);
    POt(t), ROt(t), IOt(t);
    var r = t.getErrors();
    return (e.__validationErrors = r), r;
  }
  function TOt(e) {
    var t = Ude(e);
    if (t.length !== 0)
      throw new Error(
        t.map(function (r) {
          return r.message;
        }).join(`

`),
      );
  }
  var AOt = (function () {
    function e(r) {
      (this._errors = []), (this.schema = r);
    }
    var t = e.prototype;
    return (
      (t.reportError = function (n, i) {
        var o = Array.isArray(i) ? i.filter(Boolean) : i;
        this.addError(new bOt.GraphQLError(n, o));
      }),
      (t.addError = function (n) {
        this._errors.push(n);
      }),
      (t.getErrors = function () {
        return this._errors;
      }),
      e
    );
  })();
  function POt(e) {
    var t = e.schema,
      r = t.getQueryType();
    if (!r) e.reportError("Query root type must be provided.", t.astNode);
    else if (!(0, mn.isObjectType)(r)) {
      var n;
      e.reportError(
        "Query root type must be Object type, it cannot be ".concat(
          (0, Fi.default)(r),
          ".",
        ),
        (n = S$(t, "query")) !== null && n !== void 0 ? n : r.astNode,
      );
    }
    var i = t.getMutationType();
    if (i && !(0, mn.isObjectType)(i)) {
      var o;
      e.reportError(
        "Mutation root type must be Object type if provided, it cannot be " +
          "".concat((0, Fi.default)(i), "."),
        (o = S$(t, "mutation")) !== null && o !== void 0 ? o : i.astNode,
      );
    }
    var a = t.getSubscriptionType();
    if (a && !(0, mn.isObjectType)(a)) {
      var s;
      e.reportError(
        "Subscription root type must be Object type if provided, it cannot be " +
          "".concat((0, Fi.default)(a), "."),
        (s = S$(t, "subscription")) !== null && s !== void 0 ? s : a.astNode,
      );
    }
  }
  function S$(e, t) {
    for (
      var r = w$(e, function (o) {
          return o.operationTypes;
        }),
        n = 0;
      n < r.length;
      n++
    ) {
      var i = r[n];
      if (i.operation === t) return i.type;
    }
  }
  function ROt(e) {
    for (var t = 0, r = e.schema.getDirectives(); t < r.length; t++) {
      var n = r[t];
      if (!(0, Bde.isDirective)(n)) {
        e.reportError(
          "Expected directive but got: ".concat((0, Fi.default)(n), "."),
          n?.astNode,
        );
        continue;
      }
      Om(e, n);
      for (var i = 0, o = n.args; i < o.length; i++) {
        var a = o[i];
        if (
          (Om(e, a),
          (0, mn.isInputType)(a.type) ||
            e.reportError(
              "The type of @"
                .concat(n.name, "(")
                .concat(a.name, ":) must be Input Type ") +
                "but got: ".concat((0, Fi.default)(a.type), "."),
              a.astNode,
            ),
          (0, mn.isRequiredArgument)(a) && a.deprecationReason != null)
        ) {
          var s;
          e.reportError(
            "Required argument @"
              .concat(n.name, "(")
              .concat(a.name, ":) cannot be deprecated."),
            [
              O$(a.astNode),
              (s = a.astNode) === null || s === void 0 ? void 0 : s.type,
            ],
          );
        }
      }
    }
  }
  function Om(e, t) {
    var r = (0, COt.isValidNameError)(t.name);
    r && e.addError((0, SOt.locatedError)(r, t.astNode));
  }
  function IOt(e) {
    for (
      var t = MOt(e), r = e.schema.getTypeMap(), n = 0, i = (0, C0.default)(r);
      n < i.length;
      n++
    ) {
      var o = i[n];
      if (!(0, mn.isNamedType)(o)) {
        e.reportError(
          "Expected GraphQL named type but got: ".concat(
            (0, Fi.default)(o),
            ".",
          ),
          o.astNode,
        );
        continue;
      }
      (0, OOt.isIntrospectionType)(o) || Om(e, o),
        (0, mn.isObjectType)(o) || (0, mn.isInterfaceType)(o)
          ? (qde(e, o), jde(e, o))
          : (0, mn.isUnionType)(o)
            ? kOt(e, o)
            : (0, mn.isEnumType)(o)
              ? DOt(e, o)
              : (0, mn.isInputObjectType)(o) && (LOt(e, o), t(o));
    }
  }
  function qde(e, t) {
    var r = (0, C0.default)(t.getFields());
    r.length === 0 &&
      e.reportError(
        "Type ".concat(t.name, " must define one or more fields."),
        ry(t),
      );
    for (var n = 0; n < r.length; n++) {
      var i = r[n];
      if ((Om(e, i), !(0, mn.isOutputType)(i.type))) {
        var o;
        e.reportError(
          "The type of "
            .concat(t.name, ".")
            .concat(i.name, " must be Output Type ") +
            "but got: ".concat((0, Fi.default)(i.type), "."),
          (o = i.astNode) === null || o === void 0 ? void 0 : o.type,
        );
      }
      for (var a = 0, s = i.args; a < s.length; a++) {
        var u = s[a],
          l = u.name;
        if ((Om(e, u), !(0, mn.isInputType)(u.type))) {
          var d;
          e.reportError(
            "The type of "
              .concat(t.name, ".")
              .concat(i.name, "(")
              .concat(l, ":) must be Input ") +
              "Type but got: ".concat((0, Fi.default)(u.type), "."),
            (d = u.astNode) === null || d === void 0 ? void 0 : d.type,
          );
        }
        if ((0, mn.isRequiredArgument)(u) && u.deprecationReason != null) {
          var f;
          e.reportError(
            "Required argument "
              .concat(t.name, ".")
              .concat(i.name, "(")
              .concat(l, ":) cannot be deprecated."),
            [
              O$(u.astNode),
              (f = u.astNode) === null || f === void 0 ? void 0 : f.type,
            ],
          );
        }
      }
    }
  }
  function jde(e, t) {
    for (
      var r = Object.create(null), n = 0, i = t.getInterfaces();
      n < i.length;
      n++
    ) {
      var o = i[n];
      if (!(0, mn.isInterfaceType)(o)) {
        e.reportError(
          "Type ".concat(
            (0, Fi.default)(t),
            " must only implement Interface types, ",
          ) + "it cannot implement ".concat((0, Fi.default)(o), "."),
          S0(t, o),
        );
        continue;
      }
      if (t === o) {
        e.reportError(
          "Type ".concat(
            t.name,
            " cannot implement itself because it would create a circular reference.",
          ),
          S0(t, o),
        );
        continue;
      }
      if (r[o.name]) {
        e.reportError(
          "Type "
            .concat(t.name, " can only implement ")
            .concat(o.name, " once."),
          S0(t, o),
        );
        continue;
      }
      (r[o.name] = !0), NOt(e, t, o), xOt(e, t, o);
    }
  }
  function xOt(e, t, r) {
    for (
      var n = t.getFields(), i = 0, o = (0, C0.default)(r.getFields());
      i < o.length;
      i++
    ) {
      var a = o[i],
        s = a.name,
        u = n[s];
      if (!u) {
        e.reportError(
          "Interface field "
            .concat(r.name, ".")
            .concat(s, " expected but ")
            .concat(t.name, " does not provide it."),
          [a.astNode].concat(ry(t)),
        );
        continue;
      }
      if (!(0, Mde.isTypeSubTypeOf)(e.schema, u.type, a.type)) {
        var l, d;
        e.reportError(
          "Interface field ".concat(r.name, ".").concat(s, " expects type ") +
            ""
              .concat((0, Fi.default)(a.type), " but ")
              .concat(t.name, ".")
              .concat(s, " ") +
            "is type ".concat((0, Fi.default)(u.type), "."),
          [
            (l = a.astNode) === null || l === void 0 ? void 0 : l.type,
            (d = u.astNode) === null || d === void 0 ? void 0 : d.type,
          ],
        );
      }
      for (
        var f = function (C, P) {
            var k = P[C],
              H = k.name,
              B = (0, Lde.default)(u.args, function (ft) {
                return ft.name === H;
              });
            if (!B)
              return (
                e.reportError(
                  "Interface field argument "
                    .concat(r.name, ".")
                    .concat(s, "(")
                    .concat(H, ":) expected but ")
                    .concat(t.name, ".")
                    .concat(s, " does not provide it."),
                  [k.astNode, u.astNode],
                ),
                "continue"
              );
            if (!(0, Mde.isEqualType)(k.type, B.type)) {
              var L, Z;
              e.reportError(
                "Interface field argument "
                  .concat(r.name, ".")
                  .concat(s, "(")
                  .concat(H, ":) ") +
                  "expects type ".concat((0, Fi.default)(k.type), " but ") +
                  ""
                    .concat(t.name, ".")
                    .concat(s, "(")
                    .concat(H, ":) is type ") +
                  "".concat((0, Fi.default)(B.type), "."),
                [
                  (L = k.astNode) === null || L === void 0 ? void 0 : L.type,
                  (Z = B.astNode) === null || Z === void 0 ? void 0 : Z.type,
                ],
              );
            }
          },
          m = 0,
          h = a.args;
        m < h.length;
        m++
      )
        var y = f(m, h);
      for (
        var _ = function (C, P) {
            var k = P[C],
              H = k.name,
              B = (0, Lde.default)(a.args, function (L) {
                return L.name === H;
              });
            !B &&
              (0, mn.isRequiredArgument)(k) &&
              e.reportError(
                "Object field "
                  .concat(t.name, ".")
                  .concat(s, " includes required argument ")
                  .concat(H, " that is missing from the Interface field ")
                  .concat(r.name, ".")
                  .concat(s, "."),
                [k.astNode, a.astNode],
              );
          },
          E = 0,
          b = u.args;
        E < b.length;
        E++
      )
        _(E, b);
    }
  }
  function NOt(e, t, r) {
    for (
      var n = t.getInterfaces(), i = 0, o = r.getInterfaces();
      i < o.length;
      i++
    ) {
      var a = o[i];
      n.indexOf(a) === -1 &&
        e.reportError(
          a === t
            ? "Type "
                .concat(t.name, " cannot implement ")
                .concat(
                  r.name,
                  " because it would create a circular reference.",
                )
            : "Type "
                .concat(t.name, " must implement ")
                .concat(a.name, " because it is implemented by ")
                .concat(r.name, "."),
          [].concat(S0(r, a), S0(t, r)),
        );
    }
  }
  function kOt(e, t) {
    var r = t.getTypes();
    r.length === 0 &&
      e.reportError(
        "Union type ".concat(t.name, " must define one or more member types."),
        ry(t),
      );
    for (var n = Object.create(null), i = 0; i < r.length; i++) {
      var o = r[i];
      if (n[o.name]) {
        e.reportError(
          "Union type "
            .concat(t.name, " can only include type ")
            .concat(o.name, " once."),
          Fde(t, o.name),
        );
        continue;
      }
      (n[o.name] = !0),
        (0, mn.isObjectType)(o) ||
          e.reportError(
            "Union type ".concat(t.name, " can only include Object types, ") +
              "it cannot include ".concat((0, Fi.default)(o), "."),
            Fde(t, String(o)),
          );
    }
  }
  function DOt(e, t) {
    var r = t.getValues();
    r.length === 0 &&
      e.reportError(
        "Enum type ".concat(t.name, " must define one or more values."),
        ry(t),
      );
    for (var n = 0; n < r.length; n++) {
      var i = r[n],
        o = i.name;
      Om(e, i),
        (o === "true" || o === "false" || o === "null") &&
          e.reportError(
            "Enum type "
              .concat(t.name, " cannot include value: ")
              .concat(o, "."),
            i.astNode,
          );
    }
  }
  function LOt(e, t) {
    var r = (0, C0.default)(t.getFields());
    r.length === 0 &&
      e.reportError(
        "Input Object type ".concat(t.name, " must define one or more fields."),
        ry(t),
      );
    for (var n = 0; n < r.length; n++) {
      var i = r[n];
      if ((Om(e, i), !(0, mn.isInputType)(i.type))) {
        var o;
        e.reportError(
          "The type of "
            .concat(t.name, ".")
            .concat(i.name, " must be Input Type ") +
            "but got: ".concat((0, Fi.default)(i.type), "."),
          (o = i.astNode) === null || o === void 0 ? void 0 : o.type,
        );
      }
      if ((0, mn.isRequiredInputField)(i) && i.deprecationReason != null) {
        var a;
        e.reportError(
          "Required input field "
            .concat(t.name, ".")
            .concat(i.name, " cannot be deprecated."),
          [
            O$(i.astNode),
            (a = i.astNode) === null || a === void 0 ? void 0 : a.type,
          ],
        );
      }
    }
  }
  function MOt(e) {
    var t = Object.create(null),
      r = [],
      n = Object.create(null);
    return i;
    function i(o) {
      if (!t[o.name]) {
        (t[o.name] = !0), (n[o.name] = r.length);
        for (var a = (0, C0.default)(o.getFields()), s = 0; s < a.length; s++) {
          var u = a[s];
          if (
            (0, mn.isNonNullType)(u.type) &&
            (0, mn.isInputObjectType)(u.type.ofType)
          ) {
            var l = u.type.ofType,
              d = n[l.name];
            if ((r.push(u), d === void 0)) i(l);
            else {
              var f = r.slice(d),
                m = f
                  .map(function (h) {
                    return h.name;
                  })
                  .join(".");
              e.reportError(
                'Cannot reference Input Object "'
                  .concat(
                    l.name,
                    '" within itself through a series of non-null fields: "',
                  )
                  .concat(m, '".'),
                f.map(function (h) {
                  return h.astNode;
                }),
              );
            }
            r.pop();
          }
        }
        n[o.name] = void 0;
      }
    }
  }
  function ry(e) {
    var t = e.astNode,
      r = e.extensionASTNodes;
    return t ? (r ? [t].concat(r) : [t]) : (r ?? []);
  }
  function w$(e, t) {
    for (var r = [], n = 0, i = ry(e); n < i.length; n++) {
      var o,
        a = i[n];
      r = r.concat((o = t(a)) !== null && o !== void 0 ? o : []);
    }
    return r;
  }
  function S0(e, t) {
    return w$(e, function (r) {
      return r.interfaces;
    }).filter(function (r) {
      return r.name.value === t.name;
    });
  }
  function Fde(e, t) {
    return w$(e, function (r) {
      return r.types;
    }).filter(function (r) {
      return r.name.value === t;
    });
  }
  function O$(e) {
    var t;
    return e == null || (t = e.directives) === null || t === void 0
      ? void 0
      : t.find(function (r) {
          return r.name.value === Bde.GraphQLDeprecatedDirective.name;
        });
  }
});
var Rc = g((P$) => {
  "use strict";
  c();
  Object.defineProperty(P$, "__esModule", { value: !0 });
  P$.typeFromAST = A$;
  var qOt = Gde(Lt()),
    jOt = Gde(vi()),
    T$ = lr(),
    Hde = It();
  function Gde(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function A$(e, t) {
    var r;
    if (t.kind === T$.Kind.LIST_TYPE)
      return (r = A$(e, t.type)), r && new Hde.GraphQLList(r);
    if (t.kind === T$.Kind.NON_NULL_TYPE)
      return (r = A$(e, t.type)), r && new Hde.GraphQLNonNull(r);
    if (t.kind === T$.Kind.NAMED_TYPE) return e.getType(t.name.value);
    (0, jOt.default)(0, "Unexpected type node: " + (0, qOt.default)(t));
  }
});
var vN = g((O0) => {
  "use strict";
  c();
  Object.defineProperty(O0, "__esModule", { value: !0 });
  O0.visitWithTypeInfo = VOt;
  O0.TypeInfo = void 0;
  var FOt = UOt(Wv()),
    sn = lr(),
    BOt = Hv(),
    Vde = Bd(),
    cn = It(),
    ny = Ra(),
    $de = Rc();
  function UOt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var HOt = (function () {
    function e(r, n, i) {
      (this._schema = r),
        (this._typeStack = []),
        (this._parentTypeStack = []),
        (this._inputTypeStack = []),
        (this._fieldDefStack = []),
        (this._defaultValueStack = []),
        (this._directive = null),
        (this._argument = null),
        (this._enumValue = null),
        (this._getFieldDef = n ?? GOt),
        i &&
          ((0, cn.isInputType)(i) && this._inputTypeStack.push(i),
          (0, cn.isCompositeType)(i) && this._parentTypeStack.push(i),
          (0, cn.isOutputType)(i) && this._typeStack.push(i));
    }
    var t = e.prototype;
    return (
      (t.getType = function () {
        if (this._typeStack.length > 0)
          return this._typeStack[this._typeStack.length - 1];
      }),
      (t.getParentType = function () {
        if (this._parentTypeStack.length > 0)
          return this._parentTypeStack[this._parentTypeStack.length - 1];
      }),
      (t.getInputType = function () {
        if (this._inputTypeStack.length > 0)
          return this._inputTypeStack[this._inputTypeStack.length - 1];
      }),
      (t.getParentInputType = function () {
        if (this._inputTypeStack.length > 1)
          return this._inputTypeStack[this._inputTypeStack.length - 2];
      }),
      (t.getFieldDef = function () {
        if (this._fieldDefStack.length > 0)
          return this._fieldDefStack[this._fieldDefStack.length - 1];
      }),
      (t.getDefaultValue = function () {
        if (this._defaultValueStack.length > 0)
          return this._defaultValueStack[this._defaultValueStack.length - 1];
      }),
      (t.getDirective = function () {
        return this._directive;
      }),
      (t.getArgument = function () {
        return this._argument;
      }),
      (t.getEnumValue = function () {
        return this._enumValue;
      }),
      (t.enter = function (n) {
        var i = this._schema;
        switch (n.kind) {
          case sn.Kind.SELECTION_SET: {
            var o = (0, cn.getNamedType)(this.getType());
            this._parentTypeStack.push((0, cn.isCompositeType)(o) ? o : void 0);
            break;
          }
          case sn.Kind.FIELD: {
            var a = this.getParentType(),
              s,
              u;
            a && ((s = this._getFieldDef(i, a, n)), s && (u = s.type)),
              this._fieldDefStack.push(s),
              this._typeStack.push((0, cn.isOutputType)(u) ? u : void 0);
            break;
          }
          case sn.Kind.DIRECTIVE:
            this._directive = i.getDirective(n.name.value);
            break;
          case sn.Kind.OPERATION_DEFINITION: {
            var l;
            switch (n.operation) {
              case "query":
                l = i.getQueryType();
                break;
              case "mutation":
                l = i.getMutationType();
                break;
              case "subscription":
                l = i.getSubscriptionType();
                break;
            }
            this._typeStack.push((0, cn.isObjectType)(l) ? l : void 0);
            break;
          }
          case sn.Kind.INLINE_FRAGMENT:
          case sn.Kind.FRAGMENT_DEFINITION: {
            var d = n.typeCondition,
              f = d
                ? (0, $de.typeFromAST)(i, d)
                : (0, cn.getNamedType)(this.getType());
            this._typeStack.push((0, cn.isOutputType)(f) ? f : void 0);
            break;
          }
          case sn.Kind.VARIABLE_DEFINITION: {
            var m = (0, $de.typeFromAST)(i, n.type);
            this._inputTypeStack.push((0, cn.isInputType)(m) ? m : void 0);
            break;
          }
          case sn.Kind.ARGUMENT: {
            var h,
              y,
              _,
              E =
                (h = this.getDirective()) !== null && h !== void 0
                  ? h
                  : this.getFieldDef();
            E &&
              ((y = (0, FOt.default)(E.args, function (L) {
                return L.name === n.name.value;
              })),
              y && (_ = y.type)),
              (this._argument = y),
              this._defaultValueStack.push(y ? y.defaultValue : void 0),
              this._inputTypeStack.push((0, cn.isInputType)(_) ? _ : void 0);
            break;
          }
          case sn.Kind.LIST: {
            var b = (0, cn.getNullableType)(this.getInputType()),
              O = (0, cn.isListType)(b) ? b.ofType : b;
            this._defaultValueStack.push(void 0),
              this._inputTypeStack.push((0, cn.isInputType)(O) ? O : void 0);
            break;
          }
          case sn.Kind.OBJECT_FIELD: {
            var C = (0, cn.getNamedType)(this.getInputType()),
              P,
              k;
            (0, cn.isInputObjectType)(C) &&
              ((k = C.getFields()[n.name.value]), k && (P = k.type)),
              this._defaultValueStack.push(k ? k.defaultValue : void 0),
              this._inputTypeStack.push((0, cn.isInputType)(P) ? P : void 0);
            break;
          }
          case sn.Kind.ENUM: {
            var H = (0, cn.getNamedType)(this.getInputType()),
              B;
            (0, cn.isEnumType)(H) && (B = H.getValue(n.value)),
              (this._enumValue = B);
            break;
          }
        }
      }),
      (t.leave = function (n) {
        switch (n.kind) {
          case sn.Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case sn.Kind.FIELD:
            this._fieldDefStack.pop(), this._typeStack.pop();
            break;
          case sn.Kind.DIRECTIVE:
            this._directive = null;
            break;
          case sn.Kind.OPERATION_DEFINITION:
          case sn.Kind.INLINE_FRAGMENT:
          case sn.Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case sn.Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case sn.Kind.ARGUMENT:
            (this._argument = null),
              this._defaultValueStack.pop(),
              this._inputTypeStack.pop();
            break;
          case sn.Kind.LIST:
          case sn.Kind.OBJECT_FIELD:
            this._defaultValueStack.pop(), this._inputTypeStack.pop();
            break;
          case sn.Kind.ENUM:
            this._enumValue = null;
            break;
        }
      }),
      e
    );
  })();
  O0.TypeInfo = HOt;
  function GOt(e, t, r) {
    var n = r.name.value;
    if (n === ny.SchemaMetaFieldDef.name && e.getQueryType() === t)
      return ny.SchemaMetaFieldDef;
    if (n === ny.TypeMetaFieldDef.name && e.getQueryType() === t)
      return ny.TypeMetaFieldDef;
    if (n === ny.TypeNameMetaFieldDef.name && (0, cn.isCompositeType)(t))
      return ny.TypeNameMetaFieldDef;
    if ((0, cn.isObjectType)(t) || (0, cn.isInterfaceType)(t))
      return t.getFields()[n];
  }
  function VOt(e, t) {
    return {
      enter: function (n) {
        e.enter(n);
        var i = (0, Vde.getVisitFn)(t, n.kind, !1);
        if (i) {
          var o = i.apply(t, arguments);
          return (
            o !== void 0 && (e.leave(n), (0, BOt.isNode)(o) && e.enter(o)), o
          );
        }
      },
      leave: function (n) {
        var i = (0, Vde.getVisitFn)(t, n.kind, !0),
          o;
        return i && (o = i.apply(t, arguments)), e.leave(n), o;
      },
    };
  }
});
var Tm = g((Fs) => {
  "use strict";
  c();
  Object.defineProperty(Fs, "__esModule", { value: !0 });
  Fs.isDefinitionNode = $Ot;
  Fs.isExecutableDefinitionNode = zde;
  Fs.isSelectionNode = zOt;
  Fs.isValueNode = KOt;
  Fs.isTypeNode = WOt;
  Fs.isTypeSystemDefinitionNode = Kde;
  Fs.isTypeDefinitionNode = Wde;
  Fs.isTypeSystemExtensionNode = Qde;
  Fs.isTypeExtensionNode = Yde;
  var Mt = lr();
  function $Ot(e) {
    return zde(e) || Kde(e) || Qde(e);
  }
  function zde(e) {
    return (
      e.kind === Mt.Kind.OPERATION_DEFINITION ||
      e.kind === Mt.Kind.FRAGMENT_DEFINITION
    );
  }
  function zOt(e) {
    return (
      e.kind === Mt.Kind.FIELD ||
      e.kind === Mt.Kind.FRAGMENT_SPREAD ||
      e.kind === Mt.Kind.INLINE_FRAGMENT
    );
  }
  function KOt(e) {
    return (
      e.kind === Mt.Kind.VARIABLE ||
      e.kind === Mt.Kind.INT ||
      e.kind === Mt.Kind.FLOAT ||
      e.kind === Mt.Kind.STRING ||
      e.kind === Mt.Kind.BOOLEAN ||
      e.kind === Mt.Kind.NULL ||
      e.kind === Mt.Kind.ENUM ||
      e.kind === Mt.Kind.LIST ||
      e.kind === Mt.Kind.OBJECT
    );
  }
  function WOt(e) {
    return (
      e.kind === Mt.Kind.NAMED_TYPE ||
      e.kind === Mt.Kind.LIST_TYPE ||
      e.kind === Mt.Kind.NON_NULL_TYPE
    );
  }
  function Kde(e) {
    return (
      e.kind === Mt.Kind.SCHEMA_DEFINITION ||
      Wde(e) ||
      e.kind === Mt.Kind.DIRECTIVE_DEFINITION
    );
  }
  function Wde(e) {
    return (
      e.kind === Mt.Kind.SCALAR_TYPE_DEFINITION ||
      e.kind === Mt.Kind.OBJECT_TYPE_DEFINITION ||
      e.kind === Mt.Kind.INTERFACE_TYPE_DEFINITION ||
      e.kind === Mt.Kind.UNION_TYPE_DEFINITION ||
      e.kind === Mt.Kind.ENUM_TYPE_DEFINITION ||
      e.kind === Mt.Kind.INPUT_OBJECT_TYPE_DEFINITION
    );
  }
  function Qde(e) {
    return e.kind === Mt.Kind.SCHEMA_EXTENSION || Yde(e);
  }
  function Yde(e) {
    return (
      e.kind === Mt.Kind.SCALAR_TYPE_EXTENSION ||
      e.kind === Mt.Kind.OBJECT_TYPE_EXTENSION ||
      e.kind === Mt.Kind.INTERFACE_TYPE_EXTENSION ||
      e.kind === Mt.Kind.UNION_TYPE_EXTENSION ||
      e.kind === Mt.Kind.ENUM_TYPE_EXTENSION ||
      e.kind === Mt.Kind.INPUT_OBJECT_TYPE_EXTENSION
    );
  }
});
var I$ = g((R$) => {
  "use strict";
  c();
  Object.defineProperty(R$, "__esModule", { value: !0 });
  R$.ExecutableDefinitionsRule = XOt;
  var QOt = Ue(),
    Xde = lr(),
    YOt = Tm();
  function XOt(e) {
    return {
      Document: function (r) {
        for (var n = 0, i = r.definitions; n < i.length; n++) {
          var o = i[n];
          if (!(0, YOt.isExecutableDefinitionNode)(o)) {
            var a =
              o.kind === Xde.Kind.SCHEMA_DEFINITION ||
              o.kind === Xde.Kind.SCHEMA_EXTENSION
                ? "schema"
                : '"' + o.name.value + '"';
            e.reportError(
              new QOt.GraphQLError(
                "The ".concat(a, " definition is not executable."),
                o,
              ),
            );
          }
        }
        return !1;
      },
    };
  }
});
var N$ = g((x$) => {
  "use strict";
  c();
  Object.defineProperty(x$, "__esModule", { value: !0 });
  x$.UniqueOperationNamesRule = ZOt;
  var JOt = Ue();
  function ZOt(e) {
    var t = Object.create(null);
    return {
      OperationDefinition: function (n) {
        var i = n.name;
        return (
          i &&
            (t[i.value]
              ? e.reportError(
                  new JOt.GraphQLError(
                    'There can be only one operation named "'.concat(
                      i.value,
                      '".',
                    ),
                    [t[i.value], i],
                  ),
                )
              : (t[i.value] = i)),
          !1
        );
      },
      FragmentDefinition: function () {
        return !1;
      },
    };
  }
});
var D$ = g((k$) => {
  "use strict";
  c();
  Object.defineProperty(k$, "__esModule", { value: !0 });
  k$.LoneAnonymousOperationRule = rTt;
  var eTt = Ue(),
    tTt = lr();
  function rTt(e) {
    var t = 0;
    return {
      Document: function (n) {
        t = n.definitions.filter(function (i) {
          return i.kind === tTt.Kind.OPERATION_DEFINITION;
        }).length;
      },
      OperationDefinition: function (n) {
        !n.name &&
          t > 1 &&
          e.reportError(
            new eTt.GraphQLError(
              "This anonymous operation must be the only defined operation.",
              n,
            ),
          );
      },
    };
  }
});
var M$ = g((L$) => {
  "use strict";
  c();
  Object.defineProperty(L$, "__esModule", { value: !0 });
  L$.SingleFieldSubscriptionsRule = iTt;
  var nTt = Ue();
  function iTt(e) {
    return {
      OperationDefinition: function (r) {
        r.operation === "subscription" &&
          r.selectionSet.selections.length !== 1 &&
          e.reportError(
            new nTt.GraphQLError(
              r.name
                ? 'Subscription "'.concat(
                    r.name.value,
                    '" must select only one top level field.',
                  )
                : "Anonymous Subscription must select only one top level field.",
              r.selectionSet.selections.slice(1),
            ),
          );
      },
    };
  }
});
var F$ = g((j$) => {
  "use strict";
  c();
  Object.defineProperty(j$, "__esModule", { value: !0 });
  j$.KnownTypeNamesRule = lTt;
  var oTt = Jde(Hd()),
    aTt = Jde(Gd()),
    sTt = Ue(),
    q$ = Tm(),
    cTt = Pc(),
    uTt = Ra();
  function Jde(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function lTt(e) {
    for (
      var t = e.getSchema(),
        r = t ? t.getTypeMap() : Object.create(null),
        n = Object.create(null),
        i = 0,
        o = e.getDocument().definitions;
      i < o.length;
      i++
    ) {
      var a = o[i];
      (0, q$.isTypeDefinitionNode)(a) && (n[a.name.value] = !0);
    }
    var s = Object.keys(r).concat(Object.keys(n));
    return {
      NamedType: function (l, d, f, m, h) {
        var y = l.name.value;
        if (!r[y] && !n[y]) {
          var _,
            E = (_ = h[2]) !== null && _ !== void 0 ? _ : f,
            b = E != null && fTt(E);
          if (b && dTt(y)) return;
          var O = (0, aTt.default)(y, b ? Zde.concat(s) : s);
          e.reportError(
            new sTt.GraphQLError(
              'Unknown type "'.concat(y, '".') + (0, oTt.default)(O),
              l,
            ),
          );
        }
      },
    };
  }
  var Zde = []
    .concat(cTt.specifiedScalarTypes, uTt.introspectionTypes)
    .map(function (e) {
      return e.name;
    });
  function dTt(e) {
    return Zde.indexOf(e) !== -1;
  }
  function fTt(e) {
    return (
      !Array.isArray(e) &&
      ((0, q$.isTypeSystemDefinitionNode)(e) ||
        (0, q$.isTypeSystemExtensionNode)(e))
    );
  }
});
var U$ = g((B$) => {
  "use strict";
  c();
  Object.defineProperty(B$, "__esModule", { value: !0 });
  B$.FragmentsOnCompositeTypesRule = pTt;
  var efe = Ue(),
    tfe = ta(),
    rfe = It(),
    nfe = Rc();
  function pTt(e) {
    return {
      InlineFragment: function (r) {
        var n = r.typeCondition;
        if (n) {
          var i = (0, nfe.typeFromAST)(e.getSchema(), n);
          if (i && !(0, rfe.isCompositeType)(i)) {
            var o = (0, tfe.print)(n);
            e.reportError(
              new efe.GraphQLError(
                'Fragment cannot condition on non composite type "'.concat(
                  o,
                  '".',
                ),
                n,
              ),
            );
          }
        }
      },
      FragmentDefinition: function (r) {
        var n = (0, nfe.typeFromAST)(e.getSchema(), r.typeCondition);
        if (n && !(0, rfe.isCompositeType)(n)) {
          var i = (0, tfe.print)(r.typeCondition);
          e.reportError(
            new efe.GraphQLError(
              'Fragment "'
                .concat(
                  r.name.value,
                  '" cannot condition on non composite type "',
                )
                .concat(i, '".'),
              r.typeCondition,
            ),
          );
        }
      },
    };
  }
});
var G$ = g((H$) => {
  "use strict";
  c();
  Object.defineProperty(H$, "__esModule", { value: !0 });
  H$.VariablesAreInputTypesRule = yTt;
  var mTt = Ue(),
    hTt = ta(),
    gTt = It(),
    vTt = Rc();
  function yTt(e) {
    return {
      VariableDefinition: function (r) {
        var n = (0, vTt.typeFromAST)(e.getSchema(), r.type);
        if (n && !(0, gTt.isInputType)(n)) {
          var i = r.variable.name.value,
            o = (0, hTt.print)(r.type);
          e.reportError(
            new mTt.GraphQLError(
              'Variable "$'
                .concat(i, '" cannot be non-input type "')
                .concat(o, '".'),
              r.type,
            ),
          );
        }
      },
    };
  }
});
var $$ = g((V$) => {
  "use strict";
  c();
  Object.defineProperty(V$, "__esModule", { value: !0 });
  V$.ScalarLeafsRule = ETt;
  var ife = _Tt(Lt()),
    ofe = Ue(),
    afe = It();
  function _Tt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function ETt(e) {
    return {
      Field: function (r) {
        var n = e.getType(),
          i = r.selectionSet;
        if (n) {
          if ((0, afe.isLeafType)((0, afe.getNamedType)(n))) {
            if (i) {
              var o = r.name.value,
                a = (0, ife.default)(n);
              e.reportError(
                new ofe.GraphQLError(
                  'Field "'
                    .concat(o, '" must not have a selection since type "')
                    .concat(a, '" has no subfields.'),
                  i,
                ),
              );
            }
          } else if (!i) {
            var s = r.name.value,
              u = (0, ife.default)(n);
            e.reportError(
              new ofe.GraphQLError(
                'Field "'
                  .concat(s, '" of type "')
                  .concat(
                    u,
                    '" must have a selection of subfields. Did you mean "',
                  )
                  .concat(s, ' { ... }"?'),
                r,
              ),
            );
          }
        }
      },
    };
  }
});
var K$ = g((z$) => {
  "use strict";
  c();
  Object.defineProperty(z$, "__esModule", { value: !0 });
  z$.FieldsOnCorrectTypeRule = OTt;
  var bTt = yN(o$()),
    sfe = yN(Hd()),
    STt = yN(Gd()),
    CTt = yN(u0()),
    wTt = Ue(),
    T0 = It();
  function yN(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function OTt(e) {
    return {
      Field: function (r) {
        var n = e.getParentType();
        if (n) {
          var i = e.getFieldDef();
          if (!i) {
            var o = e.getSchema(),
              a = r.name.value,
              s = (0, sfe.default)(
                "to use an inline fragment on",
                TTt(o, n, a),
              );
            s === "" && (s = (0, sfe.default)(ATt(n, a))),
              e.reportError(
                new wTt.GraphQLError(
                  'Cannot query field "'
                    .concat(a, '" on type "')
                    .concat(n.name, '".') + s,
                  r,
                ),
              );
          }
        }
      },
    };
  }
  function TTt(e, t, r) {
    if (!(0, T0.isAbstractType)(t)) return [];
    for (
      var n = new Set(),
        i = Object.create(null),
        o = 0,
        a = e.getPossibleTypes(t);
      o < a.length;
      o++
    ) {
      var s = a[o];
      if (s.getFields()[r]) {
        n.add(s), (i[s.name] = 1);
        for (var u = 0, l = s.getInterfaces(); u < l.length; u++) {
          var d,
            f = l[u];
          f.getFields()[r] &&
            (n.add(f),
            (i[f.name] =
              ((d = i[f.name]) !== null && d !== void 0 ? d : 0) + 1));
        }
      }
    }
    return (0, bTt.default)(n)
      .sort(function (m, h) {
        var y = i[h.name] - i[m.name];
        return y !== 0
          ? y
          : (0, T0.isInterfaceType)(m) && e.isSubType(m, h)
            ? -1
            : (0, T0.isInterfaceType)(h) && e.isSubType(h, m)
              ? 1
              : (0, CTt.default)(m.name, h.name);
      })
      .map(function (m) {
        return m.name;
      });
  }
  function ATt(e, t) {
    if ((0, T0.isObjectType)(e) || (0, T0.isInterfaceType)(e)) {
      var r = Object.keys(e.getFields());
      return (0, STt.default)(t, r);
    }
    return [];
  }
});
var Q$ = g((W$) => {
  "use strict";
  c();
  Object.defineProperty(W$, "__esModule", { value: !0 });
  W$.UniqueFragmentNamesRule = RTt;
  var PTt = Ue();
  function RTt(e) {
    var t = Object.create(null);
    return {
      OperationDefinition: function () {
        return !1;
      },
      FragmentDefinition: function (n) {
        var i = n.name.value;
        return (
          t[i]
            ? e.reportError(
                new PTt.GraphQLError(
                  'There can be only one fragment named "'.concat(i, '".'),
                  [t[i], n.name],
                ),
              )
            : (t[i] = n.name),
          !1
        );
      },
    };
  }
});
var X$ = g((Y$) => {
  "use strict";
  c();
  Object.defineProperty(Y$, "__esModule", { value: !0 });
  Y$.KnownFragmentNamesRule = xTt;
  var ITt = Ue();
  function xTt(e) {
    return {
      FragmentSpread: function (r) {
        var n = r.name.value,
          i = e.getFragment(n);
        i ||
          e.reportError(
            new ITt.GraphQLError('Unknown fragment "'.concat(n, '".'), r.name),
          );
      },
    };
  }
});
var Z$ = g((J$) => {
  "use strict";
  c();
  Object.defineProperty(J$, "__esModule", { value: !0 });
  J$.NoUnusedFragmentsRule = kTt;
  var NTt = Ue();
  function kTt(e) {
    var t = [],
      r = [];
    return {
      OperationDefinition: function (i) {
        return t.push(i), !1;
      },
      FragmentDefinition: function (i) {
        return r.push(i), !1;
      },
      Document: {
        leave: function () {
          for (var i = Object.create(null), o = 0; o < t.length; o++)
            for (
              var a = t[o], s = 0, u = e.getRecursivelyReferencedFragments(a);
              s < u.length;
              s++
            ) {
              var l = u[s];
              i[l.name.value] = !0;
            }
          for (var d = 0; d < r.length; d++) {
            var f = r[d],
              m = f.name.value;
            i[m] !== !0 &&
              e.reportError(
                new NTt.GraphQLError(
                  'Fragment "'.concat(m, '" is never used.'),
                  f,
                ),
              );
          }
        },
      },
    };
  }
});
var rz = g((tz) => {
  "use strict";
  c();
  Object.defineProperty(tz, "__esModule", { value: !0 });
  tz.PossibleFragmentSpreadsRule = MTt;
  var _N = LTt(Lt()),
    cfe = Ue(),
    ez = It(),
    DTt = Rc(),
    ufe = m0();
  function LTt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function MTt(e) {
    return {
      InlineFragment: function (r) {
        var n = e.getType(),
          i = e.getParentType();
        if (
          (0, ez.isCompositeType)(n) &&
          (0, ez.isCompositeType)(i) &&
          !(0, ufe.doTypesOverlap)(e.getSchema(), n, i)
        ) {
          var o = (0, _N.default)(i),
            a = (0, _N.default)(n);
          e.reportError(
            new cfe.GraphQLError(
              'Fragment cannot be spread here as objects of type "'
                .concat(o, '" can never be of type "')
                .concat(a, '".'),
              r,
            ),
          );
        }
      },
      FragmentSpread: function (r) {
        var n = r.name.value,
          i = qTt(e, n),
          o = e.getParentType();
        if (i && o && !(0, ufe.doTypesOverlap)(e.getSchema(), i, o)) {
          var a = (0, _N.default)(o),
            s = (0, _N.default)(i);
          e.reportError(
            new cfe.GraphQLError(
              'Fragment "'
                .concat(n, '" cannot be spread here as objects of type "')
                .concat(a, '" can never be of type "')
                .concat(s, '".'),
              r,
            ),
          );
        }
      },
    };
  }
  function qTt(e, t) {
    var r = e.getFragment(t);
    if (r) {
      var n = (0, DTt.typeFromAST)(e.getSchema(), r.typeCondition);
      if ((0, ez.isCompositeType)(n)) return n;
    }
  }
});
var iz = g((nz) => {
  "use strict";
  c();
  Object.defineProperty(nz, "__esModule", { value: !0 });
  nz.NoFragmentCyclesRule = FTt;
  var jTt = Ue();
  function FTt(e) {
    var t = Object.create(null),
      r = [],
      n = Object.create(null);
    return {
      OperationDefinition: function () {
        return !1;
      },
      FragmentDefinition: function (a) {
        return i(a), !1;
      },
    };
    function i(o) {
      if (!t[o.name.value]) {
        var a = o.name.value;
        t[a] = !0;
        var s = e.getFragmentSpreads(o.selectionSet);
        if (s.length !== 0) {
          n[a] = r.length;
          for (var u = 0; u < s.length; u++) {
            var l = s[u],
              d = l.name.value,
              f = n[d];
            if ((r.push(l), f === void 0)) {
              var m = e.getFragment(d);
              m && i(m);
            } else {
              var h = r.slice(f),
                y = h
                  .slice(0, -1)
                  .map(function (_) {
                    return '"' + _.name.value + '"';
                  })
                  .join(", ");
              e.reportError(
                new jTt.GraphQLError(
                  'Cannot spread fragment "'.concat(d, '" within itself') +
                    (y !== "" ? " via ".concat(y, ".") : "."),
                  h,
                ),
              );
            }
            r.pop();
          }
          n[a] = void 0;
        }
      }
    }
  }
});
var az = g((oz) => {
  "use strict";
  c();
  Object.defineProperty(oz, "__esModule", { value: !0 });
  oz.UniqueVariableNamesRule = UTt;
  var BTt = Ue();
  function UTt(e) {
    var t = Object.create(null);
    return {
      OperationDefinition: function () {
        t = Object.create(null);
      },
      VariableDefinition: function (n) {
        var i = n.variable.name.value;
        t[i]
          ? e.reportError(
              new BTt.GraphQLError(
                'There can be only one variable named "$'.concat(i, '".'),
                [t[i], n.variable.name],
              ),
            )
          : (t[i] = n.variable.name);
      },
    };
  }
});
var cz = g((sz) => {
  "use strict";
  c();
  Object.defineProperty(sz, "__esModule", { value: !0 });
  sz.NoUndefinedVariablesRule = GTt;
  var HTt = Ue();
  function GTt(e) {
    var t = Object.create(null);
    return {
      OperationDefinition: {
        enter: function () {
          t = Object.create(null);
        },
        leave: function (n) {
          for (
            var i = e.getRecursiveVariableUsages(n), o = 0;
            o < i.length;
            o++
          ) {
            var a = i[o],
              s = a.node,
              u = s.name.value;
            t[u] !== !0 &&
              e.reportError(
                new HTt.GraphQLError(
                  n.name
                    ? 'Variable "$'
                        .concat(u, '" is not defined by operation "')
                        .concat(n.name.value, '".')
                    : 'Variable "$'.concat(u, '" is not defined.'),
                  [s, n],
                ),
              );
          }
        },
      },
      VariableDefinition: function (n) {
        t[n.variable.name.value] = !0;
      },
    };
  }
});
var lz = g((uz) => {
  "use strict";
  c();
  Object.defineProperty(uz, "__esModule", { value: !0 });
  uz.NoUnusedVariablesRule = $Tt;
  var VTt = Ue();
  function $Tt(e) {
    var t = [];
    return {
      OperationDefinition: {
        enter: function () {
          t = [];
        },
        leave: function (n) {
          for (
            var i = Object.create(null),
              o = e.getRecursiveVariableUsages(n),
              a = 0;
            a < o.length;
            a++
          ) {
            var s = o[a],
              u = s.node;
            i[u.name.value] = !0;
          }
          for (var l = 0, d = t; l < d.length; l++) {
            var f = d[l],
              m = f.variable.name.value;
            i[m] !== !0 &&
              e.reportError(
                new VTt.GraphQLError(
                  n.name
                    ? 'Variable "$'
                        .concat(m, '" is never used in operation "')
                        .concat(n.name.value, '".')
                    : 'Variable "$'.concat(m, '" is never used.'),
                  f,
                ),
              );
          }
        },
      },
      VariableDefinition: function (n) {
        t.push(n);
      },
    };
  }
});
var fz = g((dz) => {
  "use strict";
  c();
  Object.defineProperty(dz, "__esModule", { value: !0 });
  dz.KnownDirectivesRule = WTt;
  var zTt = ffe(Lt()),
    dfe = ffe(vi()),
    lfe = Ue(),
    Mr = lr(),
    Hn = Vv(),
    KTt = bo();
  function ffe(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function WTt(e) {
    for (
      var t = Object.create(null),
        r = e.getSchema(),
        n = r ? r.getDirectives() : KTt.specifiedDirectives,
        i = 0;
      i < n.length;
      i++
    ) {
      var o = n[i];
      t[o.name] = o.locations;
    }
    for (var a = e.getDocument().definitions, s = 0; s < a.length; s++) {
      var u = a[s];
      u.kind === Mr.Kind.DIRECTIVE_DEFINITION &&
        (t[u.name.value] = u.locations.map(function (l) {
          return l.value;
        }));
    }
    return {
      Directive: function (d, f, m, h, y) {
        var _ = d.name.value,
          E = t[_];
        if (!E) {
          e.reportError(
            new lfe.GraphQLError('Unknown directive "@'.concat(_, '".'), d),
          );
          return;
        }
        var b = QTt(y);
        b &&
          E.indexOf(b) === -1 &&
          e.reportError(
            new lfe.GraphQLError(
              'Directive "@'.concat(_, '" may not be used on ').concat(b, "."),
              d,
            ),
          );
      },
    };
  }
  function QTt(e) {
    var t = e[e.length - 1];
    switch ((!Array.isArray(t) || (0, dfe.default)(0), t.kind)) {
      case Mr.Kind.OPERATION_DEFINITION:
        return YTt(t.operation);
      case Mr.Kind.FIELD:
        return Hn.DirectiveLocation.FIELD;
      case Mr.Kind.FRAGMENT_SPREAD:
        return Hn.DirectiveLocation.FRAGMENT_SPREAD;
      case Mr.Kind.INLINE_FRAGMENT:
        return Hn.DirectiveLocation.INLINE_FRAGMENT;
      case Mr.Kind.FRAGMENT_DEFINITION:
        return Hn.DirectiveLocation.FRAGMENT_DEFINITION;
      case Mr.Kind.VARIABLE_DEFINITION:
        return Hn.DirectiveLocation.VARIABLE_DEFINITION;
      case Mr.Kind.SCHEMA_DEFINITION:
      case Mr.Kind.SCHEMA_EXTENSION:
        return Hn.DirectiveLocation.SCHEMA;
      case Mr.Kind.SCALAR_TYPE_DEFINITION:
      case Mr.Kind.SCALAR_TYPE_EXTENSION:
        return Hn.DirectiveLocation.SCALAR;
      case Mr.Kind.OBJECT_TYPE_DEFINITION:
      case Mr.Kind.OBJECT_TYPE_EXTENSION:
        return Hn.DirectiveLocation.OBJECT;
      case Mr.Kind.FIELD_DEFINITION:
        return Hn.DirectiveLocation.FIELD_DEFINITION;
      case Mr.Kind.INTERFACE_TYPE_DEFINITION:
      case Mr.Kind.INTERFACE_TYPE_EXTENSION:
        return Hn.DirectiveLocation.INTERFACE;
      case Mr.Kind.UNION_TYPE_DEFINITION:
      case Mr.Kind.UNION_TYPE_EXTENSION:
        return Hn.DirectiveLocation.UNION;
      case Mr.Kind.ENUM_TYPE_DEFINITION:
      case Mr.Kind.ENUM_TYPE_EXTENSION:
        return Hn.DirectiveLocation.ENUM;
      case Mr.Kind.ENUM_VALUE_DEFINITION:
        return Hn.DirectiveLocation.ENUM_VALUE;
      case Mr.Kind.INPUT_OBJECT_TYPE_DEFINITION:
      case Mr.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return Hn.DirectiveLocation.INPUT_OBJECT;
      case Mr.Kind.INPUT_VALUE_DEFINITION: {
        var r = e[e.length - 3];
        return r.kind === Mr.Kind.INPUT_OBJECT_TYPE_DEFINITION
          ? Hn.DirectiveLocation.INPUT_FIELD_DEFINITION
          : Hn.DirectiveLocation.ARGUMENT_DEFINITION;
      }
    }
  }
  function YTt(e) {
    switch (e) {
      case "query":
        return Hn.DirectiveLocation.QUERY;
      case "mutation":
        return Hn.DirectiveLocation.MUTATION;
      case "subscription":
        return Hn.DirectiveLocation.SUBSCRIPTION;
    }
    (0, dfe.default)(0, "Unexpected operation: " + (0, zTt.default)(e));
  }
});
var hz = g((mz) => {
  "use strict";
  c();
  Object.defineProperty(mz, "__esModule", { value: !0 });
  mz.UniqueDirectivesPerLocationRule = ZTt;
  var XTt = Ue(),
    pz = lr(),
    pfe = Tm(),
    JTt = bo();
  function ZTt(e) {
    for (
      var t = Object.create(null),
        r = e.getSchema(),
        n = r ? r.getDirectives() : JTt.specifiedDirectives,
        i = 0;
      i < n.length;
      i++
    ) {
      var o = n[i];
      t[o.name] = !o.isRepeatable;
    }
    for (var a = e.getDocument().definitions, s = 0; s < a.length; s++) {
      var u = a[s];
      u.kind === pz.Kind.DIRECTIVE_DEFINITION &&
        (t[u.name.value] = !u.repeatable);
    }
    var l = Object.create(null),
      d = Object.create(null);
    return {
      enter: function (m) {
        if (m.directives != null) {
          var h;
          if (
            m.kind === pz.Kind.SCHEMA_DEFINITION ||
            m.kind === pz.Kind.SCHEMA_EXTENSION
          )
            h = l;
          else if (
            (0, pfe.isTypeDefinitionNode)(m) ||
            (0, pfe.isTypeExtensionNode)(m)
          ) {
            var y = m.name.value;
            (h = d[y]), h === void 0 && (d[y] = h = Object.create(null));
          } else h = Object.create(null);
          for (var _ = 0, E = m.directives; _ < E.length; _++) {
            var b = E[_],
              O = b.name.value;
            t[O] &&
              (h[O]
                ? e.reportError(
                    new XTt.GraphQLError(
                      'The directive "@'.concat(
                        O,
                        '" can only be used once at this location.',
                      ),
                      [h[O], b],
                    ),
                  )
                : (h[O] = b));
          }
        }
      },
    };
  }
});
var gz = g((EN) => {
  "use strict";
  c();
  Object.defineProperty(EN, "__esModule", { value: !0 });
  EN.KnownArgumentNamesRule = nAt;
  EN.KnownArgumentNamesOnDirectivesRule = Efe;
  var gfe = _fe(Hd()),
    vfe = _fe(Gd()),
    yfe = Ue(),
    eAt = lr(),
    tAt = bo();
  function _fe(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function mfe(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function (i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function hfe(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2
        ? mfe(Object(r), !0).forEach(function (n) {
            rAt(e, n, r[n]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : mfe(Object(r)).forEach(function (n) {
              Object.defineProperty(
                e,
                n,
                Object.getOwnPropertyDescriptor(r, n),
              );
            });
    }
    return e;
  }
  function rAt(e, t, r) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = r),
      e
    );
  }
  function nAt(e) {
    return hfe(
      hfe({}, Efe(e)),
      {},
      {
        Argument: function (r) {
          var n = e.getArgument(),
            i = e.getFieldDef(),
            o = e.getParentType();
          if (!n && i && o) {
            var a = r.name.value,
              s = i.args.map(function (l) {
                return l.name;
              }),
              u = (0, vfe.default)(a, s);
            e.reportError(
              new yfe.GraphQLError(
                'Unknown argument "'
                  .concat(a, '" on field "')
                  .concat(o.name, ".")
                  .concat(i.name, '".') + (0, gfe.default)(u),
                r,
              ),
            );
          }
        },
      },
    );
  }
  function Efe(e) {
    for (
      var t = Object.create(null),
        r = e.getSchema(),
        n = r ? r.getDirectives() : tAt.specifiedDirectives,
        i = 0;
      i < n.length;
      i++
    ) {
      var o = n[i];
      t[o.name] = o.args.map(function (f) {
        return f.name;
      });
    }
    for (var a = e.getDocument().definitions, s = 0; s < a.length; s++) {
      var u = a[s];
      if (u.kind === eAt.Kind.DIRECTIVE_DEFINITION) {
        var l,
          d = (l = u.arguments) !== null && l !== void 0 ? l : [];
        t[u.name.value] = d.map(function (f) {
          return f.name.value;
        });
      }
    }
    return {
      Directive: function (m) {
        var h = m.name.value,
          y = t[h];
        if (m.arguments && y)
          for (var _ = 0, E = m.arguments; _ < E.length; _++) {
            var b = E[_],
              O = b.name.value;
            if (y.indexOf(O) === -1) {
              var C = (0, vfe.default)(O, y);
              e.reportError(
                new yfe.GraphQLError(
                  'Unknown argument "'
                    .concat(O, '" on directive "@')
                    .concat(h, '".') + (0, gfe.default)(C),
                  b,
                ),
              );
            }
          }
        return !1;
      },
    };
  }
});
var yz = g((vz) => {
  "use strict";
  c();
  Object.defineProperty(vz, "__esModule", { value: !0 });
  vz.UniqueArgumentNamesRule = oAt;
  var iAt = Ue();
  function oAt(e) {
    var t = Object.create(null);
    return {
      Field: function () {
        t = Object.create(null);
      },
      Directive: function () {
        t = Object.create(null);
      },
      Argument: function (n) {
        var i = n.name.value;
        return (
          t[i]
            ? e.reportError(
                new iAt.GraphQLError(
                  'There can be only one argument named "'.concat(i, '".'),
                  [t[i], n.name],
                ),
              )
            : (t[i] = n.name),
          !1
        );
      },
    };
  }
});
var Ez = g((_z) => {
  "use strict";
  c();
  Object.defineProperty(_z, "__esModule", { value: !0 });
  _z.ValuesOfCorrectTypeRule = lAt;
  var aAt = P0(ea()),
    sAt = P0(Ud()),
    A0 = P0(Lt()),
    cAt = P0(Hd()),
    uAt = P0(Gd()),
    Pm = Ue(),
    bN = ta(),
    Ic = It();
  function P0(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function lAt(e) {
    return {
      ListValue: function (r) {
        var n = (0, Ic.getNullableType)(e.getParentInputType());
        if (!(0, Ic.isListType)(n)) return Am(e, r), !1;
      },
      ObjectValue: function (r) {
        var n = (0, Ic.getNamedType)(e.getInputType());
        if (!(0, Ic.isInputObjectType)(n)) return Am(e, r), !1;
        for (
          var i = (0, sAt.default)(r.fields, function (d) {
              return d.name.value;
            }),
            o = 0,
            a = (0, aAt.default)(n.getFields());
          o < a.length;
          o++
        ) {
          var s = a[o],
            u = i[s.name];
          if (!u && (0, Ic.isRequiredInputField)(s)) {
            var l = (0, A0.default)(s.type);
            e.reportError(
              new Pm.GraphQLError(
                'Field "'
                  .concat(n.name, ".")
                  .concat(s.name, '" of required type "')
                  .concat(l, '" was not provided.'),
                r,
              ),
            );
          }
        }
      },
      ObjectField: function (r) {
        var n = (0, Ic.getNamedType)(e.getParentInputType()),
          i = e.getInputType();
        if (!i && (0, Ic.isInputObjectType)(n)) {
          var o = (0, uAt.default)(r.name.value, Object.keys(n.getFields()));
          e.reportError(
            new Pm.GraphQLError(
              'Field "'
                .concat(r.name.value, '" is not defined by type "')
                .concat(n.name, '".') + (0, cAt.default)(o),
              r,
            ),
          );
        }
      },
      NullValue: function (r) {
        var n = e.getInputType();
        (0, Ic.isNonNullType)(n) &&
          e.reportError(
            new Pm.GraphQLError(
              'Expected value of type "'
                .concat((0, A0.default)(n), '", found ')
                .concat((0, bN.print)(r), "."),
              r,
            ),
          );
      },
      EnumValue: function (r) {
        return Am(e, r);
      },
      IntValue: function (r) {
        return Am(e, r);
      },
      FloatValue: function (r) {
        return Am(e, r);
      },
      StringValue: function (r) {
        return Am(e, r);
      },
      BooleanValue: function (r) {
        return Am(e, r);
      },
    };
  }
  function Am(e, t) {
    var r = e.getInputType();
    if (r) {
      var n = (0, Ic.getNamedType)(r);
      if (!(0, Ic.isLeafType)(n)) {
        var i = (0, A0.default)(r);
        e.reportError(
          new Pm.GraphQLError(
            'Expected value of type "'
              .concat(i, '", found ')
              .concat((0, bN.print)(t), "."),
            t,
          ),
        );
        return;
      }
      try {
        var o = n.parseLiteral(t, void 0);
        if (o === void 0) {
          var a = (0, A0.default)(r);
          e.reportError(
            new Pm.GraphQLError(
              'Expected value of type "'
                .concat(a, '", found ')
                .concat((0, bN.print)(t), "."),
              t,
            ),
          );
        }
      } catch (u) {
        var s = (0, A0.default)(r);
        u instanceof Pm.GraphQLError
          ? e.reportError(u)
          : e.reportError(
              new Pm.GraphQLError(
                'Expected value of type "'
                  .concat(s, '", found ')
                  .concat((0, bN.print)(t), "; ") + u.message,
                t,
                void 0,
                void 0,
                void 0,
                u,
              ),
            );
      }
    }
  }
});
var Sz = g((CN) => {
  "use strict";
  c();
  Object.defineProperty(CN, "__esModule", { value: !0 });
  CN.ProvidedRequiredArgumentsRule = mAt;
  CN.ProvidedRequiredArgumentsOnDirectivesRule = Afe;
  var Cfe = Tfe(Lt()),
    SN = Tfe(Ud()),
    wfe = Ue(),
    Ofe = lr(),
    dAt = ta(),
    fAt = bo(),
    bz = It();
  function Tfe(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function bfe(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function (i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function Sfe(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2
        ? bfe(Object(r), !0).forEach(function (n) {
            pAt(e, n, r[n]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : bfe(Object(r)).forEach(function (n) {
              Object.defineProperty(
                e,
                n,
                Object.getOwnPropertyDescriptor(r, n),
              );
            });
    }
    return e;
  }
  function pAt(e, t, r) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = r),
      e
    );
  }
  function mAt(e) {
    return Sfe(
      Sfe({}, Afe(e)),
      {},
      {
        Field: {
          leave: function (r) {
            var n,
              i = e.getFieldDef();
            if (!i) return !1;
            for (
              var o = (n = r.arguments) !== null && n !== void 0 ? n : [],
                a = (0, SN.default)(o, function (m) {
                  return m.name.value;
                }),
                s = 0,
                u = i.args;
              s < u.length;
              s++
            ) {
              var l = u[s],
                d = a[l.name];
              if (!d && (0, bz.isRequiredArgument)(l)) {
                var f = (0, Cfe.default)(l.type);
                e.reportError(
                  new wfe.GraphQLError(
                    'Field "'
                      .concat(i.name, '" argument "')
                      .concat(l.name, '" of type "')
                      .concat(f, '" is required, but it was not provided.'),
                    r,
                  ),
                );
              }
            }
          },
        },
      },
    );
  }
  function Afe(e) {
    for (
      var t = Object.create(null),
        r = e.getSchema(),
        n = r ? r.getDirectives() : fAt.specifiedDirectives,
        i = 0;
      i < n.length;
      i++
    ) {
      var o = n[i];
      t[o.name] = (0, SN.default)(
        o.args.filter(bz.isRequiredArgument),
        function (f) {
          return f.name;
        },
      );
    }
    for (var a = e.getDocument().definitions, s = 0; s < a.length; s++) {
      var u = a[s];
      if (u.kind === Ofe.Kind.DIRECTIVE_DEFINITION) {
        var l,
          d = (l = u.arguments) !== null && l !== void 0 ? l : [];
        t[u.name.value] = (0, SN.default)(d.filter(hAt), function (f) {
          return f.name.value;
        });
      }
    }
    return {
      Directive: {
        leave: function (m) {
          var h = m.name.value,
            y = t[h];
          if (y)
            for (
              var _,
                E = (_ = m.arguments) !== null && _ !== void 0 ? _ : [],
                b = (0, SN.default)(E, function (B) {
                  return B.name.value;
                }),
                O = 0,
                C = Object.keys(y);
              O < C.length;
              O++
            ) {
              var P = C[O];
              if (!b[P]) {
                var k = y[P].type,
                  H = (0, bz.isType)(k)
                    ? (0, Cfe.default)(k)
                    : (0, dAt.print)(k);
                e.reportError(
                  new wfe.GraphQLError(
                    'Directive "@'
                      .concat(h, '" argument "')
                      .concat(P, '" of type "')
                      .concat(H, '" is required, but it was not provided.'),
                    m,
                  ),
                );
              }
            }
        },
      },
    };
  }
  function hAt(e) {
    return e.type.kind === Ofe.Kind.NON_NULL_TYPE && e.defaultValue == null;
  }
});
var wz = g((Cz) => {
  "use strict";
  c();
  Object.defineProperty(Cz, "__esModule", { value: !0 });
  Cz.VariablesInAllowedPositionRule = EAt;
  var Pfe = _At(Lt()),
    gAt = Ue(),
    vAt = lr(),
    Rfe = It(),
    yAt = Rc(),
    Ife = m0();
  function _At(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function EAt(e) {
    var t = Object.create(null);
    return {
      OperationDefinition: {
        enter: function () {
          t = Object.create(null);
        },
        leave: function (n) {
          for (
            var i = e.getRecursiveVariableUsages(n), o = 0;
            o < i.length;
            o++
          ) {
            var a = i[o],
              s = a.node,
              u = a.type,
              l = a.defaultValue,
              d = s.name.value,
              f = t[d];
            if (f && u) {
              var m = e.getSchema(),
                h = (0, yAt.typeFromAST)(m, f.type);
              if (h && !bAt(m, h, f.defaultValue, u, l)) {
                var y = (0, Pfe.default)(h),
                  _ = (0, Pfe.default)(u);
                e.reportError(
                  new gAt.GraphQLError(
                    'Variable "$'
                      .concat(d, '" of type "')
                      .concat(y, '" used in position expecting type "')
                      .concat(_, '".'),
                    [f, s],
                  ),
                );
              }
            }
          }
        },
      },
      VariableDefinition: function (n) {
        t[n.variable.name.value] = n;
      },
    };
  }
  function bAt(e, t, r, n, i) {
    if ((0, Rfe.isNonNullType)(n) && !(0, Rfe.isNonNullType)(t)) {
      var o = r != null && r.kind !== vAt.Kind.NULL,
        a = i !== void 0;
      if (!o && !a) return !1;
      var s = n.ofType;
      return (0, Ife.isTypeSubTypeOf)(e, t, s);
    }
    return (0, Ife.isTypeSubTypeOf)(e, t, n);
  }
});
var xz = g((Iz) => {
  "use strict";
  c();
  Object.defineProperty(Iz, "__esModule", { value: !0 });
  Iz.OverlappingFieldsCanBeMergedRule = OAt;
  var SAt = Pz(Wv()),
    CAt = Pz(Qv()),
    xfe = Pz(Lt()),
    wAt = Ue(),
    Oz = lr(),
    Nfe = ta(),
    So = It(),
    kfe = Rc();
  function Pz(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Dfe(e) {
    return Array.isArray(e)
      ? e
          .map(function (t) {
            var r = t[0],
              n = t[1];
            return 'subfields "'.concat(r, '" conflict because ') + Dfe(n);
          })
          .join(" and ")
      : e;
  }
  function OAt(e) {
    var t = new NAt(),
      r = new Map();
    return {
      SelectionSet: function (i) {
        for (
          var o = TAt(e, r, t, e.getParentType(), i), a = 0;
          a < o.length;
          a++
        ) {
          var s = o[a],
            u = s[0],
            l = u[0],
            d = u[1],
            f = s[1],
            m = s[2],
            h = Dfe(d);
          e.reportError(
            new wAt.GraphQLError(
              'Fields "'
                .concat(l, '" conflict because ')
                .concat(
                  h,
                  ". Use different aliases on the fields to fetch both if this was intentional.",
                ),
              f.concat(m),
            ),
          );
        }
      },
    };
  }
  function TAt(e, t, r, n, i) {
    var o = [],
      a = TN(e, t, n, i),
      s = a[0],
      u = a[1];
    if ((PAt(e, o, t, r, s), u.length !== 0))
      for (var l = 0; l < u.length; l++) {
        wN(e, o, t, r, !1, s, u[l]);
        for (var d = l + 1; d < u.length; d++) ON(e, o, t, r, !1, u[l], u[d]);
      }
    return o;
  }
  function wN(e, t, r, n, i, o, a) {
    var s = e.getFragment(a);
    if (s) {
      var u = Az(e, r, s),
        l = u[0],
        d = u[1];
      if (o !== l) {
        Rz(e, t, r, n, i, o, l);
        for (var f = 0; f < d.length; f++) wN(e, t, r, n, i, o, d[f]);
      }
    }
  }
  function ON(e, t, r, n, i, o, a) {
    if (o !== a && !n.has(o, a, i)) {
      n.add(o, a, i);
      var s = e.getFragment(o),
        u = e.getFragment(a);
      if (!(!s || !u)) {
        var l = Az(e, r, s),
          d = l[0],
          f = l[1],
          m = Az(e, r, u),
          h = m[0],
          y = m[1];
        Rz(e, t, r, n, i, d, h);
        for (var _ = 0; _ < y.length; _++) ON(e, t, r, n, i, o, y[_]);
        for (var E = 0; E < f.length; E++) ON(e, t, r, n, i, f[E], a);
      }
    }
  }
  function AAt(e, t, r, n, i, o, a, s) {
    var u = [],
      l = TN(e, t, i, o),
      d = l[0],
      f = l[1],
      m = TN(e, t, a, s),
      h = m[0],
      y = m[1];
    if ((Rz(e, u, t, r, n, d, h), y.length !== 0))
      for (var _ = 0; _ < y.length; _++) wN(e, u, t, r, n, d, y[_]);
    if (f.length !== 0)
      for (var E = 0; E < f.length; E++) wN(e, u, t, r, n, h, f[E]);
    for (var b = 0; b < f.length; b++)
      for (var O = 0; O < y.length; O++) ON(e, u, t, r, n, f[b], y[O]);
    return u;
  }
  function PAt(e, t, r, n, i) {
    for (var o = 0, a = (0, CAt.default)(i); o < a.length; o++) {
      var s = a[o],
        u = s[0],
        l = s[1];
      if (l.length > 1)
        for (var d = 0; d < l.length; d++)
          for (var f = d + 1; f < l.length; f++) {
            var m = Lfe(e, r, n, !1, u, l[d], l[f]);
            m && t.push(m);
          }
    }
  }
  function Rz(e, t, r, n, i, o, a) {
    for (var s = 0, u = Object.keys(o); s < u.length; s++) {
      var l = u[s],
        d = a[l];
      if (d)
        for (var f = o[l], m = 0; m < f.length; m++)
          for (var h = 0; h < d.length; h++) {
            var y = Lfe(e, r, n, i, l, f[m], d[h]);
            y && t.push(y);
          }
    }
  }
  function Lfe(e, t, r, n, i, o, a) {
    var s = o[0],
      u = o[1],
      l = o[2],
      d = a[0],
      f = a[1],
      m = a[2],
      h = n || (s !== d && (0, So.isObjectType)(s) && (0, So.isObjectType)(d));
    if (!h) {
      var y,
        _,
        E = u.name.value,
        b = f.name.value;
      if (E !== b)
        return [
          [i, '"'.concat(E, '" and "').concat(b, '" are different fields')],
          [u],
          [f],
        ];
      var O = (y = u.arguments) !== null && y !== void 0 ? y : [],
        C = (_ = f.arguments) !== null && _ !== void 0 ? _ : [];
      if (!RAt(O, C)) return [[i, "they have differing arguments"], [u], [f]];
    }
    var P = l?.type,
      k = m?.type;
    if (P && k && Tz(P, k))
      return [
        [
          i,
          'they return conflicting types "'
            .concat((0, xfe.default)(P), '" and "')
            .concat((0, xfe.default)(k), '"'),
        ],
        [u],
        [f],
      ];
    var H = u.selectionSet,
      B = f.selectionSet;
    if (H && B) {
      var L = AAt(
        e,
        t,
        r,
        h,
        (0, So.getNamedType)(P),
        H,
        (0, So.getNamedType)(k),
        B,
      );
      return xAt(L, i, u, f);
    }
  }
  function RAt(e, t) {
    return e.length !== t.length
      ? !1
      : e.every(function (r) {
          var n = (0, SAt.default)(t, function (i) {
            return i.name.value === r.name.value;
          });
          return n ? IAt(r.value, n.value) : !1;
        });
  }
  function IAt(e, t) {
    return (0, Nfe.print)(e) === (0, Nfe.print)(t);
  }
  function Tz(e, t) {
    return (0, So.isListType)(e)
      ? (0, So.isListType)(t)
        ? Tz(e.ofType, t.ofType)
        : !0
      : (0, So.isListType)(t)
        ? !0
        : (0, So.isNonNullType)(e)
          ? (0, So.isNonNullType)(t)
            ? Tz(e.ofType, t.ofType)
            : !0
          : (0, So.isNonNullType)(t)
            ? !0
            : (0, So.isLeafType)(e) || (0, So.isLeafType)(t)
              ? e !== t
              : !1;
  }
  function TN(e, t, r, n) {
    var i = t.get(n);
    if (!i) {
      var o = Object.create(null),
        a = Object.create(null);
      Mfe(e, r, n, o, a), (i = [o, Object.keys(a)]), t.set(n, i);
    }
    return i;
  }
  function Az(e, t, r) {
    var n = t.get(r.selectionSet);
    if (n) return n;
    var i = (0, kfe.typeFromAST)(e.getSchema(), r.typeCondition);
    return TN(e, t, i, r.selectionSet);
  }
  function Mfe(e, t, r, n, i) {
    for (var o = 0, a = r.selections; o < a.length; o++) {
      var s = a[o];
      switch (s.kind) {
        case Oz.Kind.FIELD: {
          var u = s.name.value,
            l = void 0;
          ((0, So.isObjectType)(t) || (0, So.isInterfaceType)(t)) &&
            (l = t.getFields()[u]);
          var d = s.alias ? s.alias.value : u;
          n[d] || (n[d] = []), n[d].push([t, s, l]);
          break;
        }
        case Oz.Kind.FRAGMENT_SPREAD:
          i[s.name.value] = !0;
          break;
        case Oz.Kind.INLINE_FRAGMENT: {
          var f = s.typeCondition,
            m = f ? (0, kfe.typeFromAST)(e.getSchema(), f) : t;
          Mfe(e, m, s.selectionSet, n, i);
          break;
        }
      }
    }
  }
  function xAt(e, t, r, n) {
    if (e.length > 0)
      return [
        [
          t,
          e.map(function (i) {
            var o = i[0];
            return o;
          }),
        ],
        e.reduce(
          function (i, o) {
            var a = o[1];
            return i.concat(a);
          },
          [r],
        ),
        e.reduce(
          function (i, o) {
            var a = o[2];
            return i.concat(a);
          },
          [n],
        ),
      ];
  }
  var NAt = (function () {
    function e() {
      this._data = Object.create(null);
    }
    var t = e.prototype;
    return (
      (t.has = function (n, i, o) {
        var a = this._data[n],
          s = a && a[i];
        return s === void 0 ? !1 : o === !1 ? s === !1 : !0;
      }),
      (t.add = function (n, i, o) {
        this._pairSetAdd(n, i, o), this._pairSetAdd(i, n, o);
      }),
      (t._pairSetAdd = function (n, i, o) {
        var a = this._data[n];
        a || ((a = Object.create(null)), (this._data[n] = a)), (a[i] = o);
      }),
      e
    );
  })();
});
var kz = g((Nz) => {
  "use strict";
  c();
  Object.defineProperty(Nz, "__esModule", { value: !0 });
  Nz.UniqueInputFieldNamesRule = DAt;
  var kAt = Ue();
  function DAt(e) {
    var t = [],
      r = Object.create(null);
    return {
      ObjectValue: {
        enter: function () {
          t.push(r), (r = Object.create(null));
        },
        leave: function () {
          r = t.pop();
        },
      },
      ObjectField: function (i) {
        var o = i.name.value;
        r[o]
          ? e.reportError(
              new kAt.GraphQLError(
                'There can be only one input field named "'.concat(o, '".'),
                [r[o], i.name],
              ),
            )
          : (r[o] = i.name);
      },
    };
  }
});
var Lz = g((Dz) => {
  "use strict";
  c();
  Object.defineProperty(Dz, "__esModule", { value: !0 });
  Dz.LoneSchemaDefinitionRule = LAt;
  var qfe = Ue();
  function LAt(e) {
    var t,
      r,
      n,
      i = e.getSchema(),
      o =
        (t =
          (r =
            (n = i?.astNode) !== null && n !== void 0
              ? n
              : i?.getQueryType()) !== null && r !== void 0
            ? r
            : i?.getMutationType()) !== null && t !== void 0
          ? t
          : i?.getSubscriptionType(),
      a = 0;
    return {
      SchemaDefinition: function (u) {
        if (o) {
          e.reportError(
            new qfe.GraphQLError(
              "Cannot define a new schema within a schema extension.",
              u,
            ),
          );
          return;
        }
        a > 0 &&
          e.reportError(
            new qfe.GraphQLError("Must provide only one schema definition.", u),
          ),
          ++a;
      },
    };
  }
});
var qz = g((Mz) => {
  "use strict";
  c();
  Object.defineProperty(Mz, "__esModule", { value: !0 });
  Mz.UniqueOperationTypesRule = MAt;
  var jfe = Ue();
  function MAt(e) {
    var t = e.getSchema(),
      r = Object.create(null),
      n = t
        ? {
            query: t.getQueryType(),
            mutation: t.getMutationType(),
            subscription: t.getSubscriptionType(),
          }
        : {};
    return { SchemaDefinition: i, SchemaExtension: i };
    function i(o) {
      for (
        var a,
          s = (a = o.operationTypes) !== null && a !== void 0 ? a : [],
          u = 0;
        u < s.length;
        u++
      ) {
        var l = s[u],
          d = l.operation,
          f = r[d];
        n[d]
          ? e.reportError(
              new jfe.GraphQLError(
                "Type for ".concat(
                  d,
                  " already defined in the schema. It cannot be redefined.",
                ),
                l,
              ),
            )
          : f
            ? e.reportError(
                new jfe.GraphQLError(
                  "There can be only one ".concat(d, " type in schema."),
                  [f, l],
                ),
              )
            : (r[d] = l);
      }
      return !1;
    }
  }
});
var Fz = g((jz) => {
  "use strict";
  c();
  Object.defineProperty(jz, "__esModule", { value: !0 });
  jz.UniqueTypeNamesRule = qAt;
  var Ffe = Ue();
  function qAt(e) {
    var t = Object.create(null),
      r = e.getSchema();
    return {
      ScalarTypeDefinition: n,
      ObjectTypeDefinition: n,
      InterfaceTypeDefinition: n,
      UnionTypeDefinition: n,
      EnumTypeDefinition: n,
      InputObjectTypeDefinition: n,
    };
    function n(i) {
      var o = i.name.value;
      if (r != null && r.getType(o)) {
        e.reportError(
          new Ffe.GraphQLError(
            'Type "'.concat(
              o,
              '" already exists in the schema. It cannot also be defined in this type definition.',
            ),
            i.name,
          ),
        );
        return;
      }
      return (
        t[o]
          ? e.reportError(
              new Ffe.GraphQLError(
                'There can be only one type named "'.concat(o, '".'),
                [t[o], i.name],
              ),
            )
          : (t[o] = i.name),
        !1
      );
    }
  }
});
var Uz = g((Bz) => {
  "use strict";
  c();
  Object.defineProperty(Bz, "__esModule", { value: !0 });
  Bz.UniqueEnumValueNamesRule = FAt;
  var Bfe = Ue(),
    jAt = It();
  function FAt(e) {
    var t = e.getSchema(),
      r = t ? t.getTypeMap() : Object.create(null),
      n = Object.create(null);
    return { EnumTypeDefinition: i, EnumTypeExtension: i };
    function i(o) {
      var a,
        s = o.name.value;
      n[s] || (n[s] = Object.create(null));
      for (
        var u = (a = o.values) !== null && a !== void 0 ? a : [],
          l = n[s],
          d = 0;
        d < u.length;
        d++
      ) {
        var f = u[d],
          m = f.name.value,
          h = r[s];
        (0, jAt.isEnumType)(h) && h.getValue(m)
          ? e.reportError(
              new Bfe.GraphQLError(
                'Enum value "'
                  .concat(s, ".")
                  .concat(
                    m,
                    '" already exists in the schema. It cannot also be defined in this type extension.',
                  ),
                f.name,
              ),
            )
          : l[m]
            ? e.reportError(
                new Bfe.GraphQLError(
                  'Enum value "'
                    .concat(s, ".")
                    .concat(m, '" can only be defined once.'),
                  [l[m], f.name],
                ),
              )
            : (l[m] = f.name);
      }
      return !1;
    }
  }
});
var Vz = g((Gz) => {
  "use strict";
  c();
  Object.defineProperty(Gz, "__esModule", { value: !0 });
  Gz.UniqueFieldDefinitionNamesRule = BAt;
  var Ufe = Ue(),
    Hz = It();
  function BAt(e) {
    var t = e.getSchema(),
      r = t ? t.getTypeMap() : Object.create(null),
      n = Object.create(null);
    return {
      InputObjectTypeDefinition: i,
      InputObjectTypeExtension: i,
      InterfaceTypeDefinition: i,
      InterfaceTypeExtension: i,
      ObjectTypeDefinition: i,
      ObjectTypeExtension: i,
    };
    function i(o) {
      var a,
        s = o.name.value;
      n[s] || (n[s] = Object.create(null));
      for (
        var u = (a = o.fields) !== null && a !== void 0 ? a : [],
          l = n[s],
          d = 0;
        d < u.length;
        d++
      ) {
        var f = u[d],
          m = f.name.value;
        UAt(r[s], m)
          ? e.reportError(
              new Ufe.GraphQLError(
                'Field "'
                  .concat(s, ".")
                  .concat(
                    m,
                    '" already exists in the schema. It cannot also be defined in this type extension.',
                  ),
                f.name,
              ),
            )
          : l[m]
            ? e.reportError(
                new Ufe.GraphQLError(
                  'Field "'
                    .concat(s, ".")
                    .concat(m, '" can only be defined once.'),
                  [l[m], f.name],
                ),
              )
            : (l[m] = f.name);
      }
      return !1;
    }
  }
  function UAt(e, t) {
    return (0, Hz.isObjectType)(e) ||
      (0, Hz.isInterfaceType)(e) ||
      (0, Hz.isInputObjectType)(e)
      ? e.getFields()[t] != null
      : !1;
  }
});
var zz = g(($z) => {
  "use strict";
  c();
  Object.defineProperty($z, "__esModule", { value: !0 });
  $z.UniqueDirectiveNamesRule = HAt;
  var Hfe = Ue();
  function HAt(e) {
    var t = Object.create(null),
      r = e.getSchema();
    return {
      DirectiveDefinition: function (i) {
        var o = i.name.value;
        if (r != null && r.getDirective(o)) {
          e.reportError(
            new Hfe.GraphQLError(
              'Directive "@'.concat(
                o,
                '" already exists in the schema. It cannot be redefined.',
              ),
              i.name,
            ),
          );
          return;
        }
        return (
          t[o]
            ? e.reportError(
                new Hfe.GraphQLError(
                  'There can be only one directive named "@'.concat(o, '".'),
                  [t[o], i.name],
                ),
              )
            : (t[o] = i.name),
          !1
        );
      },
    };
  }
});
var Wz = g((Kz) => {
  "use strict";
  c();
  Object.defineProperty(Kz, "__esModule", { value: !0 });
  Kz.PossibleTypeExtensionsRule = zAt;
  var Vfe = AN(Lt()),
    $fe = AN(vi()),
    GAt = AN(Hd()),
    VAt = AN(Gd()),
    Gfe = Ue(),
    Gr = lr(),
    $At = Tm(),
    iy = It(),
    Xd;
  function AN(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function oy(e, t, r) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = r),
      e
    );
  }
  function zAt(e) {
    for (
      var t = e.getSchema(),
        r = Object.create(null),
        n = 0,
        i = e.getDocument().definitions;
      n < i.length;
      n++
    ) {
      var o = i[n];
      (0, $At.isTypeDefinitionNode)(o) && (r[o.name.value] = o);
    }
    return {
      ScalarTypeExtension: a,
      ObjectTypeExtension: a,
      InterfaceTypeExtension: a,
      UnionTypeExtension: a,
      EnumTypeExtension: a,
      InputObjectTypeExtension: a,
    };
    function a(s) {
      var u = s.name.value,
        l = r[u],
        d = t?.getType(u),
        f;
      if ((l ? (f = KAt[l.kind]) : d && (f = WAt(d)), f)) {
        if (f !== s.kind) {
          var m = QAt(s.kind);
          e.reportError(
            new Gfe.GraphQLError(
              "Cannot extend non-".concat(m, ' type "').concat(u, '".'),
              l ? [l, s] : s,
            ),
          );
        }
      } else {
        var h = Object.keys(r);
        t && (h = h.concat(Object.keys(t.getTypeMap())));
        var y = (0, VAt.default)(u, h);
        e.reportError(
          new Gfe.GraphQLError(
            'Cannot extend type "'.concat(u, '" because it is not defined.') +
              (0, GAt.default)(y),
            s.name,
          ),
        );
      }
    }
  }
  var KAt =
    ((Xd = {}),
    oy(Xd, Gr.Kind.SCALAR_TYPE_DEFINITION, Gr.Kind.SCALAR_TYPE_EXTENSION),
    oy(Xd, Gr.Kind.OBJECT_TYPE_DEFINITION, Gr.Kind.OBJECT_TYPE_EXTENSION),
    oy(Xd, Gr.Kind.INTERFACE_TYPE_DEFINITION, Gr.Kind.INTERFACE_TYPE_EXTENSION),
    oy(Xd, Gr.Kind.UNION_TYPE_DEFINITION, Gr.Kind.UNION_TYPE_EXTENSION),
    oy(Xd, Gr.Kind.ENUM_TYPE_DEFINITION, Gr.Kind.ENUM_TYPE_EXTENSION),
    oy(
      Xd,
      Gr.Kind.INPUT_OBJECT_TYPE_DEFINITION,
      Gr.Kind.INPUT_OBJECT_TYPE_EXTENSION,
    ),
    Xd);
  function WAt(e) {
    if ((0, iy.isScalarType)(e)) return Gr.Kind.SCALAR_TYPE_EXTENSION;
    if ((0, iy.isObjectType)(e)) return Gr.Kind.OBJECT_TYPE_EXTENSION;
    if ((0, iy.isInterfaceType)(e)) return Gr.Kind.INTERFACE_TYPE_EXTENSION;
    if ((0, iy.isUnionType)(e)) return Gr.Kind.UNION_TYPE_EXTENSION;
    if ((0, iy.isEnumType)(e)) return Gr.Kind.ENUM_TYPE_EXTENSION;
    if ((0, iy.isInputObjectType)(e))
      return Gr.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    (0, $fe.default)(0, "Unexpected type: " + (0, Vfe.default)(e));
  }
  function QAt(e) {
    switch (e) {
      case Gr.Kind.SCALAR_TYPE_EXTENSION:
        return "scalar";
      case Gr.Kind.OBJECT_TYPE_EXTENSION:
        return "object";
      case Gr.Kind.INTERFACE_TYPE_EXTENSION:
        return "interface";
      case Gr.Kind.UNION_TYPE_EXTENSION:
        return "union";
      case Gr.Kind.ENUM_TYPE_EXTENSION:
        return "enum";
      case Gr.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return "input object";
    }
    (0, $fe.default)(0, "Unexpected kind: " + (0, Vfe.default)(e));
  }
});
var Qz = g((ay) => {
  "use strict";
  c();
  Object.defineProperty(ay, "__esModule", { value: !0 });
  ay.specifiedSDLRules = ay.specifiedRules = void 0;
  var YAt = I$(),
    XAt = N$(),
    JAt = D$(),
    ZAt = M$(),
    zfe = F$(),
    ePt = U$(),
    tPt = G$(),
    rPt = $$(),
    nPt = K$(),
    iPt = Q$(),
    oPt = X$(),
    aPt = Z$(),
    sPt = rz(),
    cPt = iz(),
    uPt = az(),
    lPt = cz(),
    dPt = lz(),
    Kfe = fz(),
    Wfe = hz(),
    Qfe = gz(),
    Yfe = yz(),
    fPt = Ez(),
    Xfe = Sz(),
    pPt = wz(),
    mPt = xz(),
    Jfe = kz(),
    hPt = Lz(),
    gPt = qz(),
    vPt = Fz(),
    yPt = Uz(),
    _Pt = Vz(),
    EPt = zz(),
    bPt = Wz(),
    SPt = Object.freeze([
      YAt.ExecutableDefinitionsRule,
      XAt.UniqueOperationNamesRule,
      JAt.LoneAnonymousOperationRule,
      ZAt.SingleFieldSubscriptionsRule,
      zfe.KnownTypeNamesRule,
      ePt.FragmentsOnCompositeTypesRule,
      tPt.VariablesAreInputTypesRule,
      rPt.ScalarLeafsRule,
      nPt.FieldsOnCorrectTypeRule,
      iPt.UniqueFragmentNamesRule,
      oPt.KnownFragmentNamesRule,
      aPt.NoUnusedFragmentsRule,
      sPt.PossibleFragmentSpreadsRule,
      cPt.NoFragmentCyclesRule,
      uPt.UniqueVariableNamesRule,
      lPt.NoUndefinedVariablesRule,
      dPt.NoUnusedVariablesRule,
      Kfe.KnownDirectivesRule,
      Wfe.UniqueDirectivesPerLocationRule,
      Qfe.KnownArgumentNamesRule,
      Yfe.UniqueArgumentNamesRule,
      fPt.ValuesOfCorrectTypeRule,
      Xfe.ProvidedRequiredArgumentsRule,
      pPt.VariablesInAllowedPositionRule,
      mPt.OverlappingFieldsCanBeMergedRule,
      Jfe.UniqueInputFieldNamesRule,
    ]);
  ay.specifiedRules = SPt;
  var CPt = Object.freeze([
    hPt.LoneSchemaDefinitionRule,
    gPt.UniqueOperationTypesRule,
    vPt.UniqueTypeNamesRule,
    yPt.UniqueEnumValueNamesRule,
    _Pt.UniqueFieldDefinitionNamesRule,
    EPt.UniqueDirectiveNamesRule,
    zfe.KnownTypeNamesRule,
    Kfe.KnownDirectivesRule,
    Wfe.UniqueDirectivesPerLocationRule,
    bPt.PossibleTypeExtensionsRule,
    Qfe.KnownArgumentNamesOnDirectivesRule,
    Yfe.UniqueArgumentNamesRule,
    Jfe.UniqueInputFieldNamesRule,
    Xfe.ProvidedRequiredArgumentsOnDirectivesRule,
  ]);
  ay.specifiedSDLRules = CPt;
});
var Xz = g((Jd) => {
  "use strict";
  c();
  Object.defineProperty(Jd, "__esModule", { value: !0 });
  Jd.ValidationContext =
    Jd.SDLValidationContext =
    Jd.ASTValidationContext =
      void 0;
  var Zfe = lr(),
    wPt = Bd(),
    epe = vN();
  function tpe(e, t) {
    (e.prototype = Object.create(t.prototype)),
      (e.prototype.constructor = e),
      (e.__proto__ = t);
  }
  var Yz = (function () {
    function e(r, n) {
      (this._ast = r),
        (this._fragments = void 0),
        (this._fragmentSpreads = new Map()),
        (this._recursivelyReferencedFragments = new Map()),
        (this._onError = n);
    }
    var t = e.prototype;
    return (
      (t.reportError = function (n) {
        this._onError(n);
      }),
      (t.getDocument = function () {
        return this._ast;
      }),
      (t.getFragment = function (n) {
        var i = this._fragments;
        return (
          i ||
            (this._fragments = i =
              this.getDocument().definitions.reduce(function (o, a) {
                return (
                  a.kind === Zfe.Kind.FRAGMENT_DEFINITION &&
                    (o[a.name.value] = a),
                  o
                );
              }, Object.create(null))),
          i[n]
        );
      }),
      (t.getFragmentSpreads = function (n) {
        var i = this._fragmentSpreads.get(n);
        if (!i) {
          i = [];
          for (var o = [n]; o.length !== 0; )
            for (var a = o.pop(), s = 0, u = a.selections; s < u.length; s++) {
              var l = u[s];
              l.kind === Zfe.Kind.FRAGMENT_SPREAD
                ? i.push(l)
                : l.selectionSet && o.push(l.selectionSet);
            }
          this._fragmentSpreads.set(n, i);
        }
        return i;
      }),
      (t.getRecursivelyReferencedFragments = function (n) {
        var i = this._recursivelyReferencedFragments.get(n);
        if (!i) {
          i = [];
          for (
            var o = Object.create(null), a = [n.selectionSet];
            a.length !== 0;

          )
            for (
              var s = a.pop(), u = 0, l = this.getFragmentSpreads(s);
              u < l.length;
              u++
            ) {
              var d = l[u],
                f = d.name.value;
              if (o[f] !== !0) {
                o[f] = !0;
                var m = this.getFragment(f);
                m && (i.push(m), a.push(m.selectionSet));
              }
            }
          this._recursivelyReferencedFragments.set(n, i);
        }
        return i;
      }),
      e
    );
  })();
  Jd.ASTValidationContext = Yz;
  var OPt = (function (e) {
    tpe(t, e);
    function t(n, i, o) {
      var a;
      return (a = e.call(this, n, o) || this), (a._schema = i), a;
    }
    var r = t.prototype;
    return (
      (r.getSchema = function () {
        return this._schema;
      }),
      t
    );
  })(Yz);
  Jd.SDLValidationContext = OPt;
  var TPt = (function (e) {
    tpe(t, e);
    function t(n, i, o, a) {
      var s;
      return (
        (s = e.call(this, i, a) || this),
        (s._schema = n),
        (s._typeInfo = o),
        (s._variableUsages = new Map()),
        (s._recursiveVariableUsages = new Map()),
        s
      );
    }
    var r = t.prototype;
    return (
      (r.getSchema = function () {
        return this._schema;
      }),
      (r.getVariableUsages = function (i) {
        var o = this._variableUsages.get(i);
        if (!o) {
          var a = [],
            s = new epe.TypeInfo(this._schema);
          (0, wPt.visit)(
            i,
            (0, epe.visitWithTypeInfo)(s, {
              VariableDefinition: function () {
                return !1;
              },
              Variable: function (l) {
                a.push({
                  node: l,
                  type: s.getInputType(),
                  defaultValue: s.getDefaultValue(),
                });
              },
            }),
          ),
            (o = a),
            this._variableUsages.set(i, o);
        }
        return o;
      }),
      (r.getRecursiveVariableUsages = function (i) {
        var o = this._recursiveVariableUsages.get(i);
        if (!o) {
          o = this.getVariableUsages(i);
          for (
            var a = 0, s = this.getRecursivelyReferencedFragments(i);
            a < s.length;
            a++
          ) {
            var u = s[a];
            o = o.concat(this.getVariableUsages(u));
          }
          this._recursiveVariableUsages.set(i, o);
        }
        return o;
      }),
      (r.getType = function () {
        return this._typeInfo.getType();
      }),
      (r.getParentType = function () {
        return this._typeInfo.getParentType();
      }),
      (r.getInputType = function () {
        return this._typeInfo.getInputType();
      }),
      (r.getParentInputType = function () {
        return this._typeInfo.getParentInputType();
      }),
      (r.getFieldDef = function () {
        return this._typeInfo.getFieldDef();
      }),
      (r.getDirective = function () {
        return this._typeInfo.getDirective();
      }),
      (r.getArgument = function () {
        return this._typeInfo.getArgument();
      }),
      (r.getEnumValue = function () {
        return this._typeInfo.getEnumValue();
      }),
      t
    );
  })(Yz);
  Jd.ValidationContext = TPt;
});
var cy = g((sy) => {
  "use strict";
  c();
  Object.defineProperty(sy, "__esModule", { value: !0 });
  sy.validate = xPt;
  sy.validateSDL = Jz;
  sy.assertValidSDL = NPt;
  sy.assertValidSDLExtension = kPt;
  var APt = IPt(Ta()),
    PPt = Ue(),
    PN = Bd(),
    RPt = w0(),
    rpe = vN(),
    npe = Qz(),
    ipe = Xz();
  function IPt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function xPt(e, t) {
    var r =
        arguments.length > 2 && arguments[2] !== void 0
          ? arguments[2]
          : npe.specifiedRules,
      n =
        arguments.length > 3 && arguments[3] !== void 0
          ? arguments[3]
          : new rpe.TypeInfo(e),
      i =
        arguments.length > 4 && arguments[4] !== void 0
          ? arguments[4]
          : { maxErrors: void 0 };
    t || (0, APt.default)(0, "Must provide document."),
      (0, RPt.assertValidSchema)(e);
    var o = Object.freeze({}),
      a = [],
      s = new ipe.ValidationContext(e, t, n, function (l) {
        if (i.maxErrors != null && a.length >= i.maxErrors)
          throw (
            (a.push(
              new PPt.GraphQLError(
                "Too many validation errors, error limit reached. Validation aborted.",
              ),
            ),
            o)
          );
        a.push(l);
      }),
      u = (0, PN.visitInParallel)(
        r.map(function (l) {
          return l(s);
        }),
      );
    try {
      (0, PN.visit)(t, (0, rpe.visitWithTypeInfo)(n, u));
    } catch (l) {
      if (l !== o) throw l;
    }
    return a;
  }
  function Jz(e, t) {
    var r =
        arguments.length > 2 && arguments[2] !== void 0
          ? arguments[2]
          : npe.specifiedSDLRules,
      n = [],
      i = new ipe.SDLValidationContext(e, t, function (a) {
        n.push(a);
      }),
      o = r.map(function (a) {
        return a(i);
      });
    return (0, PN.visit)(e, (0, PN.visitInParallel)(o)), n;
  }
  function NPt(e) {
    var t = Jz(e);
    if (t.length !== 0)
      throw new Error(
        t.map(function (r) {
          return r.message;
        }).join(`

`),
      );
  }
  function kPt(e, t) {
    var r = Jz(e, t);
    if (r.length !== 0)
      throw new Error(
        r.map(function (n) {
          return n.message;
        }).join(`

`),
      );
  }
});
var ope = g((Zz) => {
  "use strict";
  c();
  Object.defineProperty(Zz, "__esModule", { value: !0 });
  Zz.default = DPt;
  function DPt(e) {
    var t;
    return function (n, i, o) {
      t || (t = new WeakMap());
      var a = t.get(n),
        s;
      if (a) {
        if (((s = a.get(i)), s)) {
          var u = s.get(o);
          if (u !== void 0) return u;
        }
      } else (a = new WeakMap()), t.set(n, a);
      s || ((s = new WeakMap()), a.set(i, s));
      var l = e(n, i, o);
      return s.set(o, l), l;
    };
  }
});
var ape = g((e2) => {
  "use strict";
  c();
  Object.defineProperty(e2, "__esModule", { value: !0 });
  e2.default = qPt;
  var LPt = MPt(Ox());
  function MPt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function qPt(e, t, r) {
    return e.reduce(function (n, i) {
      return (0, LPt.default)(n)
        ? n.then(function (o) {
            return t(o, i);
          })
        : t(n, i);
    }, r);
  }
});
var spe = g((t2) => {
  "use strict";
  c();
  Object.defineProperty(t2, "__esModule", { value: !0 });
  t2.default = jPt;
  function jPt(e) {
    var t = Object.keys(e),
      r = t.map(function (n) {
        return e[n];
      });
    return Promise.all(r).then(function (n) {
      return n.reduce(function (i, o, a) {
        return (i[t[a]] = o), i;
      }, Object.create(null));
    });
  }
});
var R0 = g((RN) => {
  "use strict";
  c();
  Object.defineProperty(RN, "__esModule", { value: !0 });
  RN.addPath = FPt;
  RN.pathToArray = BPt;
  function FPt(e, t, r) {
    return { prev: e, key: t, typename: r };
  }
  function BPt(e) {
    for (var t = [], r = e; r; ) t.push(r.key), (r = r.prev);
    return t.reverse();
  }
});
var xN = g((r2) => {
  "use strict";
  c();
  Object.defineProperty(r2, "__esModule", { value: !0 });
  r2.getOperationRootType = UPt;
  var IN = Ue();
  function UPt(e, t) {
    if (t.operation === "query") {
      var r = e.getQueryType();
      if (!r)
        throw new IN.GraphQLError(
          "Schema does not define the required query root type.",
          t,
        );
      return r;
    }
    if (t.operation === "mutation") {
      var n = e.getMutationType();
      if (!n)
        throw new IN.GraphQLError("Schema is not configured for mutations.", t);
      return n;
    }
    if (t.operation === "subscription") {
      var i = e.getSubscriptionType();
      if (!i)
        throw new IN.GraphQLError(
          "Schema is not configured for subscriptions.",
          t,
        );
      return i;
    }
    throw new IN.GraphQLError(
      "Can only have query, mutation and subscription operations.",
      t,
    );
  }
});
var i2 = g((n2) => {
  "use strict";
  c();
  Object.defineProperty(n2, "__esModule", { value: !0 });
  n2.default = HPt;
  function HPt(e) {
    return e
      .map(function (t) {
        return typeof t == "number" ? "[" + t.toString() + "]" : "." + t;
      })
      .join("");
  }
});
var x0 = g((o2) => {
  "use strict";
  c();
  Object.defineProperty(o2, "__esModule", { value: !0 });
  o2.valueFromAST = I0;
  var GPt = NN(ea()),
    VPt = NN(Ud()),
    $Pt = NN(Lt()),
    zPt = NN(vi()),
    uy = lr(),
    Rm = It();
  function NN(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function I0(e, t, r) {
    if (e) {
      if (e.kind === uy.Kind.VARIABLE) {
        var n = e.name.value;
        if (r == null || r[n] === void 0) return;
        var i = r[n];
        return i === null && (0, Rm.isNonNullType)(t) ? void 0 : i;
      }
      if ((0, Rm.isNonNullType)(t))
        return e.kind === uy.Kind.NULL ? void 0 : I0(e, t.ofType, r);
      if (e.kind === uy.Kind.NULL) return null;
      if ((0, Rm.isListType)(t)) {
        var o = t.ofType;
        if (e.kind === uy.Kind.LIST) {
          for (var a = [], s = 0, u = e.values; s < u.length; s++) {
            var l = u[s];
            if (cpe(l, r)) {
              if ((0, Rm.isNonNullType)(o)) return;
              a.push(null);
            } else {
              var d = I0(l, o, r);
              if (d === void 0) return;
              a.push(d);
            }
          }
          return a;
        }
        var f = I0(e, o, r);
        return f === void 0 ? void 0 : [f];
      }
      if ((0, Rm.isInputObjectType)(t)) {
        if (e.kind !== uy.Kind.OBJECT) return;
        for (
          var m = Object.create(null),
            h = (0, VPt.default)(e.fields, function (P) {
              return P.name.value;
            }),
            y = 0,
            _ = (0, GPt.default)(t.getFields());
          y < _.length;
          y++
        ) {
          var E = _[y],
            b = h[E.name];
          if (!b || cpe(b.value, r)) {
            if (E.defaultValue !== void 0) m[E.name] = E.defaultValue;
            else if ((0, Rm.isNonNullType)(E.type)) return;
            continue;
          }
          var O = I0(b.value, E.type, r);
          if (O === void 0) return;
          m[E.name] = O;
        }
        return m;
      }
      if ((0, Rm.isLeafType)(t)) {
        var C;
        try {
          C = t.parseLiteral(e, r);
        } catch {
          return;
        }
        return C === void 0 ? void 0 : C;
      }
      (0, zPt.default)(0, "Unexpected input type: " + (0, $Pt.default)(t));
    }
  }
  function cpe(e, t) {
    return (
      e.kind === uy.Kind.VARIABLE && (t == null || t[e.name.value] === void 0)
    );
  }
});
var s2 = g((a2) => {
  "use strict";
  c();
  Object.defineProperty(a2, "__esModule", { value: !0 });
  a2.coerceInputValue = eRt;
  var KPt = Zd(ea()),
    kN = Zd(Lt()),
    WPt = Zd(vi()),
    QPt = Zd(Hd()),
    YPt = Zd(wc()),
    XPt = Zd(cN()),
    JPt = Zd(Gd()),
    ZPt = Zd(i2()),
    Yu = R0(),
    Im = Ue(),
    N0 = It();
  function Zd(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function eRt(e, t) {
    var r =
      arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : tRt;
    return k0(e, t, r);
  }
  function tRt(e, t, r) {
    var n = "Invalid value " + (0, kN.default)(t);
    throw (
      (e.length > 0 && (n += ' at "value'.concat((0, ZPt.default)(e), '"')),
      (r.message = n + ": " + r.message),
      r)
    );
  }
  function k0(e, t, r, n) {
    if ((0, N0.isNonNullType)(t)) {
      if (e != null) return k0(e, t.ofType, r, n);
      r(
        (0, Yu.pathToArray)(n),
        e,
        new Im.GraphQLError(
          'Expected non-nullable type "'.concat(
            (0, kN.default)(t),
            '" not to be null.',
          ),
        ),
      );
      return;
    }
    if (e == null) return null;
    if ((0, N0.isListType)(t)) {
      var i = t.ofType,
        o = (0, XPt.default)(e, function (O, C) {
          var P = (0, Yu.addPath)(n, C, void 0);
          return k0(O, i, r, P);
        });
      return o ?? [k0(e, i, r, n)];
    }
    if ((0, N0.isInputObjectType)(t)) {
      if (!(0, YPt.default)(e)) {
        r(
          (0, Yu.pathToArray)(n),
          e,
          new Im.GraphQLError(
            'Expected type "'.concat(t.name, '" to be an object.'),
          ),
        );
        return;
      }
      for (
        var a = {}, s = t.getFields(), u = 0, l = (0, KPt.default)(s);
        u < l.length;
        u++
      ) {
        var d = l[u],
          f = e[d.name];
        if (f === void 0) {
          if (d.defaultValue !== void 0) a[d.name] = d.defaultValue;
          else if ((0, N0.isNonNullType)(d.type)) {
            var m = (0, kN.default)(d.type);
            r(
              (0, Yu.pathToArray)(n),
              e,
              new Im.GraphQLError(
                'Field "'
                  .concat(d.name, '" of required type "')
                  .concat(m, '" was not provided.'),
              ),
            );
          }
          continue;
        }
        a[d.name] = k0(f, d.type, r, (0, Yu.addPath)(n, d.name, t.name));
      }
      for (var h = 0, y = Object.keys(e); h < y.length; h++) {
        var _ = y[h];
        if (!s[_]) {
          var E = (0, JPt.default)(_, Object.keys(t.getFields()));
          r(
            (0, Yu.pathToArray)(n),
            e,
            new Im.GraphQLError(
              'Field "'
                .concat(_, '" is not defined by type "')
                .concat(t.name, '".') + (0, QPt.default)(E),
            ),
          );
        }
      }
      return a;
    }
    if ((0, N0.isLeafType)(t)) {
      var b;
      try {
        b = t.parseValue(e);
      } catch (O) {
        O instanceof Im.GraphQLError
          ? r((0, Yu.pathToArray)(n), e, O)
          : r(
              (0, Yu.pathToArray)(n),
              e,
              new Im.GraphQLError(
                'Expected type "'.concat(t.name, '". ') + O.message,
                void 0,
                void 0,
                void 0,
                void 0,
                O,
              ),
            );
        return;
      }
      return (
        b === void 0 &&
          r(
            (0, Yu.pathToArray)(n),
            e,
            new Im.GraphQLError('Expected type "'.concat(t.name, '".')),
          ),
        b
      );
    }
    (0, WPt.default)(0, "Unexpected input type: " + (0, kN.default)(t));
  }
});
var L0 = g((D0) => {
  "use strict";
  c();
  Object.defineProperty(D0, "__esModule", { value: !0 });
  D0.getVariableValues = sRt;
  D0.getArgumentValues = fpe;
  D0.getDirectiveValues = uRt;
  var rRt = DN(Wv()),
    nRt = DN(Ud()),
    ly = DN(Lt()),
    iRt = DN(i2()),
    Xu = Ue(),
    upe = lr(),
    lpe = ta(),
    dy = It(),
    oRt = Rc(),
    dpe = x0(),
    aRt = s2();
  function DN(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function sRt(e, t, r, n) {
    var i = [],
      o = n?.maxErrors;
    try {
      var a = cRt(e, t, r, function (s) {
        if (o != null && i.length >= o)
          throw new Xu.GraphQLError(
            "Too many errors processing variables, error limit reached. Execution aborted.",
          );
        i.push(s);
      });
      if (i.length === 0) return { coerced: a };
    } catch (s) {
      i.push(s);
    }
    return { errors: i };
  }
  function cRt(e, t, r, n) {
    for (
      var i = {},
        o = function (l) {
          var d = t[l],
            f = d.variable.name.value,
            m = (0, oRt.typeFromAST)(e, d.type);
          if (!(0, dy.isInputType)(m)) {
            var h = (0, lpe.print)(d.type);
            return (
              n(
                new Xu.GraphQLError(
                  'Variable "$'
                    .concat(f, '" expected value of type "')
                    .concat(h, '" which cannot be used as an input type.'),
                  d.type,
                ),
              ),
              "continue"
            );
          }
          if (!ppe(r, f)) {
            if (d.defaultValue) i[f] = (0, dpe.valueFromAST)(d.defaultValue, m);
            else if ((0, dy.isNonNullType)(m)) {
              var y = (0, ly.default)(m);
              n(
                new Xu.GraphQLError(
                  'Variable "$'
                    .concat(f, '" of required type "')
                    .concat(y, '" was not provided.'),
                  d,
                ),
              );
            }
            return "continue";
          }
          var _ = r[f];
          if (_ === null && (0, dy.isNonNullType)(m)) {
            var E = (0, ly.default)(m);
            return (
              n(
                new Xu.GraphQLError(
                  'Variable "$'
                    .concat(f, '" of non-null type "')
                    .concat(E, '" must not be null.'),
                  d,
                ),
              ),
              "continue"
            );
          }
          i[f] = (0, aRt.coerceInputValue)(_, m, function (b, O, C) {
            var P =
              'Variable "$'.concat(f, '" got invalid value ') +
              (0, ly.default)(O);
            b.length > 0 &&
              (P += ' at "'.concat(f).concat((0, iRt.default)(b), '"')),
              n(
                new Xu.GraphQLError(
                  P + "; " + C.message,
                  d,
                  void 0,
                  void 0,
                  void 0,
                  C.originalError,
                ),
              );
          });
        },
        a = 0;
      a < t.length;
      a++
    )
      var s = o(a);
    return i;
  }
  function fpe(e, t, r) {
    for (
      var n,
        i = {},
        o = (n = t.arguments) !== null && n !== void 0 ? n : [],
        a = (0, nRt.default)(o, function (b) {
          return b.name.value;
        }),
        s = 0,
        u = e.args;
      s < u.length;
      s++
    ) {
      var l = u[s],
        d = l.name,
        f = l.type,
        m = a[d];
      if (!m) {
        if (l.defaultValue !== void 0) i[d] = l.defaultValue;
        else if ((0, dy.isNonNullType)(f))
          throw new Xu.GraphQLError(
            'Argument "'
              .concat(d, '" of required type "')
              .concat((0, ly.default)(f), '" ') + "was not provided.",
            t,
          );
        continue;
      }
      var h = m.value,
        y = h.kind === upe.Kind.NULL;
      if (h.kind === upe.Kind.VARIABLE) {
        var _ = h.name.value;
        if (r == null || !ppe(r, _)) {
          if (l.defaultValue !== void 0) i[d] = l.defaultValue;
          else if ((0, dy.isNonNullType)(f))
            throw new Xu.GraphQLError(
              'Argument "'
                .concat(d, '" of required type "')
                .concat((0, ly.default)(f), '" ') +
                'was provided the variable "$'.concat(
                  _,
                  '" which was not provided a runtime value.',
                ),
              h,
            );
          continue;
        }
        y = r[_] == null;
      }
      if (y && (0, dy.isNonNullType)(f))
        throw new Xu.GraphQLError(
          'Argument "'
            .concat(d, '" of non-null type "')
            .concat((0, ly.default)(f), '" ') + "must not be null.",
          h,
        );
      var E = (0, dpe.valueFromAST)(h, f, r);
      if (E === void 0)
        throw new Xu.GraphQLError(
          'Argument "'
            .concat(d, '" has invalid value ')
            .concat((0, lpe.print)(h), "."),
          h,
        );
      i[d] = E;
    }
    return i;
  }
  function uRt(e, t, r) {
    var n =
      t.directives &&
      (0, rRt.default)(t.directives, function (i) {
        return i.name.value === e.name;
      });
    if (n) return fpe(e, n, r);
  }
  function ppe(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }
});
var F0 = g((na) => {
  "use strict";
  c();
  Object.defineProperty(na, "__esModule", { value: !0 });
  na.execute = yRt;
  na.executeSync = _Rt;
  na.assertValidExecutionArguments = bpe;
  na.buildExecutionContext = Spe;
  na.collectFields = q0;
  na.buildResolveInfo = Ope;
  na.getFieldDef = Ppe;
  na.defaultFieldResolver = na.defaultTypeResolver = void 0;
  var py = Zu(Lt()),
    lRt = Zu(ope()),
    dRt = Zu(vi()),
    mpe = Zu(Ta()),
    Ia = Zu(Ox()),
    d2 = Zu(wc()),
    fRt = Zu(cN()),
    pRt = Zu(ape()),
    mRt = Zu(spe()),
    xm = R0(),
    xc = Ue(),
    LN = s0(),
    M0 = lr(),
    hRt = w0(),
    fy = Ra(),
    hpe = bo(),
    Ju = It(),
    gRt = Rc(),
    vRt = xN(),
    MN = L0();
  function Zu(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function yRt(e, t, r, n, i, o, a, s) {
    return arguments.length === 1
      ? u2(e)
      : u2({
          schema: e,
          document: t,
          rootValue: r,
          contextValue: n,
          variableValues: i,
          operationName: o,
          fieldResolver: a,
          typeResolver: s,
        });
  }
  function _Rt(e) {
    var t = u2(e);
    if ((0, Ia.default)(t))
      throw new Error("GraphQL execution failed to complete synchronously.");
    return t;
  }
  function u2(e) {
    var t = e.schema,
      r = e.document,
      n = e.rootValue,
      i = e.contextValue,
      o = e.variableValues,
      a = e.operationName,
      s = e.fieldResolver,
      u = e.typeResolver;
    bpe(t, r, o);
    var l = Spe(t, r, n, i, o, a, s, u);
    if (Array.isArray(l)) return { errors: l };
    var d = ERt(l, l.operation, n);
    return Epe(l, d);
  }
  function Epe(e, t) {
    return (0, Ia.default)(t)
      ? t.then(function (r) {
          return Epe(e, r);
        })
      : e.errors.length === 0
        ? { data: t }
        : { errors: e.errors, data: t };
  }
  function bpe(e, t, r) {
    t || (0, mpe.default)(0, "Must provide document."),
      (0, hRt.assertValidSchema)(e),
      r == null ||
        (0, d2.default)(r) ||
        (0, mpe.default)(
          0,
          "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.",
        );
  }
  function Spe(e, t, r, n, i, o, a, s) {
    for (
      var u, l, d, f = Object.create(null), m = 0, h = t.definitions;
      m < h.length;
      m++
    ) {
      var y = h[m];
      switch (y.kind) {
        case M0.Kind.OPERATION_DEFINITION:
          if (o == null) {
            if (d !== void 0)
              return [
                new xc.GraphQLError(
                  "Must provide operation name if query contains multiple operations.",
                ),
              ];
            d = y;
          } else
            ((u = y.name) === null || u === void 0 ? void 0 : u.value) === o &&
              (d = y);
          break;
        case M0.Kind.FRAGMENT_DEFINITION:
          f[y.name.value] = y;
          break;
      }
    }
    if (!d)
      return o != null
        ? [new xc.GraphQLError('Unknown operation named "'.concat(o, '".'))]
        : [new xc.GraphQLError("Must provide an operation.")];
    var _ = (l = d.variableDefinitions) !== null && l !== void 0 ? l : [],
      E = (0, MN.getVariableValues)(e, _, i ?? {}, { maxErrors: 50 });
    return E.errors
      ? E.errors
      : {
          schema: e,
          fragments: f,
          rootValue: r,
          contextValue: n,
          operation: d,
          variableValues: E.coerced,
          fieldResolver: a ?? Ape,
          typeResolver: s ?? Tpe,
          errors: [],
        };
  }
  function ERt(e, t, r) {
    var n = (0, vRt.getOperationRootType)(e.schema, t),
      i = q0(e, n, t.selectionSet, Object.create(null), Object.create(null)),
      o = void 0;
    try {
      var a =
        t.operation === "mutation" ? bRt(e, n, r, o, i) : Cpe(e, n, r, o, i);
      return (0, Ia.default)(a)
        ? a.then(void 0, function (s) {
            return e.errors.push(s), Promise.resolve(null);
          })
        : a;
    } catch (s) {
      return e.errors.push(s), null;
    }
  }
  function bRt(e, t, r, n, i) {
    return (0, pRt.default)(
      Object.keys(i),
      function (o, a) {
        var s = i[a],
          u = (0, xm.addPath)(n, a, t.name),
          l = wpe(e, t, r, s, u);
        return l === void 0
          ? o
          : (0, Ia.default)(l)
            ? l.then(function (d) {
                return (o[a] = d), o;
              })
            : ((o[a] = l), o);
      },
      Object.create(null),
    );
  }
  function Cpe(e, t, r, n, i) {
    for (
      var o = Object.create(null), a = !1, s = 0, u = Object.keys(i);
      s < u.length;
      s++
    ) {
      var l = u[s],
        d = i[l],
        f = (0, xm.addPath)(n, l, t.name),
        m = wpe(e, t, r, d, f);
      m !== void 0 && ((o[l] = m), (0, Ia.default)(m) && (a = !0));
    }
    return a ? (0, mRt.default)(o) : o;
  }
  function q0(e, t, r, n, i) {
    for (var o = 0, a = r.selections; o < a.length; o++) {
      var s = a[o];
      switch (s.kind) {
        case M0.Kind.FIELD: {
          if (!c2(e, s)) continue;
          var u = SRt(s);
          n[u] || (n[u] = []), n[u].push(s);
          break;
        }
        case M0.Kind.INLINE_FRAGMENT: {
          if (!c2(e, s) || !gpe(e, s, t)) continue;
          q0(e, t, s.selectionSet, n, i);
          break;
        }
        case M0.Kind.FRAGMENT_SPREAD: {
          var l = s.name.value;
          if (i[l] || !c2(e, s)) continue;
          i[l] = !0;
          var d = e.fragments[l];
          if (!d || !gpe(e, d, t)) continue;
          q0(e, t, d.selectionSet, n, i);
          break;
        }
      }
    }
    return n;
  }
  function c2(e, t) {
    var r = (0, MN.getDirectiveValues)(
      hpe.GraphQLSkipDirective,
      t,
      e.variableValues,
    );
    if (r?.if === !0) return !1;
    var n = (0, MN.getDirectiveValues)(
      hpe.GraphQLIncludeDirective,
      t,
      e.variableValues,
    );
    return n?.if !== !1;
  }
  function gpe(e, t, r) {
    var n = t.typeCondition;
    if (!n) return !0;
    var i = (0, gRt.typeFromAST)(e.schema, n);
    return i === r
      ? !0
      : (0, Ju.isAbstractType)(i)
        ? e.schema.isSubType(i, r)
        : !1;
  }
  function SRt(e) {
    return e.alias ? e.alias.value : e.name.value;
  }
  function wpe(e, t, r, n, i) {
    var o,
      a = n[0],
      s = a.name.value,
      u = Ppe(e.schema, t, s);
    if (u) {
      var l = u.type,
        d = (o = u.resolve) !== null && o !== void 0 ? o : e.fieldResolver,
        f = Ope(e, u, n, t, i);
      try {
        var m = (0, MN.getArgumentValues)(u, n[0], e.variableValues),
          h = e.contextValue,
          y = d(r, m, h, f),
          _;
        return (
          (0, Ia.default)(y)
            ? (_ = y.then(function (b) {
                return j0(e, l, n, f, i, b);
              }))
            : (_ = j0(e, l, n, f, i, y)),
          (0, Ia.default)(_)
            ? _.then(void 0, function (b) {
                var O = (0, LN.locatedError)(b, n, (0, xm.pathToArray)(i));
                return qN(O, l, e);
              })
            : _
        );
      } catch (b) {
        var E = (0, LN.locatedError)(b, n, (0, xm.pathToArray)(i));
        return qN(E, l, e);
      }
    }
  }
  function Ope(e, t, r, n, i) {
    return {
      fieldName: t.name,
      fieldNodes: r,
      returnType: t.type,
      parentType: n,
      path: i,
      schema: e.schema,
      fragments: e.fragments,
      rootValue: e.rootValue,
      operation: e.operation,
      variableValues: e.variableValues,
    };
  }
  function qN(e, t, r) {
    if ((0, Ju.isNonNullType)(t)) throw e;
    return r.errors.push(e), null;
  }
  function j0(e, t, r, n, i, o) {
    if (o instanceof Error) throw o;
    if ((0, Ju.isNonNullType)(t)) {
      var a = j0(e, t.ofType, r, n, i, o);
      if (a === null)
        throw new Error(
          "Cannot return null for non-nullable field "
            .concat(n.parentType.name, ".")
            .concat(n.fieldName, "."),
        );
      return a;
    }
    if (o == null) return null;
    if ((0, Ju.isListType)(t)) return CRt(e, t, r, n, i, o);
    if ((0, Ju.isLeafType)(t)) return wRt(t, o);
    if ((0, Ju.isAbstractType)(t)) return ORt(e, t, r, n, i, o);
    if ((0, Ju.isObjectType)(t)) return l2(e, t, r, n, i, o);
    (0, dRt.default)(
      0,
      "Cannot complete value of unexpected output type: " + (0, py.default)(t),
    );
  }
  function CRt(e, t, r, n, i, o) {
    var a = t.ofType,
      s = !1,
      u = (0, fRt.default)(o, function (l, d) {
        var f = (0, xm.addPath)(i, d, void 0);
        try {
          var m;
          return (
            (0, Ia.default)(l)
              ? (m = l.then(function (y) {
                  return j0(e, a, r, n, f, y);
                }))
              : (m = j0(e, a, r, n, f, l)),
            (0, Ia.default)(m)
              ? ((s = !0),
                m.then(void 0, function (y) {
                  var _ = (0, LN.locatedError)(y, r, (0, xm.pathToArray)(f));
                  return qN(_, a, e);
                }))
              : m
          );
        } catch (y) {
          var h = (0, LN.locatedError)(y, r, (0, xm.pathToArray)(f));
          return qN(h, a, e);
        }
      });
    if (u == null)
      throw new xc.GraphQLError(
        'Expected Iterable, but did not find one for field "'
          .concat(n.parentType.name, ".")
          .concat(n.fieldName, '".'),
      );
    return s ? Promise.all(u) : u;
  }
  function wRt(e, t) {
    var r = e.serialize(t);
    if (r === void 0)
      throw new Error(
        'Expected a value of type "'.concat((0, py.default)(e), '" but ') +
          "received: ".concat((0, py.default)(t)),
      );
    return r;
  }
  function ORt(e, t, r, n, i, o) {
    var a,
      s = (a = t.resolveType) !== null && a !== void 0 ? a : e.typeResolver,
      u = e.contextValue,
      l = s(o, u, n, t);
    return (0, Ia.default)(l)
      ? l.then(function (d) {
          return l2(e, vpe(d, e, t, r, n, o), r, n, i, o);
        })
      : l2(e, vpe(l, e, t, r, n, o), r, n, i, o);
  }
  function vpe(e, t, r, n, i, o) {
    if (e == null)
      throw new xc.GraphQLError(
        'Abstract type "'
          .concat(
            r.name,
            '" must resolve to an Object type at runtime for field "',
          )
          .concat(i.parentType.name, ".")
          .concat(i.fieldName, '". Either the "')
          .concat(
            r.name,
            '" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.',
          ),
        n,
      );
    var a = (0, Ju.isNamedType)(e) ? e.name : e;
    if (typeof a != "string")
      throw new xc.GraphQLError(
        'Abstract type "'
          .concat(
            r.name,
            '" must resolve to an Object type at runtime for field "',
          )
          .concat(i.parentType.name, ".")
          .concat(i.fieldName, '" with ') +
          "value "
            .concat((0, py.default)(o), ', received "')
            .concat((0, py.default)(e), '".'),
      );
    var s = t.schema.getType(a);
    if (s == null)
      throw new xc.GraphQLError(
        'Abstract type "'
          .concat(r.name, '" was resolve to a type "')
          .concat(a, '" that does not exist inside schema.'),
        n,
      );
    if (!(0, Ju.isObjectType)(s))
      throw new xc.GraphQLError(
        'Abstract type "'
          .concat(r.name, '" was resolve to a non-object type "')
          .concat(a, '".'),
        n,
      );
    if (!t.schema.isSubType(r, s))
      throw new xc.GraphQLError(
        'Runtime Object type "'
          .concat(s.name, '" is not a possible type for "')
          .concat(r.name, '".'),
        n,
      );
    return s;
  }
  function l2(e, t, r, n, i, o) {
    if (t.isTypeOf) {
      var a = t.isTypeOf(o, e.contextValue, n);
      if ((0, Ia.default)(a))
        return a.then(function (s) {
          if (!s) throw ype(t, o, r);
          return _pe(e, t, r, i, o);
        });
      if (!a) throw ype(t, o, r);
    }
    return _pe(e, t, r, i, o);
  }
  function ype(e, t, r) {
    return new xc.GraphQLError(
      'Expected value of type "'
        .concat(e.name, '" but got: ')
        .concat((0, py.default)(t), "."),
      r,
    );
  }
  function _pe(e, t, r, n, i) {
    var o = TRt(e, t, r);
    return Cpe(e, t, i, n, o);
  }
  var TRt = (0, lRt.default)(ARt);
  function ARt(e, t, r) {
    for (
      var n = Object.create(null), i = Object.create(null), o = 0;
      o < r.length;
      o++
    ) {
      var a = r[o];
      a.selectionSet && (n = q0(e, t, a.selectionSet, n, i));
    }
    return n;
  }
  var Tpe = function (t, r, n, i) {
    if ((0, d2.default)(t) && typeof t.__typename == "string")
      return t.__typename;
    for (
      var o = n.schema.getPossibleTypes(i), a = [], s = 0;
      s < o.length;
      s++
    ) {
      var u = o[s];
      if (u.isTypeOf) {
        var l = u.isTypeOf(t, r, n);
        if ((0, Ia.default)(l)) a[s] = l;
        else if (l) return u.name;
      }
    }
    if (a.length)
      return Promise.all(a).then(function (d) {
        for (var f = 0; f < d.length; f++) if (d[f]) return o[f].name;
      });
  };
  na.defaultTypeResolver = Tpe;
  var Ape = function (t, r, n, i) {
    if ((0, d2.default)(t) || typeof t == "function") {
      var o = t[i.fieldName];
      return typeof o == "function" ? t[i.fieldName](r, n, i) : o;
    }
  };
  na.defaultFieldResolver = Ape;
  function Ppe(e, t, r) {
    return r === fy.SchemaMetaFieldDef.name && e.getQueryType() === t
      ? fy.SchemaMetaFieldDef
      : r === fy.TypeMetaFieldDef.name && e.getQueryType() === t
        ? fy.TypeMetaFieldDef
        : r === fy.TypeNameMetaFieldDef.name
          ? fy.TypeNameMetaFieldDef
          : t.getFields()[r];
  }
});
var Rpe = g((FN) => {
  "use strict";
  c();
  Object.defineProperty(FN, "__esModule", { value: !0 });
  FN.graphql = DRt;
  FN.graphqlSync = LRt;
  var PRt = kRt(Ox()),
    RRt = zv(),
    IRt = cy(),
    xRt = w0(),
    NRt = F0();
  function kRt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function DRt(e, t, r, n, i, o, a, s) {
    var u = arguments;
    return new Promise(function (l) {
      return l(
        u.length === 1
          ? jN(e)
          : jN({
              schema: e,
              source: t,
              rootValue: r,
              contextValue: n,
              variableValues: i,
              operationName: o,
              fieldResolver: a,
              typeResolver: s,
            }),
      );
    });
  }
  function LRt(e, t, r, n, i, o, a, s) {
    var u =
      arguments.length === 1
        ? jN(e)
        : jN({
            schema: e,
            source: t,
            rootValue: r,
            contextValue: n,
            variableValues: i,
            operationName: o,
            fieldResolver: a,
            typeResolver: s,
          });
    if ((0, PRt.default)(u))
      throw new Error("GraphQL execution failed to complete synchronously.");
    return u;
  }
  function jN(e) {
    var t = e.schema,
      r = e.source,
      n = e.rootValue,
      i = e.contextValue,
      o = e.variableValues,
      a = e.operationName,
      s = e.fieldResolver,
      u = e.typeResolver,
      l = (0, xRt.validateSchema)(t);
    if (l.length > 0) return { errors: l };
    var d;
    try {
      d = (0, RRt.parse)(r);
    } catch (m) {
      return { errors: [m] };
    }
    var f = (0, IRt.validate)(t, d);
    return f.length > 0
      ? { errors: f }
      : (0, NRt.execute)({
          schema: t,
          document: d,
          rootValue: n,
          contextValue: i,
          variableValues: o,
          operationName: a,
          fieldResolver: s,
          typeResolver: u,
        });
  }
});
var xpe = g((ie) => {
  "use strict";
  c();
  Object.defineProperty(ie, "__esModule", { value: !0 });
  Object.defineProperty(ie, "isSchema", {
    enumerable: !0,
    get: function () {
      return f2.isSchema;
    },
  });
  Object.defineProperty(ie, "assertSchema", {
    enumerable: !0,
    get: function () {
      return f2.assertSchema;
    },
  });
  Object.defineProperty(ie, "GraphQLSchema", {
    enumerable: !0,
    get: function () {
      return f2.GraphQLSchema;
    },
  });
  Object.defineProperty(ie, "isType", {
    enumerable: !0,
    get: function () {
      return $e.isType;
    },
  });
  Object.defineProperty(ie, "isScalarType", {
    enumerable: !0,
    get: function () {
      return $e.isScalarType;
    },
  });
  Object.defineProperty(ie, "isObjectType", {
    enumerable: !0,
    get: function () {
      return $e.isObjectType;
    },
  });
  Object.defineProperty(ie, "isInterfaceType", {
    enumerable: !0,
    get: function () {
      return $e.isInterfaceType;
    },
  });
  Object.defineProperty(ie, "isUnionType", {
    enumerable: !0,
    get: function () {
      return $e.isUnionType;
    },
  });
  Object.defineProperty(ie, "isEnumType", {
    enumerable: !0,
    get: function () {
      return $e.isEnumType;
    },
  });
  Object.defineProperty(ie, "isInputObjectType", {
    enumerable: !0,
    get: function () {
      return $e.isInputObjectType;
    },
  });
  Object.defineProperty(ie, "isListType", {
    enumerable: !0,
    get: function () {
      return $e.isListType;
    },
  });
  Object.defineProperty(ie, "isNonNullType", {
    enumerable: !0,
    get: function () {
      return $e.isNonNullType;
    },
  });
  Object.defineProperty(ie, "isInputType", {
    enumerable: !0,
    get: function () {
      return $e.isInputType;
    },
  });
  Object.defineProperty(ie, "isOutputType", {
    enumerable: !0,
    get: function () {
      return $e.isOutputType;
    },
  });
  Object.defineProperty(ie, "isLeafType", {
    enumerable: !0,
    get: function () {
      return $e.isLeafType;
    },
  });
  Object.defineProperty(ie, "isCompositeType", {
    enumerable: !0,
    get: function () {
      return $e.isCompositeType;
    },
  });
  Object.defineProperty(ie, "isAbstractType", {
    enumerable: !0,
    get: function () {
      return $e.isAbstractType;
    },
  });
  Object.defineProperty(ie, "isWrappingType", {
    enumerable: !0,
    get: function () {
      return $e.isWrappingType;
    },
  });
  Object.defineProperty(ie, "isNullableType", {
    enumerable: !0,
    get: function () {
      return $e.isNullableType;
    },
  });
  Object.defineProperty(ie, "isNamedType", {
    enumerable: !0,
    get: function () {
      return $e.isNamedType;
    },
  });
  Object.defineProperty(ie, "isRequiredArgument", {
    enumerable: !0,
    get: function () {
      return $e.isRequiredArgument;
    },
  });
  Object.defineProperty(ie, "isRequiredInputField", {
    enumerable: !0,
    get: function () {
      return $e.isRequiredInputField;
    },
  });
  Object.defineProperty(ie, "assertType", {
    enumerable: !0,
    get: function () {
      return $e.assertType;
    },
  });
  Object.defineProperty(ie, "assertScalarType", {
    enumerable: !0,
    get: function () {
      return $e.assertScalarType;
    },
  });
  Object.defineProperty(ie, "assertObjectType", {
    enumerable: !0,
    get: function () {
      return $e.assertObjectType;
    },
  });
  Object.defineProperty(ie, "assertInterfaceType", {
    enumerable: !0,
    get: function () {
      return $e.assertInterfaceType;
    },
  });
  Object.defineProperty(ie, "assertUnionType", {
    enumerable: !0,
    get: function () {
      return $e.assertUnionType;
    },
  });
  Object.defineProperty(ie, "assertEnumType", {
    enumerable: !0,
    get: function () {
      return $e.assertEnumType;
    },
  });
  Object.defineProperty(ie, "assertInputObjectType", {
    enumerable: !0,
    get: function () {
      return $e.assertInputObjectType;
    },
  });
  Object.defineProperty(ie, "assertListType", {
    enumerable: !0,
    get: function () {
      return $e.assertListType;
    },
  });
  Object.defineProperty(ie, "assertNonNullType", {
    enumerable: !0,
    get: function () {
      return $e.assertNonNullType;
    },
  });
  Object.defineProperty(ie, "assertInputType", {
    enumerable: !0,
    get: function () {
      return $e.assertInputType;
    },
  });
  Object.defineProperty(ie, "assertOutputType", {
    enumerable: !0,
    get: function () {
      return $e.assertOutputType;
    },
  });
  Object.defineProperty(ie, "assertLeafType", {
    enumerable: !0,
    get: function () {
      return $e.assertLeafType;
    },
  });
  Object.defineProperty(ie, "assertCompositeType", {
    enumerable: !0,
    get: function () {
      return $e.assertCompositeType;
    },
  });
  Object.defineProperty(ie, "assertAbstractType", {
    enumerable: !0,
    get: function () {
      return $e.assertAbstractType;
    },
  });
  Object.defineProperty(ie, "assertWrappingType", {
    enumerable: !0,
    get: function () {
      return $e.assertWrappingType;
    },
  });
  Object.defineProperty(ie, "assertNullableType", {
    enumerable: !0,
    get: function () {
      return $e.assertNullableType;
    },
  });
  Object.defineProperty(ie, "assertNamedType", {
    enumerable: !0,
    get: function () {
      return $e.assertNamedType;
    },
  });
  Object.defineProperty(ie, "getNullableType", {
    enumerable: !0,
    get: function () {
      return $e.getNullableType;
    },
  });
  Object.defineProperty(ie, "getNamedType", {
    enumerable: !0,
    get: function () {
      return $e.getNamedType;
    },
  });
  Object.defineProperty(ie, "GraphQLScalarType", {
    enumerable: !0,
    get: function () {
      return $e.GraphQLScalarType;
    },
  });
  Object.defineProperty(ie, "GraphQLObjectType", {
    enumerable: !0,
    get: function () {
      return $e.GraphQLObjectType;
    },
  });
  Object.defineProperty(ie, "GraphQLInterfaceType", {
    enumerable: !0,
    get: function () {
      return $e.GraphQLInterfaceType;
    },
  });
  Object.defineProperty(ie, "GraphQLUnionType", {
    enumerable: !0,
    get: function () {
      return $e.GraphQLUnionType;
    },
  });
  Object.defineProperty(ie, "GraphQLEnumType", {
    enumerable: !0,
    get: function () {
      return $e.GraphQLEnumType;
    },
  });
  Object.defineProperty(ie, "GraphQLInputObjectType", {
    enumerable: !0,
    get: function () {
      return $e.GraphQLInputObjectType;
    },
  });
  Object.defineProperty(ie, "GraphQLList", {
    enumerable: !0,
    get: function () {
      return $e.GraphQLList;
    },
  });
  Object.defineProperty(ie, "GraphQLNonNull", {
    enumerable: !0,
    get: function () {
      return $e.GraphQLNonNull;
    },
  });
  Object.defineProperty(ie, "isDirective", {
    enumerable: !0,
    get: function () {
      return Nc.isDirective;
    },
  });
  Object.defineProperty(ie, "assertDirective", {
    enumerable: !0,
    get: function () {
      return Nc.assertDirective;
    },
  });
  Object.defineProperty(ie, "GraphQLDirective", {
    enumerable: !0,
    get: function () {
      return Nc.GraphQLDirective;
    },
  });
  Object.defineProperty(ie, "isSpecifiedDirective", {
    enumerable: !0,
    get: function () {
      return Nc.isSpecifiedDirective;
    },
  });
  Object.defineProperty(ie, "specifiedDirectives", {
    enumerable: !0,
    get: function () {
      return Nc.specifiedDirectives;
    },
  });
  Object.defineProperty(ie, "GraphQLIncludeDirective", {
    enumerable: !0,
    get: function () {
      return Nc.GraphQLIncludeDirective;
    },
  });
  Object.defineProperty(ie, "GraphQLSkipDirective", {
    enumerable: !0,
    get: function () {
      return Nc.GraphQLSkipDirective;
    },
  });
  Object.defineProperty(ie, "GraphQLDeprecatedDirective", {
    enumerable: !0,
    get: function () {
      return Nc.GraphQLDeprecatedDirective;
    },
  });
  Object.defineProperty(ie, "GraphQLSpecifiedByDirective", {
    enumerable: !0,
    get: function () {
      return Nc.GraphQLSpecifiedByDirective;
    },
  });
  Object.defineProperty(ie, "DEFAULT_DEPRECATION_REASON", {
    enumerable: !0,
    get: function () {
      return Nc.DEFAULT_DEPRECATION_REASON;
    },
  });
  Object.defineProperty(ie, "isSpecifiedScalarType", {
    enumerable: !0,
    get: function () {
      return Nm.isSpecifiedScalarType;
    },
  });
  Object.defineProperty(ie, "specifiedScalarTypes", {
    enumerable: !0,
    get: function () {
      return Nm.specifiedScalarTypes;
    },
  });
  Object.defineProperty(ie, "GraphQLInt", {
    enumerable: !0,
    get: function () {
      return Nm.GraphQLInt;
    },
  });
  Object.defineProperty(ie, "GraphQLFloat", {
    enumerable: !0,
    get: function () {
      return Nm.GraphQLFloat;
    },
  });
  Object.defineProperty(ie, "GraphQLString", {
    enumerable: !0,
    get: function () {
      return Nm.GraphQLString;
    },
  });
  Object.defineProperty(ie, "GraphQLBoolean", {
    enumerable: !0,
    get: function () {
      return Nm.GraphQLBoolean;
    },
  });
  Object.defineProperty(ie, "GraphQLID", {
    enumerable: !0,
    get: function () {
      return Nm.GraphQLID;
    },
  });
  Object.defineProperty(ie, "isIntrospectionType", {
    enumerable: !0,
    get: function () {
      return Co.isIntrospectionType;
    },
  });
  Object.defineProperty(ie, "introspectionTypes", {
    enumerable: !0,
    get: function () {
      return Co.introspectionTypes;
    },
  });
  Object.defineProperty(ie, "__Schema", {
    enumerable: !0,
    get: function () {
      return Co.__Schema;
    },
  });
  Object.defineProperty(ie, "__Directive", {
    enumerable: !0,
    get: function () {
      return Co.__Directive;
    },
  });
  Object.defineProperty(ie, "__DirectiveLocation", {
    enumerable: !0,
    get: function () {
      return Co.__DirectiveLocation;
    },
  });
  Object.defineProperty(ie, "__Type", {
    enumerable: !0,
    get: function () {
      return Co.__Type;
    },
  });
  Object.defineProperty(ie, "__Field", {
    enumerable: !0,
    get: function () {
      return Co.__Field;
    },
  });
  Object.defineProperty(ie, "__InputValue", {
    enumerable: !0,
    get: function () {
      return Co.__InputValue;
    },
  });
  Object.defineProperty(ie, "__EnumValue", {
    enumerable: !0,
    get: function () {
      return Co.__EnumValue;
    },
  });
  Object.defineProperty(ie, "__TypeKind", {
    enumerable: !0,
    get: function () {
      return Co.__TypeKind;
    },
  });
  Object.defineProperty(ie, "TypeKind", {
    enumerable: !0,
    get: function () {
      return Co.TypeKind;
    },
  });
  Object.defineProperty(ie, "SchemaMetaFieldDef", {
    enumerable: !0,
    get: function () {
      return Co.SchemaMetaFieldDef;
    },
  });
  Object.defineProperty(ie, "TypeMetaFieldDef", {
    enumerable: !0,
    get: function () {
      return Co.TypeMetaFieldDef;
    },
  });
  Object.defineProperty(ie, "TypeNameMetaFieldDef", {
    enumerable: !0,
    get: function () {
      return Co.TypeNameMetaFieldDef;
    },
  });
  Object.defineProperty(ie, "validateSchema", {
    enumerable: !0,
    get: function () {
      return Ipe.validateSchema;
    },
  });
  Object.defineProperty(ie, "assertValidSchema", {
    enumerable: !0,
    get: function () {
      return Ipe.assertValidSchema;
    },
  });
  var f2 = wm(),
    $e = It(),
    Nc = bo(),
    Nm = Pc(),
    Co = Ra(),
    Ipe = w0();
});
var Dpe = g((er) => {
  "use strict";
  c();
  Object.defineProperty(er, "__esModule", { value: !0 });
  Object.defineProperty(er, "Source", {
    enumerable: !0,
    get: function () {
      return MRt.Source;
    },
  });
  Object.defineProperty(er, "getLocation", {
    enumerable: !0,
    get: function () {
      return qRt.getLocation;
    },
  });
  Object.defineProperty(er, "printLocation", {
    enumerable: !0,
    get: function () {
      return Npe.printLocation;
    },
  });
  Object.defineProperty(er, "printSourceLocation", {
    enumerable: !0,
    get: function () {
      return Npe.printSourceLocation;
    },
  });
  Object.defineProperty(er, "Kind", {
    enumerable: !0,
    get: function () {
      return jRt.Kind;
    },
  });
  Object.defineProperty(er, "TokenKind", {
    enumerable: !0,
    get: function () {
      return FRt.TokenKind;
    },
  });
  Object.defineProperty(er, "Lexer", {
    enumerable: !0,
    get: function () {
      return BRt.Lexer;
    },
  });
  Object.defineProperty(er, "parse", {
    enumerable: !0,
    get: function () {
      return p2.parse;
    },
  });
  Object.defineProperty(er, "parseValue", {
    enumerable: !0,
    get: function () {
      return p2.parseValue;
    },
  });
  Object.defineProperty(er, "parseType", {
    enumerable: !0,
    get: function () {
      return p2.parseType;
    },
  });
  Object.defineProperty(er, "print", {
    enumerable: !0,
    get: function () {
      return URt.print;
    },
  });
  Object.defineProperty(er, "visit", {
    enumerable: !0,
    get: function () {
      return BN.visit;
    },
  });
  Object.defineProperty(er, "visitInParallel", {
    enumerable: !0,
    get: function () {
      return BN.visitInParallel;
    },
  });
  Object.defineProperty(er, "getVisitFn", {
    enumerable: !0,
    get: function () {
      return BN.getVisitFn;
    },
  });
  Object.defineProperty(er, "BREAK", {
    enumerable: !0,
    get: function () {
      return BN.BREAK;
    },
  });
  Object.defineProperty(er, "Location", {
    enumerable: !0,
    get: function () {
      return kpe.Location;
    },
  });
  Object.defineProperty(er, "Token", {
    enumerable: !0,
    get: function () {
      return kpe.Token;
    },
  });
  Object.defineProperty(er, "isDefinitionNode", {
    enumerable: !0,
    get: function () {
      return el.isDefinitionNode;
    },
  });
  Object.defineProperty(er, "isExecutableDefinitionNode", {
    enumerable: !0,
    get: function () {
      return el.isExecutableDefinitionNode;
    },
  });
  Object.defineProperty(er, "isSelectionNode", {
    enumerable: !0,
    get: function () {
      return el.isSelectionNode;
    },
  });
  Object.defineProperty(er, "isValueNode", {
    enumerable: !0,
    get: function () {
      return el.isValueNode;
    },
  });
  Object.defineProperty(er, "isTypeNode", {
    enumerable: !0,
    get: function () {
      return el.isTypeNode;
    },
  });
  Object.defineProperty(er, "isTypeSystemDefinitionNode", {
    enumerable: !0,
    get: function () {
      return el.isTypeSystemDefinitionNode;
    },
  });
  Object.defineProperty(er, "isTypeDefinitionNode", {
    enumerable: !0,
    get: function () {
      return el.isTypeDefinitionNode;
    },
  });
  Object.defineProperty(er, "isTypeSystemExtensionNode", {
    enumerable: !0,
    get: function () {
      return el.isTypeSystemExtensionNode;
    },
  });
  Object.defineProperty(er, "isTypeExtensionNode", {
    enumerable: !0,
    get: function () {
      return el.isTypeExtensionNode;
    },
  });
  Object.defineProperty(er, "DirectiveLocation", {
    enumerable: !0,
    get: function () {
      return HRt.DirectiveLocation;
    },
  });
  var MRt = Ux(),
    qRt = Ax(),
    Npe = _V(),
    jRt = lr(),
    FRt = Gv(),
    BRt = Vx(),
    p2 = zv(),
    URt = ta(),
    BN = Bd(),
    kpe = Hv(),
    el = Tm(),
    HRt = Vv();
});
var Lpe = g((ef) => {
  "use strict";
  c();
  Object.defineProperty(ef, "__esModule", { value: !0 });
  Object.defineProperty(ef, "responsePathAsArray", {
    enumerable: !0,
    get: function () {
      return GRt.pathToArray;
    },
  });
  Object.defineProperty(ef, "execute", {
    enumerable: !0,
    get: function () {
      return UN.execute;
    },
  });
  Object.defineProperty(ef, "executeSync", {
    enumerable: !0,
    get: function () {
      return UN.executeSync;
    },
  });
  Object.defineProperty(ef, "defaultFieldResolver", {
    enumerable: !0,
    get: function () {
      return UN.defaultFieldResolver;
    },
  });
  Object.defineProperty(ef, "defaultTypeResolver", {
    enumerable: !0,
    get: function () {
      return UN.defaultTypeResolver;
    },
  });
  Object.defineProperty(ef, "getDirectiveValues", {
    enumerable: !0,
    get: function () {
      return VRt.getDirectiveValues;
    },
  });
  var GRt = R0(),
    UN = F0(),
    VRt = L0();
});
var Mpe = g((m2) => {
  "use strict";
  c();
  Object.defineProperty(m2, "__esModule", { value: !0 });
  m2.default = zRt;
  var $Rt = Oc();
  function zRt(e) {
    return typeof e?.[$Rt.SYMBOL_ASYNC_ITERATOR] == "function";
  }
});
var Bpe = g((h2) => {
  "use strict";
  c();
  Object.defineProperty(h2, "__esModule", { value: !0 });
  h2.default = WRt;
  var qpe = Oc();
  function KRt(e, t, r) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = r),
      e
    );
  }
  function WRt(e, t, r) {
    var n = e[qpe.SYMBOL_ASYNC_ITERATOR],
      i = n.call(e),
      o,
      a;
    typeof i.return == "function" &&
      ((o = i.return),
      (a = function (f) {
        var m = function () {
          return Promise.reject(f);
        };
        return o.call(i).then(m, m);
      }));
    function s(d) {
      return d.done ? d : jpe(d.value, t).then(Fpe, a);
    }
    var u;
    if (r) {
      var l = r;
      u = function (f) {
        return jpe(f, l).then(Fpe, a);
      };
    }
    return KRt(
      {
        next: function () {
          return i.next().then(s, u);
        },
        return: function () {
          return o
            ? o.call(i).then(s, u)
            : Promise.resolve({ value: void 0, done: !0 });
        },
        throw: function (f) {
          return typeof i.throw == "function"
            ? i.throw(f).then(s, u)
            : Promise.reject(f).catch(a);
        },
      },
      qpe.SYMBOL_ASYNC_ITERATOR,
      function () {
        return this;
      },
    );
  }
  function jpe(e, t) {
    return new Promise(function (r) {
      return r(t(e));
    });
  }
  function Fpe(e) {
    return { value: e, done: !1 };
  }
});
var Kpe = g((HN) => {
  "use strict";
  c();
  Object.defineProperty(HN, "__esModule", { value: !0 });
  HN.subscribe = ZRt;
  HN.createSourceEventStream = zpe;
  var QRt = v2(Lt()),
    Gpe = v2(Mpe()),
    g2 = R0(),
    Vpe = Ue(),
    Upe = s0(),
    YRt = L0(),
    my = F0(),
    XRt = xN(),
    JRt = v2(Bpe());
  function v2(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function ZRt(e, t, r, n, i, o, a, s) {
    return arguments.length === 1
      ? Hpe(e)
      : Hpe({
          schema: e,
          document: t,
          rootValue: r,
          contextValue: n,
          variableValues: i,
          operationName: o,
          fieldResolver: a,
          subscribeFieldResolver: s,
        });
  }
  function $pe(e) {
    if (e instanceof Vpe.GraphQLError) return { errors: [e] };
    throw e;
  }
  function Hpe(e) {
    var t = e.schema,
      r = e.document,
      n = e.rootValue,
      i = e.contextValue,
      o = e.variableValues,
      a = e.operationName,
      s = e.fieldResolver,
      u = e.subscribeFieldResolver,
      l = zpe(t, r, n, i, o, a, u),
      d = function (m) {
        return (0, my.execute)({
          schema: t,
          document: r,
          rootValue: m,
          contextValue: i,
          variableValues: o,
          operationName: a,
          fieldResolver: s,
        });
      };
    return l.then(function (f) {
      return (0, Gpe.default)(f) ? (0, JRt.default)(f, d, $pe) : f;
    });
  }
  function zpe(e, t, r, n, i, o, a) {
    return (
      (0, my.assertValidExecutionArguments)(e, t, i),
      new Promise(function (s) {
        var u = (0, my.buildExecutionContext)(e, t, r, n, i, o, a);
        s(Array.isArray(u) ? { errors: u } : eIt(u));
      }).catch($pe)
    );
  }
  function eIt(e) {
    var t = e.schema,
      r = e.operation,
      n = e.variableValues,
      i = e.rootValue,
      o = (0, XRt.getOperationRootType)(t, r),
      a = (0, my.collectFields)(
        e,
        o,
        r.selectionSet,
        Object.create(null),
        Object.create(null),
      ),
      s = Object.keys(a),
      u = s[0],
      l = a[u],
      d = l[0],
      f = d.name.value,
      m = (0, my.getFieldDef)(t, o, f);
    if (!m)
      throw new Vpe.GraphQLError(
        'The subscription field "'.concat(f, '" is not defined.'),
        l,
      );
    var h = (0, g2.addPath)(void 0, u, o.name),
      y = (0, my.buildResolveInfo)(e, m, l, o, h);
    return new Promise(function (_) {
      var E,
        b = (0, YRt.getArgumentValues)(m, l[0], n),
        O = e.contextValue,
        C = (E = m.subscribe) !== null && E !== void 0 ? E : e.fieldResolver;
      _(C(i, b, O, y));
    }).then(
      function (_) {
        if (_ instanceof Error)
          throw (0, Upe.locatedError)(_, l, (0, g2.pathToArray)(h));
        if (!(0, Gpe.default)(_))
          throw new Error(
            "Subscription field must return Async Iterable. " +
              "Received: ".concat((0, QRt.default)(_), "."),
          );
        return _;
      },
      function (_) {
        throw (0, Upe.locatedError)(_, l, (0, g2.pathToArray)(h));
      },
    );
  }
});
var Qpe = g((GN) => {
  "use strict";
  c();
  Object.defineProperty(GN, "__esModule", { value: !0 });
  Object.defineProperty(GN, "subscribe", {
    enumerable: !0,
    get: function () {
      return Wpe.subscribe;
    },
  });
  Object.defineProperty(GN, "createSourceEventStream", {
    enumerable: !0,
    get: function () {
      return Wpe.createSourceEventStream;
    },
  });
  var Wpe = Kpe();
});
var b2 = g((E2) => {
  "use strict";
  c();
  Object.defineProperty(E2, "__esModule", { value: !0 });
  E2.NoDeprecatedCustomRule = rIt;
  var y2 = tIt(vi()),
    B0 = Ue(),
    _2 = It();
  function tIt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function rIt(e) {
    return {
      Field: function (r) {
        var n = e.getFieldDef(),
          i = n?.deprecationReason;
        if (n && i != null) {
          var o = e.getParentType();
          o != null || (0, y2.default)(0),
            e.reportError(
              new B0.GraphQLError(
                "The field "
                  .concat(o.name, ".")
                  .concat(n.name, " is deprecated. ")
                  .concat(i),
                r,
              ),
            );
        }
      },
      Argument: function (r) {
        var n = e.getArgument(),
          i = n?.deprecationReason;
        if (n && i != null) {
          var o = e.getDirective();
          if (o != null)
            e.reportError(
              new B0.GraphQLError(
                'Directive "@'
                  .concat(o.name, '" argument "')
                  .concat(n.name, '" is deprecated. ')
                  .concat(i),
                r,
              ),
            );
          else {
            var a = e.getParentType(),
              s = e.getFieldDef();
            (a != null && s != null) || (0, y2.default)(0),
              e.reportError(
                new B0.GraphQLError(
                  'Field "'
                    .concat(a.name, ".")
                    .concat(s.name, '" argument "')
                    .concat(n.name, '" is deprecated. ')
                    .concat(i),
                  r,
                ),
              );
          }
        }
      },
      ObjectField: function (r) {
        var n = (0, _2.getNamedType)(e.getParentInputType());
        if ((0, _2.isInputObjectType)(n)) {
          var i = n.getFields()[r.name.value],
            o = i?.deprecationReason;
          o != null &&
            e.reportError(
              new B0.GraphQLError(
                "The input field "
                  .concat(n.name, ".")
                  .concat(i.name, " is deprecated. ")
                  .concat(o),
                r,
              ),
            );
        }
      },
      EnumValue: function (r) {
        var n = e.getEnumValue(),
          i = n?.deprecationReason;
        if (n && i != null) {
          var o = (0, _2.getNamedType)(e.getInputType());
          o != null || (0, y2.default)(0),
            e.reportError(
              new B0.GraphQLError(
                'The enum value "'
                  .concat(o.name, ".")
                  .concat(n.name, '" is deprecated. ')
                  .concat(i),
                r,
              ),
            );
        }
      },
    };
  }
});
var Ype = g((S2) => {
  "use strict";
  c();
  Object.defineProperty(S2, "__esModule", { value: !0 });
  S2.NoSchemaIntrospectionCustomRule = aIt;
  var nIt = Ue(),
    iIt = It(),
    oIt = Ra();
  function aIt(e) {
    return {
      Field: function (r) {
        var n = (0, iIt.getNamedType)(e.getType());
        n &&
          (0, oIt.isIntrospectionType)(n) &&
          e.reportError(
            new nIt.GraphQLError(
              'GraphQL introspection has been disabled, but the requested query contained the field "'.concat(
                r.name.value,
                '".',
              ),
              r,
            ),
          );
      },
    };
  }
});
var Xpe = g((ct) => {
  "use strict";
  c();
  Object.defineProperty(ct, "__esModule", { value: !0 });
  Object.defineProperty(ct, "validate", {
    enumerable: !0,
    get: function () {
      return sIt.validate;
    },
  });
  Object.defineProperty(ct, "ValidationContext", {
    enumerable: !0,
    get: function () {
      return cIt.ValidationContext;
    },
  });
  Object.defineProperty(ct, "specifiedRules", {
    enumerable: !0,
    get: function () {
      return uIt.specifiedRules;
    },
  });
  Object.defineProperty(ct, "ExecutableDefinitionsRule", {
    enumerable: !0,
    get: function () {
      return lIt.ExecutableDefinitionsRule;
    },
  });
  Object.defineProperty(ct, "FieldsOnCorrectTypeRule", {
    enumerable: !0,
    get: function () {
      return dIt.FieldsOnCorrectTypeRule;
    },
  });
  Object.defineProperty(ct, "FragmentsOnCompositeTypesRule", {
    enumerable: !0,
    get: function () {
      return fIt.FragmentsOnCompositeTypesRule;
    },
  });
  Object.defineProperty(ct, "KnownArgumentNamesRule", {
    enumerable: !0,
    get: function () {
      return pIt.KnownArgumentNamesRule;
    },
  });
  Object.defineProperty(ct, "KnownDirectivesRule", {
    enumerable: !0,
    get: function () {
      return mIt.KnownDirectivesRule;
    },
  });
  Object.defineProperty(ct, "KnownFragmentNamesRule", {
    enumerable: !0,
    get: function () {
      return hIt.KnownFragmentNamesRule;
    },
  });
  Object.defineProperty(ct, "KnownTypeNamesRule", {
    enumerable: !0,
    get: function () {
      return gIt.KnownTypeNamesRule;
    },
  });
  Object.defineProperty(ct, "LoneAnonymousOperationRule", {
    enumerable: !0,
    get: function () {
      return vIt.LoneAnonymousOperationRule;
    },
  });
  Object.defineProperty(ct, "NoFragmentCyclesRule", {
    enumerable: !0,
    get: function () {
      return yIt.NoFragmentCyclesRule;
    },
  });
  Object.defineProperty(ct, "NoUndefinedVariablesRule", {
    enumerable: !0,
    get: function () {
      return _It.NoUndefinedVariablesRule;
    },
  });
  Object.defineProperty(ct, "NoUnusedFragmentsRule", {
    enumerable: !0,
    get: function () {
      return EIt.NoUnusedFragmentsRule;
    },
  });
  Object.defineProperty(ct, "NoUnusedVariablesRule", {
    enumerable: !0,
    get: function () {
      return bIt.NoUnusedVariablesRule;
    },
  });
  Object.defineProperty(ct, "OverlappingFieldsCanBeMergedRule", {
    enumerable: !0,
    get: function () {
      return SIt.OverlappingFieldsCanBeMergedRule;
    },
  });
  Object.defineProperty(ct, "PossibleFragmentSpreadsRule", {
    enumerable: !0,
    get: function () {
      return CIt.PossibleFragmentSpreadsRule;
    },
  });
  Object.defineProperty(ct, "ProvidedRequiredArgumentsRule", {
    enumerable: !0,
    get: function () {
      return wIt.ProvidedRequiredArgumentsRule;
    },
  });
  Object.defineProperty(ct, "ScalarLeafsRule", {
    enumerable: !0,
    get: function () {
      return OIt.ScalarLeafsRule;
    },
  });
  Object.defineProperty(ct, "SingleFieldSubscriptionsRule", {
    enumerable: !0,
    get: function () {
      return TIt.SingleFieldSubscriptionsRule;
    },
  });
  Object.defineProperty(ct, "UniqueArgumentNamesRule", {
    enumerable: !0,
    get: function () {
      return AIt.UniqueArgumentNamesRule;
    },
  });
  Object.defineProperty(ct, "UniqueDirectivesPerLocationRule", {
    enumerable: !0,
    get: function () {
      return PIt.UniqueDirectivesPerLocationRule;
    },
  });
  Object.defineProperty(ct, "UniqueFragmentNamesRule", {
    enumerable: !0,
    get: function () {
      return RIt.UniqueFragmentNamesRule;
    },
  });
  Object.defineProperty(ct, "UniqueInputFieldNamesRule", {
    enumerable: !0,
    get: function () {
      return IIt.UniqueInputFieldNamesRule;
    },
  });
  Object.defineProperty(ct, "UniqueOperationNamesRule", {
    enumerable: !0,
    get: function () {
      return xIt.UniqueOperationNamesRule;
    },
  });
  Object.defineProperty(ct, "UniqueVariableNamesRule", {
    enumerable: !0,
    get: function () {
      return NIt.UniqueVariableNamesRule;
    },
  });
  Object.defineProperty(ct, "ValuesOfCorrectTypeRule", {
    enumerable: !0,
    get: function () {
      return kIt.ValuesOfCorrectTypeRule;
    },
  });
  Object.defineProperty(ct, "VariablesAreInputTypesRule", {
    enumerable: !0,
    get: function () {
      return DIt.VariablesAreInputTypesRule;
    },
  });
  Object.defineProperty(ct, "VariablesInAllowedPositionRule", {
    enumerable: !0,
    get: function () {
      return LIt.VariablesInAllowedPositionRule;
    },
  });
  Object.defineProperty(ct, "LoneSchemaDefinitionRule", {
    enumerable: !0,
    get: function () {
      return MIt.LoneSchemaDefinitionRule;
    },
  });
  Object.defineProperty(ct, "UniqueOperationTypesRule", {
    enumerable: !0,
    get: function () {
      return qIt.UniqueOperationTypesRule;
    },
  });
  Object.defineProperty(ct, "UniqueTypeNamesRule", {
    enumerable: !0,
    get: function () {
      return jIt.UniqueTypeNamesRule;
    },
  });
  Object.defineProperty(ct, "UniqueEnumValueNamesRule", {
    enumerable: !0,
    get: function () {
      return FIt.UniqueEnumValueNamesRule;
    },
  });
  Object.defineProperty(ct, "UniqueFieldDefinitionNamesRule", {
    enumerable: !0,
    get: function () {
      return BIt.UniqueFieldDefinitionNamesRule;
    },
  });
  Object.defineProperty(ct, "UniqueDirectiveNamesRule", {
    enumerable: !0,
    get: function () {
      return UIt.UniqueDirectiveNamesRule;
    },
  });
  Object.defineProperty(ct, "PossibleTypeExtensionsRule", {
    enumerable: !0,
    get: function () {
      return HIt.PossibleTypeExtensionsRule;
    },
  });
  Object.defineProperty(ct, "NoDeprecatedCustomRule", {
    enumerable: !0,
    get: function () {
      return GIt.NoDeprecatedCustomRule;
    },
  });
  Object.defineProperty(ct, "NoSchemaIntrospectionCustomRule", {
    enumerable: !0,
    get: function () {
      return VIt.NoSchemaIntrospectionCustomRule;
    },
  });
  var sIt = cy(),
    cIt = Xz(),
    uIt = Qz(),
    lIt = I$(),
    dIt = K$(),
    fIt = U$(),
    pIt = gz(),
    mIt = fz(),
    hIt = X$(),
    gIt = F$(),
    vIt = D$(),
    yIt = iz(),
    _It = cz(),
    EIt = Z$(),
    bIt = lz(),
    SIt = xz(),
    CIt = rz(),
    wIt = Sz(),
    OIt = $$(),
    TIt = M$(),
    AIt = yz(),
    PIt = hz(),
    RIt = Q$(),
    IIt = kz(),
    xIt = N$(),
    NIt = az(),
    kIt = Ez(),
    DIt = G$(),
    LIt = wz(),
    MIt = Lz(),
    qIt = qz(),
    jIt = Fz(),
    FIt = Uz(),
    BIt = Vz(),
    UIt = zz(),
    HIt = Wz(),
    GIt = b2(),
    VIt = Ype();
});
var Jpe = g((C2) => {
  "use strict";
  c();
  Object.defineProperty(C2, "__esModule", { value: !0 });
  C2.formatError = KIt;
  var $It = zIt(Ta());
  function zIt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function KIt(e) {
    var t;
    e || (0, $It.default)(0, "Received null or undefined error.");
    var r =
        (t = e.message) !== null && t !== void 0
          ? t
          : "An unknown error occurred.",
      n = e.locations,
      i = e.path,
      o = e.extensions;
    return o && Object.keys(o).length > 0
      ? { message: r, locations: n, path: i, extensions: o }
      : { message: r, locations: n, path: i };
  }
});
var eme = g((km) => {
  "use strict";
  c();
  Object.defineProperty(km, "__esModule", { value: !0 });
  Object.defineProperty(km, "GraphQLError", {
    enumerable: !0,
    get: function () {
      return Zpe.GraphQLError;
    },
  });
  Object.defineProperty(km, "printError", {
    enumerable: !0,
    get: function () {
      return Zpe.printError;
    },
  });
  Object.defineProperty(km, "syntaxError", {
    enumerable: !0,
    get: function () {
      return WIt.syntaxError;
    },
  });
  Object.defineProperty(km, "locatedError", {
    enumerable: !0,
    get: function () {
      return QIt.locatedError;
    },
  });
  Object.defineProperty(km, "formatError", {
    enumerable: !0,
    get: function () {
      return YIt.formatError;
    },
  });
  var Zpe = Ue(),
    WIt = Nx(),
    QIt = s0(),
    YIt = Jpe();
});
var O2 = g((w2) => {
  "use strict";
  c();
  Object.defineProperty(w2, "__esModule", { value: !0 });
  w2.getIntrospectionQuery = ZIt;
  function tme(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function (i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function XIt(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2
        ? tme(Object(r), !0).forEach(function (n) {
            JIt(e, n, r[n]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : tme(Object(r)).forEach(function (n) {
              Object.defineProperty(
                e,
                n,
                Object.getOwnPropertyDescriptor(r, n),
              );
            });
    }
    return e;
  }
  function JIt(e, t, r) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = r),
      e
    );
  }
  function ZIt(e) {
    var t = XIt(
        {
          descriptions: !0,
          specifiedByUrl: !1,
          directiveIsRepeatable: !1,
          schemaDescription: !1,
          inputValueDeprecation: !1,
        },
        e,
      ),
      r = t.descriptions ? "description" : "",
      n = t.specifiedByUrl ? "specifiedByUrl" : "",
      i = t.directiveIsRepeatable ? "isRepeatable" : "",
      o = t.schemaDescription ? r : "";
    function a(s) {
      return t.inputValueDeprecation ? s : "";
    }
    return `
    query IntrospectionQuery {
      __schema {
        `
      .concat(
        o,
        `
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          `,
      )
      .concat(
        r,
        `
          `,
      )
      .concat(
        i,
        `
          locations
          args`,
      )
      .concat(
        a("(includeDeprecated: true)"),
        ` {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      `,
      )
      .concat(
        r,
        `
      `,
      )
      .concat(
        n,
        `
      fields(includeDeprecated: true) {
        name
        `,
      )
      .concat(
        r,
        `
        args`,
      )
      .concat(
        a("(includeDeprecated: true)"),
        ` {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields`,
      )
      .concat(
        a("(includeDeprecated: true)"),
        ` {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        `,
      )
      .concat(
        r,
        `
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      `,
      )
      .concat(
        r,
        `
      type { ...TypeRef }
      defaultValue
      `,
      )
      .concat(
        a("isDeprecated"),
        `
      `,
      )
      .concat(
        a("deprecationReason"),
        `
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `,
      );
  }
});
var rme = g((T2) => {
  "use strict";
  c();
  Object.defineProperty(T2, "__esModule", { value: !0 });
  T2.getOperationAST = txt;
  var ext = lr();
  function txt(e, t) {
    for (var r = null, n = 0, i = e.definitions; n < i.length; n++) {
      var o = i[n];
      if (o.kind === ext.Kind.OPERATION_DEFINITION) {
        var a;
        if (t == null) {
          if (r) return null;
          r = o;
        } else if (
          ((a = o.name) === null || a === void 0 ? void 0 : a.value) === t
        )
          return o;
      }
    }
    return r;
  }
});
var ime = g((A2) => {
  "use strict";
  c();
  Object.defineProperty(A2, "__esModule", { value: !0 });
  A2.introspectionFromSchema = uxt;
  var rxt = axt(vi()),
    nxt = zv(),
    ixt = F0(),
    oxt = O2();
  function axt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function nme(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function (i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function sxt(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2
        ? nme(Object(r), !0).forEach(function (n) {
            cxt(e, n, r[n]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : nme(Object(r)).forEach(function (n) {
              Object.defineProperty(
                e,
                n,
                Object.getOwnPropertyDescriptor(r, n),
              );
            });
    }
    return e;
  }
  function cxt(e, t, r) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = r),
      e
    );
  }
  function uxt(e, t) {
    var r = sxt(
        {
          specifiedByUrl: !0,
          directiveIsRepeatable: !0,
          schemaDescription: !0,
          inputValueDeprecation: !0,
        },
        t,
      ),
      n = (0, nxt.parse)((0, oxt.getIntrospectionQuery)(r)),
      i = (0, ixt.executeSync)({ schema: e, document: n });
    return (!i.errors && i.data) || (0, rxt.default)(0), i.data;
  }
});
var ame = g((P2) => {
  "use strict";
  c();
  Object.defineProperty(P2, "__esModule", { value: !0 });
  P2.buildClientSchema = vxt;
  var lxt = U0(ea()),
    ia = U0(Lt()),
    dxt = U0(Ta()),
    VN = U0(c0()),
    ome = U0(wc()),
    fxt = zv(),
    pxt = wm(),
    mxt = bo(),
    hxt = Pc(),
    kc = Ra(),
    oa = It(),
    gxt = x0();
  function U0(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function vxt(e, t) {
    ((0, ome.default)(e) && (0, ome.default)(e.__schema)) ||
      (0, dxt.default)(
        0,
        'Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: '.concat(
          (0, ia.default)(e),
          ".",
        ),
      );
    for (
      var r = e.__schema,
        n = (0, VN.default)(
          r.types,
          function (j) {
            return j.name;
          },
          function (j) {
            return _(j);
          },
        ),
        i = 0,
        o = [].concat(hxt.specifiedScalarTypes, kc.introspectionTypes);
      i < o.length;
      i++
    ) {
      var a = o[i];
      n[a.name] && (n[a.name] = a);
    }
    var s = r.queryType ? h(r.queryType) : null,
      u = r.mutationType ? h(r.mutationType) : null,
      l = r.subscriptionType ? h(r.subscriptionType) : null,
      d = r.directives ? r.directives.map(Ct) : [];
    return new pxt.GraphQLSchema({
      description: r.description,
      query: s,
      mutation: u,
      subscription: l,
      types: (0, lxt.default)(n),
      directives: d,
      assumeValid: t?.assumeValid,
    });
    function f(j) {
      if (j.kind === kc.TypeKind.LIST) {
        var ce = j.ofType;
        if (!ce)
          throw new Error("Decorated type deeper than introspection query.");
        return new oa.GraphQLList(f(ce));
      }
      if (j.kind === kc.TypeKind.NON_NULL) {
        var Ve = j.ofType;
        if (!Ve)
          throw new Error("Decorated type deeper than introspection query.");
        var $t = f(Ve);
        return new oa.GraphQLNonNull((0, oa.assertNullableType)($t));
      }
      return m(j);
    }
    function m(j) {
      var ce = j.name;
      if (!ce)
        throw new Error(
          "Unknown type reference: ".concat((0, ia.default)(j), "."),
        );
      var Ve = n[ce];
      if (!Ve)
        throw new Error(
          "Invalid or incomplete schema, unknown type: ".concat(
            ce,
            ". Ensure that a full introspection query is used in order to build a client schema.",
          ),
        );
      return Ve;
    }
    function h(j) {
      return (0, oa.assertObjectType)(m(j));
    }
    function y(j) {
      return (0, oa.assertInterfaceType)(m(j));
    }
    function _(j) {
      if (j != null && j.name != null && j.kind != null)
        switch (j.kind) {
          case kc.TypeKind.SCALAR:
            return E(j);
          case kc.TypeKind.OBJECT:
            return O(j);
          case kc.TypeKind.INTERFACE:
            return C(j);
          case kc.TypeKind.UNION:
            return P(j);
          case kc.TypeKind.ENUM:
            return k(j);
          case kc.TypeKind.INPUT_OBJECT:
            return H(j);
        }
      var ce = (0, ia.default)(j);
      throw new Error(
        "Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ".concat(
          ce,
          ".",
        ),
      );
    }
    function E(j) {
      return new oa.GraphQLScalarType({
        name: j.name,
        description: j.description,
        specifiedByUrl: j.specifiedByUrl,
      });
    }
    function b(j) {
      if (j.interfaces === null && j.kind === kc.TypeKind.INTERFACE) return [];
      if (!j.interfaces) {
        var ce = (0, ia.default)(j);
        throw new Error(
          "Introspection result missing interfaces: ".concat(ce, "."),
        );
      }
      return j.interfaces.map(y);
    }
    function O(j) {
      return new oa.GraphQLObjectType({
        name: j.name,
        description: j.description,
        interfaces: function () {
          return b(j);
        },
        fields: function () {
          return B(j);
        },
      });
    }
    function C(j) {
      return new oa.GraphQLInterfaceType({
        name: j.name,
        description: j.description,
        interfaces: function () {
          return b(j);
        },
        fields: function () {
          return B(j);
        },
      });
    }
    function P(j) {
      if (!j.possibleTypes) {
        var ce = (0, ia.default)(j);
        throw new Error(
          "Introspection result missing possibleTypes: ".concat(ce, "."),
        );
      }
      return new oa.GraphQLUnionType({
        name: j.name,
        description: j.description,
        types: function () {
          return j.possibleTypes.map(h);
        },
      });
    }
    function k(j) {
      if (!j.enumValues) {
        var ce = (0, ia.default)(j);
        throw new Error(
          "Introspection result missing enumValues: ".concat(ce, "."),
        );
      }
      return new oa.GraphQLEnumType({
        name: j.name,
        description: j.description,
        values: (0, VN.default)(
          j.enumValues,
          function (Ve) {
            return Ve.name;
          },
          function (Ve) {
            return {
              description: Ve.description,
              deprecationReason: Ve.deprecationReason,
            };
          },
        ),
      });
    }
    function H(j) {
      if (!j.inputFields) {
        var ce = (0, ia.default)(j);
        throw new Error(
          "Introspection result missing inputFields: ".concat(ce, "."),
        );
      }
      return new oa.GraphQLInputObjectType({
        name: j.name,
        description: j.description,
        fields: function () {
          return Z(j.inputFields);
        },
      });
    }
    function B(j) {
      if (!j.fields)
        throw new Error(
          "Introspection result missing fields: ".concat(
            (0, ia.default)(j),
            ".",
          ),
        );
      return (0, VN.default)(
        j.fields,
        function (ce) {
          return ce.name;
        },
        L,
      );
    }
    function L(j) {
      var ce = f(j.type);
      if (!(0, oa.isOutputType)(ce)) {
        var Ve = (0, ia.default)(ce);
        throw new Error(
          "Introspection must provide output type for fields, but received: ".concat(
            Ve,
            ".",
          ),
        );
      }
      if (!j.args) {
        var $t = (0, ia.default)(j);
        throw new Error(
          "Introspection result missing field args: ".concat($t, "."),
        );
      }
      return {
        description: j.description,
        deprecationReason: j.deprecationReason,
        type: ce,
        args: Z(j.args),
      };
    }
    function Z(j) {
      return (0, VN.default)(
        j,
        function (ce) {
          return ce.name;
        },
        ft,
      );
    }
    function ft(j) {
      var ce = f(j.type);
      if (!(0, oa.isInputType)(ce)) {
        var Ve = (0, ia.default)(ce);
        throw new Error(
          "Introspection must provide input type for arguments, but received: ".concat(
            Ve,
            ".",
          ),
        );
      }
      var $t =
        j.defaultValue != null
          ? (0, gxt.valueFromAST)((0, fxt.parseValue)(j.defaultValue), ce)
          : void 0;
      return {
        description: j.description,
        type: ce,
        defaultValue: $t,
        deprecationReason: j.deprecationReason,
      };
    }
    function Ct(j) {
      if (!j.args) {
        var ce = (0, ia.default)(j);
        throw new Error(
          "Introspection result missing directive args: ".concat(ce, "."),
        );
      }
      if (!j.locations) {
        var Ve = (0, ia.default)(j);
        throw new Error(
          "Introspection result missing directive locations: ".concat(Ve, "."),
        );
      }
      return new mxt.GraphQLDirective({
        name: j.name,
        description: j.description,
        isRepeatable: j.isRepeatable,
        locations: j.locations.slice(),
        args: Z(j.args),
      });
    }
  }
});
var R2 = g((G0) => {
  "use strict";
  c();
  Object.defineProperty(G0, "__esModule", { value: !0 });
  G0.extendSchema = Oxt;
  G0.extendSchemaImpl = yme;
  G0.getDescription = Dm;
  var yxt = hy(ea()),
    _xt = hy(Ud()),
    sme = hy(Lt()),
    H0 = hy(MV()),
    cme = hy(vi()),
    Ext = hy(Ta()),
    xa = lr(),
    bxt = Gv(),
    Sxt = $v(),
    ume = Tm(),
    Cxt = cy(),
    hme = L0(),
    lme = wm(),
    gme = Pc(),
    vme = Ra(),
    zN = bo(),
    Vr = It(),
    dme = x0();
  function hy(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function fme(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function (i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function qt(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2
        ? fme(Object(r), !0).forEach(function (n) {
            wxt(e, n, r[n]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : fme(Object(r)).forEach(function (n) {
              Object.defineProperty(
                e,
                n,
                Object.getOwnPropertyDescriptor(r, n),
              );
            });
    }
    return e;
  }
  function wxt(e, t, r) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = r),
      e
    );
  }
  function Oxt(e, t, r) {
    (0, lme.assertSchema)(e),
      (t != null && t.kind === xa.Kind.DOCUMENT) ||
        (0, Ext.default)(0, "Must provide valid Document AST."),
      r?.assumeValid !== !0 &&
        r?.assumeValidSDL !== !0 &&
        (0, Cxt.assertValidSDLExtension)(t, e);
    var n = e.toConfig(),
      i = yme(n, t, r);
    return n === i ? e : new lme.GraphQLSchema(i);
  }
  function yme(e, t, r) {
    for (
      var n,
        i,
        o,
        a,
        s = [],
        u = Object.create(null),
        l = [],
        d,
        f = [],
        m = 0,
        h = t.definitions;
      m < h.length;
      m++
    ) {
      var y = h[m];
      if (y.kind === xa.Kind.SCHEMA_DEFINITION) d = y;
      else if (y.kind === xa.Kind.SCHEMA_EXTENSION) f.push(y);
      else if ((0, ume.isTypeDefinitionNode)(y)) s.push(y);
      else if ((0, ume.isTypeExtensionNode)(y)) {
        var _ = y.name.value,
          E = u[_];
        u[_] = E ? E.concat([y]) : [y];
      } else y.kind === xa.Kind.DIRECTIVE_DEFINITION && l.push(y);
    }
    if (
      Object.keys(u).length === 0 &&
      s.length === 0 &&
      l.length === 0 &&
      f.length === 0 &&
      d == null
    )
      return e;
    for (var b = Object.create(null), O = 0, C = e.types; O < C.length; O++) {
      var P = C[O];
      b[P.name] = ce(P);
    }
    for (var k = 0; k < s.length; k++) {
      var H,
        B = s[k],
        L = B.name.value;
      b[L] = (H = pme[L]) !== null && H !== void 0 ? H : Hrt(B);
    }
    var Z = qt(
      qt(
        {
          query: e.query && Ct(e.query),
          mutation: e.mutation && Ct(e.mutation),
          subscription: e.subscription && Ct(e.subscription),
        },
        d && iA([d]),
      ),
      iA(f),
    );
    return qt(
      qt(
        {
          description:
            (n = d) === null ||
            n === void 0 ||
            (i = n.description) === null ||
            i === void 0
              ? void 0
              : i.value,
        },
        Z,
      ),
      {},
      {
        types: (0, yxt.default)(b),
        directives: [].concat(e.directives.map(j), l.map(qu)),
        extensions: void 0,
        astNode: (o = d) !== null && o !== void 0 ? o : e.astNode,
        extensionASTNodes: e.extensionASTNodes.concat(f),
        assumeValid: (a = r?.assumeValid) !== null && a !== void 0 ? a : !1,
      },
    );
    function ft(z) {
      return (0, Vr.isListType)(z)
        ? new Vr.GraphQLList(ft(z.ofType))
        : (0, Vr.isNonNullType)(z)
          ? new Vr.GraphQLNonNull(ft(z.ofType))
          : Ct(z);
    }
    function Ct(z) {
      return b[z.name];
    }
    function j(z) {
      var Le = z.toConfig();
      return new zN.GraphQLDirective(
        qt(qt({}, Le), {}, { args: (0, H0.default)(Le.args, lS) }),
      );
    }
    function ce(z) {
      if ((0, vme.isIntrospectionType)(z) || (0, gme.isSpecifiedScalarType)(z))
        return z;
      if ((0, Vr.isScalarType)(z)) return Yo(z);
      if ((0, Vr.isObjectType)(z)) return Ts(z);
      if ((0, Vr.isInterfaceType)(z)) return nA(z);
      if ((0, Vr.isUnionType)(z)) return f3(z);
      if ((0, Vr.isEnumType)(z)) return $t(z);
      if ((0, Vr.isInputObjectType)(z)) return Ve(z);
      (0, cme.default)(0, "Unexpected type: " + (0, sme.default)(z));
    }
    function Ve(z) {
      var Le,
        Se = z.toConfig(),
        Ne = (Le = u[Se.name]) !== null && Le !== void 0 ? Le : [];
      return new Vr.GraphQLInputObjectType(
        qt(
          qt({}, Se),
          {},
          {
            fields: function () {
              return qt(
                qt(
                  {},
                  (0, H0.default)(Se.fields, function (zt) {
                    return qt(qt({}, zt), {}, { type: ft(zt.type) });
                  }),
                ),
                dS(Ne),
              );
            },
            extensionASTNodes: Se.extensionASTNodes.concat(Ne),
          },
        ),
      );
    }
    function $t(z) {
      var Le,
        Se = z.toConfig(),
        Ne = (Le = u[z.name]) !== null && Le !== void 0 ? Le : [];
      return new Vr.GraphQLEnumType(
        qt(
          qt({}, Se),
          {},
          {
            values: qt(qt({}, Se.values), fS(Ne)),
            extensionASTNodes: Se.extensionASTNodes.concat(Ne),
          },
        ),
      );
    }
    function Yo(z) {
      for (
        var Le,
          Se = z.toConfig(),
          Ne = (Le = u[Se.name]) !== null && Le !== void 0 ? Le : [],
          wt = Se.specifiedByUrl,
          zt = 0;
        zt < Ne.length;
        zt++
      ) {
        var Kt,
          Wt = Ne[zt];
        wt = (Kt = mme(Wt)) !== null && Kt !== void 0 ? Kt : wt;
      }
      return new Vr.GraphQLScalarType(
        qt(
          qt({}, Se),
          {},
          {
            specifiedByUrl: wt,
            extensionASTNodes: Se.extensionASTNodes.concat(Ne),
          },
        ),
      );
    }
    function Ts(z) {
      var Le,
        Se = z.toConfig(),
        Ne = (Le = u[Se.name]) !== null && Le !== void 0 ? Le : [];
      return new Vr.GraphQLObjectType(
        qt(
          qt({}, Se),
          {},
          {
            interfaces: function () {
              return [].concat(z.getInterfaces().map(Ct), aA(Ne));
            },
            fields: function () {
              return qt(qt({}, (0, H0.default)(Se.fields, uS)), Wg(Ne));
            },
            extensionASTNodes: Se.extensionASTNodes.concat(Ne),
          },
        ),
      );
    }
    function nA(z) {
      var Le,
        Se = z.toConfig(),
        Ne = (Le = u[Se.name]) !== null && Le !== void 0 ? Le : [];
      return new Vr.GraphQLInterfaceType(
        qt(
          qt({}, Se),
          {},
          {
            interfaces: function () {
              return [].concat(z.getInterfaces().map(Ct), aA(Ne));
            },
            fields: function () {
              return qt(qt({}, (0, H0.default)(Se.fields, uS)), Wg(Ne));
            },
            extensionASTNodes: Se.extensionASTNodes.concat(Ne),
          },
        ),
      );
    }
    function f3(z) {
      var Le,
        Se = z.toConfig(),
        Ne = (Le = u[Se.name]) !== null && Le !== void 0 ? Le : [];
      return new Vr.GraphQLUnionType(
        qt(
          qt({}, Se),
          {},
          {
            types: function () {
              return [].concat(z.getTypes().map(Ct), Wre(Ne));
            },
            extensionASTNodes: Se.extensionASTNodes.concat(Ne),
          },
        ),
      );
    }
    function uS(z) {
      return qt(
        qt({}, z),
        {},
        { type: ft(z.type), args: (0, H0.default)(z.args, lS) },
      );
    }
    function lS(z) {
      return qt(qt({}, z), {}, { type: ft(z.type) });
    }
    function iA(z) {
      for (var Le = {}, Se = 0; Se < z.length; Se++)
        for (
          var Ne,
            wt = z[Se],
            zt = (Ne = wt.operationTypes) !== null && Ne !== void 0 ? Ne : [],
            Kt = 0;
          Kt < zt.length;
          Kt++
        ) {
          var Wt = zt[Kt];
          Le[Wt.operation] = Kg(Wt.type);
        }
      return Le;
    }
    function Kg(z) {
      var Le,
        Se = z.name.value,
        Ne = (Le = pme[Se]) !== null && Le !== void 0 ? Le : b[Se];
      if (Ne === void 0) throw new Error('Unknown type: "'.concat(Se, '".'));
      return Ne;
    }
    function ur(z) {
      return z.kind === xa.Kind.LIST_TYPE
        ? new Vr.GraphQLList(ur(z.type))
        : z.kind === xa.Kind.NON_NULL_TYPE
          ? new Vr.GraphQLNonNull(ur(z.type))
          : Kg(z);
    }
    function qu(z) {
      var Le = z.locations.map(function (Se) {
        var Ne = Se.value;
        return Ne;
      });
      return new zN.GraphQLDirective({
        name: z.name.value,
        description: Dm(z, r),
        locations: Le,
        isRepeatable: z.repeatable,
        args: oA(z.arguments),
        astNode: z,
      });
    }
    function Wg(z) {
      for (var Le = Object.create(null), Se = 0; Se < z.length; Se++)
        for (
          var Ne,
            wt = z[Se],
            zt = (Ne = wt.fields) !== null && Ne !== void 0 ? Ne : [],
            Kt = 0;
          Kt < zt.length;
          Kt++
        ) {
          var Wt = zt[Kt];
          Le[Wt.name.value] = {
            type: ur(Wt.type),
            description: Dm(Wt, r),
            args: oA(Wt.arguments),
            deprecationReason: $N(Wt),
            astNode: Wt,
          };
        }
      return Le;
    }
    function oA(z) {
      for (
        var Le = z ?? [], Se = Object.create(null), Ne = 0;
        Ne < Le.length;
        Ne++
      ) {
        var wt = Le[Ne],
          zt = ur(wt.type);
        Se[wt.name.value] = {
          type: zt,
          description: Dm(wt, r),
          defaultValue: (0, dme.valueFromAST)(wt.defaultValue, zt),
          deprecationReason: $N(wt),
          astNode: wt,
        };
      }
      return Se;
    }
    function dS(z) {
      for (var Le = Object.create(null), Se = 0; Se < z.length; Se++)
        for (
          var Ne,
            wt = z[Se],
            zt = (Ne = wt.fields) !== null && Ne !== void 0 ? Ne : [],
            Kt = 0;
          Kt < zt.length;
          Kt++
        ) {
          var Wt = zt[Kt],
            pS = ur(Wt.type);
          Le[Wt.name.value] = {
            type: pS,
            description: Dm(Wt, r),
            defaultValue: (0, dme.valueFromAST)(Wt.defaultValue, pS),
            deprecationReason: $N(Wt),
            astNode: Wt,
          };
        }
      return Le;
    }
    function fS(z) {
      for (var Le = Object.create(null), Se = 0; Se < z.length; Se++)
        for (
          var Ne,
            wt = z[Se],
            zt = (Ne = wt.values) !== null && Ne !== void 0 ? Ne : [],
            Kt = 0;
          Kt < zt.length;
          Kt++
        ) {
          var Wt = zt[Kt];
          Le[Wt.name.value] = {
            description: Dm(Wt, r),
            deprecationReason: $N(Wt),
            astNode: Wt,
          };
        }
      return Le;
    }
    function aA(z) {
      for (var Le = [], Se = 0; Se < z.length; Se++)
        for (
          var Ne,
            wt = z[Se],
            zt = (Ne = wt.interfaces) !== null && Ne !== void 0 ? Ne : [],
            Kt = 0;
          Kt < zt.length;
          Kt++
        ) {
          var Wt = zt[Kt];
          Le.push(Kg(Wt));
        }
      return Le;
    }
    function Wre(z) {
      for (var Le = [], Se = 0; Se < z.length; Se++)
        for (
          var Ne,
            wt = z[Se],
            zt = (Ne = wt.types) !== null && Ne !== void 0 ? Ne : [],
            Kt = 0;
          Kt < zt.length;
          Kt++
        ) {
          var Wt = zt[Kt];
          Le.push(Kg(Wt));
        }
      return Le;
    }
    function Hrt(z) {
      var Le,
        Se = z.name.value,
        Ne = Dm(z, r),
        wt = (Le = u[Se]) !== null && Le !== void 0 ? Le : [];
      switch (z.kind) {
        case xa.Kind.OBJECT_TYPE_DEFINITION: {
          var zt = wt,
            Kt = [z].concat(zt);
          return new Vr.GraphQLObjectType({
            name: Se,
            description: Ne,
            interfaces: function () {
              return aA(Kt);
            },
            fields: function () {
              return Wg(Kt);
            },
            astNode: z,
            extensionASTNodes: zt,
          });
        }
        case xa.Kind.INTERFACE_TYPE_DEFINITION: {
          var Wt = wt,
            pS = [z].concat(Wt);
          return new Vr.GraphQLInterfaceType({
            name: Se,
            description: Ne,
            interfaces: function () {
              return aA(pS);
            },
            fields: function () {
              return Wg(pS);
            },
            astNode: z,
            extensionASTNodes: Wt,
          });
        }
        case xa.Kind.ENUM_TYPE_DEFINITION: {
          var Qre = wt,
            Grt = [z].concat(Qre);
          return new Vr.GraphQLEnumType({
            name: Se,
            description: Ne,
            values: fS(Grt),
            astNode: z,
            extensionASTNodes: Qre,
          });
        }
        case xa.Kind.UNION_TYPE_DEFINITION: {
          var Yre = wt,
            Vrt = [z].concat(Yre);
          return new Vr.GraphQLUnionType({
            name: Se,
            description: Ne,
            types: function () {
              return Wre(Vrt);
            },
            astNode: z,
            extensionASTNodes: Yre,
          });
        }
        case xa.Kind.SCALAR_TYPE_DEFINITION: {
          var $rt = wt;
          return new Vr.GraphQLScalarType({
            name: Se,
            description: Ne,
            specifiedByUrl: mme(z),
            astNode: z,
            extensionASTNodes: $rt,
          });
        }
        case xa.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
          var Xre = wt,
            zrt = [z].concat(Xre);
          return new Vr.GraphQLInputObjectType({
            name: Se,
            description: Ne,
            fields: function () {
              return dS(zrt);
            },
            astNode: z,
            extensionASTNodes: Xre,
          });
        }
      }
      (0, cme.default)(
        0,
        "Unexpected type definition node: " + (0, sme.default)(z),
      );
    }
  }
  var pme = (0, _xt.default)(
    gme.specifiedScalarTypes.concat(vme.introspectionTypes),
    function (e) {
      return e.name;
    },
  );
  function $N(e) {
    var t = (0, hme.getDirectiveValues)(zN.GraphQLDeprecatedDirective, e);
    return t?.reason;
  }
  function mme(e) {
    var t = (0, hme.getDirectiveValues)(zN.GraphQLSpecifiedByDirective, e);
    return t?.url;
  }
  function Dm(e, t) {
    if (e.description) return e.description.value;
    if (t?.commentDescriptions === !0) {
      var r = Txt(e);
      if (r !== void 0)
        return (0, Sxt.dedentBlockStringValue)(
          `
` + r,
        );
    }
  }
  function Txt(e) {
    var t = e.loc;
    if (t) {
      for (
        var r = [], n = t.startToken.prev;
        n != null &&
        n.kind === bxt.TokenKind.COMMENT &&
        n.next &&
        n.prev &&
        n.line + 1 === n.next.line &&
        n.line !== n.prev.line;

      ) {
        var i = String(n.value);
        r.push(i), (n = n.prev);
      }
      return r.length > 0
        ? r.reverse().join(`
`)
        : void 0;
    }
  }
});
var bme = g((KN) => {
  "use strict";
  c();
  Object.defineProperty(KN, "__esModule", { value: !0 });
  KN.buildASTSchema = Eme;
  KN.buildSchema = Dxt;
  var Axt = kxt(Ta()),
    Pxt = lr(),
    Rxt = zv(),
    Ixt = cy(),
    xxt = wm(),
    _me = bo(),
    Nxt = R2();
  function kxt(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Eme(e, t) {
    (e != null && e.kind === Pxt.Kind.DOCUMENT) ||
      (0, Axt.default)(0, "Must provide valid Document AST."),
      t?.assumeValid !== !0 &&
        t?.assumeValidSDL !== !0 &&
        (0, Ixt.assertValidSDL)(e);
    var r = {
        description: void 0,
        types: [],
        directives: [],
        extensions: void 0,
        extensionASTNodes: [],
        assumeValid: !1,
      },
      n = (0, Nxt.extendSchemaImpl)(r, e, t);
    if (n.astNode == null)
      for (var i = 0, o = n.types; i < o.length; i++) {
        var a = o[i];
        switch (a.name) {
          case "Query":
            n.query = a;
            break;
          case "Mutation":
            n.mutation = a;
            break;
          case "Subscription":
            n.subscription = a;
            break;
        }
      }
    for (
      var s = n.directives,
        u = function (f) {
          var m = _me.specifiedDirectives[f];
          s.every(function (h) {
            return h.name !== m.name;
          }) && s.push(m);
        },
        l = 0;
      l < _me.specifiedDirectives.length;
      l++
    )
      u(l);
    return new xxt.GraphQLSchema(n);
  }
  function Dxt(e, t) {
    var r = (0, Rxt.parse)(e, {
      noLocation: t?.noLocation,
      allowLegacySDLEmptyFields: t?.allowLegacySDLEmptyFields,
      allowLegacySDLImplementsInterfaces: t?.allowLegacySDLImplementsInterfaces,
      experimentalFragmentVariables: t?.experimentalFragmentVariables,
    });
    return Eme(r, {
      commentDescriptions: t?.commentDescriptions,
      assumeValidSDL: t?.assumeValidSDL,
      assumeValid: t?.assumeValid,
    });
  }
});
var Cme = g((N2) => {
  "use strict";
  c();
  Object.defineProperty(N2, "__esModule", { value: !0 });
  N2.lexicographicSortSchema = Vxt;
  var Lxt = V0(ea()),
    Mxt = V0(Lt()),
    qxt = V0(vi()),
    jxt = V0(c0()),
    Fxt = V0(u0()),
    Bxt = wm(),
    Uxt = bo(),
    Hxt = Ra(),
    eo = It();
  function V0(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Sme(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function (i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function Cn(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2
        ? Sme(Object(r), !0).forEach(function (n) {
            Gxt(e, n, r[n]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : Sme(Object(r)).forEach(function (n) {
              Object.defineProperty(
                e,
                n,
                Object.getOwnPropertyDescriptor(r, n),
              );
            });
    }
    return e;
  }
  function Gxt(e, t, r) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = r),
      e
    );
  }
  function Vxt(e) {
    var t = e.toConfig(),
      r = (0, jxt.default)(
        I2(t.types),
        function (m) {
          return m.name;
        },
        f,
      );
    return new Bxt.GraphQLSchema(
      Cn(
        Cn({}, t),
        {},
        {
          types: (0, Lxt.default)(r),
          directives: I2(t.directives).map(a),
          query: o(t.query),
          mutation: o(t.mutation),
          subscription: o(t.subscription),
        },
      ),
    );
    function n(m) {
      return (0, eo.isListType)(m)
        ? new eo.GraphQLList(n(m.ofType))
        : (0, eo.isNonNullType)(m)
          ? new eo.GraphQLNonNull(n(m.ofType))
          : i(m);
    }
    function i(m) {
      return r[m.name];
    }
    function o(m) {
      return m && i(m);
    }
    function a(m) {
      var h = m.toConfig();
      return new Uxt.GraphQLDirective(
        Cn(
          Cn({}, h),
          {},
          {
            locations: x2(h.locations, function (y) {
              return y;
            }),
            args: s(h.args),
          },
        ),
      );
    }
    function s(m) {
      return WN(m, function (h) {
        return Cn(Cn({}, h), {}, { type: n(h.type) });
      });
    }
    function u(m) {
      return WN(m, function (h) {
        return Cn(Cn({}, h), {}, { type: n(h.type), args: s(h.args) });
      });
    }
    function l(m) {
      return WN(m, function (h) {
        return Cn(Cn({}, h), {}, { type: n(h.type) });
      });
    }
    function d(m) {
      return I2(m).map(i);
    }
    function f(m) {
      if ((0, eo.isScalarType)(m) || (0, Hxt.isIntrospectionType)(m)) return m;
      if ((0, eo.isObjectType)(m)) {
        var h = m.toConfig();
        return new eo.GraphQLObjectType(
          Cn(
            Cn({}, h),
            {},
            {
              interfaces: function () {
                return d(h.interfaces);
              },
              fields: function () {
                return u(h.fields);
              },
            },
          ),
        );
      }
      if ((0, eo.isInterfaceType)(m)) {
        var y = m.toConfig();
        return new eo.GraphQLInterfaceType(
          Cn(
            Cn({}, y),
            {},
            {
              interfaces: function () {
                return d(y.interfaces);
              },
              fields: function () {
                return u(y.fields);
              },
            },
          ),
        );
      }
      if ((0, eo.isUnionType)(m)) {
        var _ = m.toConfig();
        return new eo.GraphQLUnionType(
          Cn(
            Cn({}, _),
            {},
            {
              types: function () {
                return d(_.types);
              },
            },
          ),
        );
      }
      if ((0, eo.isEnumType)(m)) {
        var E = m.toConfig();
        return new eo.GraphQLEnumType(
          Cn(Cn({}, E), {}, { values: WN(E.values) }),
        );
      }
      if ((0, eo.isInputObjectType)(m)) {
        var b = m.toConfig();
        return new eo.GraphQLInputObjectType(
          Cn(
            Cn({}, b),
            {},
            {
              fields: function () {
                return l(b.fields);
              },
            },
          ),
        );
      }
      (0, qxt.default)(0, "Unexpected type: " + (0, Mxt.default)(m));
    }
  }
  function WN(e, t) {
    for (
      var r = Object.create(null),
        n = x2(Object.keys(e), function (s) {
          return s;
        }),
        i = 0;
      i < n.length;
      i++
    ) {
      var o = n[i],
        a = e[o];
      r[o] = t ? t(a) : a;
    }
    return r;
  }
  function I2(e) {
    return x2(e, function (t) {
      return t.name;
    });
  }
  function x2(e, t) {
    return e.slice().sort(function (r, n) {
      var i = t(r),
        o = t(n);
      return (0, Fxt.default)(i, o);
    });
  }
});
var xme = g(($0) => {
  "use strict";
  c();
  Object.defineProperty($0, "__esModule", { value: !0 });
  $0.printSchema = Kxt;
  $0.printIntrospectionSchema = Wxt;
  $0.printType = Ame;
  var D2 = F2(ea()),
    $xt = F2(Lt()),
    wme = F2(vi()),
    L2 = ta(),
    zxt = $v(),
    Ome = Ra(),
    M2 = Pc(),
    q2 = bo(),
    gy = It(),
    j2 = E0();
  function F2(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Kxt(e, t) {
    return Tme(
      e,
      function (r) {
        return !(0, q2.isSpecifiedDirective)(r);
      },
      Qxt,
      t,
    );
  }
  function Wxt(e, t) {
    return Tme(e, q2.isSpecifiedDirective, Ome.isIntrospectionType, t);
  }
  function Qxt(e) {
    return (
      !(0, M2.isSpecifiedScalarType)(e) && !(0, Ome.isIntrospectionType)(e)
    );
  }
  function Tme(e, t, r, n) {
    var i = e.getDirectives().filter(t),
      o = (0, D2.default)(e.getTypeMap()).filter(r);
    return (
      [Yxt(e)]
        .concat(
          i.map(function (a) {
            return iNt(a, n);
          }),
          o.map(function (a) {
            return Ame(a, n);
          }),
        )
        .filter(Boolean).join(`

`) +
      `
`
    );
  }
  function Yxt(e) {
    if (!(e.description == null && Xxt(e))) {
      var t = [],
        r = e.getQueryType();
      r && t.push("  query: ".concat(r.name));
      var n = e.getMutationType();
      n && t.push("  mutation: ".concat(n.name));
      var i = e.getSubscriptionType();
      return (
        i && t.push("  subscription: ".concat(i.name)),
        Na({}, e) +
          `schema {
`.concat(
            t.join(`
`),
            `
}`,
          )
      );
    }
  }
  function Xxt(e) {
    var t = e.getQueryType();
    if (t && t.name !== "Query") return !1;
    var r = e.getMutationType();
    if (r && r.name !== "Mutation") return !1;
    var n = e.getSubscriptionType();
    return !(n && n.name !== "Subscription");
  }
  function Ame(e, t) {
    if ((0, gy.isScalarType)(e)) return Jxt(e, t);
    if ((0, gy.isObjectType)(e)) return Zxt(e, t);
    if ((0, gy.isInterfaceType)(e)) return eNt(e, t);
    if ((0, gy.isUnionType)(e)) return tNt(e, t);
    if ((0, gy.isEnumType)(e)) return rNt(e, t);
    if ((0, gy.isInputObjectType)(e)) return nNt(e, t);
    (0, wme.default)(0, "Unexpected type: " + (0, $xt.default)(e));
  }
  function Jxt(e, t) {
    return Na(t, e) + "scalar ".concat(e.name) + oNt(e);
  }
  function Pme(e) {
    var t = e.getInterfaces();
    return t.length
      ? " implements " +
          t
            .map(function (r) {
              return r.name;
            })
            .join(" & ")
      : "";
  }
  function Zxt(e, t) {
    return Na(t, e) + "type ".concat(e.name) + Pme(e) + Rme(t, e);
  }
  function eNt(e, t) {
    return Na(t, e) + "interface ".concat(e.name) + Pme(e) + Rme(t, e);
  }
  function tNt(e, t) {
    var r = e.getTypes(),
      n = r.length ? " = " + r.join(" | ") : "";
    return Na(t, e) + "union " + e.name + n;
  }
  function rNt(e, t) {
    var r = e.getValues().map(function (n, i) {
      return Na(t, n, "  ", !i) + "  " + n.name + U2(n.deprecationReason);
    });
    return Na(t, e) + "enum ".concat(e.name) + B2(r);
  }
  function nNt(e, t) {
    var r = (0, D2.default)(e.getFields()).map(function (n, i) {
      return Na(t, n, "  ", !i) + "  " + k2(n);
    });
    return Na(t, e) + "input ".concat(e.name) + B2(r);
  }
  function Rme(e, t) {
    var r = (0, D2.default)(t.getFields()).map(function (n, i) {
      return (
        Na(e, n, "  ", !i) +
        "  " +
        n.name +
        Ime(e, n.args, "  ") +
        ": " +
        String(n.type) +
        U2(n.deprecationReason)
      );
    });
    return B2(r);
  }
  function B2(e) {
    return e.length !== 0
      ? ` {
` +
          e.join(`
`) +
          `
}`
      : "";
  }
  function Ime(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    return t.length === 0
      ? ""
      : t.every(function (n) {
            return !n.description;
          })
        ? "(" + t.map(k2).join(", ") + ")"
        : `(
` +
          t.map(function (n, i) {
            return Na(e, n, "  " + r, !i) + "  " + r + k2(n);
          }).join(`
`) +
          `
` +
          r +
          ")";
  }
  function k2(e) {
    var t = (0, j2.astFromValue)(e.defaultValue, e.type),
      r = e.name + ": " + String(e.type);
    return (
      t && (r += " = ".concat((0, L2.print)(t))), r + U2(e.deprecationReason)
    );
  }
  function iNt(e, t) {
    return (
      Na(t, e) +
      "directive @" +
      e.name +
      Ime(t, e.args) +
      (e.isRepeatable ? " repeatable" : "") +
      " on " +
      e.locations.join(" | ")
    );
  }
  function U2(e) {
    if (e == null) return "";
    var t = (0, j2.astFromValue)(e, M2.GraphQLString);
    return t && e !== q2.DEFAULT_DEPRECATION_REASON
      ? " @deprecated(reason: " + (0, L2.print)(t) + ")"
      : " @deprecated";
  }
  function oNt(e) {
    if (e.specifiedByUrl == null) return "";
    var t = e.specifiedByUrl,
      r = (0, j2.astFromValue)(t, M2.GraphQLString);
    return (
      r ||
        (0, wme.default)(
          0,
          "Unexpected null value returned from `astFromValue` for specifiedByUrl",
        ),
      " @specifiedBy(url: " + (0, L2.print)(r) + ")"
    );
  }
  function Na(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "",
      n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0,
      i = t.description;
    if (i == null) return "";
    if (e?.commentDescriptions === !0) return aNt(i, r, n);
    var o = i.length > 70,
      a = (0, zxt.printBlockString)(i, "", o),
      s =
        r && !n
          ? `
` + r
          : r;
    return (
      s +
      a.replace(
        /\n/g,
        `
` + r,
      ) +
      `
`
    );
  }
  function aNt(e, t, r) {
    var n =
        t && !r
          ? `
`
          : "",
      i = e
        .split(
          `
`,
        )
        .map(function (o) {
          return t + (o !== "" ? "# " + o : "#");
        }).join(`
`);
    return (
      n +
      i +
      `
`
    );
  }
});
var Nme = g((H2) => {
  "use strict";
  c();
  Object.defineProperty(H2, "__esModule", { value: !0 });
  H2.concatAST = sNt;
  function sNt(e) {
    for (var t = [], r = 0; r < e.length; r++) {
      var n = e[r];
      t = t.concat(n.definitions);
    }
    return { kind: "Document", definitions: t };
  }
});
var Lme = g((G2) => {
  "use strict";
  c();
  Object.defineProperty(G2, "__esModule", { value: !0 });
  G2.separateOperations = uNt;
  var QN = lr(),
    cNt = Bd();
  function uNt(e) {
    for (
      var t = [], r = Object.create(null), n = 0, i = e.definitions;
      n < i.length;
      n++
    ) {
      var o = i[n];
      switch (o.kind) {
        case QN.Kind.OPERATION_DEFINITION:
          t.push(o);
          break;
        case QN.Kind.FRAGMENT_DEFINITION:
          r[o.name.value] = kme(o.selectionSet);
          break;
      }
    }
    for (
      var a = Object.create(null),
        s = function (d) {
          for (
            var f = t[d], m = new Set(), h = 0, y = kme(f.selectionSet);
            h < y.length;
            h++
          ) {
            var _ = y[h];
            Dme(m, r, _);
          }
          var E = f.name ? f.name.value : "";
          a[E] = {
            kind: QN.Kind.DOCUMENT,
            definitions: e.definitions.filter(function (b) {
              return (
                b === f ||
                (b.kind === QN.Kind.FRAGMENT_DEFINITION && m.has(b.name.value))
              );
            }),
          };
        },
        u = 0;
      u < t.length;
      u++
    )
      s(u);
    return a;
  }
  function Dme(e, t, r) {
    if (!e.has(r)) {
      e.add(r);
      var n = t[r];
      if (n !== void 0)
        for (var i = 0; i < n.length; i++) {
          var o = n[i];
          Dme(e, t, o);
        }
    }
  }
  function kme(e) {
    var t = [];
    return (
      (0, cNt.visit)(e, {
        FragmentSpread: function (n) {
          t.push(n.name.value);
        },
      }),
      t
    );
  }
});
var Fme = g(($2) => {
  "use strict";
  c();
  Object.defineProperty($2, "__esModule", { value: !0 });
  $2.stripIgnoredCharacters = lNt;
  var Mme = Ux(),
    V2 = Gv(),
    qme = Vx(),
    jme = $v();
  function lNt(e) {
    for (
      var t = (0, Mme.isSource)(e) ? e : new Mme.Source(e),
        r = t.body,
        n = new qme.Lexer(t),
        i = "",
        o = !1;
      n.advance().kind !== V2.TokenKind.EOF;

    ) {
      var a = n.token,
        s = a.kind,
        u = !(0, qme.isPunctuatorTokenKind)(a.kind);
      o && (u || a.kind === V2.TokenKind.SPREAD) && (i += " ");
      var l = r.slice(a.start, a.end);
      s === V2.TokenKind.BLOCK_STRING ? (i += dNt(l)) : (i += l), (o = u);
    }
    return i;
  }
  function dNt(e) {
    var t = e.slice(3, -3),
      r = (0, jme.dedentBlockStringValue)(t);
    (0, jme.getBlockStringIndentation)(r) > 0 &&
      (r =
        `
` + r);
    var n = r[r.length - 1],
      i = n === '"' && r.slice(-4) !== '\\"""';
    return (
      (i || n === "\\") &&
        (r += `
`),
      '"""' + r + '"""'
    );
  }
});
var Qme = g((tf) => {
  "use strict";
  c();
  Object.defineProperty(tf, "__esModule", { value: !0 });
  tf.findBreakingChanges = _Nt;
  tf.findDangerousChanges = ENt;
  tf.DangerousChangeType = tf.BreakingChangeType = void 0;
  var vy = W0(ea()),
    Bme = W0(Ud()),
    fNt = W0(Lt()),
    Kme = W0(vi()),
    pNt = W0(u0()),
    mNt = ta(),
    hNt = Bd(),
    gNt = Pc(),
    jt = It(),
    vNt = E0();
  function W0(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function Ume(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function (i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function Hme(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2
        ? Ume(Object(r), !0).forEach(function (n) {
            yNt(e, n, r[n]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : Ume(Object(r)).forEach(function (n) {
              Object.defineProperty(
                e,
                n,
                Object.getOwnPropertyDescriptor(r, n),
              );
            });
    }
    return e;
  }
  function yNt(e, t, r) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = r),
      e
    );
  }
  var wn = Object.freeze({
    TYPE_REMOVED: "TYPE_REMOVED",
    TYPE_CHANGED_KIND: "TYPE_CHANGED_KIND",
    TYPE_REMOVED_FROM_UNION: "TYPE_REMOVED_FROM_UNION",
    VALUE_REMOVED_FROM_ENUM: "VALUE_REMOVED_FROM_ENUM",
    REQUIRED_INPUT_FIELD_ADDED: "REQUIRED_INPUT_FIELD_ADDED",
    IMPLEMENTED_INTERFACE_REMOVED: "IMPLEMENTED_INTERFACE_REMOVED",
    FIELD_REMOVED: "FIELD_REMOVED",
    FIELD_CHANGED_KIND: "FIELD_CHANGED_KIND",
    REQUIRED_ARG_ADDED: "REQUIRED_ARG_ADDED",
    ARG_REMOVED: "ARG_REMOVED",
    ARG_CHANGED_KIND: "ARG_CHANGED_KIND",
    DIRECTIVE_REMOVED: "DIRECTIVE_REMOVED",
    DIRECTIVE_ARG_REMOVED: "DIRECTIVE_ARG_REMOVED",
    REQUIRED_DIRECTIVE_ARG_ADDED: "REQUIRED_DIRECTIVE_ARG_ADDED",
    DIRECTIVE_REPEATABLE_REMOVED: "DIRECTIVE_REPEATABLE_REMOVED",
    DIRECTIVE_LOCATION_REMOVED: "DIRECTIVE_LOCATION_REMOVED",
  });
  tf.BreakingChangeType = wn;
  var tl = Object.freeze({
    VALUE_ADDED_TO_ENUM: "VALUE_ADDED_TO_ENUM",
    TYPE_ADDED_TO_UNION: "TYPE_ADDED_TO_UNION",
    OPTIONAL_INPUT_FIELD_ADDED: "OPTIONAL_INPUT_FIELD_ADDED",
    OPTIONAL_ARG_ADDED: "OPTIONAL_ARG_ADDED",
    IMPLEMENTED_INTERFACE_ADDED: "IMPLEMENTED_INTERFACE_ADDED",
    ARG_DEFAULT_VALUE_CHANGE: "ARG_DEFAULT_VALUE_CHANGE",
  });
  tf.DangerousChangeType = tl;
  function _Nt(e, t) {
    var r = Wme(e, t).filter(function (n) {
      return n.type in wn;
    });
    return r;
  }
  function ENt(e, t) {
    var r = Wme(e, t).filter(function (n) {
      return n.type in tl;
    });
    return r;
  }
  function Wme(e, t) {
    return [].concat(SNt(e, t), bNt(e, t));
  }
  function bNt(e, t) {
    for (
      var r = [],
        n = rl(e.getDirectives(), t.getDirectives()),
        i = 0,
        o = n.removed;
      i < o.length;
      i++
    ) {
      var a = o[i];
      r.push({
        type: wn.DIRECTIVE_REMOVED,
        description: "".concat(a.name, " was removed."),
      });
    }
    for (var s = 0, u = n.persisted; s < u.length; s++) {
      for (
        var l = u[s],
          d = l[0],
          f = l[1],
          m = rl(d.args, f.args),
          h = 0,
          y = m.added;
        h < y.length;
        h++
      ) {
        var _ = y[h];
        (0, jt.isRequiredArgument)(_) &&
          r.push({
            type: wn.REQUIRED_DIRECTIVE_ARG_ADDED,
            description: "A required arg "
              .concat(_.name, " on directive ")
              .concat(d.name, " was added."),
          });
      }
      for (var E = 0, b = m.removed; E < b.length; E++) {
        var O = b[E];
        r.push({
          type: wn.DIRECTIVE_ARG_REMOVED,
          description: ""
            .concat(O.name, " was removed from ")
            .concat(d.name, "."),
        });
      }
      d.isRepeatable &&
        !f.isRepeatable &&
        r.push({
          type: wn.DIRECTIVE_REPEATABLE_REMOVED,
          description: "Repeatable flag was removed from ".concat(d.name, "."),
        });
      for (var C = 0, P = d.locations; C < P.length; C++) {
        var k = P[C];
        f.locations.indexOf(k) === -1 &&
          r.push({
            type: wn.DIRECTIVE_LOCATION_REMOVED,
            description: "".concat(k, " was removed from ").concat(d.name, "."),
          });
      }
    }
    return r;
  }
  function SNt(e, t) {
    for (
      var r = [],
        n = rl(
          (0, vy.default)(e.getTypeMap()),
          (0, vy.default)(t.getTypeMap()),
        ),
        i = 0,
        o = n.removed;
      i < o.length;
      i++
    ) {
      var a = o[i];
      r.push({
        type: wn.TYPE_REMOVED,
        description: (0, gNt.isSpecifiedScalarType)(a)
          ? "Standard scalar ".concat(
              a.name,
              " was removed because it is not referenced anymore.",
            )
          : "".concat(a.name, " was removed."),
      });
    }
    for (var s = 0, u = n.persisted; s < u.length; s++) {
      var l = u[s],
        d = l[0],
        f = l[1];
      (0, jt.isEnumType)(d) && (0, jt.isEnumType)(f)
        ? r.push.apply(r, ONt(d, f))
        : (0, jt.isUnionType)(d) && (0, jt.isUnionType)(f)
          ? r.push.apply(r, wNt(d, f))
          : (0, jt.isInputObjectType)(d) && (0, jt.isInputObjectType)(f)
            ? r.push.apply(r, CNt(d, f))
            : ((0, jt.isObjectType)(d) && (0, jt.isObjectType)(f)) ||
                ((0, jt.isInterfaceType)(d) && (0, jt.isInterfaceType)(f))
              ? r.push.apply(r, Vme(d, f).concat(Gme(d, f)))
              : d.constructor !== f.constructor &&
                r.push({
                  type: wn.TYPE_CHANGED_KIND,
                  description:
                    "".concat(d.name, " changed from ") +
                    "".concat($me(d), " to ").concat($me(f), "."),
                });
    }
    return r;
  }
  function CNt(e, t) {
    for (
      var r = [],
        n = rl((0, vy.default)(e.getFields()), (0, vy.default)(t.getFields())),
        i = 0,
        o = n.added;
      i < o.length;
      i++
    ) {
      var a = o[i];
      (0, jt.isRequiredInputField)(a)
        ? r.push({
            type: wn.REQUIRED_INPUT_FIELD_ADDED,
            description: "A required field "
              .concat(a.name, " on input type ")
              .concat(e.name, " was added."),
          })
        : r.push({
            type: tl.OPTIONAL_INPUT_FIELD_ADDED,
            description: "An optional field "
              .concat(a.name, " on input type ")
              .concat(e.name, " was added."),
          });
    }
    for (var s = 0, u = n.removed; s < u.length; s++) {
      var l = u[s];
      r.push({
        type: wn.FIELD_REMOVED,
        description: "".concat(e.name, ".").concat(l.name, " was removed."),
      });
    }
    for (var d = 0, f = n.persisted; d < f.length; d++) {
      var m = f[d],
        h = m[0],
        y = m[1],
        _ = K0(h.type, y.type);
      _ ||
        r.push({
          type: wn.FIELD_CHANGED_KIND,
          description:
            "".concat(e.name, ".").concat(h.name, " changed type from ") +
            "".concat(String(h.type), " to ").concat(String(y.type), "."),
        });
    }
    return r;
  }
  function wNt(e, t) {
    for (
      var r = [], n = rl(e.getTypes(), t.getTypes()), i = 0, o = n.added;
      i < o.length;
      i++
    ) {
      var a = o[i];
      r.push({
        type: tl.TYPE_ADDED_TO_UNION,
        description: ""
          .concat(a.name, " was added to union type ")
          .concat(e.name, "."),
      });
    }
    for (var s = 0, u = n.removed; s < u.length; s++) {
      var l = u[s];
      r.push({
        type: wn.TYPE_REMOVED_FROM_UNION,
        description: ""
          .concat(l.name, " was removed from union type ")
          .concat(e.name, "."),
      });
    }
    return r;
  }
  function ONt(e, t) {
    for (
      var r = [], n = rl(e.getValues(), t.getValues()), i = 0, o = n.added;
      i < o.length;
      i++
    ) {
      var a = o[i];
      r.push({
        type: tl.VALUE_ADDED_TO_ENUM,
        description: ""
          .concat(a.name, " was added to enum type ")
          .concat(e.name, "."),
      });
    }
    for (var s = 0, u = n.removed; s < u.length; s++) {
      var l = u[s];
      r.push({
        type: wn.VALUE_REMOVED_FROM_ENUM,
        description: ""
          .concat(l.name, " was removed from enum type ")
          .concat(e.name, "."),
      });
    }
    return r;
  }
  function Gme(e, t) {
    for (
      var r = [],
        n = rl(e.getInterfaces(), t.getInterfaces()),
        i = 0,
        o = n.added;
      i < o.length;
      i++
    ) {
      var a = o[i];
      r.push({
        type: tl.IMPLEMENTED_INTERFACE_ADDED,
        description: ""
          .concat(a.name, " added to interfaces implemented by ")
          .concat(e.name, "."),
      });
    }
    for (var s = 0, u = n.removed; s < u.length; s++) {
      var l = u[s];
      r.push({
        type: wn.IMPLEMENTED_INTERFACE_REMOVED,
        description: ""
          .concat(e.name, " no longer implements interface ")
          .concat(l.name, "."),
      });
    }
    return r;
  }
  function Vme(e, t) {
    for (
      var r = [],
        n = rl((0, vy.default)(e.getFields()), (0, vy.default)(t.getFields())),
        i = 0,
        o = n.removed;
      i < o.length;
      i++
    ) {
      var a = o[i];
      r.push({
        type: wn.FIELD_REMOVED,
        description: "".concat(e.name, ".").concat(a.name, " was removed."),
      });
    }
    for (var s = 0, u = n.persisted; s < u.length; s++) {
      var l = u[s],
        d = l[0],
        f = l[1];
      r.push.apply(r, TNt(e, d, f));
      var m = z0(d.type, f.type);
      m ||
        r.push({
          type: wn.FIELD_CHANGED_KIND,
          description:
            "".concat(e.name, ".").concat(d.name, " changed type from ") +
            "".concat(String(d.type), " to ").concat(String(f.type), "."),
        });
    }
    return r;
  }
  function TNt(e, t, r) {
    for (
      var n = [], i = rl(t.args, r.args), o = 0, a = i.removed;
      o < a.length;
      o++
    ) {
      var s = a[o];
      n.push({
        type: wn.ARG_REMOVED,
        description: ""
          .concat(e.name, ".")
          .concat(t.name, " arg ")
          .concat(s.name, " was removed."),
      });
    }
    for (var u = 0, l = i.persisted; u < l.length; u++) {
      var d = l[u],
        f = d[0],
        m = d[1],
        h = K0(f.type, m.type);
      if (!h)
        n.push({
          type: wn.ARG_CHANGED_KIND,
          description:
            ""
              .concat(e.name, ".")
              .concat(t.name, " arg ")
              .concat(f.name, " has changed type from ") +
            "".concat(String(f.type), " to ").concat(String(m.type), "."),
        });
      else if (f.defaultValue !== void 0)
        if (m.defaultValue === void 0)
          n.push({
            type: tl.ARG_DEFAULT_VALUE_CHANGE,
            description: ""
              .concat(e.name, ".")
              .concat(t.name, " arg ")
              .concat(f.name, " defaultValue was removed."),
          });
        else {
          var y = zme(f.defaultValue, f.type),
            _ = zme(m.defaultValue, m.type);
          y !== _ &&
            n.push({
              type: tl.ARG_DEFAULT_VALUE_CHANGE,
              description: ""
                .concat(e.name, ".")
                .concat(t.name, " arg ")
                .concat(f.name, " has changed defaultValue from ")
                .concat(y, " to ")
                .concat(_, "."),
            });
        }
    }
    for (var E = 0, b = i.added; E < b.length; E++) {
      var O = b[E];
      (0, jt.isRequiredArgument)(O)
        ? n.push({
            type: wn.REQUIRED_ARG_ADDED,
            description: "A required arg "
              .concat(O.name, " on ")
              .concat(e.name, ".")
              .concat(t.name, " was added."),
          })
        : n.push({
            type: tl.OPTIONAL_ARG_ADDED,
            description: "An optional arg "
              .concat(O.name, " on ")
              .concat(e.name, ".")
              .concat(t.name, " was added."),
          });
    }
    return n;
  }
  function z0(e, t) {
    return (0, jt.isListType)(e)
      ? ((0, jt.isListType)(t) && z0(e.ofType, t.ofType)) ||
          ((0, jt.isNonNullType)(t) && z0(e, t.ofType))
      : (0, jt.isNonNullType)(e)
        ? (0, jt.isNonNullType)(t) && z0(e.ofType, t.ofType)
        : ((0, jt.isNamedType)(t) && e.name === t.name) ||
          ((0, jt.isNonNullType)(t) && z0(e, t.ofType));
  }
  function K0(e, t) {
    return (0, jt.isListType)(e)
      ? (0, jt.isListType)(t) && K0(e.ofType, t.ofType)
      : (0, jt.isNonNullType)(e)
        ? ((0, jt.isNonNullType)(t) && K0(e.ofType, t.ofType)) ||
          (!(0, jt.isNonNullType)(t) && K0(e.ofType, t))
        : (0, jt.isNamedType)(t) && e.name === t.name;
  }
  function $me(e) {
    if ((0, jt.isScalarType)(e)) return "a Scalar type";
    if ((0, jt.isObjectType)(e)) return "an Object type";
    if ((0, jt.isInterfaceType)(e)) return "an Interface type";
    if ((0, jt.isUnionType)(e)) return "a Union type";
    if ((0, jt.isEnumType)(e)) return "an Enum type";
    if ((0, jt.isInputObjectType)(e)) return "an Input type";
    (0, Kme.default)(0, "Unexpected type: " + (0, fNt.default)(e));
  }
  function zme(e, t) {
    var r = (0, vNt.astFromValue)(e, t);
    r != null || (0, Kme.default)(0);
    var n = (0, hNt.visit)(r, {
      ObjectValue: function (o) {
        var a = [].concat(o.fields);
        return (
          a.sort(function (s, u) {
            return (0, pNt.default)(s.name.value, u.name.value);
          }),
          Hme(Hme({}, o), {}, { fields: a })
        );
      },
    });
    return (0, mNt.print)(n);
  }
  function rl(e, t) {
    for (
      var r = [],
        n = [],
        i = [],
        o = (0, Bme.default)(e, function (m) {
          var h = m.name;
          return h;
        }),
        a = (0, Bme.default)(t, function (m) {
          var h = m.name;
          return h;
        }),
        s = 0;
      s < e.length;
      s++
    ) {
      var u = e[s],
        l = a[u.name];
      l === void 0 ? n.push(u) : i.push([u, l]);
    }
    for (var d = 0; d < t.length; d++) {
      var f = t[d];
      o[f.name] === void 0 && r.push(f);
    }
    return { added: r, persisted: i, removed: n };
  }
});
var Yme = g((z2) => {
  "use strict";
  c();
  Object.defineProperty(z2, "__esModule", { value: !0 });
  z2.findDeprecatedUsages = RNt;
  var ANt = cy(),
    PNt = b2();
  function RNt(e, t) {
    return (0, ANt.validate)(e, t, [PNt.NoDeprecatedCustomRule]);
  }
});
var the = g((Tt) => {
  "use strict";
  c();
  Object.defineProperty(Tt, "__esModule", { value: !0 });
  Object.defineProperty(Tt, "getIntrospectionQuery", {
    enumerable: !0,
    get: function () {
      return INt.getIntrospectionQuery;
    },
  });
  Object.defineProperty(Tt, "getOperationAST", {
    enumerable: !0,
    get: function () {
      return xNt.getOperationAST;
    },
  });
  Object.defineProperty(Tt, "getOperationRootType", {
    enumerable: !0,
    get: function () {
      return NNt.getOperationRootType;
    },
  });
  Object.defineProperty(Tt, "introspectionFromSchema", {
    enumerable: !0,
    get: function () {
      return kNt.introspectionFromSchema;
    },
  });
  Object.defineProperty(Tt, "buildClientSchema", {
    enumerable: !0,
    get: function () {
      return DNt.buildClientSchema;
    },
  });
  Object.defineProperty(Tt, "buildASTSchema", {
    enumerable: !0,
    get: function () {
      return Xme.buildASTSchema;
    },
  });
  Object.defineProperty(Tt, "buildSchema", {
    enumerable: !0,
    get: function () {
      return Xme.buildSchema;
    },
  });
  Object.defineProperty(Tt, "extendSchema", {
    enumerable: !0,
    get: function () {
      return Jme.extendSchema;
    },
  });
  Object.defineProperty(Tt, "getDescription", {
    enumerable: !0,
    get: function () {
      return Jme.getDescription;
    },
  });
  Object.defineProperty(Tt, "lexicographicSortSchema", {
    enumerable: !0,
    get: function () {
      return LNt.lexicographicSortSchema;
    },
  });
  Object.defineProperty(Tt, "printSchema", {
    enumerable: !0,
    get: function () {
      return K2.printSchema;
    },
  });
  Object.defineProperty(Tt, "printType", {
    enumerable: !0,
    get: function () {
      return K2.printType;
    },
  });
  Object.defineProperty(Tt, "printIntrospectionSchema", {
    enumerable: !0,
    get: function () {
      return K2.printIntrospectionSchema;
    },
  });
  Object.defineProperty(Tt, "typeFromAST", {
    enumerable: !0,
    get: function () {
      return MNt.typeFromAST;
    },
  });
  Object.defineProperty(Tt, "valueFromAST", {
    enumerable: !0,
    get: function () {
      return qNt.valueFromAST;
    },
  });
  Object.defineProperty(Tt, "valueFromASTUntyped", {
    enumerable: !0,
    get: function () {
      return jNt.valueFromASTUntyped;
    },
  });
  Object.defineProperty(Tt, "astFromValue", {
    enumerable: !0,
    get: function () {
      return FNt.astFromValue;
    },
  });
  Object.defineProperty(Tt, "TypeInfo", {
    enumerable: !0,
    get: function () {
      return Zme.TypeInfo;
    },
  });
  Object.defineProperty(Tt, "visitWithTypeInfo", {
    enumerable: !0,
    get: function () {
      return Zme.visitWithTypeInfo;
    },
  });
  Object.defineProperty(Tt, "coerceInputValue", {
    enumerable: !0,
    get: function () {
      return BNt.coerceInputValue;
    },
  });
  Object.defineProperty(Tt, "concatAST", {
    enumerable: !0,
    get: function () {
      return UNt.concatAST;
    },
  });
  Object.defineProperty(Tt, "separateOperations", {
    enumerable: !0,
    get: function () {
      return HNt.separateOperations;
    },
  });
  Object.defineProperty(Tt, "stripIgnoredCharacters", {
    enumerable: !0,
    get: function () {
      return GNt.stripIgnoredCharacters;
    },
  });
  Object.defineProperty(Tt, "isEqualType", {
    enumerable: !0,
    get: function () {
      return W2.isEqualType;
    },
  });
  Object.defineProperty(Tt, "isTypeSubTypeOf", {
    enumerable: !0,
    get: function () {
      return W2.isTypeSubTypeOf;
    },
  });
  Object.defineProperty(Tt, "doTypesOverlap", {
    enumerable: !0,
    get: function () {
      return W2.doTypesOverlap;
    },
  });
  Object.defineProperty(Tt, "assertValidName", {
    enumerable: !0,
    get: function () {
      return ehe.assertValidName;
    },
  });
  Object.defineProperty(Tt, "isValidNameError", {
    enumerable: !0,
    get: function () {
      return ehe.isValidNameError;
    },
  });
  Object.defineProperty(Tt, "BreakingChangeType", {
    enumerable: !0,
    get: function () {
      return YN.BreakingChangeType;
    },
  });
  Object.defineProperty(Tt, "DangerousChangeType", {
    enumerable: !0,
    get: function () {
      return YN.DangerousChangeType;
    },
  });
  Object.defineProperty(Tt, "findBreakingChanges", {
    enumerable: !0,
    get: function () {
      return YN.findBreakingChanges;
    },
  });
  Object.defineProperty(Tt, "findDangerousChanges", {
    enumerable: !0,
    get: function () {
      return YN.findDangerousChanges;
    },
  });
  Object.defineProperty(Tt, "findDeprecatedUsages", {
    enumerable: !0,
    get: function () {
      return VNt.findDeprecatedUsages;
    },
  });
  var INt = O2(),
    xNt = rme(),
    NNt = xN(),
    kNt = ime(),
    DNt = ame(),
    Xme = bme(),
    Jme = R2(),
    LNt = Cme(),
    K2 = xme(),
    MNt = Rc(),
    qNt = x0(),
    jNt = WV(),
    FNt = E0(),
    Zme = vN(),
    BNt = s2(),
    UNt = Nme(),
    HNt = Lme(),
    GNt = Fme(),
    W2 = m0(),
    ehe = kV(),
    YN = Qme(),
    VNt = Yme();
});
var XN = g((x) => {
  "use strict";
  c();
  Object.defineProperty(x, "__esModule", { value: !0 });
  Object.defineProperty(x, "version", {
    enumerable: !0,
    get: function () {
      return rhe.version;
    },
  });
  Object.defineProperty(x, "versionInfo", {
    enumerable: !0,
    get: function () {
      return rhe.versionInfo;
    },
  });
  Object.defineProperty(x, "graphql", {
    enumerable: !0,
    get: function () {
      return nhe.graphql;
    },
  });
  Object.defineProperty(x, "graphqlSync", {
    enumerable: !0,
    get: function () {
      return nhe.graphqlSync;
    },
  });
  Object.defineProperty(x, "GraphQLSchema", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLSchema;
    },
  });
  Object.defineProperty(x, "GraphQLDirective", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLDirective;
    },
  });
  Object.defineProperty(x, "GraphQLScalarType", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLScalarType;
    },
  });
  Object.defineProperty(x, "GraphQLObjectType", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLObjectType;
    },
  });
  Object.defineProperty(x, "GraphQLInterfaceType", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLInterfaceType;
    },
  });
  Object.defineProperty(x, "GraphQLUnionType", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLUnionType;
    },
  });
  Object.defineProperty(x, "GraphQLEnumType", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLEnumType;
    },
  });
  Object.defineProperty(x, "GraphQLInputObjectType", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLInputObjectType;
    },
  });
  Object.defineProperty(x, "GraphQLList", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLList;
    },
  });
  Object.defineProperty(x, "GraphQLNonNull", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLNonNull;
    },
  });
  Object.defineProperty(x, "specifiedScalarTypes", {
    enumerable: !0,
    get: function () {
      return oe.specifiedScalarTypes;
    },
  });
  Object.defineProperty(x, "GraphQLInt", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLInt;
    },
  });
  Object.defineProperty(x, "GraphQLFloat", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLFloat;
    },
  });
  Object.defineProperty(x, "GraphQLString", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLString;
    },
  });
  Object.defineProperty(x, "GraphQLBoolean", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLBoolean;
    },
  });
  Object.defineProperty(x, "GraphQLID", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLID;
    },
  });
  Object.defineProperty(x, "specifiedDirectives", {
    enumerable: !0,
    get: function () {
      return oe.specifiedDirectives;
    },
  });
  Object.defineProperty(x, "GraphQLIncludeDirective", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLIncludeDirective;
    },
  });
  Object.defineProperty(x, "GraphQLSkipDirective", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLSkipDirective;
    },
  });
  Object.defineProperty(x, "GraphQLDeprecatedDirective", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLDeprecatedDirective;
    },
  });
  Object.defineProperty(x, "GraphQLSpecifiedByDirective", {
    enumerable: !0,
    get: function () {
      return oe.GraphQLSpecifiedByDirective;
    },
  });
  Object.defineProperty(x, "TypeKind", {
    enumerable: !0,
    get: function () {
      return oe.TypeKind;
    },
  });
  Object.defineProperty(x, "DEFAULT_DEPRECATION_REASON", {
    enumerable: !0,
    get: function () {
      return oe.DEFAULT_DEPRECATION_REASON;
    },
  });
  Object.defineProperty(x, "introspectionTypes", {
    enumerable: !0,
    get: function () {
      return oe.introspectionTypes;
    },
  });
  Object.defineProperty(x, "__Schema", {
    enumerable: !0,
    get: function () {
      return oe.__Schema;
    },
  });
  Object.defineProperty(x, "__Directive", {
    enumerable: !0,
    get: function () {
      return oe.__Directive;
    },
  });
  Object.defineProperty(x, "__DirectiveLocation", {
    enumerable: !0,
    get: function () {
      return oe.__DirectiveLocation;
    },
  });
  Object.defineProperty(x, "__Type", {
    enumerable: !0,
    get: function () {
      return oe.__Type;
    },
  });
  Object.defineProperty(x, "__Field", {
    enumerable: !0,
    get: function () {
      return oe.__Field;
    },
  });
  Object.defineProperty(x, "__InputValue", {
    enumerable: !0,
    get: function () {
      return oe.__InputValue;
    },
  });
  Object.defineProperty(x, "__EnumValue", {
    enumerable: !0,
    get: function () {
      return oe.__EnumValue;
    },
  });
  Object.defineProperty(x, "__TypeKind", {
    enumerable: !0,
    get: function () {
      return oe.__TypeKind;
    },
  });
  Object.defineProperty(x, "SchemaMetaFieldDef", {
    enumerable: !0,
    get: function () {
      return oe.SchemaMetaFieldDef;
    },
  });
  Object.defineProperty(x, "TypeMetaFieldDef", {
    enumerable: !0,
    get: function () {
      return oe.TypeMetaFieldDef;
    },
  });
  Object.defineProperty(x, "TypeNameMetaFieldDef", {
    enumerable: !0,
    get: function () {
      return oe.TypeNameMetaFieldDef;
    },
  });
  Object.defineProperty(x, "isSchema", {
    enumerable: !0,
    get: function () {
      return oe.isSchema;
    },
  });
  Object.defineProperty(x, "isDirective", {
    enumerable: !0,
    get: function () {
      return oe.isDirective;
    },
  });
  Object.defineProperty(x, "isType", {
    enumerable: !0,
    get: function () {
      return oe.isType;
    },
  });
  Object.defineProperty(x, "isScalarType", {
    enumerable: !0,
    get: function () {
      return oe.isScalarType;
    },
  });
  Object.defineProperty(x, "isObjectType", {
    enumerable: !0,
    get: function () {
      return oe.isObjectType;
    },
  });
  Object.defineProperty(x, "isInterfaceType", {
    enumerable: !0,
    get: function () {
      return oe.isInterfaceType;
    },
  });
  Object.defineProperty(x, "isUnionType", {
    enumerable: !0,
    get: function () {
      return oe.isUnionType;
    },
  });
  Object.defineProperty(x, "isEnumType", {
    enumerable: !0,
    get: function () {
      return oe.isEnumType;
    },
  });
  Object.defineProperty(x, "isInputObjectType", {
    enumerable: !0,
    get: function () {
      return oe.isInputObjectType;
    },
  });
  Object.defineProperty(x, "isListType", {
    enumerable: !0,
    get: function () {
      return oe.isListType;
    },
  });
  Object.defineProperty(x, "isNonNullType", {
    enumerable: !0,
    get: function () {
      return oe.isNonNullType;
    },
  });
  Object.defineProperty(x, "isInputType", {
    enumerable: !0,
    get: function () {
      return oe.isInputType;
    },
  });
  Object.defineProperty(x, "isOutputType", {
    enumerable: !0,
    get: function () {
      return oe.isOutputType;
    },
  });
  Object.defineProperty(x, "isLeafType", {
    enumerable: !0,
    get: function () {
      return oe.isLeafType;
    },
  });
  Object.defineProperty(x, "isCompositeType", {
    enumerable: !0,
    get: function () {
      return oe.isCompositeType;
    },
  });
  Object.defineProperty(x, "isAbstractType", {
    enumerable: !0,
    get: function () {
      return oe.isAbstractType;
    },
  });
  Object.defineProperty(x, "isWrappingType", {
    enumerable: !0,
    get: function () {
      return oe.isWrappingType;
    },
  });
  Object.defineProperty(x, "isNullableType", {
    enumerable: !0,
    get: function () {
      return oe.isNullableType;
    },
  });
  Object.defineProperty(x, "isNamedType", {
    enumerable: !0,
    get: function () {
      return oe.isNamedType;
    },
  });
  Object.defineProperty(x, "isRequiredArgument", {
    enumerable: !0,
    get: function () {
      return oe.isRequiredArgument;
    },
  });
  Object.defineProperty(x, "isRequiredInputField", {
    enumerable: !0,
    get: function () {
      return oe.isRequiredInputField;
    },
  });
  Object.defineProperty(x, "isSpecifiedScalarType", {
    enumerable: !0,
    get: function () {
      return oe.isSpecifiedScalarType;
    },
  });
  Object.defineProperty(x, "isIntrospectionType", {
    enumerable: !0,
    get: function () {
      return oe.isIntrospectionType;
    },
  });
  Object.defineProperty(x, "isSpecifiedDirective", {
    enumerable: !0,
    get: function () {
      return oe.isSpecifiedDirective;
    },
  });
  Object.defineProperty(x, "assertSchema", {
    enumerable: !0,
    get: function () {
      return oe.assertSchema;
    },
  });
  Object.defineProperty(x, "assertDirective", {
    enumerable: !0,
    get: function () {
      return oe.assertDirective;
    },
  });
  Object.defineProperty(x, "assertType", {
    enumerable: !0,
    get: function () {
      return oe.assertType;
    },
  });
  Object.defineProperty(x, "assertScalarType", {
    enumerable: !0,
    get: function () {
      return oe.assertScalarType;
    },
  });
  Object.defineProperty(x, "assertObjectType", {
    enumerable: !0,
    get: function () {
      return oe.assertObjectType;
    },
  });
  Object.defineProperty(x, "assertInterfaceType", {
    enumerable: !0,
    get: function () {
      return oe.assertInterfaceType;
    },
  });
  Object.defineProperty(x, "assertUnionType", {
    enumerable: !0,
    get: function () {
      return oe.assertUnionType;
    },
  });
  Object.defineProperty(x, "assertEnumType", {
    enumerable: !0,
    get: function () {
      return oe.assertEnumType;
    },
  });
  Object.defineProperty(x, "assertInputObjectType", {
    enumerable: !0,
    get: function () {
      return oe.assertInputObjectType;
    },
  });
  Object.defineProperty(x, "assertListType", {
    enumerable: !0,
    get: function () {
      return oe.assertListType;
    },
  });
  Object.defineProperty(x, "assertNonNullType", {
    enumerable: !0,
    get: function () {
      return oe.assertNonNullType;
    },
  });
  Object.defineProperty(x, "assertInputType", {
    enumerable: !0,
    get: function () {
      return oe.assertInputType;
    },
  });
  Object.defineProperty(x, "assertOutputType", {
    enumerable: !0,
    get: function () {
      return oe.assertOutputType;
    },
  });
  Object.defineProperty(x, "assertLeafType", {
    enumerable: !0,
    get: function () {
      return oe.assertLeafType;
    },
  });
  Object.defineProperty(x, "assertCompositeType", {
    enumerable: !0,
    get: function () {
      return oe.assertCompositeType;
    },
  });
  Object.defineProperty(x, "assertAbstractType", {
    enumerable: !0,
    get: function () {
      return oe.assertAbstractType;
    },
  });
  Object.defineProperty(x, "assertWrappingType", {
    enumerable: !0,
    get: function () {
      return oe.assertWrappingType;
    },
  });
  Object.defineProperty(x, "assertNullableType", {
    enumerable: !0,
    get: function () {
      return oe.assertNullableType;
    },
  });
  Object.defineProperty(x, "assertNamedType", {
    enumerable: !0,
    get: function () {
      return oe.assertNamedType;
    },
  });
  Object.defineProperty(x, "getNullableType", {
    enumerable: !0,
    get: function () {
      return oe.getNullableType;
    },
  });
  Object.defineProperty(x, "getNamedType", {
    enumerable: !0,
    get: function () {
      return oe.getNamedType;
    },
  });
  Object.defineProperty(x, "validateSchema", {
    enumerable: !0,
    get: function () {
      return oe.validateSchema;
    },
  });
  Object.defineProperty(x, "assertValidSchema", {
    enumerable: !0,
    get: function () {
      return oe.assertValidSchema;
    },
  });
  Object.defineProperty(x, "Token", {
    enumerable: !0,
    get: function () {
      return fr.Token;
    },
  });
  Object.defineProperty(x, "Source", {
    enumerable: !0,
    get: function () {
      return fr.Source;
    },
  });
  Object.defineProperty(x, "Location", {
    enumerable: !0,
    get: function () {
      return fr.Location;
    },
  });
  Object.defineProperty(x, "getLocation", {
    enumerable: !0,
    get: function () {
      return fr.getLocation;
    },
  });
  Object.defineProperty(x, "printLocation", {
    enumerable: !0,
    get: function () {
      return fr.printLocation;
    },
  });
  Object.defineProperty(x, "printSourceLocation", {
    enumerable: !0,
    get: function () {
      return fr.printSourceLocation;
    },
  });
  Object.defineProperty(x, "Lexer", {
    enumerable: !0,
    get: function () {
      return fr.Lexer;
    },
  });
  Object.defineProperty(x, "TokenKind", {
    enumerable: !0,
    get: function () {
      return fr.TokenKind;
    },
  });
  Object.defineProperty(x, "parse", {
    enumerable: !0,
    get: function () {
      return fr.parse;
    },
  });
  Object.defineProperty(x, "parseValue", {
    enumerable: !0,
    get: function () {
      return fr.parseValue;
    },
  });
  Object.defineProperty(x, "parseType", {
    enumerable: !0,
    get: function () {
      return fr.parseType;
    },
  });
  Object.defineProperty(x, "print", {
    enumerable: !0,
    get: function () {
      return fr.print;
    },
  });
  Object.defineProperty(x, "visit", {
    enumerable: !0,
    get: function () {
      return fr.visit;
    },
  });
  Object.defineProperty(x, "visitInParallel", {
    enumerable: !0,
    get: function () {
      return fr.visitInParallel;
    },
  });
  Object.defineProperty(x, "getVisitFn", {
    enumerable: !0,
    get: function () {
      return fr.getVisitFn;
    },
  });
  Object.defineProperty(x, "BREAK", {
    enumerable: !0,
    get: function () {
      return fr.BREAK;
    },
  });
  Object.defineProperty(x, "Kind", {
    enumerable: !0,
    get: function () {
      return fr.Kind;
    },
  });
  Object.defineProperty(x, "DirectiveLocation", {
    enumerable: !0,
    get: function () {
      return fr.DirectiveLocation;
    },
  });
  Object.defineProperty(x, "isDefinitionNode", {
    enumerable: !0,
    get: function () {
      return fr.isDefinitionNode;
    },
  });
  Object.defineProperty(x, "isExecutableDefinitionNode", {
    enumerable: !0,
    get: function () {
      return fr.isExecutableDefinitionNode;
    },
  });
  Object.defineProperty(x, "isSelectionNode", {
    enumerable: !0,
    get: function () {
      return fr.isSelectionNode;
    },
  });
  Object.defineProperty(x, "isValueNode", {
    enumerable: !0,
    get: function () {
      return fr.isValueNode;
    },
  });
  Object.defineProperty(x, "isTypeNode", {
    enumerable: !0,
    get: function () {
      return fr.isTypeNode;
    },
  });
  Object.defineProperty(x, "isTypeSystemDefinitionNode", {
    enumerable: !0,
    get: function () {
      return fr.isTypeSystemDefinitionNode;
    },
  });
  Object.defineProperty(x, "isTypeDefinitionNode", {
    enumerable: !0,
    get: function () {
      return fr.isTypeDefinitionNode;
    },
  });
  Object.defineProperty(x, "isTypeSystemExtensionNode", {
    enumerable: !0,
    get: function () {
      return fr.isTypeSystemExtensionNode;
    },
  });
  Object.defineProperty(x, "isTypeExtensionNode", {
    enumerable: !0,
    get: function () {
      return fr.isTypeExtensionNode;
    },
  });
  Object.defineProperty(x, "execute", {
    enumerable: !0,
    get: function () {
      return yy.execute;
    },
  });
  Object.defineProperty(x, "executeSync", {
    enumerable: !0,
    get: function () {
      return yy.executeSync;
    },
  });
  Object.defineProperty(x, "defaultFieldResolver", {
    enumerable: !0,
    get: function () {
      return yy.defaultFieldResolver;
    },
  });
  Object.defineProperty(x, "defaultTypeResolver", {
    enumerable: !0,
    get: function () {
      return yy.defaultTypeResolver;
    },
  });
  Object.defineProperty(x, "responsePathAsArray", {
    enumerable: !0,
    get: function () {
      return yy.responsePathAsArray;
    },
  });
  Object.defineProperty(x, "getDirectiveValues", {
    enumerable: !0,
    get: function () {
      return yy.getDirectiveValues;
    },
  });
  Object.defineProperty(x, "subscribe", {
    enumerable: !0,
    get: function () {
      return ihe.subscribe;
    },
  });
  Object.defineProperty(x, "createSourceEventStream", {
    enumerable: !0,
    get: function () {
      return ihe.createSourceEventStream;
    },
  });
  Object.defineProperty(x, "validate", {
    enumerable: !0,
    get: function () {
      return gt.validate;
    },
  });
  Object.defineProperty(x, "ValidationContext", {
    enumerable: !0,
    get: function () {
      return gt.ValidationContext;
    },
  });
  Object.defineProperty(x, "specifiedRules", {
    enumerable: !0,
    get: function () {
      return gt.specifiedRules;
    },
  });
  Object.defineProperty(x, "ExecutableDefinitionsRule", {
    enumerable: !0,
    get: function () {
      return gt.ExecutableDefinitionsRule;
    },
  });
  Object.defineProperty(x, "FieldsOnCorrectTypeRule", {
    enumerable: !0,
    get: function () {
      return gt.FieldsOnCorrectTypeRule;
    },
  });
  Object.defineProperty(x, "FragmentsOnCompositeTypesRule", {
    enumerable: !0,
    get: function () {
      return gt.FragmentsOnCompositeTypesRule;
    },
  });
  Object.defineProperty(x, "KnownArgumentNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.KnownArgumentNamesRule;
    },
  });
  Object.defineProperty(x, "KnownDirectivesRule", {
    enumerable: !0,
    get: function () {
      return gt.KnownDirectivesRule;
    },
  });
  Object.defineProperty(x, "KnownFragmentNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.KnownFragmentNamesRule;
    },
  });
  Object.defineProperty(x, "KnownTypeNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.KnownTypeNamesRule;
    },
  });
  Object.defineProperty(x, "LoneAnonymousOperationRule", {
    enumerable: !0,
    get: function () {
      return gt.LoneAnonymousOperationRule;
    },
  });
  Object.defineProperty(x, "NoFragmentCyclesRule", {
    enumerable: !0,
    get: function () {
      return gt.NoFragmentCyclesRule;
    },
  });
  Object.defineProperty(x, "NoUndefinedVariablesRule", {
    enumerable: !0,
    get: function () {
      return gt.NoUndefinedVariablesRule;
    },
  });
  Object.defineProperty(x, "NoUnusedFragmentsRule", {
    enumerable: !0,
    get: function () {
      return gt.NoUnusedFragmentsRule;
    },
  });
  Object.defineProperty(x, "NoUnusedVariablesRule", {
    enumerable: !0,
    get: function () {
      return gt.NoUnusedVariablesRule;
    },
  });
  Object.defineProperty(x, "OverlappingFieldsCanBeMergedRule", {
    enumerable: !0,
    get: function () {
      return gt.OverlappingFieldsCanBeMergedRule;
    },
  });
  Object.defineProperty(x, "PossibleFragmentSpreadsRule", {
    enumerable: !0,
    get: function () {
      return gt.PossibleFragmentSpreadsRule;
    },
  });
  Object.defineProperty(x, "ProvidedRequiredArgumentsRule", {
    enumerable: !0,
    get: function () {
      return gt.ProvidedRequiredArgumentsRule;
    },
  });
  Object.defineProperty(x, "ScalarLeafsRule", {
    enumerable: !0,
    get: function () {
      return gt.ScalarLeafsRule;
    },
  });
  Object.defineProperty(x, "SingleFieldSubscriptionsRule", {
    enumerable: !0,
    get: function () {
      return gt.SingleFieldSubscriptionsRule;
    },
  });
  Object.defineProperty(x, "UniqueArgumentNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueArgumentNamesRule;
    },
  });
  Object.defineProperty(x, "UniqueDirectivesPerLocationRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueDirectivesPerLocationRule;
    },
  });
  Object.defineProperty(x, "UniqueFragmentNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueFragmentNamesRule;
    },
  });
  Object.defineProperty(x, "UniqueInputFieldNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueInputFieldNamesRule;
    },
  });
  Object.defineProperty(x, "UniqueOperationNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueOperationNamesRule;
    },
  });
  Object.defineProperty(x, "UniqueVariableNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueVariableNamesRule;
    },
  });
  Object.defineProperty(x, "ValuesOfCorrectTypeRule", {
    enumerable: !0,
    get: function () {
      return gt.ValuesOfCorrectTypeRule;
    },
  });
  Object.defineProperty(x, "VariablesAreInputTypesRule", {
    enumerable: !0,
    get: function () {
      return gt.VariablesAreInputTypesRule;
    },
  });
  Object.defineProperty(x, "VariablesInAllowedPositionRule", {
    enumerable: !0,
    get: function () {
      return gt.VariablesInAllowedPositionRule;
    },
  });
  Object.defineProperty(x, "LoneSchemaDefinitionRule", {
    enumerable: !0,
    get: function () {
      return gt.LoneSchemaDefinitionRule;
    },
  });
  Object.defineProperty(x, "UniqueOperationTypesRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueOperationTypesRule;
    },
  });
  Object.defineProperty(x, "UniqueTypeNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueTypeNamesRule;
    },
  });
  Object.defineProperty(x, "UniqueEnumValueNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueEnumValueNamesRule;
    },
  });
  Object.defineProperty(x, "UniqueFieldDefinitionNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueFieldDefinitionNamesRule;
    },
  });
  Object.defineProperty(x, "UniqueDirectiveNamesRule", {
    enumerable: !0,
    get: function () {
      return gt.UniqueDirectiveNamesRule;
    },
  });
  Object.defineProperty(x, "PossibleTypeExtensionsRule", {
    enumerable: !0,
    get: function () {
      return gt.PossibleTypeExtensionsRule;
    },
  });
  Object.defineProperty(x, "NoDeprecatedCustomRule", {
    enumerable: !0,
    get: function () {
      return gt.NoDeprecatedCustomRule;
    },
  });
  Object.defineProperty(x, "NoSchemaIntrospectionCustomRule", {
    enumerable: !0,
    get: function () {
      return gt.NoSchemaIntrospectionCustomRule;
    },
  });
  Object.defineProperty(x, "GraphQLError", {
    enumerable: !0,
    get: function () {
      return Q0.GraphQLError;
    },
  });
  Object.defineProperty(x, "syntaxError", {
    enumerable: !0,
    get: function () {
      return Q0.syntaxError;
    },
  });
  Object.defineProperty(x, "locatedError", {
    enumerable: !0,
    get: function () {
      return Q0.locatedError;
    },
  });
  Object.defineProperty(x, "printError", {
    enumerable: !0,
    get: function () {
      return Q0.printError;
    },
  });
  Object.defineProperty(x, "formatError", {
    enumerable: !0,
    get: function () {
      return Q0.formatError;
    },
  });
  Object.defineProperty(x, "getIntrospectionQuery", {
    enumerable: !0,
    get: function () {
      return kt.getIntrospectionQuery;
    },
  });
  Object.defineProperty(x, "getOperationAST", {
    enumerable: !0,
    get: function () {
      return kt.getOperationAST;
    },
  });
  Object.defineProperty(x, "getOperationRootType", {
    enumerable: !0,
    get: function () {
      return kt.getOperationRootType;
    },
  });
  Object.defineProperty(x, "introspectionFromSchema", {
    enumerable: !0,
    get: function () {
      return kt.introspectionFromSchema;
    },
  });
  Object.defineProperty(x, "buildClientSchema", {
    enumerable: !0,
    get: function () {
      return kt.buildClientSchema;
    },
  });
  Object.defineProperty(x, "buildASTSchema", {
    enumerable: !0,
    get: function () {
      return kt.buildASTSchema;
    },
  });
  Object.defineProperty(x, "buildSchema", {
    enumerable: !0,
    get: function () {
      return kt.buildSchema;
    },
  });
  Object.defineProperty(x, "getDescription", {
    enumerable: !0,
    get: function () {
      return kt.getDescription;
    },
  });
  Object.defineProperty(x, "extendSchema", {
    enumerable: !0,
    get: function () {
      return kt.extendSchema;
    },
  });
  Object.defineProperty(x, "lexicographicSortSchema", {
    enumerable: !0,
    get: function () {
      return kt.lexicographicSortSchema;
    },
  });
  Object.defineProperty(x, "printSchema", {
    enumerable: !0,
    get: function () {
      return kt.printSchema;
    },
  });
  Object.defineProperty(x, "printType", {
    enumerable: !0,
    get: function () {
      return kt.printType;
    },
  });
  Object.defineProperty(x, "printIntrospectionSchema", {
    enumerable: !0,
    get: function () {
      return kt.printIntrospectionSchema;
    },
  });
  Object.defineProperty(x, "typeFromAST", {
    enumerable: !0,
    get: function () {
      return kt.typeFromAST;
    },
  });
  Object.defineProperty(x, "valueFromAST", {
    enumerable: !0,
    get: function () {
      return kt.valueFromAST;
    },
  });
  Object.defineProperty(x, "valueFromASTUntyped", {
    enumerable: !0,
    get: function () {
      return kt.valueFromASTUntyped;
    },
  });
  Object.defineProperty(x, "astFromValue", {
    enumerable: !0,
    get: function () {
      return kt.astFromValue;
    },
  });
  Object.defineProperty(x, "TypeInfo", {
    enumerable: !0,
    get: function () {
      return kt.TypeInfo;
    },
  });
  Object.defineProperty(x, "visitWithTypeInfo", {
    enumerable: !0,
    get: function () {
      return kt.visitWithTypeInfo;
    },
  });
  Object.defineProperty(x, "coerceInputValue", {
    enumerable: !0,
    get: function () {
      return kt.coerceInputValue;
    },
  });
  Object.defineProperty(x, "concatAST", {
    enumerable: !0,
    get: function () {
      return kt.concatAST;
    },
  });
  Object.defineProperty(x, "separateOperations", {
    enumerable: !0,
    get: function () {
      return kt.separateOperations;
    },
  });
  Object.defineProperty(x, "stripIgnoredCharacters", {
    enumerable: !0,
    get: function () {
      return kt.stripIgnoredCharacters;
    },
  });
  Object.defineProperty(x, "isEqualType", {
    enumerable: !0,
    get: function () {
      return kt.isEqualType;
    },
  });
  Object.defineProperty(x, "isTypeSubTypeOf", {
    enumerable: !0,
    get: function () {
      return kt.isTypeSubTypeOf;
    },
  });
  Object.defineProperty(x, "doTypesOverlap", {
    enumerable: !0,
    get: function () {
      return kt.doTypesOverlap;
    },
  });
  Object.defineProperty(x, "assertValidName", {
    enumerable: !0,
    get: function () {
      return kt.assertValidName;
    },
  });
  Object.defineProperty(x, "isValidNameError", {
    enumerable: !0,
    get: function () {
      return kt.isValidNameError;
    },
  });
  Object.defineProperty(x, "BreakingChangeType", {
    enumerable: !0,
    get: function () {
      return kt.BreakingChangeType;
    },
  });
  Object.defineProperty(x, "DangerousChangeType", {
    enumerable: !0,
    get: function () {
      return kt.DangerousChangeType;
    },
  });
  Object.defineProperty(x, "findBreakingChanges", {
    enumerable: !0,
    get: function () {
      return kt.findBreakingChanges;
    },
  });
  Object.defineProperty(x, "findDangerousChanges", {
    enumerable: !0,
    get: function () {
      return kt.findDangerousChanges;
    },
  });
  Object.defineProperty(x, "findDeprecatedUsages", {
    enumerable: !0,
    get: function () {
      return kt.findDeprecatedUsages;
    },
  });
  var rhe = yle(),
    nhe = Rpe(),
    oe = xpe(),
    fr = Dpe(),
    yy = Lpe(),
    ihe = Qpe(),
    gt = Xpe(),
    Q0 = eme(),
    kt = the();
});
var ige = g((Imn, nge) => {
  c();
  var pk = Object.defineProperty,
    Pkt = Object.getOwnPropertyDescriptor,
    Rkt = Object.getOwnPropertyNames,
    Ikt = Object.prototype.hasOwnProperty,
    xkt = (e, t) => pk(e, "name", { value: t, configurable: !0 }),
    Nkt = (e, t) => {
      for (var r in t) pk(e, r, { get: t[r], enumerable: !0 });
    },
    kkt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Rkt(t))
          !Ikt.call(e, i) &&
            i !== r &&
            pk(e, i, {
              get: () => t[i],
              enumerable: !(n = Pkt(t, i)) || n.enumerable,
            });
      return e;
    },
    Dkt = (e) => kkt(pk({}, "__esModule", { value: !0 }), e),
    rge = {};
  Nkt(rge, { isArrayBuffer: () => Lkt });
  nge.exports = Dkt(rge);
  var Lkt = xkt(
    (e) =>
      (typeof ArrayBuffer == "function" && e instanceof ArrayBuffer) ||
      Object.prototype.toString.call(e) === "[object ArrayBuffer]",
    "isArrayBuffer",
  );
});
var hk = g((Nmn, sge) => {
  c();
  var mk = Object.defineProperty,
    Mkt = Object.getOwnPropertyDescriptor,
    qkt = Object.getOwnPropertyNames,
    jkt = Object.prototype.hasOwnProperty,
    oge = (e, t) => mk(e, "name", { value: t, configurable: !0 }),
    Fkt = (e, t) => {
      for (var r in t) mk(e, r, { get: t[r], enumerable: !0 });
    },
    Bkt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of qkt(t))
          !jkt.call(e, i) &&
            i !== r &&
            mk(e, i, {
              get: () => t[i],
              enumerable: !(n = Mkt(t, i)) || n.enumerable,
            });
      return e;
    },
    Ukt = (e) => Bkt(mk({}, "__esModule", { value: !0 }), e),
    age = {};
  Fkt(age, { fromArrayBuffer: () => Gkt, fromString: () => Vkt });
  sge.exports = Ukt(age);
  var Hkt = ige(),
    _K = G("buffer"),
    Gkt = oge((e, t = 0, r = e.byteLength - t) => {
      if (!(0, Hkt.isArrayBuffer)(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`,
        );
      return _K.Buffer.from(e, t, r);
    }, "fromArrayBuffer"),
    Vkt = oge((e, t) => {
      if (typeof e != "string")
        throw new TypeError(
          `The "input" argument must be of type string. Received type ${typeof e} (${e})`,
        );
      return t ? _K.Buffer.from(e, t) : _K.Buffer.from(e);
    }, "fromString");
});
var cge = g((gk) => {
  "use strict";
  c();
  Object.defineProperty(gk, "__esModule", { value: !0 });
  gk.fromBase64 = void 0;
  var $kt = hk(),
    zkt = /^[A-Za-z0-9+/]*={0,2}$/,
    Kkt = (e) => {
      if ((e.length * 3) % 4 !== 0)
        throw new TypeError("Incorrect padding on base64 string.");
      if (!zkt.exec(e)) throw new TypeError("Invalid base64 string.");
      let t = (0, $kt.fromString)(e, "base64");
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    };
  gk.fromBase64 = Kkt;
});
var pge = g((Mmn, fge) => {
  c();
  var vk = Object.defineProperty,
    Wkt = Object.getOwnPropertyDescriptor,
    Qkt = Object.getOwnPropertyNames,
    Ykt = Object.prototype.hasOwnProperty,
    EK = (e, t) => vk(e, "name", { value: t, configurable: !0 }),
    Xkt = (e, t) => {
      for (var r in t) vk(e, r, { get: t[r], enumerable: !0 });
    },
    Jkt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Qkt(t))
          !Ykt.call(e, i) &&
            i !== r &&
            vk(e, i, {
              get: () => t[i],
              enumerable: !(n = Wkt(t, i)) || n.enumerable,
            });
      return e;
    },
    Zkt = (e) => Jkt(vk({}, "__esModule", { value: !0 }), e),
    uge = {};
  Xkt(uge, { fromUtf8: () => dge, toUint8Array: () => eDt, toUtf8: () => tDt });
  fge.exports = Zkt(uge);
  var lge = hk(),
    dge = EK((e) => {
      let t = (0, lge.fromString)(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT,
      );
    }, "fromUtf8"),
    eDt = EK(
      (e) =>
        typeof e == "string"
          ? dge(e)
          : ArrayBuffer.isView(e)
            ? new Uint8Array(
                e.buffer,
                e.byteOffset,
                e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
              )
            : new Uint8Array(e),
      "toUint8Array",
    ),
    tDt = EK((e) => {
      if (typeof e == "string") return e;
      if (
        typeof e != "object" ||
        typeof e.byteOffset != "number" ||
        typeof e.byteLength != "number"
      )
        throw new Error(
          "@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.",
        );
      return (0, lge.fromArrayBuffer)(
        e.buffer,
        e.byteOffset,
        e.byteLength,
      ).toString("utf8");
    }, "toUtf8");
});
var mge = g((yk) => {
  "use strict";
  c();
  Object.defineProperty(yk, "__esModule", { value: !0 });
  yk.toBase64 = void 0;
  var rDt = hk(),
    nDt = pge(),
    iDt = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = (0, nDt.fromUtf8)(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.",
        );
      return (0, rDt.fromArrayBuffer)(
        t.buffer,
        t.byteOffset,
        t.byteLength,
      ).toString("base64");
    };
  yk.toBase64 = iDt;
});
var Ek = g((Bmn, _k) => {
  c();
  var hge = Object.defineProperty,
    oDt = Object.getOwnPropertyDescriptor,
    aDt = Object.getOwnPropertyNames,
    sDt = Object.prototype.hasOwnProperty,
    bK = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of aDt(t))
          !sDt.call(e, i) &&
            i !== r &&
            hge(e, i, {
              get: () => t[i],
              enumerable: !(n = oDt(t, i)) || n.enumerable,
            });
      return e;
    },
    gge = (e, t, r) => (bK(e, t, "default"), r && bK(r, t, "default")),
    cDt = (e) => bK(hge({}, "__esModule", { value: !0 }), e),
    SK = {};
  _k.exports = cDt(SK);
  gge(SK, cge(), _k.exports);
  gge(SK, mge(), _k.exports);
});
var NK = g((wk) => {
  "use strict";
  c();
  Object.defineProperty(wk, "__esModule", { value: !0 });
  wk.BackendIdentifierConversions = void 0;
  var EDt = G("crypto"),
    bDt = 128,
    Qge = "amplify",
    Xge = 10,
    SDt = 4,
    xK = class {
      static fromStackName(t) {
        if (!t) return;
        let r = t.split("-");
        if (r.length !== 5) return;
        let [n, i, o, a, s] = r;
        if (n === Qge && !(a !== "sandbox" && a !== "branch"))
          return { namespace: i, name: o, type: a, hash: s };
      }
      static toStackName(t) {
        let r = CDt(t),
          n = Yge(t.name).slice(0, 50),
          i = bDt - Qge.length - t.type.length - n.length - SDt - Xge;
        return ["amplify", Yge(t.namespace).slice(0, i - 1), n, t.type, r].join(
          "-",
        );
      }
    };
  wk.BackendIdentifierConversions = xK;
  var CDt = (e) =>
      e.hash ??
      (0, EDt.createHash)("sha512")
        .update(e.namespace)
        .update(e.name)
        .digest("hex")
        .slice(0, Xge),
    Yge = (e) => e.replace(/[^A-Za-z0-9]/g, "");
});
var Tk = g((Ok) => {
  "use strict";
  c();
  Object.defineProperty(Ok, "__esModule", { value: !0 });
  Ok.AmplifyError = void 0;
  var Gs = Oy(),
    kK = class e extends Error {
      name;
      classification;
      options;
      cause;
      serializedError;
      message;
      resolution;
      details;
      link;
      code;
      constructor(t, r, n, i) {
        super(n.message, { cause: i }),
          (this.name = t),
          (this.classification = r),
          (this.options = n),
          (this.cause = i),
          Object.setPrototypeOf(this, e.prototype),
          (this.message = n.message),
          (this.details = n.details),
          (this.resolution = n.resolution),
          (this.code = n.code),
          (this.link = n.link),
          i && e.isAmplifyError(i) && (i.serializedError = void 0),
          (this.serializedError = Buffer.from(
            JSON.stringify(
              { name: t, classification: r, options: n, cause: i },
              LDt,
            ),
          ).toString("base64"));
      }
      static fromStderr = (t) => {
        try {
          let r = wDt(t);
          if (!r) return;
          let {
              name: n,
              classification: i,
              options: o,
              cause: a,
            } = JSON.parse(r),
            s = a;
          return (
            a && sC.isSerializedErrorType(a) && (s = sC.deserialize(a)),
            i === "ERROR"
              ? new Gs.AmplifyUserError(n, o, s)
              : new Gs.AmplifyFault(n, o, s)
          );
        } catch {
          return;
        }
      };
      static isAmplifyError = (t) =>
        t instanceof Error &&
        "classification" in t &&
        (t.classification === "ERROR" || t.classification === "FAULT") &&
        typeof t.name == "string" &&
        typeof t.message == "string";
      static fromError = (t) => {
        if (e.isAmplifyError(t)) return t;
        let r =
          t instanceof Error
            ? `${t.name}: ${t.message}`
            : "An unknown error happened. Check downstream error";
        return t instanceof Error && ADt(t)
          ? new Gs.AmplifyUserError(
              "CredentialsError",
              {
                message: r,
                resolution:
                  "Ensure your AWS credentials are correctly set and refreshed.",
              },
              t,
            )
          : t instanceof Error && PDt(t)
            ? new Gs.AmplifyUserError(
                "RequestSignatureError",
                {
                  message: r,
                  resolution:
                    "You can retry your last request, check if your system time is synchronized (clock skew) or ensure your AWS credentials are correctly set and refreshed.",
                },
                t,
              )
            : t instanceof Error && RDt(t)
              ? new Gs.AmplifyUserError(
                  "InvalidCommandInputError",
                  {
                    message: r,
                    resolution:
                      "Please see the underlying error message for resolution.",
                  },
                  t,
                )
              : t instanceof Error && IDt(t)
                ? new Gs.AmplifyUserError(
                    "DomainNotFoundError",
                    {
                      message: "Unable to establish a connection to a domain",
                      resolution:
                        "Ensure domain name is correct and network connection is stable.",
                    },
                    t,
                  )
                : t instanceof Error && xDt(t)
                  ? new Gs.AmplifyUserError(
                      "SyntaxError",
                      {
                        message: t.message,
                        resolution:
                          "Check your backend definition in the `amplify` folder for syntax and type errors.",
                      },
                      t,
                    )
                  : t instanceof Error && NDt(t)
                    ? new Gs.AmplifyUserError(
                        "InsufficientDiskSpaceError",
                        {
                          message: t.message,
                          resolution:
                            "There appears to be insufficient space on your system to finish. Clear up some disk space and try again.",
                        },
                        t,
                      )
                    : t instanceof Error && kDt(t)
                      ? new Gs.AmplifyUserError(
                          "InsufficientMemorySpaceError",
                          {
                            message: t.message,
                            resolution:
                              "There appears to be insufficient memory on your system to finish. Close other applications or restart your system and try again.",
                          },
                          t,
                        )
                      : t instanceof Error && DDt(t)
                        ? new Gs.AmplifyUserError(
                            "InsufficientInotifyWatchersError",
                            {
                              message: t.message,
                              resolution:
                                "There appears to be an insufficient number of inotify watchers. To increase the amount of inotify watchers, change the `fs.inotify.max_user_watches` setting in your system config files to a higher value.",
                            },
                            t,
                          )
                        : new Gs.AmplifyFault(
                            "UnknownFault",
                            { message: r },
                            t instanceof Error ? t : new Error(String(t)),
                          );
      };
    };
  Ok.AmplifyError = kK;
  var wDt = (e) => {
      let t = ODt(e);
      return t || (t = TDt(e)), t;
    },
    ODt = (e) => {
      let t =
          /["']?serializedError["']?:[ ]?(?:`([a-zA-Z0-9+/=]+?)`|'([a-zA-Z0-9+/=]+?)'|"([a-zA-Z0-9+/=]+?)")/,
        r = e.match(t);
      if (r && r.length === 4) {
        let n = r.slice(1).find((i) => i && i.length > 0);
        if (n) return Buffer.from(n, "base64").toString("utf-8");
      }
    },
    TDt = (e) => {
      let t =
          /["']?serializedError["']?:[ ]?(?:`(.+?)`|'(.+?)'|"((?:\\"|[^"])*?)")/,
        r = e.match(t);
      if (r && r.length === 4)
        return r
          .slice(1)
          .find((n) => n && n.length > 0)
          ?.replaceAll('\\"', '"')
          .replaceAll("\\'", "'");
    },
    ADt = (e) =>
      !!e &&
      [
        "ExpiredToken",
        "ExpiredTokenException",
        "CredentialsProviderError",
        "InvalidClientTokenId",
        "CredentialsError",
      ].includes(e.name),
    PDt = (e) =>
      !!e &&
      ["InvalidSignatureException", "SignatureDoesNotMatch"].includes(e.name),
    RDt = (e) =>
      !!e &&
      ([
        "Unknown command",
        "Unknown argument",
        "Did you mean",
        "Not enough non-option arguments",
        "Too many non-option arguments",
        "Missing required argument",
        "Invalid values:",
        "Missing dependent arguments",
        "Implications failed",
      ].some((t) => e.message.startsWith(t)) ||
        e.message.endsWith("are mutually exclusive")),
    IDt = (e) => !!e && e.message.includes("getaddrinfo ENOTFOUND"),
    xDt = (e) => !!e && e.name === "SyntaxError",
    NDt = (e) =>
      !!e &&
      ["ENOSPC: no space left on device", "code ENOSPC"].some((t) =>
        e.message.includes(t),
      ),
    kDt = (e) =>
      !!e &&
      (e.message.includes("process out of memory") ||
        e.message.includes("connect ENOMEM")),
    DDt = (e) => !!e && e.message.includes("inotify_add_watch"),
    LDt = (e, t) => (t instanceof Error ? sC.serialize(t) : t),
    sC = class {
      static serialize = (t) => ({ name: t.name, message: t.message });
      static deserialize = (t) => {
        let r = new Error(t.message);
        return (r.name = t.name), r;
      };
      static isSerializedErrorType = (t) => !!(t && t.name && t.message);
    };
});
var Jge = g((Ak) => {
  "use strict";
  c();
  Object.defineProperty(Ak, "__esModule", { value: !0 });
  Ak.AmplifyUserError = void 0;
  var MDt = Tk(),
    DK = class extends MDt.AmplifyError {
      constructor(t, r, n) {
        super(t, "ERROR", r, n);
      }
    };
  Ak.AmplifyUserError = DK;
});
var Zge = g((Pk) => {
  "use strict";
  c();
  Object.defineProperty(Pk, "__esModule", { value: !0 });
  Pk.AmplifyFault = void 0;
  var qDt = Tk(),
    LK = class extends qDt.AmplifyError {
      constructor(t, r, n) {
        super(t, "FAULT", r, n);
      }
    };
  Pk.AmplifyFault = LK;
});
var Oy = g((nl) => {
  "use strict";
  c();
  var jDt =
      (nl && nl.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r);
            var i = Object.getOwnPropertyDescriptor(t, r);
            (!i ||
              ("get" in i ? !t.__esModule : i.writable || i.configurable)) &&
              (i = {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              }),
              Object.defineProperty(e, n, i);
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    MK =
      (nl && nl.__exportStar) ||
      function (e, t) {
        for (var r in e)
          r !== "default" &&
            !Object.prototype.hasOwnProperty.call(t, r) &&
            jDt(t, e, r);
      };
  Object.defineProperty(nl, "__esModule", { value: !0 });
  MK(Tk(), nl);
  MK(Jge(), nl);
  MK(Zge(), nl);
});
var rve = g((Ty) => {
  "use strict";
  c();
  var tve =
    (Ty && Ty.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(Ty, "__esModule", { value: !0 });
  Ty.BackendLocator = void 0;
  var FDt = tve(G("fs")),
    eve = tve(G("path")),
    BDt = Oy(),
    qK = class {
      rootDir;
      relativePath = eve.default.join("amplify", "backend");
      supportedFileExtensions = [".js", ".mjs", ".cjs", ".ts"];
      constructor(t = process.cwd()) {
        this.rootDir = t;
      }
      locate = () => {
        for (let t of this.supportedFileExtensions)
          if (
            FDt.default.existsSync(
              eve.default.resolve(this.rootDir, this.relativePath + t),
            )
          )
            return this.relativePath + t;
        throw new BDt.AmplifyUserError("FileConventionError", {
          message: `Amplify Backend not found in ${this.rootDir}.`,
          resolution:
            "Amplify Backend must be defined in amplify/backend.(ts|js|cjs|mjs)",
        });
      };
    };
  Ty.BackendLocator = qK;
});
var FK = g((Rk) => {
  "use strict";
  c();
  Object.defineProperty(Rk, "__esModule", { value: !0 });
  Rk.FilePathExtractor = void 0;
  var UDt = G("node:url"),
    HDt = [
      /\((?<filepath>(\w:)?[^:]*)[:\d]*\)/,
      /at (?<filepath>.*\.\w[^:\d]*)[:\d]*/,
    ],
    jK = class {
      stackTraceLine;
      constructor(t) {
        this.stackTraceLine = t;
      }
      extract = () => {
        for (let t of HDt) {
          let r = this.stackTraceLine.match(t);
          if (r?.groups?.filepath)
            return this.standardizePath(r?.groups?.filepath);
        }
      };
      standardizePath = (t) => {
        try {
          let r = new URL(t);
          return r.protocol === "file:" ? (0, UDt.fileURLToPath)(r) : t;
        } catch {
          return t;
        }
      };
    };
  Rk.FilePathExtractor = jK;
});
var nve = g((La) => {
  "use strict";
  c();
  var GDt =
      (La && La.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r);
            var i = Object.getOwnPropertyDescriptor(t, r);
            (!i ||
              ("get" in i ? !t.__esModule : i.writable || i.configurable)) &&
              (i = {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              }),
              Object.defineProperty(e, n, i);
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    VDt =
      (La && La.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: !0, value: t });
          }
        : function (e, t) {
            e.default = t;
          }),
    $Dt =
      (La && La.__importStar) ||
      (function () {
        var e = function (t) {
          return (
            (e =
              Object.getOwnPropertyNames ||
              function (r) {
                var n = [];
                for (var i in r)
                  Object.prototype.hasOwnProperty.call(r, i) &&
                    (n[n.length] = i);
                return n;
              }),
            e(t)
          );
        };
        return function (t) {
          if (t && t.__esModule) return t;
          var r = {};
          if (t != null)
            for (var n = e(t), i = 0; i < n.length; i++)
              n[i] !== "default" && GDt(r, t, n[i]);
          return VDt(r, t), r;
        };
      })(),
    zDt =
      (La && La.__importDefault) ||
      function (e) {
        return e && e.__esModule ? e : { default: e };
      };
  Object.defineProperty(La, "__esModule", { value: !0 });
  La.CallerDirectoryExtractor = void 0;
  var KDt = zDt(G("path")),
    WDt = $Dt(G("os")),
    QDt = FK(),
    BK = class {
      stackTrace;
      constructor(t) {
        this.stackTrace = t;
      }
      extract = () => {
        let t = this.stackTrace,
          r = new Error(
            "Could not determine import path to construct absolute code path from relative path. Consider using an absolute path instead.",
          );
        if (!t) throw r;
        t = t.replaceAll(
          WDt.EOL,
          `
`,
        );
        let n =
          t
            .split(
              `
`,
            )
            .map((a) => a.trim())
            .filter((a) => a.startsWith("at")) || [];
        if (n.length < 2) throw r;
        let i = n[1],
          o = new QDt.FilePathExtractor(i).extract();
        if (o) return KDt.default.dirname(o);
        throw r;
      };
    };
  La.CallerDirectoryExtractor = BK;
});
var cC = g((Tr) => {
  "use strict";
  c();
  Object.defineProperty(Tr, "__esModule", { value: !0 });
  Tr.getParsedType = Tr.ZodParsedType = Tr.objectUtil = Tr.util = void 0;
  var UK;
  (function (e) {
    e.assertEqual = (i) => i;
    function t(i) {}
    e.assertIs = t;
    function r(i) {
      throw new Error();
    }
    (e.assertNever = r),
      (e.arrayToEnum = (i) => {
        let o = {};
        for (let a of i) o[a] = a;
        return o;
      }),
      (e.getValidEnumValues = (i) => {
        let o = e.objectKeys(i).filter((s) => typeof i[i[s]] != "number"),
          a = {};
        for (let s of o) a[s] = i[s];
        return e.objectValues(a);
      }),
      (e.objectValues = (i) =>
        e.objectKeys(i).map(function (o) {
          return i[o];
        })),
      (e.objectKeys =
        typeof Object.keys == "function"
          ? (i) => Object.keys(i)
          : (i) => {
              let o = [];
              for (let a in i)
                Object.prototype.hasOwnProperty.call(i, a) && o.push(a);
              return o;
            }),
      (e.find = (i, o) => {
        for (let a of i) if (o(a)) return a;
      }),
      (e.isInteger =
        typeof Number.isInteger == "function"
          ? (i) => Number.isInteger(i)
          : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i);
    function n(i, o = " | ") {
      return i.map((a) => (typeof a == "string" ? `'${a}'` : a)).join(o);
    }
    (e.joinValues = n),
      (e.jsonStringifyReplacer = (i, o) =>
        typeof o == "bigint" ? o.toString() : o);
  })(UK || (Tr.util = UK = {}));
  var ive;
  (function (e) {
    e.mergeShapes = (t, r) => ({ ...t, ...r });
  })(ive || (Tr.objectUtil = ive = {}));
  Tr.ZodParsedType = UK.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]);
  var YDt = (e) => {
    switch (typeof e) {
      case "undefined":
        return Tr.ZodParsedType.undefined;
      case "string":
        return Tr.ZodParsedType.string;
      case "number":
        return isNaN(e) ? Tr.ZodParsedType.nan : Tr.ZodParsedType.number;
      case "boolean":
        return Tr.ZodParsedType.boolean;
      case "function":
        return Tr.ZodParsedType.function;
      case "bigint":
        return Tr.ZodParsedType.bigint;
      case "symbol":
        return Tr.ZodParsedType.symbol;
      case "object":
        return Array.isArray(e)
          ? Tr.ZodParsedType.array
          : e === null
            ? Tr.ZodParsedType.null
            : e.then &&
                typeof e.then == "function" &&
                e.catch &&
                typeof e.catch == "function"
              ? Tr.ZodParsedType.promise
              : typeof Map < "u" && e instanceof Map
                ? Tr.ZodParsedType.map
                : typeof Set < "u" && e instanceof Set
                  ? Tr.ZodParsedType.set
                  : typeof Date < "u" && e instanceof Date
                    ? Tr.ZodParsedType.date
                    : Tr.ZodParsedType.object;
      default:
        return Tr.ZodParsedType.unknown;
    }
  };
  Tr.getParsedType = YDt;
});
var Ik = g((cf) => {
  "use strict";
  c();
  Object.defineProperty(cf, "__esModule", { value: !0 });
  cf.ZodError = cf.quotelessJson = cf.ZodIssueCode = void 0;
  var ove = cC();
  cf.ZodIssueCode = ove.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]);
  var XDt = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
  cf.quotelessJson = XDt;
  var uC = class e extends Error {
    get errors() {
      return this.issues;
    }
    constructor(t) {
      super(),
        (this.issues = []),
        (this.addIssue = (n) => {
          this.issues = [...this.issues, n];
        }),
        (this.addIssues = (n = []) => {
          this.issues = [...this.issues, ...n];
        });
      let r = new.target.prototype;
      Object.setPrototypeOf
        ? Object.setPrototypeOf(this, r)
        : (this.__proto__ = r),
        (this.name = "ZodError"),
        (this.issues = t);
    }
    format(t) {
      let r =
          t ||
          function (o) {
            return o.message;
          },
        n = { _errors: [] },
        i = (o) => {
          for (let a of o.issues)
            if (a.code === "invalid_union") a.unionErrors.map(i);
            else if (a.code === "invalid_return_type") i(a.returnTypeError);
            else if (a.code === "invalid_arguments") i(a.argumentsError);
            else if (a.path.length === 0) n._errors.push(r(a));
            else {
              let s = n,
                u = 0;
              for (; u < a.path.length; ) {
                let l = a.path[u];
                u === a.path.length - 1
                  ? ((s[l] = s[l] || { _errors: [] }), s[l]._errors.push(r(a)))
                  : (s[l] = s[l] || { _errors: [] }),
                  (s = s[l]),
                  u++;
              }
            }
        };
      return i(this), n;
    }
    static assert(t) {
      if (!(t instanceof e)) throw new Error(`Not a ZodError: ${t}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, ove.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(t = (r) => r.message) {
      let r = {},
        n = [];
      for (let i of this.issues)
        i.path.length > 0
          ? ((r[i.path[0]] = r[i.path[0]] || []), r[i.path[0]].push(t(i)))
          : n.push(t(i));
      return { formErrors: n, fieldErrors: r };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  cf.ZodError = uC;
  uC.create = (e) => new uC(e);
});
var GK = g((HK) => {
  "use strict";
  c();
  Object.defineProperty(HK, "__esModule", { value: !0 });
  var Fm = cC(),
    Ui = Ik(),
    JDt = (e, t) => {
      let r;
      switch (e.code) {
        case Ui.ZodIssueCode.invalid_type:
          e.received === Fm.ZodParsedType.undefined
            ? (r = "Required")
            : (r = `Expected ${e.expected}, received ${e.received}`);
          break;
        case Ui.ZodIssueCode.invalid_literal:
          r = `Invalid literal value, expected ${JSON.stringify(e.expected, Fm.util.jsonStringifyReplacer)}`;
          break;
        case Ui.ZodIssueCode.unrecognized_keys:
          r = `Unrecognized key(s) in object: ${Fm.util.joinValues(e.keys, ", ")}`;
          break;
        case Ui.ZodIssueCode.invalid_union:
          r = "Invalid input";
          break;
        case Ui.ZodIssueCode.invalid_union_discriminator:
          r = `Invalid discriminator value. Expected ${Fm.util.joinValues(e.options)}`;
          break;
        case Ui.ZodIssueCode.invalid_enum_value:
          r = `Invalid enum value. Expected ${Fm.util.joinValues(e.options)}, received '${e.received}'`;
          break;
        case Ui.ZodIssueCode.invalid_arguments:
          r = "Invalid function arguments";
          break;
        case Ui.ZodIssueCode.invalid_return_type:
          r = "Invalid function return type";
          break;
        case Ui.ZodIssueCode.invalid_date:
          r = "Invalid date";
          break;
        case Ui.ZodIssueCode.invalid_string:
          typeof e.validation == "object"
            ? "includes" in e.validation
              ? ((r = `Invalid input: must include "${e.validation.includes}"`),
                typeof e.validation.position == "number" &&
                  (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`))
              : "startsWith" in e.validation
                ? (r = `Invalid input: must start with "${e.validation.startsWith}"`)
                : "endsWith" in e.validation
                  ? (r = `Invalid input: must end with "${e.validation.endsWith}"`)
                  : Fm.util.assertNever(e.validation)
            : e.validation !== "regex"
              ? (r = `Invalid ${e.validation}`)
              : (r = "Invalid");
          break;
        case Ui.ZodIssueCode.too_small:
          e.type === "array"
            ? (r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)`)
            : e.type === "string"
              ? (r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)`)
              : e.type === "number"
                ? (r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}`)
                : e.type === "date"
                  ? (r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}`)
                  : (r = "Invalid input");
          break;
        case Ui.ZodIssueCode.too_big:
          e.type === "array"
            ? (r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)`)
            : e.type === "string"
              ? (r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)`)
              : e.type === "number"
                ? (r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}`)
                : e.type === "bigint"
                  ? (r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}`)
                  : e.type === "date"
                    ? (r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}`)
                    : (r = "Invalid input");
          break;
        case Ui.ZodIssueCode.custom:
          r = "Invalid input";
          break;
        case Ui.ZodIssueCode.invalid_intersection_types:
          r = "Intersection results could not be merged";
          break;
        case Ui.ZodIssueCode.not_multiple_of:
          r = `Number must be a multiple of ${e.multipleOf}`;
          break;
        case Ui.ZodIssueCode.not_finite:
          r = "Number must be finite";
          break;
        default:
          (r = t.defaultError), Fm.util.assertNever(e);
      }
      return { message: r };
    };
  HK.default = JDt;
});
var xk = g((qc) => {
  "use strict";
  c();
  var ZDt =
    (qc && qc.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(qc, "__esModule", { value: !0 });
  qc.getErrorMap = qc.setErrorMap = qc.defaultErrorMap = void 0;
  var ave = ZDt(GK());
  qc.defaultErrorMap = ave.default;
  var sve = ave.default;
  function eLt(e) {
    sve = e;
  }
  qc.setErrorMap = eLt;
  function tLt() {
    return sve;
  }
  qc.getErrorMap = tLt;
});
var $K = g((Qt) => {
  "use strict";
  c();
  var rLt =
    (Qt && Qt.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(Qt, "__esModule", { value: !0 });
  Qt.isAsync =
    Qt.isValid =
    Qt.isDirty =
    Qt.isAborted =
    Qt.OK =
    Qt.DIRTY =
    Qt.INVALID =
    Qt.ParseStatus =
    Qt.addIssueToContext =
    Qt.EMPTY_PATH =
    Qt.makeIssue =
      void 0;
  var nLt = xk(),
    cve = rLt(GK()),
    iLt = (e) => {
      let { data: t, path: r, errorMaps: n, issueData: i } = e,
        o = [...r, ...(i.path || [])],
        a = { ...i, path: o };
      if (i.message !== void 0) return { ...i, path: o, message: i.message };
      let s = "",
        u = n
          .filter((l) => !!l)
          .slice()
          .reverse();
      for (let l of u) s = l(a, { data: t, defaultError: s }).message;
      return { ...i, path: o, message: s };
    };
  Qt.makeIssue = iLt;
  Qt.EMPTY_PATH = [];
  function oLt(e, t) {
    let r = (0, nLt.getErrorMap)(),
      n = (0, Qt.makeIssue)({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [
          e.common.contextualErrorMap,
          e.schemaErrorMap,
          r,
          r === cve.default ? void 0 : cve.default,
        ].filter((i) => !!i),
      });
    e.common.issues.push(n);
  }
  Qt.addIssueToContext = oLt;
  var VK = class e {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(t, r) {
      let n = [];
      for (let i of r) {
        if (i.status === "aborted") return Qt.INVALID;
        i.status === "dirty" && t.dirty(), n.push(i.value);
      }
      return { status: t.value, value: n };
    }
    static async mergeObjectAsync(t, r) {
      let n = [];
      for (let i of r) {
        let o = await i.key,
          a = await i.value;
        n.push({ key: o, value: a });
      }
      return e.mergeObjectSync(t, n);
    }
    static mergeObjectSync(t, r) {
      let n = {};
      for (let i of r) {
        let { key: o, value: a } = i;
        if (o.status === "aborted" || a.status === "aborted") return Qt.INVALID;
        o.status === "dirty" && t.dirty(),
          a.status === "dirty" && t.dirty(),
          o.value !== "__proto__" &&
            (typeof a.value < "u" || i.alwaysSet) &&
            (n[o.value] = a.value);
      }
      return { status: t.value, value: n };
    }
  };
  Qt.ParseStatus = VK;
  Qt.INVALID = Object.freeze({ status: "aborted" });
  var aLt = (e) => ({ status: "dirty", value: e });
  Qt.DIRTY = aLt;
  var sLt = (e) => ({ status: "valid", value: e });
  Qt.OK = sLt;
  var cLt = (e) => e.status === "aborted";
  Qt.isAborted = cLt;
  var uLt = (e) => e.status === "dirty";
  Qt.isDirty = uLt;
  var lLt = (e) => e.status === "valid";
  Qt.isValid = lLt;
  var dLt = (e) => typeof Promise < "u" && e instanceof Promise;
  Qt.isAsync = dLt;
});
var lve = g((uve) => {
  "use strict";
  c();
  Object.defineProperty(uve, "__esModule", { value: !0 });
});
var fve = g((Nk) => {
  "use strict";
  c();
  Object.defineProperty(Nk, "__esModule", { value: !0 });
  Nk.errorUtil = void 0;
  var dve;
  (function (e) {
    (e.errToObj = (t) => (typeof t == "string" ? { message: t } : t || {})),
      (e.toString = (t) => (typeof t == "string" ? t : t?.message));
  })(dve || (Nk.errorUtil = dve = {}));
});
var Ove = g((N) => {
  "use strict";
  c();
  var Dk =
      (N && N.__classPrivateFieldGet) ||
      function (e, t, r, n) {
        if (r === "a" && !n)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof t == "function" ? e !== t || !n : !t.has(e))
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it",
          );
        return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
      },
    hve =
      (N && N.__classPrivateFieldSet) ||
      function (e, t, r, n, i) {
        if (n === "m") throw new TypeError("Private method is not writable");
        if (n === "a" && !i)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof t == "function" ? e !== t || !i : !t.has(e))
          throw new TypeError(
            "Cannot write private member to an object whose class did not declare it",
          );
        return n === "a" ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r;
      },
    lC,
    dC;
  Object.defineProperty(N, "__esModule", { value: !0 });
  N.boolean =
    N.bigint =
    N.array =
    N.any =
    N.coerce =
    N.ZodFirstPartyTypeKind =
    N.late =
    N.ZodSchema =
    N.Schema =
    N.custom =
    N.ZodReadonly =
    N.ZodPipeline =
    N.ZodBranded =
    N.BRAND =
    N.ZodNaN =
    N.ZodCatch =
    N.ZodDefault =
    N.ZodNullable =
    N.ZodOptional =
    N.ZodTransformer =
    N.ZodEffects =
    N.ZodPromise =
    N.ZodNativeEnum =
    N.ZodEnum =
    N.ZodLiteral =
    N.ZodLazy =
    N.ZodFunction =
    N.ZodSet =
    N.ZodMap =
    N.ZodRecord =
    N.ZodTuple =
    N.ZodIntersection =
    N.ZodDiscriminatedUnion =
    N.ZodUnion =
    N.ZodObject =
    N.ZodArray =
    N.ZodVoid =
    N.ZodNever =
    N.ZodUnknown =
    N.ZodAny =
    N.ZodNull =
    N.ZodUndefined =
    N.ZodSymbol =
    N.ZodDate =
    N.ZodBoolean =
    N.ZodBigInt =
    N.ZodNumber =
    N.ZodString =
    N.datetimeRegex =
    N.ZodType =
      void 0;
  N.NEVER =
    N.void =
    N.unknown =
    N.union =
    N.undefined =
    N.tuple =
    N.transformer =
    N.symbol =
    N.string =
    N.strictObject =
    N.set =
    N.record =
    N.promise =
    N.preprocess =
    N.pipeline =
    N.ostring =
    N.optional =
    N.onumber =
    N.oboolean =
    N.object =
    N.number =
    N.nullable =
    N.null =
    N.never =
    N.nativeEnum =
    N.nan =
    N.map =
    N.literal =
    N.lazy =
    N.intersection =
    N.instanceof =
    N.function =
    N.enum =
    N.effect =
    N.discriminatedUnion =
    N.date =
      void 0;
  var kk = xk(),
    De = fve(),
    D = $K(),
    ae = cC(),
    ne = Ik(),
    qa = class {
      constructor(t, r, n, i) {
        (this._cachedPath = []),
          (this.parent = t),
          (this.data = r),
          (this._path = n),
          (this._key = i);
      }
      get path() {
        return (
          this._cachedPath.length ||
            (this._key instanceof Array
              ? this._cachedPath.push(...this._path, ...this._key)
              : this._cachedPath.push(...this._path, this._key)),
          this._cachedPath
        );
      }
    },
    pve = (e, t) => {
      if ((0, D.isValid)(t)) return { success: !0, data: t.value };
      if (!e.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
      return {
        success: !1,
        get error() {
          if (this._error) return this._error;
          let r = new ne.ZodError(e.common.issues);
          return (this._error = r), this._error;
        },
      };
    };
  function Ze(e) {
    if (!e) return {};
    let {
      errorMap: t,
      invalid_type_error: r,
      required_error: n,
      description: i,
    } = e;
    if (t && (r || n))
      throw new Error(
        `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`,
      );
    return t
      ? { errorMap: t, description: i }
      : {
          errorMap: (a, s) => {
            var u, l;
            let { message: d } = e;
            return a.code === "invalid_enum_value"
              ? { message: d ?? s.defaultError }
              : typeof s.data > "u"
                ? {
                    message:
                      (u = d ?? n) !== null && u !== void 0
                        ? u
                        : s.defaultError,
                  }
                : a.code !== "invalid_type"
                  ? { message: s.defaultError }
                  : {
                      message:
                        (l = d ?? r) !== null && l !== void 0
                          ? l
                          : s.defaultError,
                    };
          },
          description: i,
        };
  }
  var et = class {
    get description() {
      return this._def.description;
    }
    _getType(t) {
      return (0, ae.getParsedType)(t.data);
    }
    _getOrReturnCtx(t, r) {
      return (
        r || {
          common: t.parent.common,
          data: t.data,
          parsedType: (0, ae.getParsedType)(t.data),
          schemaErrorMap: this._def.errorMap,
          path: t.path,
          parent: t.parent,
        }
      );
    }
    _processInputParams(t) {
      return {
        status: new D.ParseStatus(),
        ctx: {
          common: t.parent.common,
          data: t.data,
          parsedType: (0, ae.getParsedType)(t.data),
          schemaErrorMap: this._def.errorMap,
          path: t.path,
          parent: t.parent,
        },
      };
    }
    _parseSync(t) {
      let r = this._parse(t);
      if ((0, D.isAsync)(r))
        throw new Error("Synchronous parse encountered promise.");
      return r;
    }
    _parseAsync(t) {
      let r = this._parse(t);
      return Promise.resolve(r);
    }
    parse(t, r) {
      let n = this.safeParse(t, r);
      if (n.success) return n.data;
      throw n.error;
    }
    safeParse(t, r) {
      var n;
      let i = {
          common: {
            issues: [],
            async: (n = r?.async) !== null && n !== void 0 ? n : !1,
            contextualErrorMap: r?.errorMap,
          },
          path: r?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: t,
          parsedType: (0, ae.getParsedType)(t),
        },
        o = this._parseSync({ data: t, path: i.path, parent: i });
      return pve(i, o);
    }
    "~validate"(t) {
      var r, n;
      let i = {
        common: { issues: [], async: !!this["~standard"].async },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: (0, ae.getParsedType)(t),
      };
      if (!this["~standard"].async)
        try {
          let o = this._parseSync({ data: t, path: [], parent: i });
          return (0, D.isValid)(o)
            ? { value: o.value }
            : { issues: i.common.issues };
        } catch (o) {
          !(
            (n =
              (r = o?.message) === null || r === void 0
                ? void 0
                : r.toLowerCase()) === null || n === void 0
          ) &&
            n.includes("encountered") &&
            (this["~standard"].async = !0),
            (i.common = { issues: [], async: !0 });
        }
      return this._parseAsync({ data: t, path: [], parent: i }).then((o) =>
        (0, D.isValid)(o) ? { value: o.value } : { issues: i.common.issues },
      );
    }
    async parseAsync(t, r) {
      let n = await this.safeParseAsync(t, r);
      if (n.success) return n.data;
      throw n.error;
    }
    async safeParseAsync(t, r) {
      let n = {
          common: { issues: [], contextualErrorMap: r?.errorMap, async: !0 },
          path: r?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: t,
          parsedType: (0, ae.getParsedType)(t),
        },
        i = this._parse({ data: t, path: n.path, parent: n }),
        o = await ((0, D.isAsync)(i) ? i : Promise.resolve(i));
      return pve(n, o);
    }
    refine(t, r) {
      let n = (i) =>
        typeof r == "string" || typeof r > "u"
          ? { message: r }
          : typeof r == "function"
            ? r(i)
            : r;
      return this._refinement((i, o) => {
        let a = t(i),
          s = () => o.addIssue({ code: ne.ZodIssueCode.custom, ...n(i) });
        return typeof Promise < "u" && a instanceof Promise
          ? a.then((u) => (u ? !0 : (s(), !1)))
          : a
            ? !0
            : (s(), !1);
      });
    }
    refinement(t, r) {
      return this._refinement((n, i) =>
        t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1),
      );
    }
    _refinement(t) {
      return new la({
        schema: this,
        typeName: He.ZodEffects,
        effect: { type: "refinement", refinement: t },
      });
    }
    superRefine(t) {
      return this._refinement(t);
    }
    constructor(t) {
      (this.spa = this.safeParseAsync),
        (this._def = t),
        (this.parse = this.parse.bind(this)),
        (this.safeParse = this.safeParse.bind(this)),
        (this.parseAsync = this.parseAsync.bind(this)),
        (this.safeParseAsync = this.safeParseAsync.bind(this)),
        (this.spa = this.spa.bind(this)),
        (this.refine = this.refine.bind(this)),
        (this.refinement = this.refinement.bind(this)),
        (this.superRefine = this.superRefine.bind(this)),
        (this.optional = this.optional.bind(this)),
        (this.nullable = this.nullable.bind(this)),
        (this.nullish = this.nullish.bind(this)),
        (this.array = this.array.bind(this)),
        (this.promise = this.promise.bind(this)),
        (this.or = this.or.bind(this)),
        (this.and = this.and.bind(this)),
        (this.transform = this.transform.bind(this)),
        (this.brand = this.brand.bind(this)),
        (this.default = this.default.bind(this)),
        (this.catch = this.catch.bind(this)),
        (this.describe = this.describe.bind(this)),
        (this.pipe = this.pipe.bind(this)),
        (this.readonly = this.readonly.bind(this)),
        (this.isNullable = this.isNullable.bind(this)),
        (this.isOptional = this.isOptional.bind(this)),
        (this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (r) => this["~validate"](r),
        });
    }
    optional() {
      return Ma.create(this, this._def);
    }
    nullable() {
      return Fc.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return al.create(this);
    }
    promise() {
      return df.create(this, this._def);
    }
    or(t) {
      return zm.create([this, t], this._def);
    }
    and(t) {
      return Km.create(this, t, this._def);
    }
    transform(t) {
      return new la({
        ...Ze(this._def),
        schema: this,
        typeName: He.ZodEffects,
        effect: { type: "transform", transform: t },
      });
    }
    default(t) {
      let r = typeof t == "function" ? t : () => t;
      return new Jm({
        ...Ze(this._def),
        innerType: this,
        defaultValue: r,
        typeName: He.ZodDefault,
      });
    }
    brand() {
      return new fC({ typeName: He.ZodBranded, type: this, ...Ze(this._def) });
    }
    catch(t) {
      let r = typeof t == "function" ? t : () => t;
      return new Zm({
        ...Ze(this._def),
        innerType: this,
        catchValue: r,
        typeName: He.ZodCatch,
      });
    }
    describe(t) {
      let r = this.constructor;
      return new r({ ...this._def, description: t });
    }
    pipe(t) {
      return pC.create(this, t);
    }
    readonly() {
      return eh.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  N.ZodType = et;
  N.Schema = et;
  N.ZodSchema = et;
  var fLt = /^c[^\s-]{8,}$/i,
    pLt = /^[0-9a-z]+$/,
    mLt = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
    hLt =
      /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
    gLt = /^[a-z0-9_-]{21}$/i,
    vLt = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
    yLt =
      /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
    _Lt =
      /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
    ELt = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
    zK,
    bLt =
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    SLt =
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    CLt =
      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
    wLt =
      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    OLt = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    TLt =
      /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    gve =
      "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
    ALt = new RegExp(`^${gve}$`);
  function vve(e) {
    let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return (
      e.precision
        ? (t = `${t}\\.\\d{${e.precision}}`)
        : e.precision == null && (t = `${t}(\\.\\d+)?`),
      t
    );
  }
  function PLt(e) {
    return new RegExp(`^${vve(e)}$`);
  }
  function yve(e) {
    let t = `${gve}T${vve(e)}`,
      r = [];
    return (
      r.push(e.local ? "Z?" : "Z"),
      e.offset && r.push("([+-]\\d{2}:?\\d{2})"),
      (t = `${t}(${r.join("|")})`),
      new RegExp(`^${t}$`)
    );
  }
  N.datetimeRegex = yve;
  function RLt(e, t) {
    return !!(
      ((t === "v4" || !t) && bLt.test(e)) ||
      ((t === "v6" || !t) && CLt.test(e))
    );
  }
  function ILt(e, t) {
    if (!vLt.test(e)) return !1;
    try {
      let [r] = e.split("."),
        n = r
          .replace(/-/g, "+")
          .replace(/_/g, "/")
          .padEnd(r.length + ((4 - (r.length % 4)) % 4), "="),
        i = JSON.parse(atob(n));
      return !(
        typeof i != "object" ||
        i === null ||
        !i.typ ||
        !i.alg ||
        (t && i.alg !== t)
      );
    } catch {
      return !1;
    }
  }
  function xLt(e, t) {
    return !!(
      ((t === "v4" || !t) && SLt.test(e)) ||
      ((t === "v6" || !t) && wLt.test(e))
    );
  }
  var uf = class e extends et {
    _parse(t) {
      if (
        (this._def.coerce && (t.data = String(t.data)),
        this._getType(t) !== ae.ZodParsedType.string)
      ) {
        let o = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(o, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.string,
            received: o.parsedType,
          }),
          D.INVALID
        );
      }
      let n = new D.ParseStatus(),
        i;
      for (let o of this._def.checks)
        if (o.kind === "min")
          t.data.length < o.value &&
            ((i = this._getOrReturnCtx(t, i)),
            (0, D.addIssueToContext)(i, {
              code: ne.ZodIssueCode.too_small,
              minimum: o.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: o.message,
            }),
            n.dirty());
        else if (o.kind === "max")
          t.data.length > o.value &&
            ((i = this._getOrReturnCtx(t, i)),
            (0, D.addIssueToContext)(i, {
              code: ne.ZodIssueCode.too_big,
              maximum: o.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: o.message,
            }),
            n.dirty());
        else if (o.kind === "length") {
          let a = t.data.length > o.value,
            s = t.data.length < o.value;
          (a || s) &&
            ((i = this._getOrReturnCtx(t, i)),
            a
              ? (0, D.addIssueToContext)(i, {
                  code: ne.ZodIssueCode.too_big,
                  maximum: o.value,
                  type: "string",
                  inclusive: !0,
                  exact: !0,
                  message: o.message,
                })
              : s &&
                (0, D.addIssueToContext)(i, {
                  code: ne.ZodIssueCode.too_small,
                  minimum: o.value,
                  type: "string",
                  inclusive: !0,
                  exact: !0,
                  message: o.message,
                }),
            n.dirty());
        } else if (o.kind === "email")
          _Lt.test(t.data) ||
            ((i = this._getOrReturnCtx(t, i)),
            (0, D.addIssueToContext)(i, {
              validation: "email",
              code: ne.ZodIssueCode.invalid_string,
              message: o.message,
            }),
            n.dirty());
        else if (o.kind === "emoji")
          zK || (zK = new RegExp(ELt, "u")),
            zK.test(t.data) ||
              ((i = this._getOrReturnCtx(t, i)),
              (0, D.addIssueToContext)(i, {
                validation: "emoji",
                code: ne.ZodIssueCode.invalid_string,
                message: o.message,
              }),
              n.dirty());
        else if (o.kind === "uuid")
          hLt.test(t.data) ||
            ((i = this._getOrReturnCtx(t, i)),
            (0, D.addIssueToContext)(i, {
              validation: "uuid",
              code: ne.ZodIssueCode.invalid_string,
              message: o.message,
            }),
            n.dirty());
        else if (o.kind === "nanoid")
          gLt.test(t.data) ||
            ((i = this._getOrReturnCtx(t, i)),
            (0, D.addIssueToContext)(i, {
              validation: "nanoid",
              code: ne.ZodIssueCode.invalid_string,
              message: o.message,
            }),
            n.dirty());
        else if (o.kind === "cuid")
          fLt.test(t.data) ||
            ((i = this._getOrReturnCtx(t, i)),
            (0, D.addIssueToContext)(i, {
              validation: "cuid",
              code: ne.ZodIssueCode.invalid_string,
              message: o.message,
            }),
            n.dirty());
        else if (o.kind === "cuid2")
          pLt.test(t.data) ||
            ((i = this._getOrReturnCtx(t, i)),
            (0, D.addIssueToContext)(i, {
              validation: "cuid2",
              code: ne.ZodIssueCode.invalid_string,
              message: o.message,
            }),
            n.dirty());
        else if (o.kind === "ulid")
          mLt.test(t.data) ||
            ((i = this._getOrReturnCtx(t, i)),
            (0, D.addIssueToContext)(i, {
              validation: "ulid",
              code: ne.ZodIssueCode.invalid_string,
              message: o.message,
            }),
            n.dirty());
        else if (o.kind === "url")
          try {
            new URL(t.data);
          } catch {
            (i = this._getOrReturnCtx(t, i)),
              (0, D.addIssueToContext)(i, {
                validation: "url",
                code: ne.ZodIssueCode.invalid_string,
                message: o.message,
              }),
              n.dirty();
          }
        else
          o.kind === "regex"
            ? ((o.regex.lastIndex = 0),
              o.regex.test(t.data) ||
                ((i = this._getOrReturnCtx(t, i)),
                (0, D.addIssueToContext)(i, {
                  validation: "regex",
                  code: ne.ZodIssueCode.invalid_string,
                  message: o.message,
                }),
                n.dirty()))
            : o.kind === "trim"
              ? (t.data = t.data.trim())
              : o.kind === "includes"
                ? t.data.includes(o.value, o.position) ||
                  ((i = this._getOrReturnCtx(t, i)),
                  (0, D.addIssueToContext)(i, {
                    code: ne.ZodIssueCode.invalid_string,
                    validation: { includes: o.value, position: o.position },
                    message: o.message,
                  }),
                  n.dirty())
                : o.kind === "toLowerCase"
                  ? (t.data = t.data.toLowerCase())
                  : o.kind === "toUpperCase"
                    ? (t.data = t.data.toUpperCase())
                    : o.kind === "startsWith"
                      ? t.data.startsWith(o.value) ||
                        ((i = this._getOrReturnCtx(t, i)),
                        (0, D.addIssueToContext)(i, {
                          code: ne.ZodIssueCode.invalid_string,
                          validation: { startsWith: o.value },
                          message: o.message,
                        }),
                        n.dirty())
                      : o.kind === "endsWith"
                        ? t.data.endsWith(o.value) ||
                          ((i = this._getOrReturnCtx(t, i)),
                          (0, D.addIssueToContext)(i, {
                            code: ne.ZodIssueCode.invalid_string,
                            validation: { endsWith: o.value },
                            message: o.message,
                          }),
                          n.dirty())
                        : o.kind === "datetime"
                          ? yve(o).test(t.data) ||
                            ((i = this._getOrReturnCtx(t, i)),
                            (0, D.addIssueToContext)(i, {
                              code: ne.ZodIssueCode.invalid_string,
                              validation: "datetime",
                              message: o.message,
                            }),
                            n.dirty())
                          : o.kind === "date"
                            ? ALt.test(t.data) ||
                              ((i = this._getOrReturnCtx(t, i)),
                              (0, D.addIssueToContext)(i, {
                                code: ne.ZodIssueCode.invalid_string,
                                validation: "date",
                                message: o.message,
                              }),
                              n.dirty())
                            : o.kind === "time"
                              ? PLt(o).test(t.data) ||
                                ((i = this._getOrReturnCtx(t, i)),
                                (0, D.addIssueToContext)(i, {
                                  code: ne.ZodIssueCode.invalid_string,
                                  validation: "time",
                                  message: o.message,
                                }),
                                n.dirty())
                              : o.kind === "duration"
                                ? yLt.test(t.data) ||
                                  ((i = this._getOrReturnCtx(t, i)),
                                  (0, D.addIssueToContext)(i, {
                                    validation: "duration",
                                    code: ne.ZodIssueCode.invalid_string,
                                    message: o.message,
                                  }),
                                  n.dirty())
                                : o.kind === "ip"
                                  ? RLt(t.data, o.version) ||
                                    ((i = this._getOrReturnCtx(t, i)),
                                    (0, D.addIssueToContext)(i, {
                                      validation: "ip",
                                      code: ne.ZodIssueCode.invalid_string,
                                      message: o.message,
                                    }),
                                    n.dirty())
                                  : o.kind === "jwt"
                                    ? ILt(t.data, o.alg) ||
                                      ((i = this._getOrReturnCtx(t, i)),
                                      (0, D.addIssueToContext)(i, {
                                        validation: "jwt",
                                        code: ne.ZodIssueCode.invalid_string,
                                        message: o.message,
                                      }),
                                      n.dirty())
                                    : o.kind === "cidr"
                                      ? xLt(t.data, o.version) ||
                                        ((i = this._getOrReturnCtx(t, i)),
                                        (0, D.addIssueToContext)(i, {
                                          validation: "cidr",
                                          code: ne.ZodIssueCode.invalid_string,
                                          message: o.message,
                                        }),
                                        n.dirty())
                                      : o.kind === "base64"
                                        ? OLt.test(t.data) ||
                                          ((i = this._getOrReturnCtx(t, i)),
                                          (0, D.addIssueToContext)(i, {
                                            validation: "base64",
                                            code: ne.ZodIssueCode
                                              .invalid_string,
                                            message: o.message,
                                          }),
                                          n.dirty())
                                        : o.kind === "base64url"
                                          ? TLt.test(t.data) ||
                                            ((i = this._getOrReturnCtx(t, i)),
                                            (0, D.addIssueToContext)(i, {
                                              validation: "base64url",
                                              code: ne.ZodIssueCode
                                                .invalid_string,
                                              message: o.message,
                                            }),
                                            n.dirty())
                                          : ae.util.assertNever(o);
      return { status: n.value, value: t.data };
    }
    _regex(t, r, n) {
      return this.refinement((i) => t.test(i), {
        validation: r,
        code: ne.ZodIssueCode.invalid_string,
        ...De.errorUtil.errToObj(n),
      });
    }
    _addCheck(t) {
      return new e({ ...this._def, checks: [...this._def.checks, t] });
    }
    email(t) {
      return this._addCheck({ kind: "email", ...De.errorUtil.errToObj(t) });
    }
    url(t) {
      return this._addCheck({ kind: "url", ...De.errorUtil.errToObj(t) });
    }
    emoji(t) {
      return this._addCheck({ kind: "emoji", ...De.errorUtil.errToObj(t) });
    }
    uuid(t) {
      return this._addCheck({ kind: "uuid", ...De.errorUtil.errToObj(t) });
    }
    nanoid(t) {
      return this._addCheck({ kind: "nanoid", ...De.errorUtil.errToObj(t) });
    }
    cuid(t) {
      return this._addCheck({ kind: "cuid", ...De.errorUtil.errToObj(t) });
    }
    cuid2(t) {
      return this._addCheck({ kind: "cuid2", ...De.errorUtil.errToObj(t) });
    }
    ulid(t) {
      return this._addCheck({ kind: "ulid", ...De.errorUtil.errToObj(t) });
    }
    base64(t) {
      return this._addCheck({ kind: "base64", ...De.errorUtil.errToObj(t) });
    }
    base64url(t) {
      return this._addCheck({ kind: "base64url", ...De.errorUtil.errToObj(t) });
    }
    jwt(t) {
      return this._addCheck({ kind: "jwt", ...De.errorUtil.errToObj(t) });
    }
    ip(t) {
      return this._addCheck({ kind: "ip", ...De.errorUtil.errToObj(t) });
    }
    cidr(t) {
      return this._addCheck({ kind: "cidr", ...De.errorUtil.errToObj(t) });
    }
    datetime(t) {
      var r, n;
      return typeof t == "string"
        ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: t,
          })
        : this._addCheck({
            kind: "datetime",
            precision: typeof t?.precision > "u" ? null : t?.precision,
            offset: (r = t?.offset) !== null && r !== void 0 ? r : !1,
            local: (n = t?.local) !== null && n !== void 0 ? n : !1,
            ...De.errorUtil.errToObj(t?.message),
          });
    }
    date(t) {
      return this._addCheck({ kind: "date", message: t });
    }
    time(t) {
      return typeof t == "string"
        ? this._addCheck({ kind: "time", precision: null, message: t })
        : this._addCheck({
            kind: "time",
            precision: typeof t?.precision > "u" ? null : t?.precision,
            ...De.errorUtil.errToObj(t?.message),
          });
    }
    duration(t) {
      return this._addCheck({ kind: "duration", ...De.errorUtil.errToObj(t) });
    }
    regex(t, r) {
      return this._addCheck({
        kind: "regex",
        regex: t,
        ...De.errorUtil.errToObj(r),
      });
    }
    includes(t, r) {
      return this._addCheck({
        kind: "includes",
        value: t,
        position: r?.position,
        ...De.errorUtil.errToObj(r?.message),
      });
    }
    startsWith(t, r) {
      return this._addCheck({
        kind: "startsWith",
        value: t,
        ...De.errorUtil.errToObj(r),
      });
    }
    endsWith(t, r) {
      return this._addCheck({
        kind: "endsWith",
        value: t,
        ...De.errorUtil.errToObj(r),
      });
    }
    min(t, r) {
      return this._addCheck({
        kind: "min",
        value: t,
        ...De.errorUtil.errToObj(r),
      });
    }
    max(t, r) {
      return this._addCheck({
        kind: "max",
        value: t,
        ...De.errorUtil.errToObj(r),
      });
    }
    length(t, r) {
      return this._addCheck({
        kind: "length",
        value: t,
        ...De.errorUtil.errToObj(r),
      });
    }
    nonempty(t) {
      return this.min(1, De.errorUtil.errToObj(t));
    }
    trim() {
      return new e({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }],
      });
    }
    toLowerCase() {
      return new e({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }],
      });
    }
    toUpperCase() {
      return new e({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }],
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((t) => t.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((t) => t.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((t) => t.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((t) => t.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((t) => t.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((t) => t.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((t) => t.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((t) => t.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((t) => t.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((t) => t.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((t) => t.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((t) => t.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((t) => t.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((t) => t.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((t) => t.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((t) => t.kind === "base64url");
    }
    get minLength() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t;
    }
    get maxLength() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t;
    }
  };
  N.ZodString = uf;
  uf.create = (e) => {
    var t;
    return new uf({
      checks: [],
      typeName: He.ZodString,
      coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
      ...Ze(e),
    });
  };
  function NLt(e, t) {
    let r = (e.toString().split(".")[1] || "").length,
      n = (t.toString().split(".")[1] || "").length,
      i = r > n ? r : n,
      o = parseInt(e.toFixed(i).replace(".", "")),
      a = parseInt(t.toFixed(i).replace(".", ""));
    return (o % a) / Math.pow(10, i);
  }
  var Bm = class e extends et {
    constructor() {
      super(...arguments),
        (this.min = this.gte),
        (this.max = this.lte),
        (this.step = this.multipleOf);
    }
    _parse(t) {
      if (
        (this._def.coerce && (t.data = Number(t.data)),
        this._getType(t) !== ae.ZodParsedType.number)
      ) {
        let o = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(o, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.number,
            received: o.parsedType,
          }),
          D.INVALID
        );
      }
      let n,
        i = new D.ParseStatus();
      for (let o of this._def.checks)
        o.kind === "int"
          ? ae.util.isInteger(t.data) ||
            ((n = this._getOrReturnCtx(t, n)),
            (0, D.addIssueToContext)(n, {
              code: ne.ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: o.message,
            }),
            i.dirty())
          : o.kind === "min"
            ? (o.inclusive ? t.data < o.value : t.data <= o.value) &&
              ((n = this._getOrReturnCtx(t, n)),
              (0, D.addIssueToContext)(n, {
                code: ne.ZodIssueCode.too_small,
                minimum: o.value,
                type: "number",
                inclusive: o.inclusive,
                exact: !1,
                message: o.message,
              }),
              i.dirty())
            : o.kind === "max"
              ? (o.inclusive ? t.data > o.value : t.data >= o.value) &&
                ((n = this._getOrReturnCtx(t, n)),
                (0, D.addIssueToContext)(n, {
                  code: ne.ZodIssueCode.too_big,
                  maximum: o.value,
                  type: "number",
                  inclusive: o.inclusive,
                  exact: !1,
                  message: o.message,
                }),
                i.dirty())
              : o.kind === "multipleOf"
                ? NLt(t.data, o.value) !== 0 &&
                  ((n = this._getOrReturnCtx(t, n)),
                  (0, D.addIssueToContext)(n, {
                    code: ne.ZodIssueCode.not_multiple_of,
                    multipleOf: o.value,
                    message: o.message,
                  }),
                  i.dirty())
                : o.kind === "finite"
                  ? Number.isFinite(t.data) ||
                    ((n = this._getOrReturnCtx(t, n)),
                    (0, D.addIssueToContext)(n, {
                      code: ne.ZodIssueCode.not_finite,
                      message: o.message,
                    }),
                    i.dirty())
                  : ae.util.assertNever(o);
      return { status: i.value, value: t.data };
    }
    gte(t, r) {
      return this.setLimit("min", t, !0, De.errorUtil.toString(r));
    }
    gt(t, r) {
      return this.setLimit("min", t, !1, De.errorUtil.toString(r));
    }
    lte(t, r) {
      return this.setLimit("max", t, !0, De.errorUtil.toString(r));
    }
    lt(t, r) {
      return this.setLimit("max", t, !1, De.errorUtil.toString(r));
    }
    setLimit(t, r, n, i) {
      return new e({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: t,
            value: r,
            inclusive: n,
            message: De.errorUtil.toString(i),
          },
        ],
      });
    }
    _addCheck(t) {
      return new e({ ...this._def, checks: [...this._def.checks, t] });
    }
    int(t) {
      return this._addCheck({ kind: "int", message: De.errorUtil.toString(t) });
    }
    positive(t) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: De.errorUtil.toString(t),
      });
    }
    negative(t) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: De.errorUtil.toString(t),
      });
    }
    nonpositive(t) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: De.errorUtil.toString(t),
      });
    }
    nonnegative(t) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: De.errorUtil.toString(t),
      });
    }
    multipleOf(t, r) {
      return this._addCheck({
        kind: "multipleOf",
        value: t,
        message: De.errorUtil.toString(r),
      });
    }
    finite(t) {
      return this._addCheck({
        kind: "finite",
        message: De.errorUtil.toString(t),
      });
    }
    safe(t) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: De.errorUtil.toString(t),
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: De.errorUtil.toString(t),
      });
    }
    get minValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t;
    }
    get maxValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t;
    }
    get isInt() {
      return !!this._def.checks.find(
        (t) =>
          t.kind === "int" ||
          (t.kind === "multipleOf" && ae.util.isInteger(t.value)),
      );
    }
    get isFinite() {
      let t = null,
        r = null;
      for (let n of this._def.checks) {
        if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
          return !0;
        n.kind === "min"
          ? (r === null || n.value > r) && (r = n.value)
          : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
      }
      return Number.isFinite(r) && Number.isFinite(t);
    }
  };
  N.ZodNumber = Bm;
  Bm.create = (e) =>
    new Bm({
      checks: [],
      typeName: He.ZodNumber,
      coerce: e?.coerce || !1,
      ...Ze(e),
    });
  var Um = class e extends et {
    constructor() {
      super(...arguments), (this.min = this.gte), (this.max = this.lte);
    }
    _parse(t) {
      if (this._def.coerce)
        try {
          t.data = BigInt(t.data);
        } catch {
          return this._getInvalidInput(t);
        }
      if (this._getType(t) !== ae.ZodParsedType.bigint)
        return this._getInvalidInput(t);
      let n,
        i = new D.ParseStatus();
      for (let o of this._def.checks)
        o.kind === "min"
          ? (o.inclusive ? t.data < o.value : t.data <= o.value) &&
            ((n = this._getOrReturnCtx(t, n)),
            (0, D.addIssueToContext)(n, {
              code: ne.ZodIssueCode.too_small,
              type: "bigint",
              minimum: o.value,
              inclusive: o.inclusive,
              message: o.message,
            }),
            i.dirty())
          : o.kind === "max"
            ? (o.inclusive ? t.data > o.value : t.data >= o.value) &&
              ((n = this._getOrReturnCtx(t, n)),
              (0, D.addIssueToContext)(n, {
                code: ne.ZodIssueCode.too_big,
                type: "bigint",
                maximum: o.value,
                inclusive: o.inclusive,
                message: o.message,
              }),
              i.dirty())
            : o.kind === "multipleOf"
              ? t.data % o.value !== BigInt(0) &&
                ((n = this._getOrReturnCtx(t, n)),
                (0, D.addIssueToContext)(n, {
                  code: ne.ZodIssueCode.not_multiple_of,
                  multipleOf: o.value,
                  message: o.message,
                }),
                i.dirty())
              : ae.util.assertNever(o);
      return { status: i.value, value: t.data };
    }
    _getInvalidInput(t) {
      let r = this._getOrReturnCtx(t);
      return (
        (0, D.addIssueToContext)(r, {
          code: ne.ZodIssueCode.invalid_type,
          expected: ae.ZodParsedType.bigint,
          received: r.parsedType,
        }),
        D.INVALID
      );
    }
    gte(t, r) {
      return this.setLimit("min", t, !0, De.errorUtil.toString(r));
    }
    gt(t, r) {
      return this.setLimit("min", t, !1, De.errorUtil.toString(r));
    }
    lte(t, r) {
      return this.setLimit("max", t, !0, De.errorUtil.toString(r));
    }
    lt(t, r) {
      return this.setLimit("max", t, !1, De.errorUtil.toString(r));
    }
    setLimit(t, r, n, i) {
      return new e({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: t,
            value: r,
            inclusive: n,
            message: De.errorUtil.toString(i),
          },
        ],
      });
    }
    _addCheck(t) {
      return new e({ ...this._def, checks: [...this._def.checks, t] });
    }
    positive(t) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: De.errorUtil.toString(t),
      });
    }
    negative(t) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: De.errorUtil.toString(t),
      });
    }
    nonpositive(t) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: De.errorUtil.toString(t),
      });
    }
    nonnegative(t) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: De.errorUtil.toString(t),
      });
    }
    multipleOf(t, r) {
      return this._addCheck({
        kind: "multipleOf",
        value: t,
        message: De.errorUtil.toString(r),
      });
    }
    get minValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t;
    }
    get maxValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t;
    }
  };
  N.ZodBigInt = Um;
  Um.create = (e) => {
    var t;
    return new Um({
      checks: [],
      typeName: He.ZodBigInt,
      coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
      ...Ze(e),
    });
  };
  var Hm = class extends et {
    _parse(t) {
      if (
        (this._def.coerce && (t.data = !!t.data),
        this._getType(t) !== ae.ZodParsedType.boolean)
      ) {
        let n = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.boolean,
            received: n.parsedType,
          }),
          D.INVALID
        );
      }
      return (0, D.OK)(t.data);
    }
  };
  N.ZodBoolean = Hm;
  Hm.create = (e) =>
    new Hm({ typeName: He.ZodBoolean, coerce: e?.coerce || !1, ...Ze(e) });
  var Gm = class e extends et {
    _parse(t) {
      if (
        (this._def.coerce && (t.data = new Date(t.data)),
        this._getType(t) !== ae.ZodParsedType.date)
      ) {
        let o = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(o, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.date,
            received: o.parsedType,
          }),
          D.INVALID
        );
      }
      if (isNaN(t.data.getTime())) {
        let o = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(o, { code: ne.ZodIssueCode.invalid_date }),
          D.INVALID
        );
      }
      let n = new D.ParseStatus(),
        i;
      for (let o of this._def.checks)
        o.kind === "min"
          ? t.data.getTime() < o.value &&
            ((i = this._getOrReturnCtx(t, i)),
            (0, D.addIssueToContext)(i, {
              code: ne.ZodIssueCode.too_small,
              message: o.message,
              inclusive: !0,
              exact: !1,
              minimum: o.value,
              type: "date",
            }),
            n.dirty())
          : o.kind === "max"
            ? t.data.getTime() > o.value &&
              ((i = this._getOrReturnCtx(t, i)),
              (0, D.addIssueToContext)(i, {
                code: ne.ZodIssueCode.too_big,
                message: o.message,
                inclusive: !0,
                exact: !1,
                maximum: o.value,
                type: "date",
              }),
              n.dirty())
            : ae.util.assertNever(o);
      return { status: n.value, value: new Date(t.data.getTime()) };
    }
    _addCheck(t) {
      return new e({ ...this._def, checks: [...this._def.checks, t] });
    }
    min(t, r) {
      return this._addCheck({
        kind: "min",
        value: t.getTime(),
        message: De.errorUtil.toString(r),
      });
    }
    max(t, r) {
      return this._addCheck({
        kind: "max",
        value: t.getTime(),
        message: De.errorUtil.toString(r),
      });
    }
    get minDate() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t != null ? new Date(t) : null;
    }
    get maxDate() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t != null ? new Date(t) : null;
    }
  };
  N.ZodDate = Gm;
  Gm.create = (e) =>
    new Gm({
      checks: [],
      coerce: e?.coerce || !1,
      typeName: He.ZodDate,
      ...Ze(e),
    });
  var Py = class extends et {
    _parse(t) {
      if (this._getType(t) !== ae.ZodParsedType.symbol) {
        let n = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.symbol,
            received: n.parsedType,
          }),
          D.INVALID
        );
      }
      return (0, D.OK)(t.data);
    }
  };
  N.ZodSymbol = Py;
  Py.create = (e) => new Py({ typeName: He.ZodSymbol, ...Ze(e) });
  var Vm = class extends et {
    _parse(t) {
      if (this._getType(t) !== ae.ZodParsedType.undefined) {
        let n = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.undefined,
            received: n.parsedType,
          }),
          D.INVALID
        );
      }
      return (0, D.OK)(t.data);
    }
  };
  N.ZodUndefined = Vm;
  Vm.create = (e) => new Vm({ typeName: He.ZodUndefined, ...Ze(e) });
  var $m = class extends et {
    _parse(t) {
      if (this._getType(t) !== ae.ZodParsedType.null) {
        let n = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.null,
            received: n.parsedType,
          }),
          D.INVALID
        );
      }
      return (0, D.OK)(t.data);
    }
  };
  N.ZodNull = $m;
  $m.create = (e) => new $m({ typeName: He.ZodNull, ...Ze(e) });
  var lf = class extends et {
    constructor() {
      super(...arguments), (this._any = !0);
    }
    _parse(t) {
      return (0, D.OK)(t.data);
    }
  };
  N.ZodAny = lf;
  lf.create = (e) => new lf({ typeName: He.ZodAny, ...Ze(e) });
  var ol = class extends et {
    constructor() {
      super(...arguments), (this._unknown = !0);
    }
    _parse(t) {
      return (0, D.OK)(t.data);
    }
  };
  N.ZodUnknown = ol;
  ol.create = (e) => new ol({ typeName: He.ZodUnknown, ...Ze(e) });
  var Vs = class extends et {
    _parse(t) {
      let r = this._getOrReturnCtx(t);
      return (
        (0, D.addIssueToContext)(r, {
          code: ne.ZodIssueCode.invalid_type,
          expected: ae.ZodParsedType.never,
          received: r.parsedType,
        }),
        D.INVALID
      );
    }
  };
  N.ZodNever = Vs;
  Vs.create = (e) => new Vs({ typeName: He.ZodNever, ...Ze(e) });
  var Ry = class extends et {
    _parse(t) {
      if (this._getType(t) !== ae.ZodParsedType.undefined) {
        let n = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.void,
            received: n.parsedType,
          }),
          D.INVALID
        );
      }
      return (0, D.OK)(t.data);
    }
  };
  N.ZodVoid = Ry;
  Ry.create = (e) => new Ry({ typeName: He.ZodVoid, ...Ze(e) });
  var al = class e extends et {
    _parse(t) {
      let { ctx: r, status: n } = this._processInputParams(t),
        i = this._def;
      if (r.parsedType !== ae.ZodParsedType.array)
        return (
          (0, D.addIssueToContext)(r, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.array,
            received: r.parsedType,
          }),
          D.INVALID
        );
      if (i.exactLength !== null) {
        let a = r.data.length > i.exactLength.value,
          s = r.data.length < i.exactLength.value;
        (a || s) &&
          ((0, D.addIssueToContext)(r, {
            code: a ? ne.ZodIssueCode.too_big : ne.ZodIssueCode.too_small,
            minimum: s ? i.exactLength.value : void 0,
            maximum: a ? i.exactLength.value : void 0,
            type: "array",
            inclusive: !0,
            exact: !0,
            message: i.exactLength.message,
          }),
          n.dirty());
      }
      if (
        (i.minLength !== null &&
          r.data.length < i.minLength.value &&
          ((0, D.addIssueToContext)(r, {
            code: ne.ZodIssueCode.too_small,
            minimum: i.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.minLength.message,
          }),
          n.dirty()),
        i.maxLength !== null &&
          r.data.length > i.maxLength.value &&
          ((0, D.addIssueToContext)(r, {
            code: ne.ZodIssueCode.too_big,
            maximum: i.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.maxLength.message,
          }),
          n.dirty()),
        r.common.async)
      )
        return Promise.all(
          [...r.data].map((a, s) =>
            i.type._parseAsync(new qa(r, a, r.path, s)),
          ),
        ).then((a) => D.ParseStatus.mergeArray(n, a));
      let o = [...r.data].map((a, s) =>
        i.type._parseSync(new qa(r, a, r.path, s)),
      );
      return D.ParseStatus.mergeArray(n, o);
    }
    get element() {
      return this._def.type;
    }
    min(t, r) {
      return new e({
        ...this._def,
        minLength: { value: t, message: De.errorUtil.toString(r) },
      });
    }
    max(t, r) {
      return new e({
        ...this._def,
        maxLength: { value: t, message: De.errorUtil.toString(r) },
      });
    }
    length(t, r) {
      return new e({
        ...this._def,
        exactLength: { value: t, message: De.errorUtil.toString(r) },
      });
    }
    nonempty(t) {
      return this.min(1, t);
    }
  };
  N.ZodArray = al;
  al.create = (e, t) =>
    new al({
      type: e,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: He.ZodArray,
      ...Ze(t),
    });
  function Ay(e) {
    if (e instanceof To) {
      let t = {};
      for (let r in e.shape) {
        let n = e.shape[r];
        t[r] = Ma.create(Ay(n));
      }
      return new To({ ...e._def, shape: () => t });
    } else
      return e instanceof al
        ? new al({ ...e._def, type: Ay(e.element) })
        : e instanceof Ma
          ? Ma.create(Ay(e.unwrap()))
          : e instanceof Fc
            ? Fc.create(Ay(e.unwrap()))
            : e instanceof jc
              ? jc.create(e.items.map((t) => Ay(t)))
              : e;
  }
  var To = class e extends et {
    constructor() {
      super(...arguments),
        (this._cached = null),
        (this.nonstrict = this.passthrough),
        (this.augment = this.extend);
    }
    _getCached() {
      if (this._cached !== null) return this._cached;
      let t = this._def.shape(),
        r = ae.util.objectKeys(t);
      return (this._cached = { shape: t, keys: r });
    }
    _parse(t) {
      if (this._getType(t) !== ae.ZodParsedType.object) {
        let l = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(l, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.object,
            received: l.parsedType,
          }),
          D.INVALID
        );
      }
      let { status: n, ctx: i } = this._processInputParams(t),
        { shape: o, keys: a } = this._getCached(),
        s = [];
      if (
        !(this._def.catchall instanceof Vs && this._def.unknownKeys === "strip")
      )
        for (let l in i.data) a.includes(l) || s.push(l);
      let u = [];
      for (let l of a) {
        let d = o[l],
          f = i.data[l];
        u.push({
          key: { status: "valid", value: l },
          value: d._parse(new qa(i, f, i.path, l)),
          alwaysSet: l in i.data,
        });
      }
      if (this._def.catchall instanceof Vs) {
        let l = this._def.unknownKeys;
        if (l === "passthrough")
          for (let d of s)
            u.push({
              key: { status: "valid", value: d },
              value: { status: "valid", value: i.data[d] },
            });
        else if (l === "strict")
          s.length > 0 &&
            ((0, D.addIssueToContext)(i, {
              code: ne.ZodIssueCode.unrecognized_keys,
              keys: s,
            }),
            n.dirty());
        else if (l !== "strip")
          throw new Error(
            "Internal ZodObject error: invalid unknownKeys value.",
          );
      } else {
        let l = this._def.catchall;
        for (let d of s) {
          let f = i.data[d];
          u.push({
            key: { status: "valid", value: d },
            value: l._parse(new qa(i, f, i.path, d)),
            alwaysSet: d in i.data,
          });
        }
      }
      return i.common.async
        ? Promise.resolve()
            .then(async () => {
              let l = [];
              for (let d of u) {
                let f = await d.key,
                  m = await d.value;
                l.push({ key: f, value: m, alwaysSet: d.alwaysSet });
              }
              return l;
            })
            .then((l) => D.ParseStatus.mergeObjectSync(n, l))
        : D.ParseStatus.mergeObjectSync(n, u);
    }
    get shape() {
      return this._def.shape();
    }
    strict(t) {
      return (
        De.errorUtil.errToObj,
        new e({
          ...this._def,
          unknownKeys: "strict",
          ...(t !== void 0
            ? {
                errorMap: (r, n) => {
                  var i, o, a, s;
                  let u =
                    (a =
                      (o = (i = this._def).errorMap) === null || o === void 0
                        ? void 0
                        : o.call(i, r, n).message) !== null && a !== void 0
                      ? a
                      : n.defaultError;
                  return r.code === "unrecognized_keys"
                    ? {
                        message:
                          (s = De.errorUtil.errToObj(t).message) !== null &&
                          s !== void 0
                            ? s
                            : u,
                      }
                    : { message: u };
                },
              }
            : {}),
        })
      );
    }
    strip() {
      return new e({ ...this._def, unknownKeys: "strip" });
    }
    passthrough() {
      return new e({ ...this._def, unknownKeys: "passthrough" });
    }
    extend(t) {
      return new e({
        ...this._def,
        shape: () => ({ ...this._def.shape(), ...t }),
      });
    }
    merge(t) {
      return new e({
        unknownKeys: t._def.unknownKeys,
        catchall: t._def.catchall,
        shape: () => ({ ...this._def.shape(), ...t._def.shape() }),
        typeName: He.ZodObject,
      });
    }
    setKey(t, r) {
      return this.augment({ [t]: r });
    }
    catchall(t) {
      return new e({ ...this._def, catchall: t });
    }
    pick(t) {
      let r = {};
      return (
        ae.util.objectKeys(t).forEach((n) => {
          t[n] && this.shape[n] && (r[n] = this.shape[n]);
        }),
        new e({ ...this._def, shape: () => r })
      );
    }
    omit(t) {
      let r = {};
      return (
        ae.util.objectKeys(this.shape).forEach((n) => {
          t[n] || (r[n] = this.shape[n]);
        }),
        new e({ ...this._def, shape: () => r })
      );
    }
    deepPartial() {
      return Ay(this);
    }
    partial(t) {
      let r = {};
      return (
        ae.util.objectKeys(this.shape).forEach((n) => {
          let i = this.shape[n];
          t && !t[n] ? (r[n] = i) : (r[n] = i.optional());
        }),
        new e({ ...this._def, shape: () => r })
      );
    }
    required(t) {
      let r = {};
      return (
        ae.util.objectKeys(this.shape).forEach((n) => {
          if (t && !t[n]) r[n] = this.shape[n];
          else {
            let o = this.shape[n];
            for (; o instanceof Ma; ) o = o._def.innerType;
            r[n] = o;
          }
        }),
        new e({ ...this._def, shape: () => r })
      );
    }
    keyof() {
      return _ve(ae.util.objectKeys(this.shape));
    }
  };
  N.ZodObject = To;
  To.create = (e, t) =>
    new To({
      shape: () => e,
      unknownKeys: "strip",
      catchall: Vs.create(),
      typeName: He.ZodObject,
      ...Ze(t),
    });
  To.strictCreate = (e, t) =>
    new To({
      shape: () => e,
      unknownKeys: "strict",
      catchall: Vs.create(),
      typeName: He.ZodObject,
      ...Ze(t),
    });
  To.lazycreate = (e, t) =>
    new To({
      shape: e,
      unknownKeys: "strip",
      catchall: Vs.create(),
      typeName: He.ZodObject,
      ...Ze(t),
    });
  var zm = class extends et {
    _parse(t) {
      let { ctx: r } = this._processInputParams(t),
        n = this._def.options;
      function i(o) {
        for (let s of o) if (s.result.status === "valid") return s.result;
        for (let s of o)
          if (s.result.status === "dirty")
            return r.common.issues.push(...s.ctx.common.issues), s.result;
        let a = o.map((s) => new ne.ZodError(s.ctx.common.issues));
        return (
          (0, D.addIssueToContext)(r, {
            code: ne.ZodIssueCode.invalid_union,
            unionErrors: a,
          }),
          D.INVALID
        );
      }
      if (r.common.async)
        return Promise.all(
          n.map(async (o) => {
            let a = { ...r, common: { ...r.common, issues: [] }, parent: null };
            return {
              result: await o._parseAsync({
                data: r.data,
                path: r.path,
                parent: a,
              }),
              ctx: a,
            };
          }),
        ).then(i);
      {
        let o,
          a = [];
        for (let u of n) {
          let l = { ...r, common: { ...r.common, issues: [] }, parent: null },
            d = u._parseSync({ data: r.data, path: r.path, parent: l });
          if (d.status === "valid") return d;
          d.status === "dirty" && !o && (o = { result: d, ctx: l }),
            l.common.issues.length && a.push(l.common.issues);
        }
        if (o) return r.common.issues.push(...o.ctx.common.issues), o.result;
        let s = a.map((u) => new ne.ZodError(u));
        return (
          (0, D.addIssueToContext)(r, {
            code: ne.ZodIssueCode.invalid_union,
            unionErrors: s,
          }),
          D.INVALID
        );
      }
    }
    get options() {
      return this._def.options;
    }
  };
  N.ZodUnion = zm;
  zm.create = (e, t) => new zm({ options: e, typeName: He.ZodUnion, ...Ze(t) });
  var il = (e) =>
      e instanceof Wm
        ? il(e.schema)
        : e instanceof la
          ? il(e.innerType())
          : e instanceof Qm
            ? [e.value]
            : e instanceof Ym
              ? e.options
              : e instanceof Xm
                ? ae.util.objectValues(e.enum)
                : e instanceof Jm
                  ? il(e._def.innerType)
                  : e instanceof Vm
                    ? [void 0]
                    : e instanceof $m
                      ? [null]
                      : e instanceof Ma
                        ? [void 0, ...il(e.unwrap())]
                        : e instanceof Fc
                          ? [null, ...il(e.unwrap())]
                          : e instanceof fC || e instanceof eh
                            ? il(e.unwrap())
                            : e instanceof Zm
                              ? il(e._def.innerType)
                              : [],
    Lk = class e extends et {
      _parse(t) {
        let { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== ae.ZodParsedType.object)
          return (
            (0, D.addIssueToContext)(r, {
              code: ne.ZodIssueCode.invalid_type,
              expected: ae.ZodParsedType.object,
              received: r.parsedType,
            }),
            D.INVALID
          );
        let n = this.discriminator,
          i = r.data[n],
          o = this.optionsMap.get(i);
        return o
          ? r.common.async
            ? o._parseAsync({ data: r.data, path: r.path, parent: r })
            : o._parseSync({ data: r.data, path: r.path, parent: r })
          : ((0, D.addIssueToContext)(r, {
              code: ne.ZodIssueCode.invalid_union_discriminator,
              options: Array.from(this.optionsMap.keys()),
              path: [n],
            }),
            D.INVALID);
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      static create(t, r, n) {
        let i = new Map();
        for (let o of r) {
          let a = il(o.shape[t]);
          if (!a.length)
            throw new Error(
              `A discriminator value for key \`${t}\` could not be extracted from all schema options`,
            );
          for (let s of a) {
            if (i.has(s))
              throw new Error(
                `Discriminator property ${String(t)} has duplicate value ${String(s)}`,
              );
            i.set(s, o);
          }
        }
        return new e({
          typeName: He.ZodDiscriminatedUnion,
          discriminator: t,
          options: r,
          optionsMap: i,
          ...Ze(n),
        });
      }
    };
  N.ZodDiscriminatedUnion = Lk;
  function KK(e, t) {
    let r = (0, ae.getParsedType)(e),
      n = (0, ae.getParsedType)(t);
    if (e === t) return { valid: !0, data: e };
    if (r === ae.ZodParsedType.object && n === ae.ZodParsedType.object) {
      let i = ae.util.objectKeys(t),
        o = ae.util.objectKeys(e).filter((s) => i.indexOf(s) !== -1),
        a = { ...e, ...t };
      for (let s of o) {
        let u = KK(e[s], t[s]);
        if (!u.valid) return { valid: !1 };
        a[s] = u.data;
      }
      return { valid: !0, data: a };
    } else if (r === ae.ZodParsedType.array && n === ae.ZodParsedType.array) {
      if (e.length !== t.length) return { valid: !1 };
      let i = [];
      for (let o = 0; o < e.length; o++) {
        let a = e[o],
          s = t[o],
          u = KK(a, s);
        if (!u.valid) return { valid: !1 };
        i.push(u.data);
      }
      return { valid: !0, data: i };
    } else
      return r === ae.ZodParsedType.date &&
        n === ae.ZodParsedType.date &&
        +e == +t
        ? { valid: !0, data: e }
        : { valid: !1 };
  }
  var Km = class extends et {
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t),
        i = (o, a) => {
          if ((0, D.isAborted)(o) || (0, D.isAborted)(a)) return D.INVALID;
          let s = KK(o.value, a.value);
          return s.valid
            ? (((0, D.isDirty)(o) || (0, D.isDirty)(a)) && r.dirty(),
              { status: r.value, value: s.data })
            : ((0, D.addIssueToContext)(n, {
                code: ne.ZodIssueCode.invalid_intersection_types,
              }),
              D.INVALID);
        };
      return n.common.async
        ? Promise.all([
            this._def.left._parseAsync({
              data: n.data,
              path: n.path,
              parent: n,
            }),
            this._def.right._parseAsync({
              data: n.data,
              path: n.path,
              parent: n,
            }),
          ]).then(([o, a]) => i(o, a))
        : i(
            this._def.left._parseSync({
              data: n.data,
              path: n.path,
              parent: n,
            }),
            this._def.right._parseSync({
              data: n.data,
              path: n.path,
              parent: n,
            }),
          );
    }
  };
  N.ZodIntersection = Km;
  Km.create = (e, t, r) =>
    new Km({ left: e, right: t, typeName: He.ZodIntersection, ...Ze(r) });
  var jc = class e extends et {
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t);
      if (n.parsedType !== ae.ZodParsedType.array)
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.array,
            received: n.parsedType,
          }),
          D.INVALID
        );
      if (n.data.length < this._def.items.length)
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array",
          }),
          D.INVALID
        );
      !this._def.rest &&
        n.data.length > this._def.items.length &&
        ((0, D.addIssueToContext)(n, {
          code: ne.ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        r.dirty());
      let o = [...n.data]
        .map((a, s) => {
          let u = this._def.items[s] || this._def.rest;
          return u ? u._parse(new qa(n, a, n.path, s)) : null;
        })
        .filter((a) => !!a);
      return n.common.async
        ? Promise.all(o).then((a) => D.ParseStatus.mergeArray(r, a))
        : D.ParseStatus.mergeArray(r, o);
    }
    get items() {
      return this._def.items;
    }
    rest(t) {
      return new e({ ...this._def, rest: t });
    }
  };
  N.ZodTuple = jc;
  jc.create = (e, t) => {
    if (!Array.isArray(e))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new jc({ items: e, typeName: He.ZodTuple, rest: null, ...Ze(t) });
  };
  var Mk = class e extends et {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t);
      if (n.parsedType !== ae.ZodParsedType.object)
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.object,
            received: n.parsedType,
          }),
          D.INVALID
        );
      let i = [],
        o = this._def.keyType,
        a = this._def.valueType;
      for (let s in n.data)
        i.push({
          key: o._parse(new qa(n, s, n.path, s)),
          value: a._parse(new qa(n, n.data[s], n.path, s)),
          alwaysSet: s in n.data,
        });
      return n.common.async
        ? D.ParseStatus.mergeObjectAsync(r, i)
        : D.ParseStatus.mergeObjectSync(r, i);
    }
    get element() {
      return this._def.valueType;
    }
    static create(t, r, n) {
      return r instanceof et
        ? new e({ keyType: t, valueType: r, typeName: He.ZodRecord, ...Ze(n) })
        : new e({
            keyType: uf.create(),
            valueType: t,
            typeName: He.ZodRecord,
            ...Ze(r),
          });
    }
  };
  N.ZodRecord = Mk;
  var Iy = class extends et {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t);
      if (n.parsedType !== ae.ZodParsedType.map)
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.map,
            received: n.parsedType,
          }),
          D.INVALID
        );
      let i = this._def.keyType,
        o = this._def.valueType,
        a = [...n.data.entries()].map(([s, u], l) => ({
          key: i._parse(new qa(n, s, n.path, [l, "key"])),
          value: o._parse(new qa(n, u, n.path, [l, "value"])),
        }));
      if (n.common.async) {
        let s = new Map();
        return Promise.resolve().then(async () => {
          for (let u of a) {
            let l = await u.key,
              d = await u.value;
            if (l.status === "aborted" || d.status === "aborted")
              return D.INVALID;
            (l.status === "dirty" || d.status === "dirty") && r.dirty(),
              s.set(l.value, d.value);
          }
          return { status: r.value, value: s };
        });
      } else {
        let s = new Map();
        for (let u of a) {
          let l = u.key,
            d = u.value;
          if (l.status === "aborted" || d.status === "aborted")
            return D.INVALID;
          (l.status === "dirty" || d.status === "dirty") && r.dirty(),
            s.set(l.value, d.value);
        }
        return { status: r.value, value: s };
      }
    }
  };
  N.ZodMap = Iy;
  Iy.create = (e, t, r) =>
    new Iy({ valueType: t, keyType: e, typeName: He.ZodMap, ...Ze(r) });
  var xy = class e extends et {
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t);
      if (n.parsedType !== ae.ZodParsedType.set)
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.set,
            received: n.parsedType,
          }),
          D.INVALID
        );
      let i = this._def;
      i.minSize !== null &&
        n.data.size < i.minSize.value &&
        ((0, D.addIssueToContext)(n, {
          code: ne.ZodIssueCode.too_small,
          minimum: i.minSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: i.minSize.message,
        }),
        r.dirty()),
        i.maxSize !== null &&
          n.data.size > i.maxSize.value &&
          ((0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.too_big,
            maximum: i.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.maxSize.message,
          }),
          r.dirty());
      let o = this._def.valueType;
      function a(u) {
        let l = new Set();
        for (let d of u) {
          if (d.status === "aborted") return D.INVALID;
          d.status === "dirty" && r.dirty(), l.add(d.value);
        }
        return { status: r.value, value: l };
      }
      let s = [...n.data.values()].map((u, l) =>
        o._parse(new qa(n, u, n.path, l)),
      );
      return n.common.async ? Promise.all(s).then((u) => a(u)) : a(s);
    }
    min(t, r) {
      return new e({
        ...this._def,
        minSize: { value: t, message: De.errorUtil.toString(r) },
      });
    }
    max(t, r) {
      return new e({
        ...this._def,
        maxSize: { value: t, message: De.errorUtil.toString(r) },
      });
    }
    size(t, r) {
      return this.min(t, r).max(t, r);
    }
    nonempty(t) {
      return this.min(1, t);
    }
  };
  N.ZodSet = xy;
  xy.create = (e, t) =>
    new xy({
      valueType: e,
      minSize: null,
      maxSize: null,
      typeName: He.ZodSet,
      ...Ze(t),
    });
  var qk = class e extends et {
    constructor() {
      super(...arguments), (this.validate = this.implement);
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      if (r.parsedType !== ae.ZodParsedType.function)
        return (
          (0, D.addIssueToContext)(r, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.function,
            received: r.parsedType,
          }),
          D.INVALID
        );
      function n(s, u) {
        return (0, D.makeIssue)({
          data: s,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            (0, kk.getErrorMap)(),
            kk.defaultErrorMap,
          ].filter((l) => !!l),
          issueData: {
            code: ne.ZodIssueCode.invalid_arguments,
            argumentsError: u,
          },
        });
      }
      function i(s, u) {
        return (0, D.makeIssue)({
          data: s,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            (0, kk.getErrorMap)(),
            kk.defaultErrorMap,
          ].filter((l) => !!l),
          issueData: {
            code: ne.ZodIssueCode.invalid_return_type,
            returnTypeError: u,
          },
        });
      }
      let o = { errorMap: r.common.contextualErrorMap },
        a = r.data;
      if (this._def.returns instanceof df) {
        let s = this;
        return (0, D.OK)(async function (...u) {
          let l = new ne.ZodError([]),
            d = await s._def.args.parseAsync(u, o).catch((h) => {
              throw (l.addIssue(n(u, h)), l);
            }),
            f = await Reflect.apply(a, this, d);
          return await s._def.returns._def.type.parseAsync(f, o).catch((h) => {
            throw (l.addIssue(i(f, h)), l);
          });
        });
      } else {
        let s = this;
        return (0, D.OK)(function (...u) {
          let l = s._def.args.safeParse(u, o);
          if (!l.success) throw new ne.ZodError([n(u, l.error)]);
          let d = Reflect.apply(a, this, l.data),
            f = s._def.returns.safeParse(d, o);
          if (!f.success) throw new ne.ZodError([i(d, f.error)]);
          return f.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...t) {
      return new e({ ...this._def, args: jc.create(t).rest(ol.create()) });
    }
    returns(t) {
      return new e({ ...this._def, returns: t });
    }
    implement(t) {
      return this.parse(t);
    }
    strictImplement(t) {
      return this.parse(t);
    }
    static create(t, r, n) {
      return new e({
        args: t || jc.create([]).rest(ol.create()),
        returns: r || ol.create(),
        typeName: He.ZodFunction,
        ...Ze(n),
      });
    }
  };
  N.ZodFunction = qk;
  var Wm = class extends et {
    get schema() {
      return this._def.getter();
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      return this._def
        .getter()
        ._parse({ data: r.data, path: r.path, parent: r });
    }
  };
  N.ZodLazy = Wm;
  Wm.create = (e, t) => new Wm({ getter: e, typeName: He.ZodLazy, ...Ze(t) });
  var Qm = class extends et {
    _parse(t) {
      if (t.data !== this._def.value) {
        let r = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(r, {
            received: r.data,
            code: ne.ZodIssueCode.invalid_literal,
            expected: this._def.value,
          }),
          D.INVALID
        );
      }
      return { status: "valid", value: t.data };
    }
    get value() {
      return this._def.value;
    }
  };
  N.ZodLiteral = Qm;
  Qm.create = (e, t) => new Qm({ value: e, typeName: He.ZodLiteral, ...Ze(t) });
  function _ve(e, t) {
    return new Ym({ values: e, typeName: He.ZodEnum, ...Ze(t) });
  }
  var Ym = class e extends et {
    constructor() {
      super(...arguments), lC.set(this, void 0);
    }
    _parse(t) {
      if (typeof t.data != "string") {
        let r = this._getOrReturnCtx(t),
          n = this._def.values;
        return (
          (0, D.addIssueToContext)(r, {
            expected: ae.util.joinValues(n),
            received: r.parsedType,
            code: ne.ZodIssueCode.invalid_type,
          }),
          D.INVALID
        );
      }
      if (
        (Dk(this, lC, "f") || hve(this, lC, new Set(this._def.values), "f"),
        !Dk(this, lC, "f").has(t.data))
      ) {
        let r = this._getOrReturnCtx(t),
          n = this._def.values;
        return (
          (0, D.addIssueToContext)(r, {
            received: r.data,
            code: ne.ZodIssueCode.invalid_enum_value,
            options: n,
          }),
          D.INVALID
        );
      }
      return (0, D.OK)(t.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      let t = {};
      for (let r of this._def.values) t[r] = r;
      return t;
    }
    get Values() {
      let t = {};
      for (let r of this._def.values) t[r] = r;
      return t;
    }
    get Enum() {
      let t = {};
      for (let r of this._def.values) t[r] = r;
      return t;
    }
    extract(t, r = this._def) {
      return e.create(t, { ...this._def, ...r });
    }
    exclude(t, r = this._def) {
      return e.create(
        this.options.filter((n) => !t.includes(n)),
        { ...this._def, ...r },
      );
    }
  };
  N.ZodEnum = Ym;
  lC = new WeakMap();
  Ym.create = _ve;
  var Xm = class extends et {
    constructor() {
      super(...arguments), dC.set(this, void 0);
    }
    _parse(t) {
      let r = ae.util.getValidEnumValues(this._def.values),
        n = this._getOrReturnCtx(t);
      if (
        n.parsedType !== ae.ZodParsedType.string &&
        n.parsedType !== ae.ZodParsedType.number
      ) {
        let i = ae.util.objectValues(r);
        return (
          (0, D.addIssueToContext)(n, {
            expected: ae.util.joinValues(i),
            received: n.parsedType,
            code: ne.ZodIssueCode.invalid_type,
          }),
          D.INVALID
        );
      }
      if (
        (Dk(this, dC, "f") ||
          hve(
            this,
            dC,
            new Set(ae.util.getValidEnumValues(this._def.values)),
            "f",
          ),
        !Dk(this, dC, "f").has(t.data))
      ) {
        let i = ae.util.objectValues(r);
        return (
          (0, D.addIssueToContext)(n, {
            received: n.data,
            code: ne.ZodIssueCode.invalid_enum_value,
            options: i,
          }),
          D.INVALID
        );
      }
      return (0, D.OK)(t.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  N.ZodNativeEnum = Xm;
  dC = new WeakMap();
  Xm.create = (e, t) =>
    new Xm({ values: e, typeName: He.ZodNativeEnum, ...Ze(t) });
  var df = class extends et {
    unwrap() {
      return this._def.type;
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      if (r.parsedType !== ae.ZodParsedType.promise && r.common.async === !1)
        return (
          (0, D.addIssueToContext)(r, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.promise,
            received: r.parsedType,
          }),
          D.INVALID
        );
      let n =
        r.parsedType === ae.ZodParsedType.promise
          ? r.data
          : Promise.resolve(r.data);
      return (0, D.OK)(
        n.then((i) =>
          this._def.type.parseAsync(i, {
            path: r.path,
            errorMap: r.common.contextualErrorMap,
          }),
        ),
      );
    }
  };
  N.ZodPromise = df;
  df.create = (e, t) => new df({ type: e, typeName: He.ZodPromise, ...Ze(t) });
  var la = class extends et {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === He.ZodEffects
        ? this._def.schema.sourceType()
        : this._def.schema;
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t),
        i = this._def.effect || null,
        o = {
          addIssue: (a) => {
            (0, D.addIssueToContext)(n, a), a.fatal ? r.abort() : r.dirty();
          },
          get path() {
            return n.path;
          },
        };
      if (((o.addIssue = o.addIssue.bind(o)), i.type === "preprocess")) {
        let a = i.transform(n.data, o);
        if (n.common.async)
          return Promise.resolve(a).then(async (s) => {
            if (r.value === "aborted") return D.INVALID;
            let u = await this._def.schema._parseAsync({
              data: s,
              path: n.path,
              parent: n,
            });
            return u.status === "aborted"
              ? D.INVALID
              : u.status === "dirty" || r.value === "dirty"
                ? (0, D.DIRTY)(u.value)
                : u;
          });
        {
          if (r.value === "aborted") return D.INVALID;
          let s = this._def.schema._parseSync({
            data: a,
            path: n.path,
            parent: n,
          });
          return s.status === "aborted"
            ? D.INVALID
            : s.status === "dirty" || r.value === "dirty"
              ? (0, D.DIRTY)(s.value)
              : s;
        }
      }
      if (i.type === "refinement") {
        let a = (s) => {
          let u = i.refinement(s, o);
          if (n.common.async) return Promise.resolve(u);
          if (u instanceof Promise)
            throw new Error(
              "Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
            );
          return s;
        };
        if (n.common.async === !1) {
          let s = this._def.schema._parseSync({
            data: n.data,
            path: n.path,
            parent: n,
          });
          return s.status === "aborted"
            ? D.INVALID
            : (s.status === "dirty" && r.dirty(),
              a(s.value),
              { status: r.value, value: s.value });
        } else
          return this._def.schema
            ._parseAsync({ data: n.data, path: n.path, parent: n })
            .then((s) =>
              s.status === "aborted"
                ? D.INVALID
                : (s.status === "dirty" && r.dirty(),
                  a(s.value).then(() => ({ status: r.value, value: s.value }))),
            );
      }
      if (i.type === "transform")
        if (n.common.async === !1) {
          let a = this._def.schema._parseSync({
            data: n.data,
            path: n.path,
            parent: n,
          });
          if (!(0, D.isValid)(a)) return a;
          let s = i.transform(a.value, o);
          if (s instanceof Promise)
            throw new Error(
              "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.",
            );
          return { status: r.value, value: s };
        } else
          return this._def.schema
            ._parseAsync({ data: n.data, path: n.path, parent: n })
            .then((a) =>
              (0, D.isValid)(a)
                ? Promise.resolve(i.transform(a.value, o)).then((s) => ({
                    status: r.value,
                    value: s,
                  }))
                : a,
            );
      ae.util.assertNever(i);
    }
  };
  N.ZodEffects = la;
  N.ZodTransformer = la;
  la.create = (e, t, r) =>
    new la({ schema: e, typeName: He.ZodEffects, effect: t, ...Ze(r) });
  la.createWithPreprocess = (e, t, r) =>
    new la({
      schema: t,
      effect: { type: "preprocess", transform: e },
      typeName: He.ZodEffects,
      ...Ze(r),
    });
  var Ma = class extends et {
    _parse(t) {
      return this._getType(t) === ae.ZodParsedType.undefined
        ? (0, D.OK)(void 0)
        : this._def.innerType._parse(t);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  N.ZodOptional = Ma;
  Ma.create = (e, t) =>
    new Ma({ innerType: e, typeName: He.ZodOptional, ...Ze(t) });
  var Fc = class extends et {
    _parse(t) {
      return this._getType(t) === ae.ZodParsedType.null
        ? (0, D.OK)(null)
        : this._def.innerType._parse(t);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  N.ZodNullable = Fc;
  Fc.create = (e, t) =>
    new Fc({ innerType: e, typeName: He.ZodNullable, ...Ze(t) });
  var Jm = class extends et {
    _parse(t) {
      let { ctx: r } = this._processInputParams(t),
        n = r.data;
      return (
        r.parsedType === ae.ZodParsedType.undefined &&
          (n = this._def.defaultValue()),
        this._def.innerType._parse({ data: n, path: r.path, parent: r })
      );
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  N.ZodDefault = Jm;
  Jm.create = (e, t) =>
    new Jm({
      innerType: e,
      typeName: He.ZodDefault,
      defaultValue:
        typeof t.default == "function" ? t.default : () => t.default,
      ...Ze(t),
    });
  var Zm = class extends et {
    _parse(t) {
      let { ctx: r } = this._processInputParams(t),
        n = { ...r, common: { ...r.common, issues: [] } },
        i = this._def.innerType._parse({
          data: n.data,
          path: n.path,
          parent: { ...n },
        });
      return (0, D.isAsync)(i)
        ? i.then((o) => ({
            status: "valid",
            value:
              o.status === "valid"
                ? o.value
                : this._def.catchValue({
                    get error() {
                      return new ne.ZodError(n.common.issues);
                    },
                    input: n.data,
                  }),
          }))
        : {
            status: "valid",
            value:
              i.status === "valid"
                ? i.value
                : this._def.catchValue({
                    get error() {
                      return new ne.ZodError(n.common.issues);
                    },
                    input: n.data,
                  }),
          };
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  N.ZodCatch = Zm;
  Zm.create = (e, t) =>
    new Zm({
      innerType: e,
      typeName: He.ZodCatch,
      catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
      ...Ze(t),
    });
  var Ny = class extends et {
    _parse(t) {
      if (this._getType(t) !== ae.ZodParsedType.nan) {
        let n = this._getOrReturnCtx(t);
        return (
          (0, D.addIssueToContext)(n, {
            code: ne.ZodIssueCode.invalid_type,
            expected: ae.ZodParsedType.nan,
            received: n.parsedType,
          }),
          D.INVALID
        );
      }
      return { status: "valid", value: t.data };
    }
  };
  N.ZodNaN = Ny;
  Ny.create = (e) => new Ny({ typeName: He.ZodNaN, ...Ze(e) });
  N.BRAND = Symbol("zod_brand");
  var fC = class extends et {
    _parse(t) {
      let { ctx: r } = this._processInputParams(t),
        n = r.data;
      return this._def.type._parse({ data: n, path: r.path, parent: r });
    }
    unwrap() {
      return this._def.type;
    }
  };
  N.ZodBranded = fC;
  var pC = class e extends et {
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t);
      if (n.common.async)
        return (async () => {
          let o = await this._def.in._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          });
          return o.status === "aborted"
            ? D.INVALID
            : o.status === "dirty"
              ? (r.dirty(), (0, D.DIRTY)(o.value))
              : this._def.out._parseAsync({
                  data: o.value,
                  path: n.path,
                  parent: n,
                });
        })();
      {
        let i = this._def.in._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        return i.status === "aborted"
          ? D.INVALID
          : i.status === "dirty"
            ? (r.dirty(), { status: "dirty", value: i.value })
            : this._def.out._parseSync({
                data: i.value,
                path: n.path,
                parent: n,
              });
      }
    }
    static create(t, r) {
      return new e({ in: t, out: r, typeName: He.ZodPipeline });
    }
  };
  N.ZodPipeline = pC;
  var eh = class extends et {
    _parse(t) {
      let r = this._def.innerType._parse(t),
        n = (i) => ((0, D.isValid)(i) && (i.value = Object.freeze(i.value)), i);
      return (0, D.isAsync)(r) ? r.then((i) => n(i)) : n(r);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  N.ZodReadonly = eh;
  eh.create = (e, t) =>
    new eh({ innerType: e, typeName: He.ZodReadonly, ...Ze(t) });
  function mve(e, t) {
    let r =
      typeof e == "function" ? e(t) : typeof e == "string" ? { message: e } : e;
    return typeof r == "string" ? { message: r } : r;
  }
  function Eve(e, t = {}, r) {
    return e
      ? lf.create().superRefine((n, i) => {
          var o, a;
          let s = e(n);
          if (s instanceof Promise)
            return s.then((u) => {
              var l, d;
              if (!u) {
                let f = mve(t, n),
                  m =
                    (d = (l = f.fatal) !== null && l !== void 0 ? l : r) !==
                      null && d !== void 0
                      ? d
                      : !0;
                i.addIssue({ code: "custom", ...f, fatal: m });
              }
            });
          if (!s) {
            let u = mve(t, n),
              l =
                (a = (o = u.fatal) !== null && o !== void 0 ? o : r) !== null &&
                a !== void 0
                  ? a
                  : !0;
            i.addIssue({ code: "custom", ...u, fatal: l });
          }
        })
      : lf.create();
  }
  N.custom = Eve;
  N.late = { object: To.lazycreate };
  var He;
  (function (e) {
    (e.ZodString = "ZodString"),
      (e.ZodNumber = "ZodNumber"),
      (e.ZodNaN = "ZodNaN"),
      (e.ZodBigInt = "ZodBigInt"),
      (e.ZodBoolean = "ZodBoolean"),
      (e.ZodDate = "ZodDate"),
      (e.ZodSymbol = "ZodSymbol"),
      (e.ZodUndefined = "ZodUndefined"),
      (e.ZodNull = "ZodNull"),
      (e.ZodAny = "ZodAny"),
      (e.ZodUnknown = "ZodUnknown"),
      (e.ZodNever = "ZodNever"),
      (e.ZodVoid = "ZodVoid"),
      (e.ZodArray = "ZodArray"),
      (e.ZodObject = "ZodObject"),
      (e.ZodUnion = "ZodUnion"),
      (e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
      (e.ZodIntersection = "ZodIntersection"),
      (e.ZodTuple = "ZodTuple"),
      (e.ZodRecord = "ZodRecord"),
      (e.ZodMap = "ZodMap"),
      (e.ZodSet = "ZodSet"),
      (e.ZodFunction = "ZodFunction"),
      (e.ZodLazy = "ZodLazy"),
      (e.ZodLiteral = "ZodLiteral"),
      (e.ZodEnum = "ZodEnum"),
      (e.ZodEffects = "ZodEffects"),
      (e.ZodNativeEnum = "ZodNativeEnum"),
      (e.ZodOptional = "ZodOptional"),
      (e.ZodNullable = "ZodNullable"),
      (e.ZodDefault = "ZodDefault"),
      (e.ZodCatch = "ZodCatch"),
      (e.ZodPromise = "ZodPromise"),
      (e.ZodBranded = "ZodBranded"),
      (e.ZodPipeline = "ZodPipeline"),
      (e.ZodReadonly = "ZodReadonly");
  })(He || (N.ZodFirstPartyTypeKind = He = {}));
  var kLt = (e, t = { message: `Input not instance of ${e.name}` }) =>
    Eve((r) => r instanceof e, t);
  N.instanceof = kLt;
  var bve = uf.create;
  N.string = bve;
  var Sve = Bm.create;
  N.number = Sve;
  var DLt = Ny.create;
  N.nan = DLt;
  var LLt = Um.create;
  N.bigint = LLt;
  var Cve = Hm.create;
  N.boolean = Cve;
  var MLt = Gm.create;
  N.date = MLt;
  var qLt = Py.create;
  N.symbol = qLt;
  var jLt = Vm.create;
  N.undefined = jLt;
  var FLt = $m.create;
  N.null = FLt;
  var BLt = lf.create;
  N.any = BLt;
  var ULt = ol.create;
  N.unknown = ULt;
  var HLt = Vs.create;
  N.never = HLt;
  var GLt = Ry.create;
  N.void = GLt;
  var VLt = al.create;
  N.array = VLt;
  var $Lt = To.create;
  N.object = $Lt;
  var zLt = To.strictCreate;
  N.strictObject = zLt;
  var KLt = zm.create;
  N.union = KLt;
  var WLt = Lk.create;
  N.discriminatedUnion = WLt;
  var QLt = Km.create;
  N.intersection = QLt;
  var YLt = jc.create;
  N.tuple = YLt;
  var XLt = Mk.create;
  N.record = XLt;
  var JLt = Iy.create;
  N.map = JLt;
  var ZLt = xy.create;
  N.set = ZLt;
  var eMt = qk.create;
  N.function = eMt;
  var tMt = Wm.create;
  N.lazy = tMt;
  var rMt = Qm.create;
  N.literal = rMt;
  var nMt = Ym.create;
  N.enum = nMt;
  var iMt = Xm.create;
  N.nativeEnum = iMt;
  var oMt = df.create;
  N.promise = oMt;
  var wve = la.create;
  N.effect = wve;
  N.transformer = wve;
  var aMt = Ma.create;
  N.optional = aMt;
  var sMt = Fc.create;
  N.nullable = sMt;
  var cMt = la.createWithPreprocess;
  N.preprocess = cMt;
  var uMt = pC.create;
  N.pipeline = uMt;
  var lMt = () => bve().optional();
  N.ostring = lMt;
  var dMt = () => Sve().optional();
  N.onumber = dMt;
  var fMt = () => Cve().optional();
  N.oboolean = fMt;
  N.coerce = {
    string: (e) => uf.create({ ...e, coerce: !0 }),
    number: (e) => Bm.create({ ...e, coerce: !0 }),
    boolean: (e) => Hm.create({ ...e, coerce: !0 }),
    bigint: (e) => Um.create({ ...e, coerce: !0 }),
    date: (e) => Gm.create({ ...e, coerce: !0 }),
  };
  N.NEVER = D.INVALID;
});
var WK = g((ja) => {
  "use strict";
  c();
  var pMt =
      (ja && ja.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r);
            var i = Object.getOwnPropertyDescriptor(t, r);
            (!i ||
              ("get" in i ? !t.__esModule : i.writable || i.configurable)) &&
              (i = {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              }),
              Object.defineProperty(e, n, i);
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    ky =
      (ja && ja.__exportStar) ||
      function (e, t) {
        for (var r in e)
          r !== "default" &&
            !Object.prototype.hasOwnProperty.call(t, r) &&
            pMt(t, e, r);
      };
  Object.defineProperty(ja, "__esModule", { value: !0 });
  ky(xk(), ja);
  ky($K(), ja);
  ky(lve(), ja);
  ky(cC(), ja);
  ky(Ove(), ja);
  ky(Ik(), ja);
});
var QK = g((Ao) => {
  "use strict";
  c();
  var Tve =
      (Ao && Ao.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r);
            var i = Object.getOwnPropertyDescriptor(t, r);
            (!i ||
              ("get" in i ? !t.__esModule : i.writable || i.configurable)) &&
              (i = {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              }),
              Object.defineProperty(e, n, i);
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    mMt =
      (Ao && Ao.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: !0, value: t });
          }
        : function (e, t) {
            e.default = t;
          }),
    hMt =
      (Ao && Ao.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null)
          for (var r in e)
            r !== "default" &&
              Object.prototype.hasOwnProperty.call(e, r) &&
              Tve(t, e, r);
        return mMt(t, e), t;
      },
    gMt =
      (Ao && Ao.__exportStar) ||
      function (e, t) {
        for (var r in e)
          r !== "default" &&
            !Object.prototype.hasOwnProperty.call(t, r) &&
            Tve(t, e, r);
      };
  Object.defineProperty(Ao, "__esModule", { value: !0 });
  Ao.z = void 0;
  var Ave = hMt(WK());
  Ao.z = Ave;
  gMt(WK(), Ao);
  Ao.default = Ave;
});
var Ive = g((sl) => {
  "use strict";
  c();
  var XK =
    (sl && sl.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(sl, "__esModule", { value: !0 });
  sl.packageJsonSchema = sl.PackageJsonReader = void 0;
  var Pve = XK(G("fs")),
    vMt = XK(G("path")),
    Dy = XK(QK()),
    Rve = Oy(),
    YK = class {
      read = (t) => {
        if (!Pve.default.existsSync(t))
          throw new Rve.AmplifyUserError("InvalidPackageJsonError", {
            message: `Could not find a package.json file at ${t}`,
            resolution: `Ensure that ${t} exists and is a valid JSON file`,
          });
        let r;
        try {
          r = JSON.parse(Pve.default.readFileSync(t, "utf-8"));
        } catch (n) {
          throw new Rve.AmplifyUserError(
            "InvalidPackageJsonError",
            {
              message: `Could not parse the contents of ${t}`,
              resolution: `Ensure that ${t} exists and is a valid JSON file`,
            },
            n,
          );
        }
        return sl.packageJsonSchema.parse(r);
      };
      readFromCwd = () =>
        this.read(vMt.default.resolve(process.cwd(), "package.json"));
    };
  sl.PackageJsonReader = YK;
  sl.packageJsonSchema = Dy.default.object({
    name: Dy.default.string().optional(),
    version: Dy.default.string().optional(),
    type: Dy.default
      .union([Dy.default.literal("module"), Dy.default.literal("commonjs")])
      .optional(),
  });
});
var JK = g((Ly) => {
  "use strict";
  c();
  var xve =
    (Ly && Ly.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(Ly, "__esModule", { value: !0 });
  Ly.getConfigDirPath = void 0;
  var yMt = xve(G("os")),
    mC = xve(G("path")),
    _Mt = () => {
      let e = "amplify",
        t = yMt.default.homedir(),
        r = () => mC.default.join(t, "Library", "Preferences", e),
        n = () =>
          mC.default.join(
            process.env.APPDATA || mC.default.join(t, "AppData", "Roaming"),
            e,
            "Config",
          ),
        i = () =>
          mC.default.join(
            process.env.XDG_STATE_HOME || mC.default.join(t, ".local", "state"),
            e,
          );
      switch (process.platform) {
        case "darwin":
          return r();
        case "win32":
          return n();
        default:
          return i();
      }
    };
  Ly.getConfigDirPath = _Mt;
});
var kve = g((My) => {
  "use strict";
  c();
  var Nve =
    (My && My.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(My, "__esModule", { value: !0 });
  My.LocalConfigurationController = void 0;
  var EMt = Nve(G("path")),
    th = Nve(G("fs/promises")),
    bMt = JK(),
    ZK = class {
      configFileName;
      dirPath;
      configFilePath;
      _store;
      constructor(t = "config.json") {
        (this.configFileName = t),
          (this.dirPath = (0, bMt.getConfigDirPath)()),
          (this.configFilePath = EMt.default.join(
            this.dirPath,
            this.configFileName,
          ));
      }
      async get(t) {
        return t.split(".").reduce((r, n) => r?.[n], await this.store());
      }
      async set(t, r) {
        let n = await this.store();
        t.split(".").forEach((i, o, a) => {
          o === a.length - 1
            ? (n[i] = r)
            : (n[i] == null && (n[i] = {}), (n = n[i]));
        }),
          await this.write();
      }
      async write() {
        await this.mkConfigDir();
        let t = JSON.stringify(this._store ? this._store : {});
        await th.default.writeFile(this.configFilePath, t, "utf8");
      }
      async clear() {
        (this._store = {}), await th.default.rm(this.configFilePath);
      }
      async store() {
        if (this._store) return this._store;
        let t;
        try {
          t = await th.default.open(
            this.configFilePath,
            th.default.constants.F_OK,
            th.default.constants.O_RDWR,
          );
          let r = await th.default.readFile(t, "utf-8");
          this._store = JSON.parse(r);
        } catch {
          (this._store = {}), await this.write();
        } finally {
          await t?.close();
        }
        return this._store;
      }
      mkConfigDir() {
        return th.default.mkdir(this.dirPath, { recursive: !0 });
      }
    };
  My.LocalConfigurationController = ZK;
});
var e4 = g((qy) => {
  "use strict";
  c();
  Object.defineProperty(qy, "__esModule", { value: !0 });
  qy.configControllerFactory = qy.ConfigurationControllerFactory = void 0;
  var SMt = kve(),
    jk = class {
      controllers;
      constructor() {
        this.controllers = {};
      }
      getInstance = (t) =>
        this.controllers[t]
          ? this.controllers[t]
          : ((this.controllers[t] = new SMt.LocalConfigurationController(t)),
            this.controllers[t]);
    };
  qy.ConfigurationControllerFactory = jk;
  qy.configControllerFactory = new jk();
});
var Dve = g((Fk) => {
  "use strict";
  c();
  Object.defineProperty(Fk, "__esModule", { value: !0 });
  Fk.NoOpUsageDataEmitter = void 0;
  var t4 = class {
    emitSuccess() {
      return Promise.resolve();
    }
    emitFailure() {
      return Promise.resolve();
    }
  };
  Fk.NoOpUsageDataEmitter = t4;
});
var Lve = g((r4) => {
  "use strict";
  c();
  Object.defineProperty(r4, "__esModule", { value: !0 });
  r4.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
});
var Mve = g((n4) => {
  "use strict";
  c();
  Object.defineProperty(n4, "__esModule", { value: !0 });
  n4.default = "00000000-0000-0000-0000-000000000000";
});
var qve = g((i4) => {
  "use strict";
  c();
  Object.defineProperty(i4, "__esModule", { value: !0 });
  i4.default =
    /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
});
var hC = g((o4) => {
  "use strict";
  c();
  Object.defineProperty(o4, "__esModule", { value: !0 });
  var CMt = qve();
  function wMt(e) {
    return typeof e == "string" && CMt.default.test(e);
  }
  o4.default = wMt;
});
var gC = g((a4) => {
  "use strict";
  c();
  Object.defineProperty(a4, "__esModule", { value: !0 });
  var OMt = hC();
  function TMt(e) {
    if (!(0, OMt.default)(e)) throw TypeError("Invalid UUID");
    let t;
    return Uint8Array.of(
      (t = parseInt(e.slice(0, 8), 16)) >>> 24,
      (t >>> 16) & 255,
      (t >>> 8) & 255,
      t & 255,
      (t = parseInt(e.slice(9, 13), 16)) >>> 8,
      t & 255,
      (t = parseInt(e.slice(14, 18), 16)) >>> 8,
      t & 255,
      (t = parseInt(e.slice(19, 23), 16)) >>> 8,
      t & 255,
      ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255,
      (t / 4294967296) & 255,
      (t >>> 24) & 255,
      (t >>> 16) & 255,
      (t >>> 8) & 255,
      t & 255,
    );
  }
  a4.default = TMt;
});
var cl = g((vC) => {
  "use strict";
  c();
  Object.defineProperty(vC, "__esModule", { value: !0 });
  vC.unsafeStringify = void 0;
  var AMt = hC(),
    _i = [];
  for (let e = 0; e < 256; ++e) _i.push((e + 256).toString(16).slice(1));
  function jve(e, t = 0) {
    return (
      _i[e[t + 0]] +
      _i[e[t + 1]] +
      _i[e[t + 2]] +
      _i[e[t + 3]] +
      "-" +
      _i[e[t + 4]] +
      _i[e[t + 5]] +
      "-" +
      _i[e[t + 6]] +
      _i[e[t + 7]] +
      "-" +
      _i[e[t + 8]] +
      _i[e[t + 9]] +
      "-" +
      _i[e[t + 10]] +
      _i[e[t + 11]] +
      _i[e[t + 12]] +
      _i[e[t + 13]] +
      _i[e[t + 14]] +
      _i[e[t + 15]]
    ).toLowerCase();
  }
  vC.unsafeStringify = jve;
  function PMt(e, t = 0) {
    let r = jve(e, t);
    if (!(0, AMt.default)(r)) throw TypeError("Stringified UUID is invalid");
    return r;
  }
  vC.default = PMt;
});
var Hk = g((s4) => {
  "use strict";
  c();
  Object.defineProperty(s4, "__esModule", { value: !0 });
  var RMt = G("crypto"),
    Uk = new Uint8Array(256),
    Bk = Uk.length;
  function IMt() {
    return (
      Bk > Uk.length - 16 && ((0, RMt.randomFillSync)(Uk), (Bk = 0)),
      Uk.slice(Bk, (Bk += 16))
    );
  }
  s4.default = IMt;
});
var c4 = g((_C) => {
  "use strict";
  c();
  Object.defineProperty(_C, "__esModule", { value: !0 });
  _C.updateV1State = void 0;
  var Fve = Hk(),
    xMt = cl(),
    yC = {};
  function NMt(e, t, r) {
    let n,
      i = e?._v6 ?? !1;
    if (e) {
      let o = Object.keys(e);
      o.length === 1 && o[0] === "_v6" && (e = void 0);
    }
    if (e)
      n = Bve(
        e.random ?? e.rng?.() ?? (0, Fve.default)(),
        e.msecs,
        e.nsecs,
        e.clockseq,
        e.node,
        t,
        r,
      );
    else {
      let o = Date.now(),
        a = (0, Fve.default)();
      Uve(yC, o, a),
        (n = Bve(
          a,
          yC.msecs,
          yC.nsecs,
          i ? void 0 : yC.clockseq,
          i ? void 0 : yC.node,
          t,
          r,
        ));
    }
    return t ?? (0, xMt.unsafeStringify)(n);
  }
  function Uve(e, t, r) {
    return (
      (e.msecs ??= -1 / 0),
      (e.nsecs ??= 0),
      t === e.msecs
        ? (e.nsecs++, e.nsecs >= 1e4 && ((e.node = void 0), (e.nsecs = 0)))
        : t > e.msecs
          ? (e.nsecs = 0)
          : t < e.msecs && (e.node = void 0),
      e.node ||
        ((e.node = r.slice(10, 16)),
        (e.node[0] |= 1),
        (e.clockseq = ((r[8] << 8) | r[9]) & 16383)),
      (e.msecs = t),
      e
    );
  }
  _C.updateV1State = Uve;
  function Bve(e, t, r, n, i, o, a = 0) {
    if (e.length < 16) throw new Error("Random bytes length must be >= 16");
    if (!o) (o = new Uint8Array(16)), (a = 0);
    else if (a < 0 || a + 16 > o.length)
      throw new RangeError(
        `UUID byte range ${a}:${a + 15} is out of buffer bounds`,
      );
    (t ??= Date.now()),
      (r ??= 0),
      (n ??= ((e[8] << 8) | e[9]) & 16383),
      (i ??= e.slice(10, 16)),
      (t += 122192928e5);
    let s = ((t & 268435455) * 1e4 + r) % 4294967296;
    (o[a++] = (s >>> 24) & 255),
      (o[a++] = (s >>> 16) & 255),
      (o[a++] = (s >>> 8) & 255),
      (o[a++] = s & 255);
    let u = ((t / 4294967296) * 1e4) & 268435455;
    (o[a++] = (u >>> 8) & 255),
      (o[a++] = u & 255),
      (o[a++] = ((u >>> 24) & 15) | 16),
      (o[a++] = (u >>> 16) & 255),
      (o[a++] = (n >>> 8) | 128),
      (o[a++] = n & 255);
    for (let l = 0; l < 6; ++l) o[a++] = i[l];
    return o;
  }
  _C.default = NMt;
});
var l4 = g((u4) => {
  "use strict";
  c();
  Object.defineProperty(u4, "__esModule", { value: !0 });
  var kMt = gC(),
    DMt = cl();
  function LMt(e) {
    let t = typeof e == "string" ? (0, kMt.default)(e) : e,
      r = MMt(t);
    return typeof e == "string" ? (0, DMt.unsafeStringify)(r) : r;
  }
  u4.default = LMt;
  function MMt(e) {
    return Uint8Array.of(
      ((e[6] & 15) << 4) | ((e[7] >> 4) & 15),
      ((e[7] & 15) << 4) | ((e[4] & 240) >> 4),
      ((e[4] & 15) << 4) | ((e[5] & 240) >> 4),
      ((e[5] & 15) << 4) | ((e[0] & 240) >> 4),
      ((e[0] & 15) << 4) | ((e[1] & 240) >> 4),
      ((e[1] & 15) << 4) | ((e[2] & 240) >> 4),
      96 | (e[2] & 15),
      e[3],
      e[8],
      e[9],
      e[10],
      e[11],
      e[12],
      e[13],
      e[14],
      e[15],
    );
  }
});
var Hve = g((d4) => {
  "use strict";
  c();
  Object.defineProperty(d4, "__esModule", { value: !0 });
  var qMt = G("crypto");
  function jMt(e) {
    return (
      Array.isArray(e)
        ? (e = Buffer.from(e))
        : typeof e == "string" && (e = Buffer.from(e, "utf8")),
      (0, qMt.createHash)("md5").update(e).digest()
    );
  }
  d4.default = jMt;
});
var EC = g((ul) => {
  "use strict";
  c();
  Object.defineProperty(ul, "__esModule", { value: !0 });
  ul.URL = ul.DNS = ul.stringToBytes = void 0;
  var Gve = gC(),
    FMt = cl();
  function Vve(e) {
    e = unescape(encodeURIComponent(e));
    let t = new Uint8Array(e.length);
    for (let r = 0; r < e.length; ++r) t[r] = e.charCodeAt(r);
    return t;
  }
  ul.stringToBytes = Vve;
  ul.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  ul.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function BMt(e, t, r, n, i, o) {
    let a = typeof r == "string" ? Vve(r) : r,
      s = typeof n == "string" ? (0, Gve.default)(n) : n;
    if ((typeof n == "string" && (n = (0, Gve.default)(n)), n?.length !== 16))
      throw TypeError(
        "Namespace must be array-like (16 iterable integer values, 0-255)",
      );
    let u = new Uint8Array(16 + a.length);
    if (
      (u.set(s),
      u.set(a, s.length),
      (u = t(u)),
      (u[6] = (u[6] & 15) | e),
      (u[8] = (u[8] & 63) | 128),
      i)
    ) {
      o = o || 0;
      for (let l = 0; l < 16; ++l) i[o + l] = u[l];
      return i;
    }
    return (0, FMt.unsafeStringify)(u);
  }
  ul.default = BMt;
});
var zve = g((rh) => {
  "use strict";
  c();
  Object.defineProperty(rh, "__esModule", { value: !0 });
  rh.URL = rh.DNS = void 0;
  var UMt = Hve(),
    f4 = EC(),
    $ve = EC();
  Object.defineProperty(rh, "DNS", {
    enumerable: !0,
    get: function () {
      return $ve.DNS;
    },
  });
  Object.defineProperty(rh, "URL", {
    enumerable: !0,
    get: function () {
      return $ve.URL;
    },
  });
  function p4(e, t, r, n) {
    return (0, f4.default)(48, UMt.default, e, t, r, n);
  }
  p4.DNS = f4.DNS;
  p4.URL = f4.URL;
  rh.default = p4;
});
var Kve = g((m4) => {
  "use strict";
  c();
  Object.defineProperty(m4, "__esModule", { value: !0 });
  var HMt = G("crypto");
  m4.default = { randomUUID: HMt.randomUUID };
});
var Qve = g((h4) => {
  "use strict";
  c();
  Object.defineProperty(h4, "__esModule", { value: !0 });
  var Wve = Kve(),
    GMt = Hk(),
    VMt = cl();
  function $Mt(e, t, r) {
    if (Wve.default.randomUUID && !t && !e) return Wve.default.randomUUID();
    e = e || {};
    let n = e.random ?? e.rng?.() ?? (0, GMt.default)();
    if (n.length < 16) throw new Error("Random bytes length must be >= 16");
    if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), t)) {
      if (((r = r || 0), r < 0 || r + 16 > t.length))
        throw new RangeError(
          `UUID byte range ${r}:${r + 15} is out of buffer bounds`,
        );
      for (let i = 0; i < 16; ++i) t[r + i] = n[i];
      return t;
    }
    return (0, VMt.unsafeStringify)(n);
  }
  h4.default = $Mt;
});
var Yve = g((g4) => {
  "use strict";
  c();
  Object.defineProperty(g4, "__esModule", { value: !0 });
  var zMt = G("crypto");
  function KMt(e) {
    return (
      Array.isArray(e)
        ? (e = Buffer.from(e))
        : typeof e == "string" && (e = Buffer.from(e, "utf8")),
      (0, zMt.createHash)("sha1").update(e).digest()
    );
  }
  g4.default = KMt;
});
var Jve = g((nh) => {
  "use strict";
  c();
  Object.defineProperty(nh, "__esModule", { value: !0 });
  nh.URL = nh.DNS = void 0;
  var WMt = Yve(),
    v4 = EC(),
    Xve = EC();
  Object.defineProperty(nh, "DNS", {
    enumerable: !0,
    get: function () {
      return Xve.DNS;
    },
  });
  Object.defineProperty(nh, "URL", {
    enumerable: !0,
    get: function () {
      return Xve.URL;
    },
  });
  function y4(e, t, r, n) {
    return (0, v4.default)(80, WMt.default, e, t, r, n);
  }
  y4.DNS = v4.DNS;
  y4.URL = v4.URL;
  nh.default = y4;
});
var Zve = g((_4) => {
  "use strict";
  c();
  Object.defineProperty(_4, "__esModule", { value: !0 });
  var QMt = cl(),
    YMt = c4(),
    XMt = l4();
  function JMt(e, t, r) {
    (e ??= {}), (r ??= 0);
    let n = (0, YMt.default)({ ...e, _v6: !0 }, new Uint8Array(16));
    if (((n = (0, XMt.default)(n)), t)) {
      for (let i = 0; i < 16; i++) t[r + i] = n[i];
      return t;
    }
    return (0, QMt.unsafeStringify)(n);
  }
  _4.default = JMt;
});
var eye = g((E4) => {
  "use strict";
  c();
  Object.defineProperty(E4, "__esModule", { value: !0 });
  var ZMt = gC(),
    eqt = cl();
  function tqt(e) {
    let t = typeof e == "string" ? (0, ZMt.default)(e) : e,
      r = rqt(t);
    return typeof e == "string" ? (0, eqt.unsafeStringify)(r) : r;
  }
  E4.default = tqt;
  function rqt(e) {
    return Uint8Array.of(
      ((e[3] & 15) << 4) | ((e[4] >> 4) & 15),
      ((e[4] & 15) << 4) | ((e[5] & 240) >> 4),
      ((e[5] & 15) << 4) | (e[6] & 15),
      e[7],
      ((e[1] & 15) << 4) | ((e[2] & 240) >> 4),
      ((e[2] & 15) << 4) | ((e[3] & 240) >> 4),
      16 | ((e[0] & 240) >> 4),
      ((e[0] & 15) << 4) | ((e[1] & 240) >> 4),
      e[8],
      e[9],
      e[10],
      e[11],
      e[12],
      e[13],
      e[14],
      e[15],
    );
  }
});
var iye = g((bC) => {
  "use strict";
  c();
  Object.defineProperty(bC, "__esModule", { value: !0 });
  bC.updateV7State = void 0;
  var tye = Hk(),
    nqt = cl(),
    b4 = {};
  function iqt(e, t, r) {
    let n;
    if (e)
      n = rye(
        e.random ?? e.rng?.() ?? (0, tye.default)(),
        e.msecs,
        e.seq,
        t,
        r,
      );
    else {
      let i = Date.now(),
        o = (0, tye.default)();
      nye(b4, i, o), (n = rye(o, b4.msecs, b4.seq, t, r));
    }
    return t ?? (0, nqt.unsafeStringify)(n);
  }
  function nye(e, t, r) {
    return (
      (e.msecs ??= -1 / 0),
      (e.seq ??= 0),
      t > e.msecs
        ? ((e.seq = (r[6] << 23) | (r[7] << 16) | (r[8] << 8) | r[9]),
          (e.msecs = t))
        : ((e.seq = (e.seq + 1) | 0), e.seq === 0 && e.msecs++),
      e
    );
  }
  bC.updateV7State = nye;
  function rye(e, t, r, n, i = 0) {
    if (e.length < 16) throw new Error("Random bytes length must be >= 16");
    if (!n) (n = new Uint8Array(16)), (i = 0);
    else if (i < 0 || i + 16 > n.length)
      throw new RangeError(
        `UUID byte range ${i}:${i + 15} is out of buffer bounds`,
      );
    return (
      (t ??= Date.now()),
      (r ??= ((e[6] * 127) << 24) | (e[7] << 16) | (e[8] << 8) | e[9]),
      (n[i++] = (t / 1099511627776) & 255),
      (n[i++] = (t / 4294967296) & 255),
      (n[i++] = (t / 16777216) & 255),
      (n[i++] = (t / 65536) & 255),
      (n[i++] = (t / 256) & 255),
      (n[i++] = t & 255),
      (n[i++] = 112 | ((r >>> 28) & 15)),
      (n[i++] = (r >>> 20) & 255),
      (n[i++] = 128 | ((r >>> 14) & 63)),
      (n[i++] = (r >>> 6) & 255),
      (n[i++] = ((r << 2) & 255) | (e[10] & 3)),
      (n[i++] = e[11]),
      (n[i++] = e[12]),
      (n[i++] = e[13]),
      (n[i++] = e[14]),
      (n[i++] = e[15]),
      n
    );
  }
  bC.default = iqt;
});
var oye = g((S4) => {
  "use strict";
  c();
  Object.defineProperty(S4, "__esModule", { value: !0 });
  var oqt = hC();
  function aqt(e) {
    if (!(0, oqt.default)(e)) throw TypeError("Invalid UUID");
    return parseInt(e.slice(14, 15), 16);
  }
  S4.default = aqt;
});
var Gk = g((Yt) => {
  "use strict";
  c();
  Object.defineProperty(Yt, "__esModule", { value: !0 });
  Yt.version =
    Yt.validate =
    Yt.v7 =
    Yt.v6ToV1 =
    Yt.v6 =
    Yt.v5 =
    Yt.v4 =
    Yt.v3 =
    Yt.v1ToV6 =
    Yt.v1 =
    Yt.stringify =
    Yt.parse =
    Yt.NIL =
    Yt.MAX =
      void 0;
  var sqt = Lve();
  Object.defineProperty(Yt, "MAX", {
    enumerable: !0,
    get: function () {
      return sqt.default;
    },
  });
  var cqt = Mve();
  Object.defineProperty(Yt, "NIL", {
    enumerable: !0,
    get: function () {
      return cqt.default;
    },
  });
  var uqt = gC();
  Object.defineProperty(Yt, "parse", {
    enumerable: !0,
    get: function () {
      return uqt.default;
    },
  });
  var lqt = cl();
  Object.defineProperty(Yt, "stringify", {
    enumerable: !0,
    get: function () {
      return lqt.default;
    },
  });
  var dqt = c4();
  Object.defineProperty(Yt, "v1", {
    enumerable: !0,
    get: function () {
      return dqt.default;
    },
  });
  var fqt = l4();
  Object.defineProperty(Yt, "v1ToV6", {
    enumerable: !0,
    get: function () {
      return fqt.default;
    },
  });
  var pqt = zve();
  Object.defineProperty(Yt, "v3", {
    enumerable: !0,
    get: function () {
      return pqt.default;
    },
  });
  var mqt = Qve();
  Object.defineProperty(Yt, "v4", {
    enumerable: !0,
    get: function () {
      return mqt.default;
    },
  });
  var hqt = Jve();
  Object.defineProperty(Yt, "v5", {
    enumerable: !0,
    get: function () {
      return hqt.default;
    },
  });
  var gqt = Zve();
  Object.defineProperty(Yt, "v6", {
    enumerable: !0,
    get: function () {
      return gqt.default;
    },
  });
  var vqt = eye();
  Object.defineProperty(Yt, "v6ToV1", {
    enumerable: !0,
    get: function () {
      return vqt.default;
    },
  });
  var yqt = iye();
  Object.defineProperty(Yt, "v7", {
    enumerable: !0,
    get: function () {
      return yqt.default;
    },
  });
  var _qt = hC();
  Object.defineProperty(Yt, "validate", {
    enumerable: !0,
    get: function () {
      return _qt.default;
    },
  });
  var Eqt = oye();
  Object.defineProperty(Yt, "version", {
    enumerable: !0,
    get: function () {
      return Eqt.default;
    },
  });
});
var ll = g((S_n, mye) => {
  c();
  var Vk = Object.defineProperty,
    bqt = Object.getOwnPropertyDescriptor,
    Sqt = Object.getOwnPropertyNames,
    Cqt = Object.prototype.hasOwnProperty,
    $k = (e, t) => Vk(e, "name", { value: t, configurable: !0 }),
    wqt = (e, t) => {
      for (var r in t) Vk(e, r, { get: t[r], enumerable: !0 });
    },
    Oqt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Sqt(t))
          !Cqt.call(e, i) &&
            i !== r &&
            Vk(e, i, {
              get: () => t[i],
              enumerable: !(n = bqt(t, i)) || n.enumerable,
            });
      return e;
    },
    Tqt = (e) => Oqt(Vk({}, "__esModule", { value: !0 }), e),
    aye = {};
  wqt(aye, {
    AlgorithmId: () => lye,
    EndpointURLScheme: () => uye,
    FieldPosition: () => dye,
    HttpApiKeyAuthLocation: () => cye,
    HttpAuthLocation: () => sye,
    IniSectionType: () => fye,
    RequestHandlerProtocol: () => pye,
    SMITHY_CONTEXT_KEY: () => xqt,
    getDefaultClientConfiguration: () => Rqt,
    resolveDefaultRuntimeConfig: () => Iqt,
  });
  mye.exports = Tqt(aye);
  var sye = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(sye || {}),
    cye = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(cye || {}),
    uye = ((e) => ((e.HTTP = "http"), (e.HTTPS = "https"), e))(uye || {}),
    lye = ((e) => (
      (e.MD5 = "md5"),
      (e.CRC32 = "crc32"),
      (e.CRC32C = "crc32c"),
      (e.SHA1 = "sha1"),
      (e.SHA256 = "sha256"),
      e
    ))(lye || {}),
    Aqt = $k((e) => {
      let t = [];
      return (
        e.sha256 !== void 0 &&
          t.push({
            algorithmId: () => "sha256",
            checksumConstructor: () => e.sha256,
          }),
        e.md5 != null &&
          t.push({
            algorithmId: () => "md5",
            checksumConstructor: () => e.md5,
          }),
        {
          addChecksumAlgorithm(r) {
            t.push(r);
          },
          checksumAlgorithms() {
            return t;
          },
        }
      );
    }, "getChecksumConfiguration"),
    Pqt = $k((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    Rqt = $k((e) => Aqt(e), "getDefaultClientConfiguration"),
    Iqt = $k((e) => Pqt(e), "resolveDefaultRuntimeConfig"),
    dye = ((e) => (
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER"), e
    ))(dye || {}),
    xqt = "__smithy_context",
    fye = ((e) => (
      (e.PROFILE = "profile"),
      (e.SSO_SESSION = "sso-session"),
      (e.SERVICES = "services"),
      e
    ))(fye || {}),
    pye = ((e) => (
      (e.HTTP_0_9 = "http/0.9"),
      (e.HTTP_1_0 = "http/1.0"),
      (e.TDS_8_0 = "tds/8.0"),
      e
    ))(pye || {});
});
var Jr = g((w_n, _ye) => {
  c();
  var zk = Object.defineProperty,
    Nqt = Object.getOwnPropertyDescriptor,
    kqt = Object.getOwnPropertyNames,
    Dqt = Object.prototype.hasOwnProperty,
    ff = (e, t) => zk(e, "name", { value: t, configurable: !0 }),
    Lqt = (e, t) => {
      for (var r in t) zk(e, r, { get: t[r], enumerable: !0 });
    },
    Mqt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of kqt(t))
          !Dqt.call(e, i) &&
            i !== r &&
            zk(e, i, {
              get: () => t[i],
              enumerable: !(n = Nqt(t, i)) || n.enumerable,
            });
      return e;
    },
    qqt = (e) => Mqt(zk({}, "__esModule", { value: !0 }), e),
    hye = {};
  Lqt(hye, {
    Field: () => Bqt,
    Fields: () => Uqt,
    HttpRequest: () => Hqt,
    HttpResponse: () => Gqt,
    IHttpRequest: () => gye.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => jqt,
    isValidHostname: () => yye,
    resolveHttpHandlerRuntimeConfig: () => Fqt,
  });
  _ye.exports = qqt(hye);
  var jqt = ff(
      (e) => ({
        setHttpHandler(t) {
          e.httpHandler = t;
        },
        httpHandler() {
          return e.httpHandler;
        },
        updateHttpClientConfig(t, r) {
          e.httpHandler?.updateHttpClientConfig(t, r);
        },
        httpHandlerConfigs() {
          return e.httpHandler.httpHandlerConfigs();
        },
      }),
      "getHttpHandlerExtensionConfiguration",
    ),
    Fqt = ff(
      (e) => ({ httpHandler: e.httpHandler() }),
      "resolveHttpHandlerRuntimeConfig",
    ),
    gye = ll(),
    Bqt = class {
      static {
        ff(this, "Field");
      }
      constructor({
        name: e,
        kind: t = gye.FieldPosition.HEADER,
        values: r = [],
      }) {
        (this.name = e), (this.kind = t), (this.values = r);
      }
      add(e) {
        this.values.push(e);
      }
      set(e) {
        this.values = e;
      }
      remove(e) {
        this.values = this.values.filter((t) => t !== e);
      }
      toString() {
        return this.values
          .map((e) => (e.includes(",") || e.includes(" ") ? `"${e}"` : e))
          .join(", ");
      }
      get() {
        return this.values;
      }
    },
    Uqt = class {
      constructor({ fields: e = [], encoding: t = "utf-8" }) {
        (this.entries = {}),
          e.forEach(this.setField.bind(this)),
          (this.encoding = t);
      }
      static {
        ff(this, "Fields");
      }
      setField(e) {
        this.entries[e.name.toLowerCase()] = e;
      }
      getField(e) {
        return this.entries[e.toLowerCase()];
      }
      removeField(e) {
        delete this.entries[e.toLowerCase()];
      }
      getByType(e) {
        return Object.values(this.entries).filter((t) => t.kind === e);
      }
    },
    Hqt = class C4 {
      static {
        ff(this, "HttpRequest");
      }
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new C4({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = vye(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return C4.clone(this);
      }
    };
  function vye(e) {
    return Object.keys(e).reduce((t, r) => {
      let n = e[r];
      return { ...t, [r]: Array.isArray(n) ? [...n] : n };
    }, {});
  }
  ff(vye, "cloneQuery");
  var Gqt = class {
    static {
      ff(this, "HttpResponse");
    }
    constructor(e) {
      (this.statusCode = e.statusCode),
        (this.reason = e.reason),
        (this.headers = e.headers || {}),
        (this.body = e.body);
    }
    static isInstance(e) {
      if (!e) return !1;
      let t = e;
      return typeof t.statusCode == "number" && typeof t.headers == "object";
    }
  };
  function yye(e) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e);
  }
  ff(yye, "isValidHostname");
});
var SC = g((R_n, wye) => {
  "use strict";
  c();
  var Wk = Object.defineProperty,
    Vqt = Object.getOwnPropertyDescriptor,
    $qt = Object.getOwnPropertyNames,
    zqt = Object.prototype.hasOwnProperty,
    Kk = (e, t) => Wk(e, "name", { value: t, configurable: !0 }),
    Kqt = (e, t) => {
      for (var r in t) Wk(e, r, { get: t[r], enumerable: !0 });
    },
    Wqt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of $qt(t))
          !zqt.call(e, i) &&
            i !== r &&
            Wk(e, i, {
              get: () => t[i],
              enumerable: !(n = Vqt(t, i)) || n.enumerable,
            });
      return e;
    },
    Qqt = (e) => Wqt(Wk({}, "__esModule", { value: !0 }), e),
    Eye = {};
  Kqt(Eye, {
    getHostHeaderPlugin: () => Xqt,
    hostHeaderMiddleware: () => Sye,
    hostHeaderMiddlewareOptions: () => Cye,
    resolveHostHeaderConfig: () => bye,
  });
  wye.exports = Qqt(Eye);
  var Yqt = Jr();
  function bye(e) {
    return e;
  }
  Kk(bye, "resolveHostHeaderConfig");
  var Sye = Kk(
      (e) => (t) => async (r) => {
        if (!Yqt.HttpRequest.isInstance(r.request)) return t(r);
        let { request: n } = r,
          { handlerProtocol: i = "" } = e.requestHandler.metadata || {};
        if (i.indexOf("h2") >= 0 && !n.headers[":authority"])
          delete n.headers.host,
            (n.headers[":authority"] =
              n.hostname + (n.port ? ":" + n.port : ""));
        else if (!n.headers.host) {
          let o = n.hostname;
          n.port != null && (o += `:${n.port}`), (n.headers.host = o);
        }
        return t(r);
      },
      "hostHeaderMiddleware",
    ),
    Cye = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: !0,
    },
    Xqt = Kk(
      (e) => ({
        applyToStack: Kk((t) => {
          t.add(Sye(e), Cye);
        }, "applyToStack"),
      }),
      "getHostHeaderPlugin",
    );
});
var CC = g((x_n, Pye) => {
  "use strict";
  c();
  var Qk = Object.defineProperty,
    Jqt = Object.getOwnPropertyDescriptor,
    Zqt = Object.getOwnPropertyNames,
    ejt = Object.prototype.hasOwnProperty,
    w4 = (e, t) => Qk(e, "name", { value: t, configurable: !0 }),
    tjt = (e, t) => {
      for (var r in t) Qk(e, r, { get: t[r], enumerable: !0 });
    },
    rjt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Zqt(t))
          !ejt.call(e, i) &&
            i !== r &&
            Qk(e, i, {
              get: () => t[i],
              enumerable: !(n = Jqt(t, i)) || n.enumerable,
            });
      return e;
    },
    njt = (e) => rjt(Qk({}, "__esModule", { value: !0 }), e),
    Oye = {};
  tjt(Oye, {
    getLoggerPlugin: () => ijt,
    loggerMiddleware: () => Tye,
    loggerMiddlewareOptions: () => Aye,
  });
  Pye.exports = njt(Oye);
  var Tye = w4(
      () => (e, t) => async (r) => {
        try {
          let n = await e(r),
            {
              clientName: i,
              commandName: o,
              logger: a,
              dynamoDbDocumentClientOptions: s = {},
            } = t,
            {
              overrideInputFilterSensitiveLog: u,
              overrideOutputFilterSensitiveLog: l,
            } = s,
            d = u ?? t.inputFilterSensitiveLog,
            f = l ?? t.outputFilterSensitiveLog,
            { $metadata: m, ...h } = n.output;
          return (
            a?.info?.({
              clientName: i,
              commandName: o,
              input: d(r.input),
              output: f(h),
              metadata: m,
            }),
            n
          );
        } catch (n) {
          let {
              clientName: i,
              commandName: o,
              logger: a,
              dynamoDbDocumentClientOptions: s = {},
            } = t,
            { overrideInputFilterSensitiveLog: u } = s,
            l = u ?? t.inputFilterSensitiveLog;
          throw (
            (a?.error?.({
              clientName: i,
              commandName: o,
              input: l(r.input),
              error: n,
              metadata: n.$metadata,
            }),
            n)
          );
        }
      },
      "loggerMiddleware",
    ),
    Aye = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: !0,
    },
    ijt = w4(
      (e) => ({
        applyToStack: w4((t) => {
          t.add(Tye(), Aye);
        }, "applyToStack"),
      }),
      "getLoggerPlugin",
    );
});
var wC = g((k_n, Nye) => {
  "use strict";
  c();
  var Xk = Object.defineProperty,
    ojt = Object.getOwnPropertyDescriptor,
    ajt = Object.getOwnPropertyNames,
    sjt = Object.prototype.hasOwnProperty,
    Yk = (e, t) => Xk(e, "name", { value: t, configurable: !0 }),
    cjt = (e, t) => {
      for (var r in t) Xk(e, r, { get: t[r], enumerable: !0 });
    },
    ujt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of ajt(t))
          !sjt.call(e, i) &&
            i !== r &&
            Xk(e, i, {
              get: () => t[i],
              enumerable: !(n = ojt(t, i)) || n.enumerable,
            });
      return e;
    },
    ljt = (e) => ujt(Xk({}, "__esModule", { value: !0 }), e),
    Rye = {};
  cjt(Rye, {
    addRecursionDetectionMiddlewareOptions: () => xye,
    getRecursionDetectionPlugin: () => mjt,
    recursionDetectionMiddleware: () => Iye,
  });
  Nye.exports = ljt(Rye);
  var djt = Jr(),
    O4 = "X-Amzn-Trace-Id",
    fjt = "AWS_LAMBDA_FUNCTION_NAME",
    pjt = "_X_AMZN_TRACE_ID",
    Iye = Yk(
      (e) => (t) => async (r) => {
        let { request: n } = r;
        if (!djt.HttpRequest.isInstance(n) || e.runtime !== "node") return t(r);
        let i =
          Object.keys(n.headers ?? {}).find(
            (u) => u.toLowerCase() === O4.toLowerCase(),
          ) ?? O4;
        if (n.headers.hasOwnProperty(i)) return t(r);
        let o = process.env[fjt],
          a = process.env[pjt],
          s = Yk((u) => typeof u == "string" && u.length > 0, "nonEmptyString");
        return s(o) && s(a) && (n.headers[O4] = a), t({ ...r, request: n });
      },
      "recursionDetectionMiddleware",
    ),
    xye = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: !0,
      priority: "low",
    },
    mjt = Yk(
      (e) => ({
        applyToStack: Yk((t) => {
          t.add(Iye(e), xye);
        }, "applyToStack"),
      }),
      "getRecursionDetectionPlugin",
    );
});
var T4,
  hjt,
  kye = w(() => {
    c();
    (T4 = A(ll())),
      (hjt = (e) =>
        e[T4.SMITHY_CONTEXT_KEY] || (e[T4.SMITHY_CONTEXT_KEY] = {}));
  });
var $s = g((q_n, qye) => {
  c();
  var Jk = Object.defineProperty,
    gjt = Object.getOwnPropertyDescriptor,
    vjt = Object.getOwnPropertyNames,
    yjt = Object.prototype.hasOwnProperty,
    Lye = (e, t) => Jk(e, "name", { value: t, configurable: !0 }),
    _jt = (e, t) => {
      for (var r in t) Jk(e, r, { get: t[r], enumerable: !0 });
    },
    Ejt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of vjt(t))
          !yjt.call(e, i) &&
            i !== r &&
            Jk(e, i, {
              get: () => t[i],
              enumerable: !(n = gjt(t, i)) || n.enumerable,
            });
      return e;
    },
    bjt = (e) => Ejt(Jk({}, "__esModule", { value: !0 }), e),
    Mye = {};
  _jt(Mye, { getSmithyContext: () => Sjt, normalizeProvider: () => Cjt });
  qye.exports = bjt(Mye);
  var Dye = ll(),
    Sjt = Lye(
      (e) => e[Dye.SMITHY_CONTEXT_KEY] || (e[Dye.SMITHY_CONTEXT_KEY] = {}),
      "getSmithyContext",
    ),
    Cjt = Lye((e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    }, "normalizeProvider");
});
var jye,
  Fye = w(() => {
    c();
    jye = (e, t) => {
      if (!t || t.length === 0) return e;
      let r = [];
      for (let n of t)
        for (let i of e) i.schemeId.split("#")[1] === n && r.push(i);
      for (let n of e)
        r.find(({ schemeId: i }) => i === n.schemeId) || r.push(n);
      return r;
    };
  });
function wjt(e) {
  let t = new Map();
  for (let r of e) t.set(r.schemeId, r);
  return t;
}
var U_n,
  Bye,
  OC,
  Zk = w(() => {
    c();
    (U_n = A(ll())), (Bye = A($s()));
    Fye();
    OC = (e, t) => (r, n) => async (i) => {
      let o = e.httpAuthSchemeProvider(
          await t.httpAuthSchemeParametersProvider(e, n, i.input),
        ),
        a = e.authSchemePreference ? await e.authSchemePreference() : [],
        s = jye(o, a),
        u = wjt(e.httpAuthSchemes),
        l = (0, Bye.getSmithyContext)(n),
        d = [];
      for (let f of s) {
        let m = u.get(f.schemeId);
        if (!m) {
          d.push(
            `HttpAuthScheme \`${f.schemeId}\` was not enabled for this service.`,
          );
          continue;
        }
        let h = m.identityProvider(await t.identityProviderConfigProvider(e));
        if (!h) {
          d.push(
            `HttpAuthScheme \`${f.schemeId}\` did not have an IdentityProvider configured.`,
          );
          continue;
        }
        let { identityProperties: y = {}, signingProperties: _ = {} } =
          f.propertiesExtractor?.(e, n) || {};
        (f.identityProperties = Object.assign(f.identityProperties || {}, y)),
          (f.signingProperties = Object.assign(f.signingProperties || {}, _)),
          (l.selectedHttpAuthScheme = {
            httpAuthOption: f,
            identity: await h(f.identityProperties),
            signer: m.signer,
          });
        break;
      }
      if (!l.selectedHttpAuthScheme)
        throw new Error(
          d.join(`
`),
        );
      return r(i);
    };
  });
var Uye,
  TC,
  Hye = w(() => {
    c();
    Zk();
    (Uye = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: "endpointV2Middleware",
    }),
      (TC = (
        e,
        {
          httpAuthSchemeParametersProvider: t,
          identityProviderConfigProvider: r,
        },
      ) => ({
        applyToStack: (n) => {
          n.addRelativeTo(
            OC(e, {
              httpAuthSchemeParametersProvider: t,
              identityProviderConfigProvider: r,
            }),
            Uye,
          );
        },
      }));
  });
var pf = g((Q_n, Qye) => {
  c();
  var eD = Object.defineProperty,
    Ojt = Object.getOwnPropertyDescriptor,
    Tjt = Object.getOwnPropertyNames,
    Ajt = Object.prototype.hasOwnProperty,
    A4 = (e, t) => eD(e, "name", { value: t, configurable: !0 }),
    Pjt = (e, t) => {
      for (var r in t) eD(e, r, { get: t[r], enumerable: !0 });
    },
    Rjt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Tjt(t))
          !Ajt.call(e, i) &&
            i !== r &&
            eD(e, i, {
              get: () => t[i],
              enumerable: !(n = Ojt(t, i)) || n.enumerable,
            });
      return e;
    },
    Ijt = (e) => Rjt(eD({}, "__esModule", { value: !0 }), e),
    Gye = {};
  Pjt(Gye, {
    deserializerMiddleware: () => Vye,
    deserializerMiddlewareOption: () => zye,
    getSerdePlugin: () => Wye,
    serializerMiddleware: () => $ye,
    serializerMiddlewareOption: () => Kye,
  });
  Qye.exports = Ijt(Gye);
  var Vye = A4(
      (e, t) => (r, n) => async (i) => {
        let { response: o } = await r(i);
        try {
          let a = await t(o, e);
          return { response: o, output: a };
        } catch (a) {
          if (
            (Object.defineProperty(a, "$response", { value: o }),
            !("$metadata" in a))
          ) {
            let s =
              "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
            try {
              a.message +=
                `
  ` + s;
            } catch {
              !n.logger || n.logger?.constructor?.name === "NoOpLogger"
                ? console.warn(s)
                : n.logger?.warn?.(s);
            }
            typeof a.$responseBodyText < "u" &&
              a.$response &&
              (a.$response.body = a.$responseBodyText);
          }
          throw a;
        }
      },
      "deserializerMiddleware",
    ),
    $ye = A4(
      (e, t) => (r, n) => async (i) => {
        let o =
          n.endpointV2?.url && e.urlParser
            ? async () => e.urlParser(n.endpointV2.url)
            : e.endpoint;
        if (!o) throw new Error("No valid endpoint provider available.");
        let a = await t(i.input, { ...e, endpoint: o });
        return r({ ...i, request: a });
      },
      "serializerMiddleware",
    ),
    zye = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: !0,
    },
    Kye = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: !0,
    };
  function Wye(e, t, r) {
    return {
      applyToStack: (n) => {
        n.add(Vye(e, r), zye), n.add($ye(e, t), Kye);
      },
    };
  }
  A4(Wye, "getSerdePlugin");
});
var Yye,
  Xye,
  xjt,
  Jye = w(() => {
    c();
    Yye = A(pf());
    Zk();
    (Xye = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: Yye.serializerMiddlewareOption.name,
    }),
      (xjt = (
        e,
        {
          httpAuthSchemeParametersProvider: t,
          identityProviderConfigProvider: r,
        },
      ) => ({
        applyToStack: (n) => {
          n.addRelativeTo(
            OC(e, {
              httpAuthSchemeParametersProvider: t,
              identityProviderConfigProvider: r,
            }),
            Xye,
          );
        },
      }));
  });
var Zye = w(() => {
  c();
  Zk();
  Hye();
  Jye();
});
var e_e,
  oEn,
  t_e,
  Njt,
  kjt,
  P4,
  R4 = w(() => {
    c();
    (e_e = A(Jr())),
      (oEn = A(ll())),
      (t_e = A($s())),
      (Njt = (e) => (t) => {
        throw t;
      }),
      (kjt = (e, t) => {}),
      (P4 = (e) => (t, r) => async (n) => {
        if (!e_e.HttpRequest.isInstance(n.request)) return t(n);
        let o = (0, t_e.getSmithyContext)(r).selectedHttpAuthScheme;
        if (!o)
          throw new Error(
            "No HttpAuthScheme was selected: unable to sign request",
          );
        let {
            httpAuthOption: { signingProperties: a = {} },
            identity: s,
            signer: u,
          } = o,
          l = await t({ ...n, request: await u.sign(n.request, s, a) }).catch(
            (u.errorHandler || Njt)(a),
          );
        return (u.successHandler || kjt)(l.response, a), l;
      });
  });
var r_e,
  AC,
  n_e = w(() => {
    c();
    R4();
    (r_e = {
      step: "finalizeRequest",
      tags: ["HTTP_SIGNING"],
      name: "httpSigningMiddleware",
      aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
      override: !0,
      relation: "after",
      toMiddleware: "retryMiddleware",
    }),
      (AC = (e) => ({
        applyToStack: (t) => {
          t.addRelativeTo(P4(e), r_e);
        },
      }));
  });
var i_e = w(() => {
  c();
  R4();
  n_e();
});
var mf,
  o_e = w(() => {
    c();
    mf = (e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    };
  });
function a_e(e, t, r, n, i) {
  return async function* (a, s, ...u) {
    let l = s,
      d = a.startingToken ?? l[r],
      f = !0,
      m;
    for (; f; ) {
      if (((l[r] = d), i && (l[i] = l[i] ?? a.pageSize), a.client instanceof e))
        m = await Djt(t, a.client, s, a.withCommand, ...u);
      else throw new Error(`Invalid client, expected instance of ${e.name}`);
      yield m;
      let h = d;
      (d = Ljt(m, n)), (f = !!(d && (!a.stopOnSameToken || d !== h)));
    }
    return void 0;
  };
}
var Djt,
  Ljt,
  s_e = w(() => {
    c();
    Djt = async (e, t, r, n = (o) => o, ...i) => {
      let o = new e(r);
      return (o = n(o) ?? o), await t.send(o, ...i);
    };
    Ljt = (e, t) => {
      let r = e,
        n = t.split(".");
      for (let i of n) {
        if (!r || typeof r != "object") return;
        r = r[i];
      }
      return r;
    };
  });
var hf = g((EEn, u_e) => {
  c();
  var tD = Object.defineProperty,
    Mjt = Object.getOwnPropertyDescriptor,
    qjt = Object.getOwnPropertyNames,
    jjt = Object.prototype.hasOwnProperty,
    Fjt = (e, t) => tD(e, "name", { value: t, configurable: !0 }),
    Bjt = (e, t) => {
      for (var r in t) tD(e, r, { get: t[r], enumerable: !0 });
    },
    Ujt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of qjt(t))
          !jjt.call(e, i) &&
            i !== r &&
            tD(e, i, {
              get: () => t[i],
              enumerable: !(n = Mjt(t, i)) || n.enumerable,
            });
      return e;
    },
    Hjt = (e) => Ujt(tD({}, "__esModule", { value: !0 }), e),
    c_e = {};
  Bjt(c_e, { isArrayBuffer: () => Gjt });
  u_e.exports = Hjt(c_e);
  var Gjt = Fjt(
    (e) =>
      (typeof ArrayBuffer == "function" && e instanceof ArrayBuffer) ||
      Object.prototype.toString.call(e) === "[object ArrayBuffer]",
    "isArrayBuffer",
  );
});
var Hi = g((SEn, f_e) => {
  c();
  var rD = Object.defineProperty,
    Vjt = Object.getOwnPropertyDescriptor,
    $jt = Object.getOwnPropertyNames,
    zjt = Object.prototype.hasOwnProperty,
    l_e = (e, t) => rD(e, "name", { value: t, configurable: !0 }),
    Kjt = (e, t) => {
      for (var r in t) rD(e, r, { get: t[r], enumerable: !0 });
    },
    Wjt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of $jt(t))
          !zjt.call(e, i) &&
            i !== r &&
            rD(e, i, {
              get: () => t[i],
              enumerable: !(n = Vjt(t, i)) || n.enumerable,
            });
      return e;
    },
    Qjt = (e) => Wjt(rD({}, "__esModule", { value: !0 }), e),
    d_e = {};
  Kjt(d_e, { fromArrayBuffer: () => Xjt, fromString: () => Jjt });
  f_e.exports = Qjt(d_e);
  var Yjt = hf(),
    I4 = G("buffer"),
    Xjt = l_e((e, t = 0, r = e.byteLength - t) => {
      if (!(0, Yjt.isArrayBuffer)(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`,
        );
      return I4.Buffer.from(e, t, r);
    }, "fromArrayBuffer"),
    Jjt = l_e((e, t) => {
      if (typeof e != "string")
        throw new TypeError(
          `The "input" argument must be of type string. Received type ${typeof e} (${e})`,
        );
      return t ? I4.Buffer.from(e, t) : I4.Buffer.from(e);
    }, "fromString");
});
var p_e = g((nD) => {
  "use strict";
  c();
  Object.defineProperty(nD, "__esModule", { value: !0 });
  nD.fromBase64 = void 0;
  var Zjt = Hi(),
    eFt = /^[A-Za-z0-9+/]*={0,2}$/,
    tFt = (e) => {
      if ((e.length * 3) % 4 !== 0)
        throw new TypeError("Incorrect padding on base64 string.");
      if (!eFt.exec(e)) throw new TypeError("Invalid base64 string.");
      let t = (0, Zjt.fromString)(e, "base64");
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    };
  nD.fromBase64 = tFt;
});
var Fe = g((TEn, v_e) => {
  c();
  var iD = Object.defineProperty,
    rFt = Object.getOwnPropertyDescriptor,
    nFt = Object.getOwnPropertyNames,
    iFt = Object.prototype.hasOwnProperty,
    x4 = (e, t) => iD(e, "name", { value: t, configurable: !0 }),
    oFt = (e, t) => {
      for (var r in t) iD(e, r, { get: t[r], enumerable: !0 });
    },
    aFt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of nFt(t))
          !iFt.call(e, i) &&
            i !== r &&
            iD(e, i, {
              get: () => t[i],
              enumerable: !(n = rFt(t, i)) || n.enumerable,
            });
      return e;
    },
    sFt = (e) => aFt(iD({}, "__esModule", { value: !0 }), e),
    m_e = {};
  oFt(m_e, { fromUtf8: () => g_e, toUint8Array: () => cFt, toUtf8: () => uFt });
  v_e.exports = sFt(m_e);
  var h_e = Hi(),
    g_e = x4((e) => {
      let t = (0, h_e.fromString)(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT,
      );
    }, "fromUtf8"),
    cFt = x4(
      (e) =>
        typeof e == "string"
          ? g_e(e)
          : ArrayBuffer.isView(e)
            ? new Uint8Array(
                e.buffer,
                e.byteOffset,
                e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
              )
            : new Uint8Array(e),
      "toUint8Array",
    ),
    uFt = x4((e) => {
      if (typeof e == "string") return e;
      if (
        typeof e != "object" ||
        typeof e.byteOffset != "number" ||
        typeof e.byteLength != "number"
      )
        throw new Error(
          "@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.",
        );
      return (0, h_e.fromArrayBuffer)(
        e.buffer,
        e.byteOffset,
        e.byteLength,
      ).toString("utf8");
    }, "toUtf8");
});
var y_e = g((oD) => {
  "use strict";
  c();
  Object.defineProperty(oD, "__esModule", { value: !0 });
  oD.toBase64 = void 0;
  var lFt = Hi(),
    dFt = Fe(),
    fFt = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = (0, dFt.fromUtf8)(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.",
        );
      return (0, lFt.fromArrayBuffer)(
        t.buffer,
        t.byteOffset,
        t.byteLength,
      ).toString("base64");
    };
  oD.toBase64 = fFt;
});
var Bc = g((IEn, aD) => {
  c();
  var __e = Object.defineProperty,
    pFt = Object.getOwnPropertyDescriptor,
    mFt = Object.getOwnPropertyNames,
    hFt = Object.prototype.hasOwnProperty,
    N4 = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of mFt(t))
          !hFt.call(e, i) &&
            i !== r &&
            __e(e, i, {
              get: () => t[i],
              enumerable: !(n = pFt(t, i)) || n.enumerable,
            });
      return e;
    },
    E_e = (e, t, r) => (N4(e, t, "default"), r && N4(r, t, "default")),
    gFt = (e) => N4(__e({}, "__esModule", { value: !0 }), e),
    k4 = {};
  aD.exports = gFt(k4);
  E_e(k4, p_e(), aD.exports);
  E_e(k4, y_e(), aD.exports);
});
var L4 = g((sD) => {
  "use strict";
  c();
  Object.defineProperty(sD, "__esModule", { value: !0 });
  sD.ChecksumStream = void 0;
  var vFt = Bc(),
    yFt = G("stream"),
    D4 = class extends yFt.Duplex {
      constructor({
        expectedChecksum: t,
        checksum: r,
        source: n,
        checksumSourceLocation: i,
        base64Encoder: o,
      }) {
        var a, s;
        if ((super(), typeof n.pipe == "function")) this.source = n;
        else
          throw new Error(
            `@smithy/util-stream: unsupported source type ${(s = (a = n?.constructor) === null || a === void 0 ? void 0 : a.name) !== null && s !== void 0 ? s : n} in ChecksumStream.`,
          );
        (this.base64Encoder = o ?? vFt.toBase64),
          (this.expectedChecksum = t),
          (this.checksum = r),
          (this.checksumSourceLocation = i),
          this.source.pipe(this);
      }
      _read(t) {}
      _write(t, r, n) {
        try {
          this.checksum.update(t), this.push(t);
        } catch (i) {
          return n(i);
        }
        return n();
      }
      async _final(t) {
        try {
          let r = await this.checksum.digest(),
            n = this.base64Encoder(r);
          if (this.expectedChecksum !== n)
            return t(
              new Error(
                `Checksum mismatch: expected "${this.expectedChecksum}" but received "${n}" in response header "${this.checksumSourceLocation}".`,
              ),
            );
        } catch (r) {
          return t(r);
        }
        return this.push(null), t();
      }
    };
  sD.ChecksumStream = D4;
});
var gf = g((jy) => {
  "use strict";
  c();
  Object.defineProperty(jy, "__esModule", { value: !0 });
  jy.isBlob = jy.isReadableStream = void 0;
  var _Ft = (e) => {
    var t;
    return (
      typeof ReadableStream == "function" &&
      (((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) ===
        ReadableStream.name ||
        e instanceof ReadableStream)
    );
  };
  jy.isReadableStream = _Ft;
  var EFt = (e) => {
    var t;
    return (
      typeof Blob == "function" &&
      (((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) ===
        Blob.name ||
        e instanceof Blob)
    );
  };
  jy.isBlob = EFt;
});
var b_e = g((cD) => {
  "use strict";
  c();
  Object.defineProperty(cD, "__esModule", { value: !0 });
  cD.ChecksumStream = void 0;
  var bFt =
      typeof ReadableStream == "function" ? ReadableStream : function () {},
    M4 = class extends bFt {};
  cD.ChecksumStream = M4;
});
var S_e = g((uD) => {
  "use strict";
  c();
  Object.defineProperty(uD, "__esModule", { value: !0 });
  uD.createChecksumStream = void 0;
  var SFt = Bc(),
    CFt = gf(),
    wFt = b_e(),
    OFt = ({
      expectedChecksum: e,
      checksum: t,
      source: r,
      checksumSourceLocation: n,
      base64Encoder: i,
    }) => {
      var o, a;
      if (!(0, CFt.isReadableStream)(r))
        throw new Error(
          `@smithy/util-stream: unsupported source type ${(a = (o = r?.constructor) === null || o === void 0 ? void 0 : o.name) !== null && a !== void 0 ? a : r} in ChecksumStream.`,
        );
      let s = i ?? SFt.toBase64;
      if (typeof TransformStream != "function")
        throw new Error(
          "@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.",
        );
      let u = new TransformStream({
        start() {},
        async transform(d, f) {
          t.update(d), f.enqueue(d);
        },
        async flush(d) {
          let f = await t.digest(),
            m = s(f);
          if (e !== m) {
            let h = new Error(
              `Checksum mismatch: expected "${e}" but received "${m}" in response header "${n}".`,
            );
            d.error(h);
          } else d.terminate();
        },
      });
      r.pipeThrough(u);
      let l = u.readable;
      return Object.setPrototypeOf(l, wFt.ChecksumStream.prototype), l;
    };
  uD.createChecksumStream = OFt;
});
var C_e = g((lD) => {
  "use strict";
  c();
  Object.defineProperty(lD, "__esModule", { value: !0 });
  lD.createChecksumStream = void 0;
  var TFt = gf(),
    AFt = L4(),
    PFt = S_e();
  function RFt(e) {
    return typeof ReadableStream == "function" &&
      (0, TFt.isReadableStream)(e.source)
      ? (0, PFt.createChecksumStream)(e)
      : new AFt.ChecksumStream(e);
  }
  lD.createChecksumStream = RFt;
});
var j4 = g((dD) => {
  "use strict";
  c();
  Object.defineProperty(dD, "__esModule", { value: !0 });
  dD.ByteArrayCollector = void 0;
  var q4 = class {
    constructor(t) {
      (this.allocByteArray = t), (this.byteLength = 0), (this.byteArrays = []);
    }
    push(t) {
      this.byteArrays.push(t), (this.byteLength += t.byteLength);
    }
    flush() {
      if (this.byteArrays.length === 1) {
        let n = this.byteArrays[0];
        return this.reset(), n;
      }
      let t = this.allocByteArray(this.byteLength),
        r = 0;
      for (let n = 0; n < this.byteArrays.length; ++n) {
        let i = this.byteArrays[n];
        t.set(i, r), (r += i.byteLength);
      }
      return this.reset(), t;
    }
    reset() {
      (this.byteArrays = []), (this.byteLength = 0);
    }
  };
  dD.ByteArrayCollector = q4;
});
var A_e = g((Po) => {
  "use strict";
  c();
  Object.defineProperty(Po, "__esModule", { value: !0 });
  Po.modeOf =
    Po.sizeOf =
    Po.flush =
    Po.merge =
    Po.createBufferedReadable =
    Po.createBufferedReadableStream =
      void 0;
  var IFt = j4();
  function w_e(e, t, r) {
    let n = e.getReader(),
      i = !1,
      o = 0,
      a = ["", new IFt.ByteArrayCollector((l) => new Uint8Array(l))],
      s = -1,
      u = async (l) => {
        let { value: d, done: f } = await n.read(),
          m = d;
        if (f) {
          if (s !== -1) {
            let h = fD(a, s);
            Fy(h) > 0 && l.enqueue(h);
          }
          l.close();
        } else {
          let h = T_e(m, !1);
          if ((s !== h && (s >= 0 && l.enqueue(fD(a, s)), (s = h)), s === -1)) {
            l.enqueue(m);
            return;
          }
          let y = Fy(m);
          o += y;
          let _ = Fy(a[s]);
          if (y >= t && _ === 0) l.enqueue(m);
          else {
            let E = O_e(a, s, m);
            !i &&
              o > t * 2 &&
              ((i = !0),
              r?.warn(
                `@smithy/util-stream - stream chunk size ${y} is below threshold of ${t}, automatically buffering.`,
              )),
              E >= t ? l.enqueue(fD(a, s)) : await u(l);
          }
        }
      };
    return new ReadableStream({ pull: u });
  }
  Po.createBufferedReadableStream = w_e;
  Po.createBufferedReadable = w_e;
  function O_e(e, t, r) {
    switch (t) {
      case 0:
        return (e[0] += r), Fy(e[0]);
      case 1:
      case 2:
        return e[t].push(r), Fy(e[t]);
    }
  }
  Po.merge = O_e;
  function fD(e, t) {
    switch (t) {
      case 0:
        let r = e[0];
        return (e[0] = ""), r;
      case 1:
      case 2:
        return e[t].flush();
    }
    throw new Error(
      `@smithy/util-stream - invalid index ${t} given to flush()`,
    );
  }
  Po.flush = fD;
  function Fy(e) {
    var t, r;
    return (r =
      (t = e?.byteLength) !== null && t !== void 0 ? t : e?.length) !== null &&
      r !== void 0
      ? r
      : 0;
  }
  Po.sizeOf = Fy;
  function T_e(e, t = !0) {
    return t && typeof Buffer < "u" && e instanceof Buffer
      ? 2
      : e instanceof Uint8Array
        ? 1
        : typeof e == "string"
          ? 0
          : -1;
  }
  Po.modeOf = T_e;
});
var R_e = g((pD) => {
  "use strict";
  c();
  Object.defineProperty(pD, "__esModule", { value: !0 });
  pD.createBufferedReadable = void 0;
  var xFt = G("node:stream"),
    P_e = j4(),
    dl = A_e(),
    NFt = gf();
  function kFt(e, t, r) {
    if ((0, NFt.isReadableStream)(e))
      return (0, dl.createBufferedReadableStream)(e, t, r);
    let n = new xFt.Readable({ read() {} }),
      i = !1,
      o = 0,
      a = [
        "",
        new P_e.ByteArrayCollector((u) => new Uint8Array(u)),
        new P_e.ByteArrayCollector((u) => Buffer.from(new Uint8Array(u))),
      ],
      s = -1;
    return (
      e.on("data", (u) => {
        let l = (0, dl.modeOf)(u, !0);
        if (
          (s !== l && (s >= 0 && n.push((0, dl.flush)(a, s)), (s = l)),
          s === -1)
        ) {
          n.push(u);
          return;
        }
        let d = (0, dl.sizeOf)(u);
        o += d;
        let f = (0, dl.sizeOf)(a[s]);
        if (d >= t && f === 0) n.push(u);
        else {
          let m = (0, dl.merge)(a, s, u);
          !i &&
            o > t * 2 &&
            ((i = !0),
            r?.warn(
              `@smithy/util-stream - stream chunk size ${d} is below threshold of ${t}, automatically buffering.`,
            )),
            m >= t && n.push((0, dl.flush)(a, s));
        }
      }),
      e.on("end", () => {
        if (s !== -1) {
          let u = (0, dl.flush)(a, s);
          (0, dl.sizeOf)(u) > 0 && n.push(u);
        }
        n.push(null);
      }),
      n
    );
  }
  pD.createBufferedReadable = kFt;
});
var I_e = g((mD) => {
  "use strict";
  c();
  Object.defineProperty(mD, "__esModule", { value: !0 });
  mD.getAwsChunkedEncodingStream = void 0;
  var DFt = G("stream"),
    LFt = (e, t) => {
      let {
          base64Encoder: r,
          bodyLengthChecker: n,
          checksumAlgorithmFn: i,
          checksumLocationName: o,
          streamHasher: a,
        } = t,
        s = r !== void 0 && i !== void 0 && o !== void 0 && a !== void 0,
        u = s ? a(i, e) : void 0,
        l = new DFt.Readable({ read: () => {} });
      return (
        e.on("data", (d) => {
          let f = n(d) || 0;
          l.push(`${f.toString(16)}\r
`),
            l.push(d),
            l.push(`\r
`);
        }),
        e.on("end", async () => {
          if (
            (l.push(`0\r
`),
            s)
          ) {
            let d = r(await u);
            l.push(`${o}:${d}\r
`),
              l.push(`\r
`);
          }
          l.push(null);
        }),
        l
      );
    };
  mD.getAwsChunkedEncodingStream = LFt;
});
var x_e = g((hD) => {
  "use strict";
  c();
  Object.defineProperty(hD, "__esModule", { value: !0 });
  hD.headStream = void 0;
  async function MFt(e, t) {
    var r;
    let n = 0,
      i = [],
      o = e.getReader(),
      a = !1;
    for (; !a; ) {
      let { done: l, value: d } = await o.read();
      if (
        (d &&
          (i.push(d),
          (n += (r = d?.byteLength) !== null && r !== void 0 ? r : 0)),
        n >= t)
      )
        break;
      a = l;
    }
    o.releaseLock();
    let s = new Uint8Array(Math.min(t, n)),
      u = 0;
    for (let l of i) {
      if (l.byteLength > s.byteLength - u) {
        s.set(l.subarray(0, s.byteLength - u), u);
        break;
      } else s.set(l, u);
      u += l.length;
    }
    return s;
  }
  hD.headStream = MFt;
});
var N_e = g((gD) => {
  "use strict";
  c();
  Object.defineProperty(gD, "__esModule", { value: !0 });
  gD.headStream = void 0;
  var qFt = G("stream"),
    jFt = x_e(),
    FFt = gf(),
    BFt = (e, t) =>
      (0, FFt.isReadableStream)(e)
        ? (0, jFt.headStream)(e, t)
        : new Promise((r, n) => {
            let i = new F4();
            (i.limit = t),
              e.pipe(i),
              e.on("error", (o) => {
                i.end(), n(o);
              }),
              i.on("error", n),
              i.on("finish", function () {
                let o = new Uint8Array(Buffer.concat(this.buffers));
                r(o);
              });
          });
  gD.headStream = BFt;
  var F4 = class extends qFt.Writable {
    constructor() {
      super(...arguments),
        (this.buffers = []),
        (this.limit = 1 / 0),
        (this.bytesBuffered = 0);
    }
    _write(t, r, n) {
      var i;
      if (
        (this.buffers.push(t),
        (this.bytesBuffered +=
          (i = t.byteLength) !== null && i !== void 0 ? i : 0),
        this.bytesBuffered >= this.limit)
      ) {
        let o = this.bytesBuffered - this.limit,
          a = this.buffers[this.buffers.length - 1];
        (this.buffers[this.buffers.length - 1] = a.subarray(
          0,
          a.byteLength - o,
        )),
          this.emit("finish");
      }
      n();
    }
  };
});
var U4 = g((ebn, L_e) => {
  c();
  var vD = Object.defineProperty,
    UFt = Object.getOwnPropertyDescriptor,
    HFt = Object.getOwnPropertyNames,
    GFt = Object.prototype.hasOwnProperty,
    B4 = (e, t) => vD(e, "name", { value: t, configurable: !0 }),
    VFt = (e, t) => {
      for (var r in t) vD(e, r, { get: t[r], enumerable: !0 });
    },
    $Ft = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of HFt(t))
          !GFt.call(e, i) &&
            i !== r &&
            vD(e, i, {
              get: () => t[i],
              enumerable: !(n = UFt(t, i)) || n.enumerable,
            });
      return e;
    },
    zFt = (e) => $Ft(vD({}, "__esModule", { value: !0 }), e),
    k_e = {};
  VFt(k_e, { escapeUri: () => D_e, escapeUriPath: () => WFt });
  L_e.exports = zFt(k_e);
  var D_e = B4(
      (e) => encodeURIComponent(e).replace(/[!'()*]/g, KFt),
      "escapeUri",
    ),
    KFt = B4(
      (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`,
      "hexEncode",
    ),
    WFt = B4((e) => e.split("/").map(D_e).join("/"), "escapeUriPath");
});
var G4 = g((rbn, j_e) => {
  c();
  var yD = Object.defineProperty,
    QFt = Object.getOwnPropertyDescriptor,
    YFt = Object.getOwnPropertyNames,
    XFt = Object.prototype.hasOwnProperty,
    JFt = (e, t) => yD(e, "name", { value: t, configurable: !0 }),
    ZFt = (e, t) => {
      for (var r in t) yD(e, r, { get: t[r], enumerable: !0 });
    },
    e1t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of YFt(t))
          !XFt.call(e, i) &&
            i !== r &&
            yD(e, i, {
              get: () => t[i],
              enumerable: !(n = QFt(t, i)) || n.enumerable,
            });
      return e;
    },
    t1t = (e) => e1t(yD({}, "__esModule", { value: !0 }), e),
    M_e = {};
  ZFt(M_e, { buildQueryString: () => q_e });
  j_e.exports = t1t(M_e);
  var H4 = U4();
  function q_e(e) {
    let t = [];
    for (let r of Object.keys(e).sort()) {
      let n = e[r];
      if (((r = (0, H4.escapeUri)(r)), Array.isArray(n)))
        for (let i = 0, o = n.length; i < o; i++)
          t.push(`${r}=${(0, H4.escapeUri)(n[i])}`);
      else {
        let i = r;
        (n || typeof n == "string") && (i += `=${(0, H4.escapeUri)(n)}`),
          t.push(i);
      }
    }
    return t.join("&");
  }
  JFt(q_e, "buildQueryString");
});
var ih = g((ibn, Z_e) => {
  c();
  var r1t = Object.create,
    PC = Object.defineProperty,
    n1t = Object.getOwnPropertyDescriptor,
    i1t = Object.getOwnPropertyNames,
    o1t = Object.getPrototypeOf,
    a1t = Object.prototype.hasOwnProperty,
    pr = (e, t) => PC(e, "name", { value: t, configurable: !0 }),
    s1t = (e, t) => {
      for (var r in t) PC(e, r, { get: t[r], enumerable: !0 });
    },
    G_e = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of i1t(t))
          !a1t.call(e, i) &&
            i !== r &&
            PC(e, i, {
              get: () => t[i],
              enumerable: !(n = n1t(t, i)) || n.enumerable,
            });
      return e;
    },
    c1t = (e, t, r) => (
      (r = e != null ? r1t(o1t(e)) : {}),
      G_e(
        t || !e || !e.__esModule
          ? PC(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    u1t = (e) => G_e(PC({}, "__esModule", { value: !0 }), e),
    V_e = {};
  s1t(V_e, {
    DEFAULT_REQUEST_TIMEOUT: () => Y_e,
    NodeHttp2Handler: () => _1t,
    NodeHttpHandler: () => h1t,
    streamCollector: () => b1t,
  });
  Z_e.exports = u1t(V_e);
  var $_e = Jr(),
    z_e = G4(),
    V4 = G("http"),
    $4 = G("https"),
    l1t = ["ECONNRESET", "EPIPE", "ETIMEDOUT"],
    K_e = pr((e) => {
      let t = {};
      for (let r of Object.keys(e)) {
        let n = e[r];
        t[r] = Array.isArray(n) ? n.join(",") : n;
      }
      return t;
    }, "getTransformedHeaders"),
    Ro = {
      setTimeout: (e, t) => setTimeout(e, t),
      clearTimeout: (e) => clearTimeout(e),
    },
    F_e = 1e3,
    d1t = pr((e, t, r = 0) => {
      if (!r) return -1;
      let n = pr((i) => {
        let o = Ro.setTimeout(() => {
            e.destroy(),
              t(
                Object.assign(
                  new Error(
                    `Socket timed out without establishing a connection within ${r} ms`,
                  ),
                  { name: "TimeoutError" },
                ),
              );
          }, r - i),
          a = pr((s) => {
            s?.connecting
              ? s.on("connect", () => {
                  Ro.clearTimeout(o);
                })
              : Ro.clearTimeout(o);
          }, "doWithSocket");
        e.socket ? a(e.socket) : e.on("socket", a);
      }, "registerTimeout");
      return r < 2e3 ? (n(0), 0) : Ro.setTimeout(n.bind(null, F_e), F_e);
    }, "setConnectionTimeout"),
    f1t = 3e3,
    p1t = pr((e, { keepAlive: t, keepAliveMsecs: r }, n = f1t) => {
      if (t !== !0) return -1;
      let i = pr(() => {
        e.socket
          ? e.socket.setKeepAlive(t, r || 0)
          : e.on("socket", (o) => {
              o.setKeepAlive(t, r || 0);
            });
      }, "registerListener");
      return n === 0 ? (i(), 0) : Ro.setTimeout(i, n);
    }, "setSocketKeepAlive"),
    B_e = 3e3,
    m1t = pr((e, t, r = Y_e) => {
      let n = pr((i) => {
        let o = r - i,
          a = pr(() => {
            e.destroy(),
              t(
                Object.assign(new Error(`Connection timed out after ${r} ms`), {
                  name: "TimeoutError",
                }),
              );
          }, "onTimeout");
        e.socket
          ? (e.socket.setTimeout(o, a),
            e.on("close", () => e.socket?.removeListener("timeout", a)))
          : e.setTimeout(o, a);
      }, "registerTimeout");
      return 0 < r && r < 6e3
        ? (n(0), 0)
        : Ro.setTimeout(n.bind(null, r === 0 ? 0 : B_e), B_e);
    }, "setSocketTimeout"),
    W_e = G("stream"),
    U_e = 6e3;
  async function K4(e, t, r = U_e) {
    let n = t.headers ?? {},
      i = n.Expect || n.expect,
      o = -1,
      a = !0;
    i === "100-continue" &&
      (a = await Promise.race([
        new Promise((s) => {
          o = Number(Ro.setTimeout(() => s(!0), Math.max(U_e, r)));
        }),
        new Promise((s) => {
          e.on("continue", () => {
            Ro.clearTimeout(o), s(!0);
          }),
            e.on("response", () => {
              Ro.clearTimeout(o), s(!1);
            }),
            e.on("error", () => {
              Ro.clearTimeout(o), s(!1);
            });
        }),
      ])),
      a && Q_e(e, t.body);
  }
  pr(K4, "writeRequestBody");
  function Q_e(e, t) {
    if (t instanceof W_e.Readable) {
      t.pipe(e);
      return;
    }
    if (t) {
      if (Buffer.isBuffer(t) || typeof t == "string") {
        e.end(t);
        return;
      }
      let r = t;
      if (
        typeof r == "object" &&
        r.buffer &&
        typeof r.byteOffset == "number" &&
        typeof r.byteLength == "number"
      ) {
        e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength));
        return;
      }
      e.end(Buffer.from(t));
      return;
    }
    e.end();
  }
  pr(Q_e, "writeBody");
  var Y_e = 0,
    h1t = class z4 {
      constructor(t) {
        (this.socketWarningTimestamp = 0),
          (this.metadata = { handlerProtocol: "http/1.1" }),
          (this.configProvider = new Promise((r, n) => {
            typeof t == "function"
              ? t()
                  .then((i) => {
                    r(this.resolveDefaultConfig(i));
                  })
                  .catch(n)
              : r(this.resolveDefaultConfig(t));
          }));
      }
      static {
        pr(this, "NodeHttpHandler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new z4(t);
      }
      static checkSocketUsage(t, r, n = console) {
        let { sockets: i, requests: o, maxSockets: a } = t;
        if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r)
          return r;
        if (i && o)
          for (let u in i) {
            let l = i[u]?.length ?? 0,
              d = o[u]?.length ?? 0;
            if (l >= a && d >= 2 * a)
              return (
                n?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${l} and ${d} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`),
                Date.now()
              );
          }
        return r;
      }
      resolveDefaultConfig(t) {
        let {
            requestTimeout: r,
            connectionTimeout: n,
            socketTimeout: i,
            socketAcquisitionWarningTimeout: o,
            httpAgent: a,
            httpsAgent: s,
          } = t || {},
          u = !0,
          l = 50;
        return {
          connectionTimeout: n,
          requestTimeout: r ?? i,
          socketAcquisitionWarningTimeout: o,
          httpAgent:
            a instanceof V4.Agent || typeof a?.destroy == "function"
              ? a
              : new V4.Agent({ keepAlive: u, maxSockets: l, ...a }),
          httpsAgent:
            s instanceof $4.Agent || typeof s?.destroy == "function"
              ? s
              : new $4.Agent({ keepAlive: u, maxSockets: l, ...s }),
          logger: console,
        };
      }
      destroy() {
        this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy();
      }
      async handle(t, { abortSignal: r } = {}) {
        return (
          this.config || (this.config = await this.configProvider),
          new Promise((n, i) => {
            let o,
              a = [],
              s = pr(async (C) => {
                await o, a.forEach(Ro.clearTimeout), n(C);
              }, "resolve"),
              u = pr(async (C) => {
                await o, a.forEach(Ro.clearTimeout), i(C);
              }, "reject");
            if (!this.config)
              throw new Error(
                "Node HTTP request handler config is not resolved",
              );
            if (r?.aborted) {
              let C = new Error("Request aborted");
              (C.name = "AbortError"), u(C);
              return;
            }
            let l = t.protocol === "https:",
              d = l ? this.config.httpsAgent : this.config.httpAgent;
            a.push(
              Ro.setTimeout(
                () => {
                  this.socketWarningTimestamp = z4.checkSocketUsage(
                    d,
                    this.socketWarningTimestamp,
                    this.config.logger,
                  );
                },
                this.config.socketAcquisitionWarningTimeout ??
                  (this.config.requestTimeout ?? 2e3) +
                    (this.config.connectionTimeout ?? 1e3),
              ),
            );
            let f = (0, z_e.buildQueryString)(t.query || {}),
              m;
            if (t.username != null || t.password != null) {
              let C = t.username ?? "",
                P = t.password ?? "";
              m = `${C}:${P}`;
            }
            let h = t.path;
            f && (h += `?${f}`), t.fragment && (h += `#${t.fragment}`);
            let y = t.hostname ?? "";
            y[0] === "[" && y.endsWith("]")
              ? (y = t.hostname.slice(1, -1))
              : (y = t.hostname);
            let _ = {
                headers: t.headers,
                host: y,
                method: t.method,
                path: h,
                port: t.port,
                agent: d,
                auth: m,
              },
              b = (l ? $4.request : V4.request)(_, (C) => {
                let P = new $_e.HttpResponse({
                  statusCode: C.statusCode || -1,
                  reason: C.statusMessage,
                  headers: K_e(C.headers),
                  body: C,
                });
                s({ response: P });
              });
            if (
              (b.on("error", (C) => {
                l1t.includes(C.code)
                  ? u(Object.assign(C, { name: "TimeoutError" }))
                  : u(C);
              }),
              r)
            ) {
              let C = pr(() => {
                b.destroy();
                let P = new Error("Request aborted");
                (P.name = "AbortError"), u(P);
              }, "onAbort");
              if (typeof r.addEventListener == "function") {
                let P = r;
                P.addEventListener("abort", C, { once: !0 }),
                  b.once("close", () => P.removeEventListener("abort", C));
              } else r.onabort = C;
            }
            a.push(d1t(b, u, this.config.connectionTimeout)),
              a.push(m1t(b, u, this.config.requestTimeout));
            let O = _.agent;
            typeof O == "object" &&
              "keepAlive" in O &&
              a.push(
                p1t(b, {
                  keepAlive: O.keepAlive,
                  keepAliveMsecs: O.keepAliveMsecs,
                }),
              ),
              (o = K4(b, t, this.config.requestTimeout).catch(
                (C) => (a.forEach(Ro.clearTimeout), i(C)),
              ));
          })
        );
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then((n) => ({
            ...n,
            [t]: r,
          })));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    },
    H_e = G("http2"),
    g1t = c1t(G("http2")),
    v1t = class {
      constructor(e) {
        (this.sessions = []), (this.sessions = e ?? []);
      }
      static {
        pr(this, "NodeHttp2ConnectionPool");
      }
      poll() {
        if (this.sessions.length > 0) return this.sessions.shift();
      }
      offerLast(e) {
        this.sessions.push(e);
      }
      contains(e) {
        return this.sessions.includes(e);
      }
      remove(e) {
        this.sessions = this.sessions.filter((t) => t !== e);
      }
      [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
      }
      destroy(e) {
        for (let t of this.sessions) t === e && (t.destroyed || t.destroy());
      }
    },
    y1t = class {
      constructor(e) {
        if (
          ((this.sessionCache = new Map()),
          (this.config = e),
          this.config.maxConcurrency && this.config.maxConcurrency <= 0)
        )
          throw new RangeError("maxConcurrency must be greater than zero.");
      }
      static {
        pr(this, "NodeHttp2ConnectionManager");
      }
      lease(e, t) {
        let r = this.getUrlString(e),
          n = this.sessionCache.get(r);
        if (n) {
          let s = n.poll();
          if (s && !this.config.disableConcurrency) return s;
        }
        let i = g1t.default.connect(r);
        this.config.maxConcurrency &&
          i.settings(
            { maxConcurrentStreams: this.config.maxConcurrency },
            (s) => {
              if (s)
                throw new Error(
                  "Fail to set maxConcurrentStreams to " +
                    this.config.maxConcurrency +
                    "when creating new session for " +
                    e.destination.toString(),
                );
            },
          ),
          i.unref();
        let o = pr(() => {
          i.destroy(), this.deleteSession(r, i);
        }, "destroySessionCb");
        i.on("goaway", o),
          i.on("error", o),
          i.on("frameError", o),
          i.on("close", () => this.deleteSession(r, i)),
          t.requestTimeout && i.setTimeout(t.requestTimeout, o);
        let a = this.sessionCache.get(r) || new v1t();
        return a.offerLast(i), this.sessionCache.set(r, a), i;
      }
      deleteSession(e, t) {
        let r = this.sessionCache.get(e);
        r && r.contains(t) && (r.remove(t), this.sessionCache.set(e, r));
      }
      release(e, t) {
        let r = this.getUrlString(e);
        this.sessionCache.get(r)?.offerLast(t);
      }
      destroy() {
        for (let [e, t] of this.sessionCache) {
          for (let r of t) r.destroyed || r.destroy(), t.remove(r);
          this.sessionCache.delete(e);
        }
      }
      setMaxConcurrentStreams(e) {
        if (e && e <= 0)
          throw new RangeError(
            "maxConcurrentStreams must be greater than zero.",
          );
        this.config.maxConcurrency = e;
      }
      setDisableConcurrentStreams(e) {
        this.config.disableConcurrency = e;
      }
      getUrlString(e) {
        return e.destination.toString();
      }
    },
    _1t = class X_e {
      constructor(t) {
        (this.metadata = { handlerProtocol: "h2" }),
          (this.connectionManager = new y1t({})),
          (this.configProvider = new Promise((r, n) => {
            typeof t == "function"
              ? t()
                  .then((i) => {
                    r(i || {});
                  })
                  .catch(n)
              : r(t || {});
          }));
      }
      static {
        pr(this, "NodeHttp2Handler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new X_e(t);
      }
      destroy() {
        this.connectionManager.destroy();
      }
      async handle(t, { abortSignal: r } = {}) {
        this.config ||
          ((this.config = await this.configProvider),
          this.connectionManager.setDisableConcurrentStreams(
            this.config.disableConcurrentStreams || !1,
          ),
          this.config.maxConcurrentStreams &&
            this.connectionManager.setMaxConcurrentStreams(
              this.config.maxConcurrentStreams,
            ));
        let { requestTimeout: n, disableConcurrentStreams: i } = this.config;
        return new Promise((o, a) => {
          let s = !1,
            u,
            l = pr(async (L) => {
              await u, o(L);
            }, "resolve"),
            d = pr(async (L) => {
              await u, a(L);
            }, "reject");
          if (r?.aborted) {
            s = !0;
            let L = new Error("Request aborted");
            (L.name = "AbortError"), d(L);
            return;
          }
          let { hostname: f, method: m, port: h, protocol: y, query: _ } = t,
            E = "";
          if (t.username != null || t.password != null) {
            let L = t.username ?? "",
              Z = t.password ?? "";
            E = `${L}:${Z}@`;
          }
          let b = `${y}//${E}${f}${h ? `:${h}` : ""}`,
            O = { destination: new URL(b) },
            C = this.connectionManager.lease(O, {
              requestTimeout: this.config?.sessionTimeout,
              disableConcurrentStreams: i || !1,
            }),
            P = pr((L) => {
              i && this.destroySession(C), (s = !0), d(L);
            }, "rejectWithDestroy"),
            k = (0, z_e.buildQueryString)(_ || {}),
            H = t.path;
          k && (H += `?${k}`), t.fragment && (H += `#${t.fragment}`);
          let B = C.request({
            ...t.headers,
            [H_e.constants.HTTP2_HEADER_PATH]: H,
            [H_e.constants.HTTP2_HEADER_METHOD]: m,
          });
          if (
            (C.ref(),
            B.on("response", (L) => {
              let Z = new $_e.HttpResponse({
                statusCode: L[":status"] || -1,
                headers: K_e(L),
                body: B,
              });
              (s = !0),
                l({ response: Z }),
                i && (C.close(), this.connectionManager.deleteSession(b, C));
            }),
            n &&
              B.setTimeout(n, () => {
                B.close();
                let L = new Error(
                  `Stream timed out because of no activity for ${n} ms`,
                );
                (L.name = "TimeoutError"), P(L);
              }),
            r)
          ) {
            let L = pr(() => {
              B.close();
              let Z = new Error("Request aborted");
              (Z.name = "AbortError"), P(Z);
            }, "onAbort");
            if (typeof r.addEventListener == "function") {
              let Z = r;
              Z.addEventListener("abort", L, { once: !0 }),
                B.once("close", () => Z.removeEventListener("abort", L));
            } else r.onabort = L;
          }
          B.on("frameError", (L, Z, ft) => {
            P(
              new Error(
                `Frame type id ${L} in stream id ${ft} has failed with code ${Z}.`,
              ),
            );
          }),
            B.on("error", P),
            B.on("aborted", () => {
              P(
                new Error(
                  `HTTP/2 stream is abnormally aborted in mid-communication with result code ${B.rstCode}.`,
                ),
              );
            }),
            B.on("close", () => {
              C.unref(),
                i && C.destroy(),
                s ||
                  P(
                    new Error(
                      "Unexpected error: http2 request did not get a response",
                    ),
                  );
            }),
            (u = K4(B, t, n));
        });
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then((n) => ({
            ...n,
            [t]: r,
          })));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
      destroySession(t) {
        t.destroyed || t.destroy();
      }
    },
    E1t = class extends W_e.Writable {
      constructor() {
        super(...arguments), (this.bufferedBytes = []);
      }
      static {
        pr(this, "Collector");
      }
      _write(e, t, r) {
        this.bufferedBytes.push(e), r();
      }
    },
    b1t = pr(
      (e) =>
        S1t(e)
          ? J_e(e)
          : new Promise((t, r) => {
              let n = new E1t();
              e.pipe(n),
                e.on("error", (i) => {
                  n.end(), r(i);
                }),
                n.on("error", r),
                n.on("finish", function () {
                  let i = new Uint8Array(Buffer.concat(this.bufferedBytes));
                  t(i);
                });
            }),
      "streamCollector",
    ),
    S1t = pr(
      (e) => typeof ReadableStream == "function" && e instanceof ReadableStream,
      "isReadableStreamInstance",
    );
  async function J_e(e) {
    let t = [],
      r = e.getReader(),
      n = !1,
      i = 0;
    for (; !n; ) {
      let { done: s, value: u } = await r.read();
      u && (t.push(u), (i += u.length)), (n = s);
    }
    let o = new Uint8Array(i),
      a = 0;
    for (let s of t) o.set(s, a), (a += s.length);
    return o;
  }
  pr(J_e, "collectReadableStream");
});
var cEe = g((ubn, sEe) => {
  c();
  var ED = Object.defineProperty,
    C1t = Object.getOwnPropertyDescriptor,
    w1t = Object.getOwnPropertyNames,
    O1t = Object.prototype.hasOwnProperty,
    Uc = (e, t) => ED(e, "name", { value: t, configurable: !0 }),
    T1t = (e, t) => {
      for (var r in t) ED(e, r, { get: t[r], enumerable: !0 });
    },
    A1t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of w1t(t))
          !O1t.call(e, i) &&
            i !== r &&
            ED(e, i, {
              get: () => t[i],
              enumerable: !(n = C1t(t, i)) || n.enumerable,
            });
      return e;
    },
    P1t = (e) => A1t(ED({}, "__esModule", { value: !0 }), e),
    tEe = {};
  T1t(tEe, {
    FetchHttpHandler: () => I1t,
    keepAliveSupport: () => _D,
    streamCollector: () => N1t,
  });
  sEe.exports = P1t(tEe);
  var eEe = Jr(),
    R1t = G4();
  function W4(e, t) {
    return new Request(e, t);
  }
  Uc(W4, "createRequest");
  function rEe(e = 0) {
    return new Promise((t, r) => {
      e &&
        setTimeout(() => {
          let n = new Error(`Request did not complete within ${e} ms`);
          (n.name = "TimeoutError"), r(n);
        }, e);
    });
  }
  Uc(rEe, "requestTimeout");
  var _D = { supported: void 0 },
    I1t = class nEe {
      static {
        Uc(this, "FetchHttpHandler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new nEe(t);
      }
      constructor(t) {
        typeof t == "function"
          ? (this.configProvider = t().then((r) => r || {}))
          : ((this.config = t ?? {}),
            (this.configProvider = Promise.resolve(this.config))),
          _D.supported === void 0 &&
            (_D.supported =
              typeof Request < "u" && "keepalive" in W4("https://[::1]"));
      }
      destroy() {}
      async handle(t, { abortSignal: r } = {}) {
        this.config || (this.config = await this.configProvider);
        let n = this.config.requestTimeout,
          i = this.config.keepAlive === !0,
          o = this.config.credentials;
        if (r?.aborted) {
          let b = new Error("Request aborted");
          return (b.name = "AbortError"), Promise.reject(b);
        }
        let a = t.path,
          s = (0, R1t.buildQueryString)(t.query || {});
        s && (a += `?${s}`), t.fragment && (a += `#${t.fragment}`);
        let u = "";
        if (t.username != null || t.password != null) {
          let b = t.username ?? "",
            O = t.password ?? "";
          u = `${b}:${O}@`;
        }
        let { port: l, method: d } = t,
          f = `${t.protocol}//${u}${t.hostname}${l ? `:${l}` : ""}${a}`,
          m = d === "GET" || d === "HEAD" ? void 0 : t.body,
          h = {
            body: m,
            headers: new Headers(t.headers),
            method: d,
            credentials: o,
          };
        this.config?.cache && (h.cache = this.config.cache),
          m && (h.duplex = "half"),
          typeof AbortController < "u" && (h.signal = r),
          _D.supported && (h.keepalive = i),
          typeof this.config.requestInit == "function" &&
            Object.assign(h, this.config.requestInit(t));
        let y = Uc(() => {}, "removeSignalEventListener"),
          _ = W4(f, h),
          E = [
            fetch(_).then((b) => {
              let O = b.headers,
                C = {};
              for (let k of O.entries()) C[k[0]] = k[1];
              return b.body != null
                ? {
                    response: new eEe.HttpResponse({
                      headers: C,
                      reason: b.statusText,
                      statusCode: b.status,
                      body: b.body,
                    }),
                  }
                : b.blob().then((k) => ({
                    response: new eEe.HttpResponse({
                      headers: C,
                      reason: b.statusText,
                      statusCode: b.status,
                      body: k,
                    }),
                  }));
            }),
            rEe(n),
          ];
        return (
          r &&
            E.push(
              new Promise((b, O) => {
                let C = Uc(() => {
                  let P = new Error("Request aborted");
                  (P.name = "AbortError"), O(P);
                }, "onAbort");
                if (typeof r.addEventListener == "function") {
                  let P = r;
                  P.addEventListener("abort", C, { once: !0 }),
                    (y = Uc(
                      () => P.removeEventListener("abort", C),
                      "removeSignalEventListener",
                    ));
                } else r.onabort = C;
              }),
            ),
          Promise.race(E).finally(y)
        );
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then(
            (n) => ((n[t] = r), n),
          ));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    },
    x1t = Bc(),
    N1t = Uc(
      async (e) =>
        (typeof Blob == "function" && e instanceof Blob) ||
        e.constructor?.name === "Blob"
          ? Blob.prototype.arrayBuffer !== void 0
            ? new Uint8Array(await e.arrayBuffer())
            : iEe(e)
          : oEe(e),
      "streamCollector",
    );
  async function iEe(e) {
    let t = await aEe(e),
      r = (0, x1t.fromBase64)(t);
    return new Uint8Array(r);
  }
  Uc(iEe, "collectBlob");
  async function oEe(e) {
    let t = [],
      r = e.getReader(),
      n = !1,
      i = 0;
    for (; !n; ) {
      let { done: s, value: u } = await r.read();
      u && (t.push(u), (i += u.length)), (n = s);
    }
    let o = new Uint8Array(i),
      a = 0;
    for (let s of t) o.set(s, a), (a += s.length);
    return o;
  }
  Uc(oEe, "collectStream");
  function aEe(e) {
    return new Promise((t, r) => {
      let n = new FileReader();
      (n.onloadend = () => {
        if (n.readyState !== 2) return r(new Error("Reader aborted too early"));
        let i = n.result ?? "",
          o = i.indexOf(","),
          a = o > -1 ? o + 1 : i.length;
        t(i.substring(a));
      }),
        (n.onabort = () => r(new Error("Read aborted"))),
        (n.onerror = () => r(n.error)),
        n.readAsDataURL(e);
    });
  }
  Uc(aEe, "readToBase64");
});
var zs = g((dbn, mEe) => {
  c();
  var bD = Object.defineProperty,
    k1t = Object.getOwnPropertyDescriptor,
    D1t = Object.getOwnPropertyNames,
    L1t = Object.prototype.hasOwnProperty,
    uEe = (e, t) => bD(e, "name", { value: t, configurable: !0 }),
    M1t = (e, t) => {
      for (var r in t) bD(e, r, { get: t[r], enumerable: !0 });
    },
    q1t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of D1t(t))
          !L1t.call(e, i) &&
            i !== r &&
            bD(e, i, {
              get: () => t[i],
              enumerable: !(n = k1t(t, i)) || n.enumerable,
            });
      return e;
    },
    j1t = (e) => q1t(bD({}, "__esModule", { value: !0 }), e),
    lEe = {};
  M1t(lEe, { fromHex: () => fEe, toHex: () => pEe });
  mEe.exports = j1t(lEe);
  var dEe = {},
    Q4 = {};
  for (let e = 0; e < 256; e++) {
    let t = e.toString(16).toLowerCase();
    t.length === 1 && (t = `0${t}`), (dEe[e] = t), (Q4[t] = e);
  }
  function fEe(e) {
    if (e.length % 2 !== 0)
      throw new Error("Hex encoded strings must have an even number length");
    let t = new Uint8Array(e.length / 2);
    for (let r = 0; r < e.length; r += 2) {
      let n = e.slice(r, r + 2).toLowerCase();
      if (n in Q4) t[r / 2] = Q4[n];
      else
        throw new Error(
          `Cannot decode unrecognized sequence ${n} as hexadecimal`,
        );
    }
    return t;
  }
  uEe(fEe, "fromHex");
  function pEe(e) {
    let t = "";
    for (let r = 0; r < e.byteLength; r++) t += dEe[e[r]];
    return t;
  }
  uEe(pEe, "toHex");
});
var yEe = g((SD) => {
  "use strict";
  c();
  Object.defineProperty(SD, "__esModule", { value: !0 });
  SD.sdkStreamMixin = void 0;
  var F1t = cEe(),
    B1t = Bc(),
    U1t = zs(),
    H1t = Fe(),
    hEe = gf(),
    gEe = "The stream has already been transformed.",
    G1t = (e) => {
      var t, r;
      if (!vEe(e) && !(0, hEe.isReadableStream)(e)) {
        let a =
          ((r =
            (t = e?.__proto__) === null || t === void 0
              ? void 0
              : t.constructor) === null || r === void 0
            ? void 0
            : r.name) || e;
        throw new Error(
          `Unexpected stream implementation, expect Blob or ReadableStream, got ${a}`,
        );
      }
      let n = !1,
        i = async () => {
          if (n) throw new Error(gEe);
          return (n = !0), await (0, F1t.streamCollector)(e);
        },
        o = (a) => {
          if (typeof a.stream != "function")
            throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
          return a.stream();
        };
      return Object.assign(e, {
        transformToByteArray: i,
        transformToString: async (a) => {
          let s = await i();
          if (a === "base64") return (0, B1t.toBase64)(s);
          if (a === "hex") return (0, U1t.toHex)(s);
          if (a === void 0 || a === "utf8" || a === "utf-8")
            return (0, H1t.toUtf8)(s);
          if (typeof TextDecoder == "function")
            return new TextDecoder(a).decode(s);
          throw new Error(
            "TextDecoder is not available, please make sure polyfill is provided.",
          );
        },
        transformToWebStream: () => {
          if (n) throw new Error(gEe);
          if (((n = !0), vEe(e))) return o(e);
          if ((0, hEe.isReadableStream)(e)) return e;
          throw new Error(`Cannot transform payload to web stream, got ${e}`);
        },
      });
    };
  SD.sdkStreamMixin = G1t;
  var vEe = (e) => typeof Blob == "function" && e instanceof Blob;
});
var EEe = g((CD) => {
  "use strict";
  c();
  Object.defineProperty(CD, "__esModule", { value: !0 });
  CD.sdkStreamMixin = void 0;
  var V1t = ih(),
    $1t = Hi(),
    Y4 = G("stream"),
    z1t = yEe(),
    _Ee = "The stream has already been transformed.",
    K1t = (e) => {
      var t, r;
      if (!(e instanceof Y4.Readable))
        try {
          return (0, z1t.sdkStreamMixin)(e);
        } catch {
          let a =
            ((r =
              (t = e?.__proto__) === null || t === void 0
                ? void 0
                : t.constructor) === null || r === void 0
              ? void 0
              : r.name) || e;
          throw new Error(
            `Unexpected stream implementation, expect Stream.Readable instance, got ${a}`,
          );
        }
      let n = !1,
        i = async () => {
          if (n) throw new Error(_Ee);
          return (n = !0), await (0, V1t.streamCollector)(e);
        };
      return Object.assign(e, {
        transformToByteArray: i,
        transformToString: async (o) => {
          let a = await i();
          return o === void 0 || Buffer.isEncoding(o)
            ? (0, $1t.fromArrayBuffer)(
                a.buffer,
                a.byteOffset,
                a.byteLength,
              ).toString(o)
            : new TextDecoder(o).decode(a);
        },
        transformToWebStream: () => {
          if (n) throw new Error(_Ee);
          if (e.readableFlowing !== null)
            throw new Error("The stream has been consumed by other callbacks.");
          if (typeof Y4.Readable.toWeb != "function")
            throw new Error(
              "Readable.toWeb() is not supported. Please ensure a polyfill is available.",
            );
          return (n = !0), Y4.Readable.toWeb(e);
        },
      });
    };
  CD.sdkStreamMixin = K1t;
});
var bEe = g((wD) => {
  "use strict";
  c();
  Object.defineProperty(wD, "__esModule", { value: !0 });
  wD.splitStream = void 0;
  async function W1t(e) {
    return typeof e.stream == "function" && (e = e.stream()), e.tee();
  }
  wD.splitStream = W1t;
});
var wEe = g((OD) => {
  "use strict";
  c();
  Object.defineProperty(OD, "__esModule", { value: !0 });
  OD.splitStream = void 0;
  var SEe = G("stream"),
    Q1t = bEe(),
    CEe = gf();
  async function Y1t(e) {
    if ((0, CEe.isReadableStream)(e) || (0, CEe.isBlob)(e))
      return (0, Q1t.splitStream)(e);
    let t = new SEe.PassThrough(),
      r = new SEe.PassThrough();
    return e.pipe(t), e.pipe(r), [t, r];
  }
  OD.splitStream = Y1t;
});
var eW = g((bbn, Gc) => {
  c();
  var TD = Object.defineProperty,
    X1t = Object.getOwnPropertyDescriptor,
    J1t = Object.getOwnPropertyNames,
    Z1t = Object.prototype.hasOwnProperty,
    Z4 = (e, t) => TD(e, "name", { value: t, configurable: !0 }),
    eBt = (e, t) => {
      for (var r in t) TD(e, r, { get: t[r], enumerable: !0 });
    },
    X4 = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of J1t(t))
          !Z1t.call(e, i) &&
            i !== r &&
            TD(e, i, {
              get: () => t[i],
              enumerable: !(n = X1t(t, i)) || n.enumerable,
            });
      return e;
    },
    vf = (e, t, r) => (X4(e, t, "default"), r && X4(r, t, "default")),
    tBt = (e) => X4(TD({}, "__esModule", { value: !0 }), e),
    Hc = {};
  eBt(Hc, { Uint8ArrayBlobAdapter: () => J4 });
  Gc.exports = tBt(Hc);
  var OEe = Bc(),
    TEe = Fe();
  function AEe(e, t = "utf-8") {
    return t === "base64" ? (0, OEe.toBase64)(e) : (0, TEe.toUtf8)(e);
  }
  Z4(AEe, "transformToString");
  function PEe(e, t) {
    return t === "base64"
      ? J4.mutate((0, OEe.fromBase64)(e))
      : J4.mutate((0, TEe.fromUtf8)(e));
  }
  Z4(PEe, "transformFromString");
  var J4 = class REe extends Uint8Array {
    static {
      Z4(this, "Uint8ArrayBlobAdapter");
    }
    static fromString(t, r = "utf-8") {
      switch (typeof t) {
        case "string":
          return PEe(t, r);
        default:
          throw new Error(
            `Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`,
          );
      }
    }
    static mutate(t) {
      return Object.setPrototypeOf(t, REe.prototype), t;
    }
    transformToString(t = "utf-8") {
      return AEe(this, t);
    }
  };
  vf(Hc, L4(), Gc.exports);
  vf(Hc, C_e(), Gc.exports);
  vf(Hc, R_e(), Gc.exports);
  vf(Hc, I_e(), Gc.exports);
  vf(Hc, N_e(), Gc.exports);
  vf(Hc, EEe(), Gc.exports);
  vf(Hc, wEe(), Gc.exports);
  vf(Hc, gf(), Gc.exports);
});
var AD,
  rBt,
  IEe = w(() => {
    c();
    (AD = A(eW())),
      (rBt = async (e = new Uint8Array(), t) => {
        if (e instanceof Uint8Array) return AD.Uint8ArrayBlobAdapter.mutate(e);
        if (!e) return AD.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
        let r = t.streamCollector(e);
        return AD.Uint8ArrayBlobAdapter.mutate(await r);
      });
  });
function PD(e) {
  return encodeURIComponent(e).replace(/[!'()*]/g, function (t) {
    return "%" + t.charCodeAt(0).toString(16).toUpperCase();
  });
}
var tW = w(() => {
  c();
});
var rW,
  nW = w(() => {
    c();
    tW();
    rW = (e, t, r, n, i, o) => {
      if (t != null && t[r] !== void 0) {
        let a = n();
        if (a.length <= 0)
          throw new Error(
            "Empty value provided for input HTTP label: " + r + ".",
          );
        e = e.replace(
          i,
          o
            ? a
                .split("/")
                .map((s) => PD(s))
                .join("/")
            : PD(a),
        );
      } else
        throw new Error("No value provided for input HTTP label: " + r + ".");
      return e;
    };
  });
function RC(e, t) {
  return new RD(e, t);
}
var xEe,
  RD,
  NEe = w(() => {
    c();
    xEe = A(Jr());
    nW();
    RD = class {
      constructor(t, r) {
        (this.input = t),
          (this.context = r),
          (this.query = {}),
          (this.method = ""),
          (this.headers = {}),
          (this.path = ""),
          (this.body = null),
          (this.hostname = ""),
          (this.resolvePathStack = []);
      }
      async build() {
        let {
          hostname: t,
          protocol: r = "https",
          port: n,
          path: i,
        } = await this.context.endpoint();
        this.path = i;
        for (let o of this.resolvePathStack) o(this.path);
        return new xEe.HttpRequest({
          protocol: r,
          hostname: this.hostname || t,
          port: n,
          method: this.method,
          path: this.path,
          query: this.query,
          body: this.body,
          headers: this.headers,
        });
      }
      hn(t) {
        return (this.hostname = t), this;
      }
      bp(t) {
        return (
          this.resolvePathStack.push((r) => {
            this.path = `${r?.endsWith("/") ? r.slice(0, -1) : r || ""}` + t;
          }),
          this
        );
      }
      p(t, r, n, i) {
        return (
          this.resolvePathStack.push((o) => {
            this.path = rW(o, this.input, t, r, n, i);
          }),
          this
        );
      }
      h(t) {
        return (this.headers = t), this;
      }
      q(t) {
        return (this.query = t), this;
      }
      b(t) {
        return (this.body = t), this;
      }
      m(t) {
        return (this.method = t), this;
      }
    };
  });
var kEe = {};
bn(kEe, {
  RequestBuilder: () => RD,
  collectBody: () => rBt,
  extendedEncodeURIComponent: () => PD,
  requestBuilder: () => RC,
  resolvedPath: () => rW,
});
var iW = w(() => {
  c();
  IEe();
  tW();
  NEe();
  nW();
});
var DEe = w(() => {
  c();
  iW();
});
function nBt(e, t, r) {
  e.__smithy_context
    ? e.__smithy_context.features || (e.__smithy_context.features = {})
    : (e.__smithy_context = { features: {} }),
    (e.__smithy_context.features[t] = r);
}
var LEe = w(() => {
  c();
});
var oh,
  MEe = w(() => {
    c();
    oh = class {
      constructor(t) {
        this.authSchemes = new Map();
        for (let [r, n] of Object.entries(t))
          n !== void 0 && this.authSchemes.set(r, n);
      }
      getIdentityProvider(t) {
        return this.authSchemes.get(t);
      }
    };
  });
var qEe,
  oW,
  aW,
  jEe = w(() => {
    c();
    (qEe = A(Jr())),
      (oW = A(ll())),
      (aW = class {
        async sign(t, r, n) {
          if (!n)
            throw new Error(
              "request could not be signed with `apiKey` since the `name` and `in` signer properties are missing",
            );
          if (!n.name)
            throw new Error(
              "request could not be signed with `apiKey` since the `name` signer property is missing",
            );
          if (!n.in)
            throw new Error(
              "request could not be signed with `apiKey` since the `in` signer property is missing",
            );
          if (!r.apiKey)
            throw new Error(
              "request could not be signed with `apiKey` since the `apiKey` is not defined",
            );
          let i = qEe.HttpRequest.clone(t);
          if (n.in === oW.HttpApiKeyAuthLocation.QUERY)
            i.query[n.name] = r.apiKey;
          else if (n.in === oW.HttpApiKeyAuthLocation.HEADER)
            i.headers[n.name] = n.scheme ? `${n.scheme} ${r.apiKey}` : r.apiKey;
          else
            throw new Error(
              "request can only be signed with `apiKey` locations `query` or `header`, but found: `" +
                n.in +
                "`",
            );
          return i;
        }
      });
  });
var FEe,
  sW,
  BEe = w(() => {
    c();
    (FEe = A(Jr())),
      (sW = class {
        async sign(t, r, n) {
          let i = FEe.HttpRequest.clone(t);
          if (!r.token)
            throw new Error(
              "request could not be signed with `token` since the `token` is not defined",
            );
          return (i.headers.Authorization = `Bearer ${r.token}`), i;
        }
      });
  });
var fl,
  UEe = w(() => {
    c();
    fl = class {
      async sign(t, r, n) {
        return t;
      }
    };
  });
var HEe = w(() => {
  c();
  jEe();
  BEe();
  UEe();
});
var GEe,
  iBt,
  cW,
  ID,
  uW,
  VEe = w(() => {
    c();
    (GEe = (e) => (t) => ID(t) && t.expiration.getTime() - Date.now() < e),
      (iBt = 3e5),
      (cW = GEe(3e5)),
      (ID = (e) => e.expiration !== void 0),
      (uW = (e, t, r) => {
        if (e === void 0) return;
        let n = typeof e != "function" ? async () => Promise.resolve(e) : e,
          i,
          o,
          a,
          s = !1,
          u = async (l) => {
            o || (o = n(l));
            try {
              (i = await o), (a = !0), (s = !1);
            } finally {
              o = void 0;
            }
            return i;
          };
        return t === void 0
          ? async (l) => ((!a || l?.forceRefresh) && (i = await u(l)), i)
          : async (l) => (
              (!a || l?.forceRefresh) && (i = await u(l)),
              s ? i : r(i) ? (t(i) && (await u(l)), i) : ((s = !0), i)
            );
      });
  });
var $Ee = w(() => {
  c();
  MEe();
  HEe();
  VEe();
});
var yf = {};
bn(yf, {
  DefaultIdentityProviderConfig: () => oh,
  EXPIRATION_MS: () => iBt,
  HttpApiKeyAuthSigner: () => aW,
  HttpBearerAuthSigner: () => sW,
  NoAuthSigner: () => fl,
  createIsIdentityExpiredFunction: () => GEe,
  createPaginator: () => a_e,
  doesIdentityRequireRefresh: () => ID,
  getHttpAuthSchemeEndpointRuleSetPlugin: () => TC,
  getHttpAuthSchemePlugin: () => xjt,
  getHttpSigningPlugin: () => AC,
  getSmithyContext: () => hjt,
  httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => Uye,
  httpAuthSchemeMiddleware: () => OC,
  httpAuthSchemeMiddlewareOptions: () => Xye,
  httpSigningMiddleware: () => P4,
  httpSigningMiddlewareOptions: () => r_e,
  isIdentityExpired: () => cW,
  memoizeIdentityProvider: () => uW,
  normalizeProvider: () => mf,
  requestBuilder: () => RC,
  setFeature: () => nBt,
});
var Gi = w(() => {
  c();
  kye();
  Zye();
  i_e();
  o_e();
  s_e();
  DEe();
  LEe();
  $Ee();
});
var By = g((ySn, ebe) => {
  c();
  var xD = Object.defineProperty,
    oBt = Object.getOwnPropertyDescriptor,
    aBt = Object.getOwnPropertyNames,
    sBt = Object.prototype.hasOwnProperty,
    tr = (e, t) => xD(e, "name", { value: t, configurable: !0 }),
    cBt = (e, t) => {
      for (var r in t) xD(e, r, { get: t[r], enumerable: !0 });
    },
    uBt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of aBt(t))
          !sBt.call(e, i) &&
            i !== r &&
            xD(e, i, {
              get: () => t[i],
              enumerable: !(n = oBt(t, i)) || n.enumerable,
            });
      return e;
    },
    lBt = (e) => uBt(xD({}, "__esModule", { value: !0 }), e),
    zEe = {};
  cBt(zEe, {
    EndpointCache: () => dBt,
    EndpointError: () => Io,
    customEndpointFunctions: () => dW,
    isIpAddress: () => KEe,
    isValidHostLabel: () => pW,
    resolveEndpoint: () => IBt,
  });
  ebe.exports = lBt(zEe);
  var dBt = class {
      constructor({ size: e, params: t }) {
        (this.data = new Map()),
          (this.parameters = []),
          (this.capacity = e ?? 50),
          t && (this.parameters = t);
      }
      static {
        tr(this, "EndpointCache");
      }
      get(e, t) {
        let r = this.hash(e);
        if (r === !1) return t();
        if (!this.data.has(r)) {
          if (this.data.size > this.capacity + 10) {
            let n = this.data.keys(),
              i = 0;
            for (;;) {
              let { value: o, done: a } = n.next();
              if ((this.data.delete(o), a || ++i > 10)) break;
            }
          }
          this.data.set(r, t());
        }
        return this.data.get(r);
      }
      size() {
        return this.data.size;
      }
      hash(e) {
        let t = "",
          { parameters: r } = this;
        if (r.length === 0) return !1;
        for (let n of r) {
          let i = String(e[n] ?? "");
          if (i.includes("|;")) return !1;
          t += i + "|;";
        }
        return t;
      }
    },
    fBt = new RegExp(
      "^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$",
    ),
    KEe = tr(
      (e) => fBt.test(e) || (e.startsWith("[") && e.endsWith("]")),
      "isIpAddress",
    ),
    pBt = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"),
    pW = tr((e, t = !1) => {
      if (!t) return pBt.test(e);
      let r = e.split(".");
      for (let n of r) if (!pW(n)) return !1;
      return !0;
    }, "isValidHostLabel"),
    dW = {},
    IC = "endpoints";
  function pl(e) {
    return typeof e != "object" || e == null
      ? e
      : "ref" in e
        ? `$${pl(e.ref)}`
        : "fn" in e
          ? `${e.fn}(${(e.argv || []).map(pl).join(", ")})`
          : JSON.stringify(e, null, 2);
  }
  tr(pl, "toDebugString");
  var Io = class extends Error {
      static {
        tr(this, "EndpointError");
      }
      constructor(e) {
        super(e), (this.name = "EndpointError");
      }
    },
    mBt = tr((e, t) => e === t, "booleanEquals"),
    hBt = tr((e) => {
      let t = e.split("."),
        r = [];
      for (let n of t) {
        let i = n.indexOf("[");
        if (i !== -1) {
          if (n.indexOf("]") !== n.length - 1)
            throw new Io(`Path: '${e}' does not end with ']'`);
          let o = n.slice(i + 1, -1);
          if (Number.isNaN(parseInt(o)))
            throw new Io(`Invalid array index: '${o}' in path: '${e}'`);
          i !== 0 && r.push(n.slice(0, i)), r.push(o);
        } else r.push(n);
      }
      return r;
    }, "getAttrPathList"),
    WEe = tr(
      (e, t) =>
        hBt(t).reduce((r, n) => {
          if (typeof r != "object")
            throw new Io(
              `Index '${n}' in '${t}' not found in '${JSON.stringify(e)}'`,
            );
          return Array.isArray(r) ? r[parseInt(n)] : r[n];
        }, e),
      "getAttr",
    ),
    gBt = tr((e) => e != null, "isSet"),
    vBt = tr((e) => !e, "not"),
    fW = ll(),
    lW = { [fW.EndpointURLScheme.HTTP]: 80, [fW.EndpointURLScheme.HTTPS]: 443 },
    yBt = tr((e) => {
      let t = (() => {
        try {
          if (e instanceof URL) return e;
          if (typeof e == "object" && "hostname" in e) {
            let {
                hostname: m,
                port: h,
                protocol: y = "",
                path: _ = "",
                query: E = {},
              } = e,
              b = new URL(`${y}//${m}${h ? `:${h}` : ""}${_}`);
            return (
              (b.search = Object.entries(E)
                .map(([O, C]) => `${O}=${C}`)
                .join("&")),
              b
            );
          }
          return new URL(e);
        } catch {
          return null;
        }
      })();
      if (!t)
        return (
          console.error(
            `Unable to parse ${JSON.stringify(e)} as a whatwg URL.`,
          ),
          null
        );
      let r = t.href,
        { host: n, hostname: i, pathname: o, protocol: a, search: s } = t;
      if (s) return null;
      let u = a.slice(0, -1);
      if (!Object.values(fW.EndpointURLScheme).includes(u)) return null;
      let l = KEe(i),
        d =
          r.includes(`${n}:${lW[u]}`) ||
          (typeof e == "string" && e.includes(`${n}:${lW[u]}`)),
        f = `${n}${d ? `:${lW[u]}` : ""}`;
      return {
        scheme: u,
        authority: f,
        path: o,
        normalizedPath: o.endsWith("/") ? o : `${o}/`,
        isIp: l,
      };
    }, "parseURL"),
    _Bt = tr((e, t) => e === t, "stringEquals"),
    EBt = tr(
      (e, t, r, n) =>
        t >= r || e.length < r
          ? null
          : n
            ? e.substring(e.length - r, e.length - t)
            : e.substring(t, r),
      "substring",
    ),
    bBt = tr(
      (e) =>
        encodeURIComponent(e).replace(
          /[!*'()]/g,
          (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`,
        ),
      "uriEncode",
    ),
    SBt = {
      booleanEquals: mBt,
      getAttr: WEe,
      isSet: gBt,
      isValidHostLabel: pW,
      not: vBt,
      parseURL: yBt,
      stringEquals: _Bt,
      substring: EBt,
      uriEncode: bBt,
    },
    QEe = tr((e, t) => {
      let r = [],
        n = { ...t.endpointParams, ...t.referenceRecord },
        i = 0;
      for (; i < e.length; ) {
        let o = e.indexOf("{", i);
        if (o === -1) {
          r.push(e.slice(i));
          break;
        }
        r.push(e.slice(i, o));
        let a = e.indexOf("}", o);
        if (a === -1) {
          r.push(e.slice(o));
          break;
        }
        e[o + 1] === "{" &&
          e[a + 1] === "}" &&
          (r.push(e.slice(o + 1, a)), (i = a + 2));
        let s = e.substring(o + 1, a);
        if (s.includes("#")) {
          let [u, l] = s.split("#");
          r.push(WEe(n[u], l));
        } else r.push(n[s]);
        i = a + 1;
      }
      return r.join("");
    }, "evaluateTemplate"),
    CBt = tr(
      ({ ref: e }, t) => ({ ...t.endpointParams, ...t.referenceRecord })[e],
      "getReferenceValue",
    ),
    ND = tr((e, t, r) => {
      if (typeof e == "string") return QEe(e, r);
      if (e.fn) return YEe(e, r);
      if (e.ref) return CBt(e, r);
      throw new Io(
        `'${t}': ${String(e)} is not a string, function or reference.`,
      );
    }, "evaluateExpression"),
    YEe = tr(({ fn: e, argv: t }, r) => {
      let n = t.map((o) =>
          ["boolean", "number"].includes(typeof o) ? o : ND(o, "arg", r),
        ),
        i = e.split(".");
      return i[0] in dW && i[1] != null ? dW[i[0]][i[1]](...n) : SBt[e](...n);
    }, "callFunction"),
    wBt = tr(({ assign: e, ...t }, r) => {
      if (e && e in r.referenceRecord)
        throw new Io(`'${e}' is already defined in Reference Record.`);
      let n = YEe(t, r);
      return (
        r.logger?.debug?.(`${IC} evaluateCondition: ${pl(t)} = ${pl(n)}`),
        {
          result: n === "" ? !0 : !!n,
          ...(e != null && { toAssign: { name: e, value: n } }),
        }
      );
    }, "evaluateCondition"),
    mW = tr((e = [], t) => {
      let r = {};
      for (let n of e) {
        let { result: i, toAssign: o } = wBt(n, {
          ...t,
          referenceRecord: { ...t.referenceRecord, ...r },
        });
        if (!i) return { result: i };
        o &&
          ((r[o.name] = o.value),
          t.logger?.debug?.(`${IC} assign: ${o.name} := ${pl(o.value)}`));
      }
      return { result: !0, referenceRecord: r };
    }, "evaluateConditions"),
    OBt = tr(
      (e, t) =>
        Object.entries(e).reduce(
          (r, [n, i]) => ({
            ...r,
            [n]: i.map((o) => {
              let a = ND(o, "Header value entry", t);
              if (typeof a != "string")
                throw new Io(`Header '${n}' value '${a}' is not a string`);
              return a;
            }),
          }),
          {},
        ),
      "getEndpointHeaders",
    ),
    XEe = tr((e, t) => {
      if (Array.isArray(e)) return e.map((r) => XEe(r, t));
      switch (typeof e) {
        case "string":
          return QEe(e, t);
        case "object":
          if (e === null) throw new Io(`Unexpected endpoint property: ${e}`);
          return JEe(e, t);
        case "boolean":
          return e;
        default:
          throw new Io(`Unexpected endpoint property type: ${typeof e}`);
      }
    }, "getEndpointProperty"),
    JEe = tr(
      (e, t) =>
        Object.entries(e).reduce((r, [n, i]) => ({ ...r, [n]: XEe(i, t) }), {}),
      "getEndpointProperties",
    ),
    TBt = tr((e, t) => {
      let r = ND(e, "Endpoint URL", t);
      if (typeof r == "string")
        try {
          return new URL(r);
        } catch (n) {
          throw (console.error(`Failed to construct URL with ${r}`, n), n);
        }
      throw new Io(`Endpoint URL must be a string, got ${typeof r}`);
    }, "getEndpointUrl"),
    ABt = tr((e, t) => {
      let { conditions: r, endpoint: n } = e,
        { result: i, referenceRecord: o } = mW(r, t);
      if (!i) return;
      let a = { ...t, referenceRecord: { ...t.referenceRecord, ...o } },
        { url: s, properties: u, headers: l } = n;
      return (
        t.logger?.debug?.(`${IC} Resolving endpoint from template: ${pl(n)}`),
        {
          ...(l != null && { headers: OBt(l, a) }),
          ...(u != null && { properties: JEe(u, a) }),
          url: TBt(s, a),
        }
      );
    }, "evaluateEndpointRule"),
    PBt = tr((e, t) => {
      let { conditions: r, error: n } = e,
        { result: i, referenceRecord: o } = mW(r, t);
      if (i)
        throw new Io(
          ND(n, "Error", {
            ...t,
            referenceRecord: { ...t.referenceRecord, ...o },
          }),
        );
    }, "evaluateErrorRule"),
    RBt = tr((e, t) => {
      let { conditions: r, rules: n } = e,
        { result: i, referenceRecord: o } = mW(r, t);
      if (i)
        return ZEe(n, {
          ...t,
          referenceRecord: { ...t.referenceRecord, ...o },
        });
    }, "evaluateTreeRule"),
    ZEe = tr((e, t) => {
      for (let r of e)
        if (r.type === "endpoint") {
          let n = ABt(r, t);
          if (n) return n;
        } else if (r.type === "error") PBt(r, t);
        else if (r.type === "tree") {
          let n = RBt(r, t);
          if (n) return n;
        } else throw new Io(`Unknown endpoint rule: ${r}`);
      throw new Io("Rules evaluation failed");
    }, "evaluateRules"),
    IBt = tr((e, t) => {
      let { endpointParams: r, logger: n } = t,
        { parameters: i, rules: o } = e;
      t.logger?.debug?.(`${IC} Initial EndpointParams: ${pl(r)}`);
      let a = Object.entries(i)
        .filter(([, l]) => l.default != null)
        .map(([l, d]) => [l, d.default]);
      if (a.length > 0) for (let [l, d] of a) r[l] = r[l] ?? d;
      let s = Object.entries(i)
        .filter(([, l]) => l.required)
        .map(([l]) => l);
      for (let l of s)
        if (r[l] == null) throw new Io(`Missing required parameter: '${l}'`);
      let u = ZEe(o, { endpointParams: r, logger: n, referenceRecord: {} });
      return t.logger?.debug?.(`${IC} Resolved endpoint: ${pl(u)}`), u;
    }, "resolveEndpoint");
});
var Hy = g((SSn, lbe) => {
  "use strict";
  c();
  var kD = Object.defineProperty,
    xBt = Object.getOwnPropertyDescriptor,
    NBt = Object.getOwnPropertyNames,
    kBt = Object.prototype.hasOwnProperty,
    Uy = (e, t) => kD(e, "name", { value: t, configurable: !0 }),
    DBt = (e, t) => {
      for (var r in t) kD(e, r, { get: t[r], enumerable: !0 });
    },
    LBt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of NBt(t))
          !kBt.call(e, i) &&
            i !== r &&
            kD(e, i, {
              get: () => t[i],
              enumerable: !(n = xBt(t, i)) || n.enumerable,
            });
      return e;
    },
    MBt = (e) => LBt(kD({}, "__esModule", { value: !0 }), e),
    rbe = {};
  DBt(rbe, {
    ConditionObject: () => Ar.ConditionObject,
    DeprecatedObject: () => Ar.DeprecatedObject,
    EndpointError: () => Ar.EndpointError,
    EndpointObject: () => Ar.EndpointObject,
    EndpointObjectHeaders: () => Ar.EndpointObjectHeaders,
    EndpointObjectProperties: () => Ar.EndpointObjectProperties,
    EndpointParams: () => Ar.EndpointParams,
    EndpointResolverOptions: () => Ar.EndpointResolverOptions,
    EndpointRuleObject: () => Ar.EndpointRuleObject,
    ErrorRuleObject: () => Ar.ErrorRuleObject,
    EvaluateOptions: () => Ar.EvaluateOptions,
    Expression: () => Ar.Expression,
    FunctionArgv: () => Ar.FunctionArgv,
    FunctionObject: () => Ar.FunctionObject,
    FunctionReturn: () => Ar.FunctionReturn,
    ParameterObject: () => Ar.ParameterObject,
    ReferenceObject: () => Ar.ReferenceObject,
    ReferenceRecord: () => Ar.ReferenceRecord,
    RuleSetObject: () => Ar.RuleSetObject,
    RuleSetRules: () => Ar.RuleSetRules,
    TreeRuleObject: () => Ar.TreeRuleObject,
    awsEndpointFunctions: () => ube,
    getUserAgentPrefix: () => BBt,
    isIpAddress: () => Ar.isIpAddress,
    partition: () => sbe,
    resolveEndpoint: () => Ar.resolveEndpoint,
    setPartitionInfo: () => cbe,
    useDefaultPartitionInfo: () => FBt,
  });
  lbe.exports = MBt(rbe);
  var Ar = By(),
    nbe = Uy((e, t = !1) => {
      if (t) {
        for (let r of e.split(".")) if (!nbe(r)) return !1;
        return !0;
      }
      return !(
        !(0, Ar.isValidHostLabel)(e) ||
        e.length < 3 ||
        e.length > 63 ||
        e !== e.toLowerCase() ||
        (0, Ar.isIpAddress)(e)
      );
    }, "isVirtualHostableS3Bucket"),
    tbe = ":",
    qBt = "/",
    jBt = Uy((e) => {
      let t = e.split(tbe);
      if (t.length < 6) return null;
      let [r, n, i, o, a, ...s] = t;
      if (r !== "arn" || n === "" || i === "" || s.join(tbe) === "")
        return null;
      let u = s.map((l) => l.split(qBt)).flat();
      return {
        partition: n,
        service: i,
        region: o,
        accountId: a,
        resourceId: u,
      };
    }, "parseArn"),
    ibe = {
      partitions: [
        {
          id: "aws",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-east-1",
            name: "aws",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
          regions: {
            "af-south-1": { description: "Africa (Cape Town)" },
            "ap-east-1": { description: "Asia Pacific (Hong Kong)" },
            "ap-northeast-1": { description: "Asia Pacific (Tokyo)" },
            "ap-northeast-2": { description: "Asia Pacific (Seoul)" },
            "ap-northeast-3": { description: "Asia Pacific (Osaka)" },
            "ap-south-1": { description: "Asia Pacific (Mumbai)" },
            "ap-south-2": { description: "Asia Pacific (Hyderabad)" },
            "ap-southeast-1": { description: "Asia Pacific (Singapore)" },
            "ap-southeast-2": { description: "Asia Pacific (Sydney)" },
            "ap-southeast-3": { description: "Asia Pacific (Jakarta)" },
            "ap-southeast-4": { description: "Asia Pacific (Melbourne)" },
            "ap-southeast-5": { description: "Asia Pacific (Malaysia)" },
            "ap-southeast-7": { description: "Asia Pacific (Thailand)" },
            "aws-global": { description: "AWS Standard global region" },
            "ca-central-1": { description: "Canada (Central)" },
            "ca-west-1": { description: "Canada West (Calgary)" },
            "eu-central-1": { description: "Europe (Frankfurt)" },
            "eu-central-2": { description: "Europe (Zurich)" },
            "eu-north-1": { description: "Europe (Stockholm)" },
            "eu-south-1": { description: "Europe (Milan)" },
            "eu-south-2": { description: "Europe (Spain)" },
            "eu-west-1": { description: "Europe (Ireland)" },
            "eu-west-2": { description: "Europe (London)" },
            "eu-west-3": { description: "Europe (Paris)" },
            "il-central-1": { description: "Israel (Tel Aviv)" },
            "me-central-1": { description: "Middle East (UAE)" },
            "me-south-1": { description: "Middle East (Bahrain)" },
            "mx-central-1": { description: "Mexico (Central)" },
            "sa-east-1": { description: "South America (Sao Paulo)" },
            "us-east-1": { description: "US East (N. Virginia)" },
            "us-east-2": { description: "US East (Ohio)" },
            "us-west-1": { description: "US West (N. California)" },
            "us-west-2": { description: "US West (Oregon)" },
          },
        },
        {
          id: "aws-cn",
          outputs: {
            dnsSuffix: "amazonaws.com.cn",
            dualStackDnsSuffix: "api.amazonwebservices.com.cn",
            implicitGlobalRegion: "cn-northwest-1",
            name: "aws-cn",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^cn\\-\\w+\\-\\d+$",
          regions: {
            "aws-cn-global": { description: "AWS China global region" },
            "cn-north-1": { description: "China (Beijing)" },
            "cn-northwest-1": { description: "China (Ningxia)" },
          },
        },
        {
          id: "aws-us-gov",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-gov-west-1",
            name: "aws-us-gov",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
          regions: {
            "aws-us-gov-global": {
              description: "AWS GovCloud (US) global region",
            },
            "us-gov-east-1": { description: "AWS GovCloud (US-East)" },
            "us-gov-west-1": { description: "AWS GovCloud (US-West)" },
          },
        },
        {
          id: "aws-iso",
          outputs: {
            dnsSuffix: "c2s.ic.gov",
            dualStackDnsSuffix: "c2s.ic.gov",
            implicitGlobalRegion: "us-iso-east-1",
            name: "aws-iso",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-global": { description: "AWS ISO (US) global region" },
            "us-iso-east-1": { description: "US ISO East" },
            "us-iso-west-1": { description: "US ISO WEST" },
          },
        },
        {
          id: "aws-iso-b",
          outputs: {
            dnsSuffix: "sc2s.sgov.gov",
            dualStackDnsSuffix: "sc2s.sgov.gov",
            implicitGlobalRegion: "us-isob-east-1",
            name: "aws-iso-b",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-b-global": { description: "AWS ISOB (US) global region" },
            "us-isob-east-1": { description: "US ISOB East (Ohio)" },
          },
        },
        {
          id: "aws-iso-e",
          outputs: {
            dnsSuffix: "cloud.adc-e.uk",
            dualStackDnsSuffix: "cloud.adc-e.uk",
            implicitGlobalRegion: "eu-isoe-west-1",
            name: "aws-iso-e",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-e-global": {
              description: "AWS ISOE (Europe) global region",
            },
            "eu-isoe-west-1": { description: "EU ISOE West" },
          },
        },
        {
          id: "aws-iso-f",
          outputs: {
            dnsSuffix: "csp.hci.ic.gov",
            dualStackDnsSuffix: "csp.hci.ic.gov",
            implicitGlobalRegion: "us-isof-south-1",
            name: "aws-iso-f",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-f-global": { description: "AWS ISOF global region" },
            "us-isof-east-1": { description: "US ISOF EAST" },
            "us-isof-south-1": { description: "US ISOF SOUTH" },
          },
        },
        {
          id: "aws-eusc",
          outputs: {
            dnsSuffix: "amazonaws.eu",
            dualStackDnsSuffix: "amazonaws.eu",
            implicitGlobalRegion: "eusc-de-east-1",
            name: "aws-eusc",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
          regions: { "eusc-de-east-1": { description: "EU (Germany)" } },
        },
      ],
      version: "1.1",
    },
    obe = ibe,
    abe = "",
    sbe = Uy((e) => {
      let { partitions: t } = obe;
      for (let n of t) {
        let { regions: i, outputs: o } = n;
        for (let [a, s] of Object.entries(i))
          if (a === e) return { ...o, ...s };
      }
      for (let n of t) {
        let { regionRegex: i, outputs: o } = n;
        if (new RegExp(i).test(e)) return { ...o };
      }
      let r = t.find((n) => n.id === "aws");
      if (!r)
        throw new Error(
          "Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.",
        );
      return { ...r.outputs };
    }, "partition"),
    cbe = Uy((e, t = "") => {
      (obe = e), (abe = t);
    }, "setPartitionInfo"),
    FBt = Uy(() => {
      cbe(ibe, "");
    }, "useDefaultPartitionInfo"),
    BBt = Uy(() => abe, "getUserAgentPrefix"),
    ube = { isVirtualHostableS3Bucket: nbe, parseArn: jBt, partition: sbe };
  Ar.customEndpointFunctions.aws = ube;
});
var DD,
  Gy,
  dbe = w(() => {
    c();
    (DD = { warningEmitted: !1 }),
      (Gy = (e) => {
        e &&
          !DD.warningEmitted &&
          parseInt(e.substring(1, e.indexOf("."))) < 18 &&
          ((DD.warningEmitted = !0),
          process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`));
      });
  });
function _f(e, t, r) {
  return e.$source || (e.$source = {}), (e.$source[t] = r), e;
}
var fbe = w(() => {
  c();
});
function pbe(e, t, r) {
  e.__aws_sdk_context
    ? e.__aws_sdk_context.features || (e.__aws_sdk_context.features = {})
    : (e.__aws_sdk_context = { features: {} }),
    (e.__aws_sdk_context.features[t] = r);
}
var mbe = w(() => {
  c();
});
var Ef = {};
bn(Ef, {
  emitWarningIfUnsupportedVersion: () => Gy,
  setCredentialFeature: () => _f,
  setFeature: () => pbe,
  state: () => DD,
});
var Ks = w(() => {
  c();
  dbe();
  fbe();
  mbe();
});
var hbe,
  hW,
  gbe = w(() => {
    c();
    (hbe = A(Jr())),
      (hW = (e) =>
        hbe.HttpResponse.isInstance(e)
          ? (e.headers?.date ?? e.headers?.Date)
          : void 0);
  });
var Vy,
  gW = w(() => {
    c();
    Vy = (e) => new Date(Date.now() + e);
  });
var vbe,
  ybe = w(() => {
    c();
    gW();
    vbe = (e, t) => Math.abs(Vy(t).getTime() - e) >= 3e5;
  });
var vW,
  _be = w(() => {
    c();
    ybe();
    vW = (e, t) => {
      let r = Date.parse(e);
      return vbe(r, t) ? r - Date.now() : t;
    };
  });
var yW = w(() => {
  c();
  gbe();
  gW();
  _be();
});
var Ebe,
  xC,
  NC,
  da,
  bbe,
  _W = w(() => {
    c();
    Ebe = A(Jr());
    yW();
    (xC = (e, t) => {
      if (!t)
        throw new Error(
          `Property \`${e}\` is not resolved for AWS SDK SigV4Auth`,
        );
      return t;
    }),
      (NC = async (e) => {
        let t = xC("context", e.context),
          r = xC("config", e.config),
          n = t.endpointV2?.properties?.authSchemes?.[0],
          o = await xC("signer", r.signer)(n),
          a = e?.signingRegion,
          s = e?.signingRegionSet,
          u = e?.signingName;
        return {
          config: r,
          signer: o,
          signingRegion: a,
          signingRegionSet: s,
          signingName: u,
        };
      }),
      (da = class {
        async sign(t, r, n) {
          if (!Ebe.HttpRequest.isInstance(t))
            throw new Error(
              "The request is not an instance of `HttpRequest` and cannot be signed",
            );
          let i = await NC(n),
            { config: o, signer: a } = i,
            { signingRegion: s, signingName: u } = i,
            l = n.context;
          if (l?.authSchemes?.length ?? !1) {
            let [f, m] = l.authSchemes;
            f?.name === "sigv4a" &&
              m?.name === "sigv4" &&
              ((s = m?.signingRegion ?? s), (u = m?.signingName ?? u));
          }
          return await a.sign(t, {
            signingDate: Vy(o.systemClockOffset),
            signingRegion: s,
            signingService: u,
          });
        }
        errorHandler(t) {
          return (r) => {
            let n = r.ServerTime ?? hW(r.$response);
            if (n) {
              let i = xC("config", t.config),
                o = i.systemClockOffset;
              (i.systemClockOffset = vW(n, i.systemClockOffset)),
                i.systemClockOffset !== o &&
                  r.$metadata &&
                  (r.$metadata.clockSkewCorrected = !0);
            }
            throw r;
          };
        }
        successHandler(t, r) {
          let n = hW(t);
          if (n) {
            let i = xC("config", r.config);
            i.systemClockOffset = vW(n, i.systemClockOffset);
          }
        }
      }),
      (bbe = da);
  });
var Sbe,
  LD,
  Cbe = w(() => {
    c();
    Sbe = A(Jr());
    yW();
    _W();
    LD = class extends da {
      async sign(t, r, n) {
        if (!Sbe.HttpRequest.isInstance(t))
          throw new Error(
            "The request is not an instance of `HttpRequest` and cannot be signed",
          );
        let {
            config: i,
            signer: o,
            signingRegion: a,
            signingRegionSet: s,
            signingName: u,
          } = await NC(n),
          d = ((await i.sigv4aSigningRegionSet?.()) ?? s ?? [a]).join(",");
        return await o.sign(t, {
          signingDate: Vy(i.systemClockOffset),
          signingRegion: d,
          signingService: u,
        });
      }
    };
  });
var EW,
  wbe = w(() => {
    c();
    EW = (e) =>
      typeof e == "string" && e.length > 0
        ? e.split(",").map((t) => t.trim())
        : [];
  });
var Obe,
  Tbe,
  kC,
  Abe = w(() => {
    c();
    wbe();
    (Obe = "AWS_AUTH_SCHEME_PREFERENCE"),
      (Tbe = "auth_scheme_preference"),
      (kC = {
        environmentVariableSelector: (e) => {
          if (Obe in e) return EW(e[Obe]);
        },
        configFileSelector: (e) => {
          if (Tbe in e) return EW(e[Tbe]);
        },
        default: [],
      });
  });
var xo = g((s0n, Nbe) => {
  c();
  var MD = Object.defineProperty,
    UBt = Object.getOwnPropertyDescriptor,
    HBt = Object.getOwnPropertyNames,
    GBt = Object.prototype.hasOwnProperty,
    ah = (e, t) => MD(e, "name", { value: t, configurable: !0 }),
    VBt = (e, t) => {
      for (var r in t) MD(e, r, { get: t[r], enumerable: !0 });
    },
    $Bt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of HBt(t))
          !GBt.call(e, i) &&
            i !== r &&
            MD(e, i, {
              get: () => t[i],
              enumerable: !(n = UBt(t, i)) || n.enumerable,
            });
      return e;
    },
    zBt = (e) => $Bt(MD({}, "__esModule", { value: !0 }), e),
    Pbe = {};
  VBt(Pbe, {
    CredentialsProviderError: () => KBt,
    ProviderError: () => qD,
    TokenProviderError: () => WBt,
    chain: () => QBt,
    fromStatic: () => YBt,
    memoize: () => XBt,
  });
  Nbe.exports = zBt(Pbe);
  var qD = class Rbe extends Error {
      constructor(t, r = !0) {
        let n,
          i = !0;
        typeof r == "boolean"
          ? ((n = void 0), (i = r))
          : r != null &&
            typeof r == "object" &&
            ((n = r.logger), (i = r.tryNextLink ?? !0)),
          super(t),
          (this.name = "ProviderError"),
          (this.tryNextLink = i),
          Object.setPrototypeOf(this, Rbe.prototype),
          n?.debug?.(`@smithy/property-provider ${i ? "->" : "(!)"} ${t}`);
      }
      static {
        ah(this, "ProviderError");
      }
      static from(t, r = !0) {
        return Object.assign(new this(t.message, r), t);
      }
    },
    KBt = class Ibe extends qD {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "CredentialsProviderError"),
          Object.setPrototypeOf(this, Ibe.prototype);
      }
      static {
        ah(this, "CredentialsProviderError");
      }
    },
    WBt = class xbe extends qD {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "TokenProviderError"),
          Object.setPrototypeOf(this, xbe.prototype);
      }
      static {
        ah(this, "TokenProviderError");
      }
    },
    QBt = ah(
      (...e) =>
        async () => {
          if (e.length === 0) throw new qD("No providers in chain");
          let t;
          for (let r of e)
            try {
              return await r();
            } catch (n) {
              if (((t = n), n?.tryNextLink)) continue;
              throw n;
            }
          throw t;
        },
      "chain",
    ),
    YBt = ah((e) => () => Promise.resolve(e), "fromStatic"),
    XBt = ah((e, t, r) => {
      let n,
        i,
        o,
        a = !1,
        s = ah(async () => {
          i || (i = e());
          try {
            (n = await i), (o = !0), (a = !1);
          } finally {
            i = void 0;
          }
          return n;
        }, "coalesceProvider");
      return t === void 0
        ? async (u) => ((!o || u?.forceRefresh) && (n = await s()), n)
        : async (u) => (
            (!o || u?.forceRefresh) && (n = await s()),
            a ? n : r && !r(n) ? ((a = !0), n) : (t(n) && (await s()), n)
          );
    }, "memoize");
});
var bW,
  JBt,
  ZBt,
  kbe = w(() => {
    c();
    Gi();
    (bW = A(xo())),
      (JBt = (e) => (
        (e.sigv4aSigningRegionSet = mf(e.sigv4aSigningRegionSet)), e
      )),
      (ZBt = {
        environmentVariableSelector(e) {
          if (e.AWS_SIGV4A_SIGNING_REGION_SET)
            return e.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((t) =>
              t.trim(),
            );
          throw new bW.ProviderError(
            "AWS_SIGV4A_SIGNING_REGION_SET not set in env.",
            { tryNextLink: !0 },
          );
        },
        configFileSelector(e) {
          if (e.sigv4a_signing_region_set)
            return (e.sigv4a_signing_region_set ?? "")
              .split(",")
              .map((t) => t.trim());
          throw new bW.ProviderError(
            "sigv4a_signing_region_set not set in profile.",
            { tryNextLink: !0 },
          );
        },
        default: void 0,
      });
  });
var cSe = g((f0n, sSe) => {
  c();
  var VD = Object.defineProperty,
    eUt = Object.getOwnPropertyDescriptor,
    tUt = Object.getOwnPropertyNames,
    rUt = Object.prototype.hasOwnProperty,
    Ei = (e, t) => VD(e, "name", { value: t, configurable: !0 }),
    nUt = (e, t) => {
      for (var r in t) VD(e, r, { get: t[r], enumerable: !0 });
    },
    iUt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of tUt(t))
          !rUt.call(e, i) &&
            i !== r &&
            VD(e, i, {
              get: () => t[i],
              enumerable: !(n = eUt(t, i)) || n.enumerable,
            });
      return e;
    },
    oUt = (e) => iUt(VD({}, "__esModule", { value: !0 }), e),
    jbe = {};
  nUt(jbe, {
    ALGORITHM_IDENTIFIER: () => jD,
    ALGORITHM_IDENTIFIER_V4A: () => uUt,
    ALGORITHM_QUERY_PARAM: () => Fbe,
    ALWAYS_UNSIGNABLE_HEADERS: () => Kbe,
    AMZ_DATE_HEADER: () => RW,
    AMZ_DATE_QUERY_PARAM: () => OW,
    AUTH_HEADER: () => PW,
    CREDENTIAL_QUERY_PARAM: () => Bbe,
    DATE_HEADER: () => Gbe,
    EVENT_ALGORITHM_IDENTIFIER: () => Ybe,
    EXPIRES_QUERY_PARAM: () => Hbe,
    GENERATED_HEADERS: () => Vbe,
    HOST_HEADER: () => sUt,
    KEY_TYPE_IDENTIFIER: () => IW,
    MAX_CACHE_SIZE: () => Jbe,
    MAX_PRESIGNED_TTL: () => Zbe,
    PROXY_HEADER_PATTERN: () => Wbe,
    REGION_SET_PARAM: () => aUt,
    SEC_HEADER_PATTERN: () => Qbe,
    SHA256_HEADER: () => GD,
    SIGNATURE_HEADER: () => $be,
    SIGNATURE_QUERY_PARAM: () => TW,
    SIGNED_HEADERS_QUERY_PARAM: () => Ube,
    SignatureV4: () => EUt,
    SignatureV4Base: () => aSe,
    TOKEN_HEADER: () => zbe,
    TOKEN_QUERY_PARAM: () => AW,
    UNSIGNABLE_PATTERNS: () => cUt,
    UNSIGNED_PAYLOAD: () => Xbe,
    clearCredentialCache: () => dUt,
    createScope: () => BD,
    getCanonicalHeaders: () => SW,
    getCanonicalQuery: () => oSe,
    getPayloadHash: () => UD,
    getSigningKey: () => eSe,
    hasHeader: () => rSe,
    moveHeadersToQuery: () => iSe,
    prepareRequest: () => wW,
    signatureV4aContainer: () => bUt,
  });
  sSe.exports = oUt(jbe);
  var Dbe = Fe(),
    Fbe = "X-Amz-Algorithm",
    Bbe = "X-Amz-Credential",
    OW = "X-Amz-Date",
    Ube = "X-Amz-SignedHeaders",
    Hbe = "X-Amz-Expires",
    TW = "X-Amz-Signature",
    AW = "X-Amz-Security-Token",
    aUt = "X-Amz-Region-Set",
    PW = "authorization",
    RW = OW.toLowerCase(),
    Gbe = "date",
    Vbe = [PW, RW, Gbe],
    $be = TW.toLowerCase(),
    GD = "x-amz-content-sha256",
    zbe = AW.toLowerCase(),
    sUt = "host",
    Kbe = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0,
    },
    Wbe = /^proxy-/,
    Qbe = /^sec-/,
    cUt = [/^proxy-/i, /^sec-/i],
    jD = "AWS4-HMAC-SHA256",
    uUt = "AWS4-ECDSA-P256-SHA256",
    Ybe = "AWS4-HMAC-SHA256-PAYLOAD",
    Xbe = "UNSIGNED-PAYLOAD",
    Jbe = 50,
    IW = "aws4_request",
    Zbe = 60 * 60 * 24 * 7,
    bf = zs(),
    lUt = Fe(),
    $y = {},
    FD = [],
    BD = Ei((e, t, r) => `${e}/${t}/${r}/${IW}`, "createScope"),
    eSe = Ei(async (e, t, r, n, i) => {
      let o = await Lbe(e, t.secretAccessKey, t.accessKeyId),
        a = `${r}:${n}:${i}:${(0, bf.toHex)(o)}:${t.sessionToken}`;
      if (a in $y) return $y[a];
      for (FD.push(a); FD.length > Jbe; ) delete $y[FD.shift()];
      let s = `AWS4${t.secretAccessKey}`;
      for (let u of [r, n, i, IW]) s = await Lbe(e, s, u);
      return ($y[a] = s);
    }, "getSigningKey"),
    dUt = Ei(() => {
      (FD.length = 0),
        Object.keys($y).forEach((e) => {
          delete $y[e];
        });
    }, "clearCredentialCache"),
    Lbe = Ei((e, t, r) => {
      let n = new e(t);
      return n.update((0, lUt.toUint8Array)(r)), n.digest();
    }, "hmac"),
    SW = Ei(({ headers: e }, t, r) => {
      let n = {};
      for (let i of Object.keys(e).sort()) {
        if (e[i] == null) continue;
        let o = i.toLowerCase();
        ((o in Kbe || t?.has(o) || Wbe.test(o) || Qbe.test(o)) &&
          (!r || (r && !r.has(o)))) ||
          (n[o] = e[i].trim().replace(/\s+/g, " "));
      }
      return n;
    }, "getCanonicalHeaders"),
    fUt = hf(),
    pUt = Fe(),
    UD = Ei(async ({ headers: e, body: t }, r) => {
      for (let n of Object.keys(e)) if (n.toLowerCase() === GD) return e[n];
      if (t == null)
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      if (
        typeof t == "string" ||
        ArrayBuffer.isView(t) ||
        (0, fUt.isArrayBuffer)(t)
      ) {
        let n = new r();
        return (
          n.update((0, pUt.toUint8Array)(t)), (0, bf.toHex)(await n.digest())
        );
      }
      return Xbe;
    }, "getPayloadHash"),
    Mbe = Fe(),
    mUt = class {
      static {
        Ei(this, "HeaderFormatter");
      }
      format(e) {
        let t = [];
        for (let i of Object.keys(e)) {
          let o = (0, Mbe.fromUtf8)(i);
          t.push(
            Uint8Array.from([o.byteLength]),
            o,
            this.formatHeaderValue(e[i]),
          );
        }
        let r = new Uint8Array(t.reduce((i, o) => i + o.byteLength, 0)),
          n = 0;
        for (let i of t) r.set(i, n), (n += i.byteLength);
        return r;
      }
      formatHeaderValue(e) {
        switch (e.type) {
          case "boolean":
            return Uint8Array.from([e.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, e.value]);
          case "short":
            let t = new DataView(new ArrayBuffer(3));
            return (
              t.setUint8(0, 3),
              t.setInt16(1, e.value, !1),
              new Uint8Array(t.buffer)
            );
          case "integer":
            let r = new DataView(new ArrayBuffer(5));
            return (
              r.setUint8(0, 4),
              r.setInt32(1, e.value, !1),
              new Uint8Array(r.buffer)
            );
          case "long":
            let n = new Uint8Array(9);
            return (n[0] = 5), n.set(e.value.bytes, 1), n;
          case "binary":
            let i = new DataView(new ArrayBuffer(3 + e.value.byteLength));
            i.setUint8(0, 6), i.setUint16(1, e.value.byteLength, !1);
            let o = new Uint8Array(i.buffer);
            return o.set(e.value, 3), o;
          case "string":
            let a = (0, Mbe.fromUtf8)(e.value),
              s = new DataView(new ArrayBuffer(3 + a.byteLength));
            s.setUint8(0, 7), s.setUint16(1, a.byteLength, !1);
            let u = new Uint8Array(s.buffer);
            return u.set(a, 3), u;
          case "timestamp":
            let l = new Uint8Array(9);
            return (
              (l[0] = 8), l.set(gUt.fromNumber(e.value.valueOf()).bytes, 1), l
            );
          case "uuid":
            if (!hUt.test(e.value))
              throw new Error(`Invalid UUID received: ${e.value}`);
            let d = new Uint8Array(17);
            return (
              (d[0] = 9),
              d.set((0, bf.fromHex)(e.value.replace(/\-/g, "")), 1),
              d
            );
        }
      }
    },
    hUt = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    gUt = class tSe {
      constructor(t) {
        if (((this.bytes = t), t.byteLength !== 8))
          throw new Error("Int64 buffers must be exactly 8 bytes");
      }
      static {
        Ei(this, "Int64");
      }
      static fromNumber(t) {
        if (t > 9223372036854776e3 || t < -9223372036854776e3)
          throw new Error(
            `${t} is too large (or, if negative, too small) to represent as an Int64`,
          );
        let r = new Uint8Array(8);
        for (
          let n = 7, i = Math.abs(Math.round(t));
          n > -1 && i > 0;
          n--, i /= 256
        )
          r[n] = i;
        return t < 0 && CW(r), new tSe(r);
      }
      valueOf() {
        let t = this.bytes.slice(0),
          r = t[0] & 128;
        return r && CW(t), parseInt((0, bf.toHex)(t), 16) * (r ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  function CW(e) {
    for (let t = 0; t < 8; t++) e[t] ^= 255;
    for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
  }
  Ei(CW, "negate");
  var rSe = Ei((e, t) => {
      e = e.toLowerCase();
      for (let r of Object.keys(t)) if (e === r.toLowerCase()) return !0;
      return !1;
    }, "hasHeader"),
    nSe = Jr(),
    iSe = Ei((e, t = {}) => {
      let { headers: r, query: n = {} } = nSe.HttpRequest.clone(e);
      for (let i of Object.keys(r)) {
        let o = i.toLowerCase();
        ((o.slice(0, 6) === "x-amz-" && !t.unhoistableHeaders?.has(o)) ||
          t.hoistableHeaders?.has(o)) &&
          ((n[i] = r[i]), delete r[i]);
      }
      return { ...e, headers: r, query: n };
    }, "moveHeadersToQuery"),
    wW = Ei((e) => {
      e = nSe.HttpRequest.clone(e);
      for (let t of Object.keys(e.headers))
        Vbe.indexOf(t.toLowerCase()) > -1 && delete e.headers[t];
      return e;
    }, "prepareRequest"),
    qbe = $s(),
    vUt = Fe(),
    HD = U4(),
    oSe = Ei(({ query: e = {} }) => {
      let t = [],
        r = {};
      for (let n of Object.keys(e)) {
        if (n.toLowerCase() === $be) continue;
        let i = (0, HD.escapeUri)(n);
        t.push(i);
        let o = e[n];
        typeof o == "string"
          ? (r[i] = `${i}=${(0, HD.escapeUri)(o)}`)
          : Array.isArray(o) &&
            (r[i] = o
              .slice(0)
              .reduce((a, s) => a.concat([`${i}=${(0, HD.escapeUri)(s)}`]), [])
              .sort()
              .join("&"));
      }
      return t
        .sort()
        .map((n) => r[n])
        .filter((n) => n)
        .join("&");
    }, "getCanonicalQuery"),
    yUt = Ei(
      (e) =>
        _Ut(e)
          .toISOString()
          .replace(/\.\d{3}Z$/, "Z"),
      "iso8601",
    ),
    _Ut = Ei(
      (e) =>
        typeof e == "number"
          ? new Date(e * 1e3)
          : typeof e == "string"
            ? Number(e)
              ? new Date(Number(e) * 1e3)
              : new Date(e)
            : e,
      "toDate",
    ),
    aSe = class {
      static {
        Ei(this, "SignatureV4Base");
      }
      constructor({
        applyChecksum: e,
        credentials: t,
        region: r,
        service: n,
        sha256: i,
        uriEscapePath: o = !0,
      }) {
        (this.service = n),
          (this.sha256 = i),
          (this.uriEscapePath = o),
          (this.applyChecksum = typeof e == "boolean" ? e : !0),
          (this.regionProvider = (0, qbe.normalizeProvider)(r)),
          (this.credentialProvider = (0, qbe.normalizeProvider)(t));
      }
      createCanonicalRequest(e, t, r) {
        let n = Object.keys(t).sort();
        return `${e.method}
${this.getCanonicalPath(e)}
${oSe(e)}
${n.map((i) => `${i}:${t[i]}`).join(`
`)}

${n.join(";")}
${r}`;
      }
      async createStringToSign(e, t, r, n) {
        let i = new this.sha256();
        i.update((0, vUt.toUint8Array)(r));
        let o = await i.digest();
        return `${n}
${e}
${t}
${(0, bf.toHex)(o)}`;
      }
      getCanonicalPath({ path: e }) {
        if (this.uriEscapePath) {
          let t = [];
          for (let i of e.split("/"))
            i?.length !== 0 && i !== "." && (i === ".." ? t.pop() : t.push(i));
          let r = `${e?.startsWith("/") ? "/" : ""}${t.join("/")}${t.length > 0 && e?.endsWith("/") ? "/" : ""}`;
          return (0, HD.escapeUri)(r).replace(/%2F/g, "/");
        }
        return e;
      }
      validateResolvedCredentials(e) {
        if (
          typeof e != "object" ||
          typeof e.accessKeyId != "string" ||
          typeof e.secretAccessKey != "string"
        )
          throw new Error("Resolved credential object is not valid");
      }
      formatDate(e) {
        let t = yUt(e).replace(/[\-:]/g, "");
        return { longDate: t, shortDate: t.slice(0, 8) };
      }
      getCanonicalHeaderList(e) {
        return Object.keys(e).sort().join(";");
      }
    },
    EUt = class extends aSe {
      constructor({
        applyChecksum: e,
        credentials: t,
        region: r,
        service: n,
        sha256: i,
        uriEscapePath: o = !0,
      }) {
        super({
          applyChecksum: e,
          credentials: t,
          region: r,
          service: n,
          sha256: i,
          uriEscapePath: o,
        }),
          (this.headerFormatter = new mUt());
      }
      static {
        Ei(this, "SignatureV4");
      }
      async presign(e, t = {}) {
        let {
            signingDate: r = new Date(),
            expiresIn: n = 3600,
            unsignableHeaders: i,
            unhoistableHeaders: o,
            signableHeaders: a,
            hoistableHeaders: s,
            signingRegion: u,
            signingService: l,
          } = t,
          d = await this.credentialProvider();
        this.validateResolvedCredentials(d);
        let f = u ?? (await this.regionProvider()),
          { longDate: m, shortDate: h } = this.formatDate(r);
        if (n > Zbe)
          return Promise.reject(
            "Signature version 4 presigned URLs must have an expiration date less than one week in the future",
          );
        let y = BD(h, f, l ?? this.service),
          _ = iSe(wW(e), { unhoistableHeaders: o, hoistableHeaders: s });
        d.sessionToken && (_.query[AW] = d.sessionToken),
          (_.query[Fbe] = jD),
          (_.query[Bbe] = `${d.accessKeyId}/${y}`),
          (_.query[OW] = m),
          (_.query[Hbe] = n.toString(10));
        let E = SW(_, i, a);
        return (
          (_.query[Ube] = this.getCanonicalHeaderList(E)),
          (_.query[TW] = await this.getSignature(
            m,
            y,
            this.getSigningKey(d, f, h, l),
            this.createCanonicalRequest(_, E, await UD(e, this.sha256)),
          )),
          _
        );
      }
      async sign(e, t) {
        return typeof e == "string"
          ? this.signString(e, t)
          : e.headers && e.payload
            ? this.signEvent(e, t)
            : e.message
              ? this.signMessage(e, t)
              : this.signRequest(e, t);
      }
      async signEvent(
        { headers: e, payload: t },
        {
          signingDate: r = new Date(),
          priorSignature: n,
          signingRegion: i,
          signingService: o,
        },
      ) {
        let a = i ?? (await this.regionProvider()),
          { shortDate: s, longDate: u } = this.formatDate(r),
          l = BD(s, a, o ?? this.service),
          d = await UD({ headers: {}, body: t }, this.sha256),
          f = new this.sha256();
        f.update(e);
        let m = (0, bf.toHex)(await f.digest()),
          h = [Ybe, u, l, n, m, d].join(`
`);
        return this.signString(h, {
          signingDate: r,
          signingRegion: a,
          signingService: o,
        });
      }
      async signMessage(
        e,
        { signingDate: t = new Date(), signingRegion: r, signingService: n },
      ) {
        return this.signEvent(
          {
            headers: this.headerFormatter.format(e.message.headers),
            payload: e.message.body,
          },
          {
            signingDate: t,
            signingRegion: r,
            signingService: n,
            priorSignature: e.priorSignature,
          },
        ).then((o) => ({ message: e.message, signature: o }));
      }
      async signString(
        e,
        {
          signingDate: t = new Date(),
          signingRegion: r,
          signingService: n,
        } = {},
      ) {
        let i = await this.credentialProvider();
        this.validateResolvedCredentials(i);
        let o = r ?? (await this.regionProvider()),
          { shortDate: a } = this.formatDate(t),
          s = new this.sha256(await this.getSigningKey(i, o, a, n));
        return (
          s.update((0, Dbe.toUint8Array)(e)), (0, bf.toHex)(await s.digest())
        );
      }
      async signRequest(
        e,
        {
          signingDate: t = new Date(),
          signableHeaders: r,
          unsignableHeaders: n,
          signingRegion: i,
          signingService: o,
        } = {},
      ) {
        let a = await this.credentialProvider();
        this.validateResolvedCredentials(a);
        let s = i ?? (await this.regionProvider()),
          u = wW(e),
          { longDate: l, shortDate: d } = this.formatDate(t),
          f = BD(d, s, o ?? this.service);
        (u.headers[RW] = l),
          a.sessionToken && (u.headers[zbe] = a.sessionToken);
        let m = await UD(u, this.sha256);
        !rSe(GD, u.headers) && this.applyChecksum && (u.headers[GD] = m);
        let h = SW(u, n, r),
          y = await this.getSignature(
            l,
            f,
            this.getSigningKey(a, s, d, o),
            this.createCanonicalRequest(u, h, m),
          );
        return (
          (u.headers[PW] =
            `${jD} Credential=${a.accessKeyId}/${f}, SignedHeaders=${this.getCanonicalHeaderList(h)}, Signature=${y}`),
          u
        );
      }
      async getSignature(e, t, r, n) {
        let i = await this.createStringToSign(e, t, n, jD),
          o = new this.sha256(await r);
        return (
          o.update((0, Dbe.toUint8Array)(i)), (0, bf.toHex)(await o.digest())
        );
      }
      getSigningKey(e, t, r, n) {
        return eSe(this.sha256, e, r, t, n || this.service);
      }
    },
    bUt = { SignatureV4a: null };
});
function CUt(e, { credentials: t, credentialDefaultProvider: r }) {
  let n;
  return (
    t
      ? t?.memoized
        ? (n = t)
        : (n = uW(t, cW, ID))
      : r
        ? (n = mf(r(Object.assign({}, e, { parentClientConfig: e }))))
        : (n = async () => {
            throw new Error(
              "@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.",
            );
          }),
    (n.memoized = !0),
    n
  );
}
function wUt(e, t) {
  if (t.configBound) return t;
  let r = async (n) => t({ ...n, callerClientConfig: e });
  return (r.memoized = t.memoized), (r.configBound = !0), r;
}
var xW,
  zy,
  SUt,
  uSe = w(() => {
    c();
    Ks();
    Gi();
    (xW = A(cSe())),
      (zy = (e) => {
        let t = e.credentials,
          r = !!e.credentials,
          n;
        Object.defineProperty(e, "credentials", {
          set(l) {
            l && l !== t && l !== n && (r = !0), (t = l);
            let d = CUt(e, {
                credentials: t,
                credentialDefaultProvider: e.credentialDefaultProvider,
              }),
              f = wUt(e, d);
            r && !f.attributed
              ? ((n = async (m) =>
                  f(m).then((h) => _f(h, "CREDENTIALS_CODE", "e"))),
                (n.memoized = f.memoized),
                (n.configBound = f.configBound),
                (n.attributed = !0))
              : (n = f);
          },
          get() {
            return n;
          },
          enumerable: !0,
          configurable: !0,
        }),
          (e.credentials = t);
        let {
            signingEscapePath: i = !0,
            systemClockOffset: o = e.systemClockOffset || 0,
            sha256: a,
          } = e,
          s;
        return (
          e.signer
            ? (s = mf(e.signer))
            : e.regionInfoProvider
              ? (s = () =>
                  mf(e.region)()
                    .then(async (l) => [
                      (await e.regionInfoProvider(l, {
                        useFipsEndpoint: await e.useFipsEndpoint(),
                        useDualstackEndpoint: await e.useDualstackEndpoint(),
                      })) || {},
                      l,
                    ])
                    .then(([l, d]) => {
                      let { signingRegion: f, signingService: m } = l;
                      (e.signingRegion = e.signingRegion || f || d),
                        (e.signingName = e.signingName || m || e.serviceId);
                      let h = {
                          ...e,
                          credentials: e.credentials,
                          region: e.signingRegion,
                          service: e.signingName,
                          sha256: a,
                          uriEscapePath: i,
                        },
                        y = e.signerConstructor || xW.SignatureV4;
                      return new y(h);
                    }))
              : (s = async (l) => {
                  l = Object.assign(
                    {},
                    {
                      name: "sigv4",
                      signingName: e.signingName || e.defaultSigningName,
                      signingRegion: await mf(e.region)(),
                      properties: {},
                    },
                    l,
                  );
                  let d = l.signingRegion,
                    f = l.signingName;
                  (e.signingRegion = e.signingRegion || d),
                    (e.signingName = e.signingName || f || e.serviceId);
                  let m = {
                      ...e,
                      credentials: e.credentials,
                      region: e.signingRegion,
                      service: e.signingName,
                      sha256: a,
                      uriEscapePath: i,
                    },
                    h = e.signerConstructor || xW.SignatureV4;
                  return new h(m);
                }),
          Object.assign(e, {
            systemClockOffset: o,
            signingEscapePath: i,
            signer: s,
          })
        );
      }),
      (SUt = zy);
  });
var lSe = w(() => {
  c();
  _W();
  Cbe();
  Abe();
  kbe();
  uSe();
});
var dSe = w(() => {
  c();
  lSe();
});
var OUt,
  TUt,
  AUt,
  fSe = w(() => {
    c();
    (OUt = (e) => {
      if (e == null) return e;
      if (typeof e == "number" || typeof e == "bigint") {
        let t = new Error(`Received number ${e} where a string was expected.`);
        return (t.name = "Warning"), console.warn(t), String(e);
      }
      if (typeof e == "boolean") {
        let t = new Error(`Received boolean ${e} where a string was expected.`);
        return (t.name = "Warning"), console.warn(t), String(e);
      }
      return e;
    }),
      (TUt = (e) => {
        if (e == null) return e;
        if (typeof e == "string") {
          let t = e.toLowerCase();
          if (e !== "" && t !== "false" && t !== "true") {
            let r = new Error(
              `Received string "${e}" where a boolean was expected.`,
            );
            (r.name = "Warning"), console.warn(r);
          }
          return e !== "" && t !== "false";
        }
        return e;
      }),
      (AUt = (e) => {
        if (e == null) return e;
        if (typeof e == "string") {
          let t = Number(e);
          if (t.toString() !== e) {
            let r = new Error(
              `Received string "${e}" where a number was expected.`,
            );
            return (r.name = "Warning"), console.warn(r), e;
          }
          return t;
        }
        return e;
      });
  });
var vSe = g((k0n, gSe) => {
  c();
  var $D = Object.defineProperty,
    PUt = Object.getOwnPropertyDescriptor,
    RUt = Object.getOwnPropertyNames,
    IUt = Object.prototype.hasOwnProperty,
    Fa = (e, t) => $D(e, "name", { value: t, configurable: !0 }),
    xUt = (e, t) => {
      for (var r in t) $D(e, r, { get: t[r], enumerable: !0 });
    },
    NUt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of RUt(t))
          !IUt.call(e, i) &&
            i !== r &&
            $D(e, i, {
              get: () => t[i],
              enumerable: !(n = PUt(t, i)) || n.enumerable,
            });
      return e;
    },
    kUt = (e) => NUt($D({}, "__esModule", { value: !0 }), e),
    hSe = {};
  xUt(hSe, { constructStack: () => NW });
  gSe.exports = kUt(hSe);
  var sh = Fa((e, t) => {
      let r = [];
      if ((e && r.push(e), t)) for (let n of t) r.push(n);
      return r;
    }, "getAllAliases"),
    Sf = Fa(
      (e, t) =>
        `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`,
      "getMiddlewareNameWithAliases",
    ),
    NW = Fa(() => {
      let e = [],
        t = [],
        r = !1,
        n = new Set(),
        i = Fa(
          (f) =>
            f.sort(
              (m, h) =>
                pSe[h.step] - pSe[m.step] ||
                mSe[h.priority || "normal"] - mSe[m.priority || "normal"],
            ),
          "sort",
        ),
        o = Fa((f) => {
          let m = !1,
            h = Fa((y) => {
              let _ = sh(y.name, y.aliases);
              if (_.includes(f)) {
                m = !0;
                for (let E of _) n.delete(E);
                return !1;
              }
              return !0;
            }, "filterCb");
          return (e = e.filter(h)), (t = t.filter(h)), m;
        }, "removeByName"),
        a = Fa((f) => {
          let m = !1,
            h = Fa((y) => {
              if (y.middleware === f) {
                m = !0;
                for (let _ of sh(y.name, y.aliases)) n.delete(_);
                return !1;
              }
              return !0;
            }, "filterCb");
          return (e = e.filter(h)), (t = t.filter(h)), m;
        }, "removeByReference"),
        s = Fa(
          (f) => (
            e.forEach((m) => {
              f.add(m.middleware, { ...m });
            }),
            t.forEach((m) => {
              f.addRelativeTo(m.middleware, { ...m });
            }),
            f.identifyOnResolve?.(d.identifyOnResolve()),
            f
          ),
          "cloneTo",
        ),
        u = Fa((f) => {
          let m = [];
          return (
            f.before.forEach((h) => {
              h.before.length === 0 && h.after.length === 0
                ? m.push(h)
                : m.push(...u(h));
            }),
            m.push(f),
            f.after.reverse().forEach((h) => {
              h.before.length === 0 && h.after.length === 0
                ? m.push(h)
                : m.push(...u(h));
            }),
            m
          );
        }, "expandRelativeMiddlewareList"),
        l = Fa((f = !1) => {
          let m = [],
            h = [],
            y = {};
          return (
            e.forEach((E) => {
              let b = { ...E, before: [], after: [] };
              for (let O of sh(b.name, b.aliases)) y[O] = b;
              m.push(b);
            }),
            t.forEach((E) => {
              let b = { ...E, before: [], after: [] };
              for (let O of sh(b.name, b.aliases)) y[O] = b;
              h.push(b);
            }),
            h.forEach((E) => {
              if (E.toMiddleware) {
                let b = y[E.toMiddleware];
                if (b === void 0) {
                  if (f) return;
                  throw new Error(
                    `${E.toMiddleware} is not found when adding ${Sf(E.name, E.aliases)} middleware ${E.relation} ${E.toMiddleware}`,
                  );
                }
                E.relation === "after" && b.after.push(E),
                  E.relation === "before" && b.before.push(E);
              }
            }),
            i(m)
              .map(u)
              .reduce((E, b) => (E.push(...b), E), [])
          );
        }, "getMiddlewareList"),
        d = {
          add: (f, m = {}) => {
            let { name: h, override: y, aliases: _ } = m,
              E = {
                step: "initialize",
                priority: "normal",
                middleware: f,
                ...m,
              },
              b = sh(h, _);
            if (b.length > 0) {
              if (b.some((O) => n.has(O))) {
                if (!y)
                  throw new Error(`Duplicate middleware name '${Sf(h, _)}'`);
                for (let O of b) {
                  let C = e.findIndex(
                    (k) => k.name === O || k.aliases?.some((H) => H === O),
                  );
                  if (C === -1) continue;
                  let P = e[C];
                  if (P.step !== E.step || E.priority !== P.priority)
                    throw new Error(
                      `"${Sf(P.name, P.aliases)}" middleware with ${P.priority} priority in ${P.step} step cannot be overridden by "${Sf(h, _)}" middleware with ${E.priority} priority in ${E.step} step.`,
                    );
                  e.splice(C, 1);
                }
              }
              for (let O of b) n.add(O);
            }
            e.push(E);
          },
          addRelativeTo: (f, m) => {
            let { name: h, override: y, aliases: _ } = m,
              E = { middleware: f, ...m },
              b = sh(h, _);
            if (b.length > 0) {
              if (b.some((O) => n.has(O))) {
                if (!y)
                  throw new Error(`Duplicate middleware name '${Sf(h, _)}'`);
                for (let O of b) {
                  let C = t.findIndex(
                    (k) => k.name === O || k.aliases?.some((H) => H === O),
                  );
                  if (C === -1) continue;
                  let P = t[C];
                  if (
                    P.toMiddleware !== E.toMiddleware ||
                    P.relation !== E.relation
                  )
                    throw new Error(
                      `"${Sf(P.name, P.aliases)}" middleware ${P.relation} "${P.toMiddleware}" middleware cannot be overridden by "${Sf(h, _)}" middleware ${E.relation} "${E.toMiddleware}" middleware.`,
                    );
                  t.splice(C, 1);
                }
              }
              for (let O of b) n.add(O);
            }
            t.push(E);
          },
          clone: () => s(NW()),
          use: (f) => {
            f.applyToStack(d);
          },
          remove: (f) => (typeof f == "string" ? o(f) : a(f)),
          removeByTag: (f) => {
            let m = !1,
              h = Fa((y) => {
                let { tags: _, name: E, aliases: b } = y;
                if (_ && _.includes(f)) {
                  let O = sh(E, b);
                  for (let C of O) n.delete(C);
                  return (m = !0), !1;
                }
                return !0;
              }, "filterCb");
            return (e = e.filter(h)), (t = t.filter(h)), m;
          },
          concat: (f) => {
            let m = s(NW());
            return (
              m.use(f),
              m.identifyOnResolve(
                r || m.identifyOnResolve() || (f.identifyOnResolve?.() ?? !1),
              ),
              m
            );
          },
          applyToStack: s,
          identify: () =>
            l(!0).map((f) => {
              let m = f.step ?? f.relation + " " + f.toMiddleware;
              return Sf(f.name, f.aliases) + " - " + m;
            }),
          identifyOnResolve(f) {
            return typeof f == "boolean" && (r = f), r;
          },
          resolve: (f, m) => {
            for (let h of l()
              .map((y) => y.middleware)
              .reverse())
              f = h(f, m);
            return r && console.log(d.identify()), f;
          },
        };
      return d;
    }, "constructStack"),
    pSe = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1,
    },
    mSe = { high: 3, normal: 2, low: 1 };
});
var vt = g((L0n, LSe) => {
  c();
  var WD = Object.defineProperty,
    DUt = Object.getOwnPropertyDescriptor,
    LUt = Object.getOwnPropertyNames,
    MUt = Object.prototype.hasOwnProperty,
    le = (e, t) => WD(e, "name", { value: t, configurable: !0 }),
    qUt = (e, t) => {
      for (var r in t) WD(e, r, { get: t[r], enumerable: !0 });
    },
    jUt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of LUt(t))
          !MUt.call(e, i) &&
            i !== r &&
            WD(e, i, {
              get: () => t[i],
              enumerable: !(n = DUt(t, i)) || n.enumerable,
            });
      return e;
    },
    FUt = (e) => jUt(WD({}, "__esModule", { value: !0 }), e),
    _Se = {};
  qUt(_Se, {
    Client: () => BUt,
    Command: () => bSe,
    LazyJsonString: () => ch,
    NoOpLogger: () => MHt,
    SENSITIVE_STRING: () => HUt,
    ServiceException: () => CHt,
    _json: () => FW,
    collectBody: () => kW.collectBody,
    convertMap: () => qHt,
    createAggregatedClient: () => GUt,
    dateToUtcString: () => ASe,
    decorateServiceException: () => PSe,
    emitWarningIfUnsupportedVersion: () => AHt,
    expectBoolean: () => $Ut,
    expectByte: () => jW,
    expectFloat32: () => zD,
    expectInt: () => KUt,
    expectInt32: () => MW,
    expectLong: () => qC,
    expectNonNull: () => QUt,
    expectNumber: () => MC,
    expectObject: () => SSe,
    expectShort: () => qW,
    expectString: () => YUt,
    expectUnion: () => XUt,
    extendedEncodeURIComponent: () => kW.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => DHt,
    getDefaultClientConfiguration: () => NHt,
    getDefaultExtensionConfiguration: () => ISe,
    getValueFromTextNode: () => xSe,
    handleFloat: () => eHt,
    isSerializableHeaderValue: () => LHt,
    limitedParseDouble: () => HW,
    limitedParseFloat: () => tHt,
    limitedParseFloat32: () => rHt,
    loadConfigsForDefaultMode: () => THt,
    logger: () => jC,
    map: () => VW,
    parseBoolean: () => VUt,
    parseEpochTimestamp: () => mHt,
    parseRfc3339DateTime: () => sHt,
    parseRfc3339DateTimeWithOffset: () => uHt,
    parseRfc7231DateTime: () => pHt,
    quoteHeader: () => kSe,
    resolveDefaultRuntimeConfig: () => kHt,
    resolvedPath: () => kW.resolvedPath,
    serializeDateTime: () => GHt,
    serializeFloat: () => HHt,
    splitEvery: () => DSe,
    splitHeader: () => VHt,
    strictParseByte: () => TSe,
    strictParseDouble: () => UW,
    strictParseFloat: () => JUt,
    strictParseFloat32: () => CSe,
    strictParseInt: () => nHt,
    strictParseInt32: () => iHt,
    strictParseLong: () => OSe,
    strictParseShort: () => Ky,
    take: () => jHt,
    throwDefaultError: () => RSe,
    withBaseException: () => wHt,
  });
  LSe.exports = FUt(_Se);
  var ESe = vSe(),
    BUt = class {
      constructor(e) {
        (this.config = e), (this.middlewareStack = (0, ESe.constructStack)());
      }
      static {
        le(this, "Client");
      }
      send(e, t, r) {
        let n = typeof t != "function" ? t : void 0,
          i = typeof t == "function" ? t : r,
          o = n === void 0 && this.config.cacheMiddleware === !0,
          a;
        if (o) {
          this.handlers || (this.handlers = new WeakMap());
          let s = this.handlers;
          s.has(e.constructor)
            ? (a = s.get(e.constructor))
            : ((a = e.resolveMiddleware(this.middlewareStack, this.config, n)),
              s.set(e.constructor, a));
        } else
          delete this.handlers,
            (a = e.resolveMiddleware(this.middlewareStack, this.config, n));
        if (i)
          a(e)
            .then(
              (s) => i(null, s.output),
              (s) => i(s),
            )
            .catch(() => {});
        else return a(e).then((s) => s.output);
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers;
      }
    },
    kW = (iW(), ue(kEe)),
    LW = ll(),
    bSe = class {
      constructor() {
        this.middlewareStack = (0, ESe.constructStack)();
      }
      static {
        le(this, "Command");
      }
      static classBuilder() {
        return new UUt();
      }
      resolveMiddlewareWithContext(
        e,
        t,
        r,
        {
          middlewareFn: n,
          clientName: i,
          commandName: o,
          inputFilterSensitiveLog: a,
          outputFilterSensitiveLog: s,
          smithyContext: u,
          additionalContext: l,
          CommandCtor: d,
        },
      ) {
        for (let _ of n.bind(this)(d, e, t, r)) this.middlewareStack.use(_);
        let f = e.concat(this.middlewareStack),
          { logger: m } = t,
          h = {
            logger: m,
            clientName: i,
            commandName: o,
            inputFilterSensitiveLog: a,
            outputFilterSensitiveLog: s,
            [LW.SMITHY_CONTEXT_KEY]: { commandInstance: this, ...u },
            ...l,
          },
          { requestHandler: y } = t;
        return f.resolve((_) => y.handle(_.request, r || {}), h);
      }
    },
    UUt = class {
      constructor() {
        (this._init = () => {}),
          (this._ep = {}),
          (this._middlewareFn = () => []),
          (this._commandName = ""),
          (this._clientName = ""),
          (this._additionalContext = {}),
          (this._smithyContext = {}),
          (this._inputFilterSensitiveLog = (e) => e),
          (this._outputFilterSensitiveLog = (e) => e),
          (this._serializer = null),
          (this._deserializer = null);
      }
      static {
        le(this, "ClassBuilder");
      }
      init(e) {
        this._init = e;
      }
      ep(e) {
        return (this._ep = e), this;
      }
      m(e) {
        return (this._middlewareFn = e), this;
      }
      s(e, t, r = {}) {
        return (this._smithyContext = { service: e, operation: t, ...r }), this;
      }
      c(e = {}) {
        return (this._additionalContext = e), this;
      }
      n(e, t) {
        return (this._clientName = e), (this._commandName = t), this;
      }
      f(e = (r) => r, t = (r) => r) {
        return (
          (this._inputFilterSensitiveLog = e),
          (this._outputFilterSensitiveLog = t),
          this
        );
      }
      ser(e) {
        return (this._serializer = e), this;
      }
      de(e) {
        return (this._deserializer = e), this;
      }
      build() {
        let e = this,
          t;
        return (t = class extends bSe {
          constructor(...[r]) {
            super(),
              (this.serialize = e._serializer),
              (this.deserialize = e._deserializer),
              (this.input = r ?? {}),
              e._init(this);
          }
          static {
            le(this, "CommandRef");
          }
          static getEndpointParameterInstructions() {
            return e._ep;
          }
          resolveMiddleware(r, n, i) {
            return this.resolveMiddlewareWithContext(r, n, i, {
              CommandCtor: t,
              middlewareFn: e._middlewareFn,
              clientName: e._clientName,
              commandName: e._commandName,
              inputFilterSensitiveLog: e._inputFilterSensitiveLog,
              outputFilterSensitiveLog: e._outputFilterSensitiveLog,
              smithyContext: e._smithyContext,
              additionalContext: e._additionalContext,
            });
          }
        });
      }
    },
    HUt = "***SensitiveInformation***",
    GUt = le((e, t) => {
      for (let r of Object.keys(e)) {
        let n = e[r],
          i = le(async function (a, s, u) {
            let l = new n(a);
            if (typeof s == "function") this.send(l, s);
            else if (typeof u == "function") {
              if (typeof s != "object")
                throw new Error(`Expected http options but got ${typeof s}`);
              this.send(l, s || {}, u);
            } else return this.send(l, s);
          }, "methodImpl"),
          o = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, "");
        t.prototype[o] = i;
      }
    }, "createAggregatedClient"),
    VUt = le((e) => {
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw new Error(`Unable to parse boolean value "${e}"`);
      }
    }, "parseBoolean"),
    $Ut = le((e) => {
      if (e != null) {
        if (typeof e == "number") {
          if (
            ((e === 0 || e === 1) &&
              jC.warn(KD(`Expected boolean, got ${typeof e}: ${e}`)),
            e === 0)
          )
            return !1;
          if (e === 1) return !0;
        }
        if (typeof e == "string") {
          let t = e.toLowerCase();
          if (
            ((t === "false" || t === "true") &&
              jC.warn(KD(`Expected boolean, got ${typeof e}: ${e}`)),
            t === "false")
          )
            return !1;
          if (t === "true") return !0;
        }
        if (typeof e == "boolean") return e;
        throw new TypeError(`Expected boolean, got ${typeof e}: ${e}`);
      }
    }, "expectBoolean"),
    MC = le((e) => {
      if (e != null) {
        if (typeof e == "string") {
          let t = parseFloat(e);
          if (!Number.isNaN(t))
            return (
              String(t) !== String(e) &&
                jC.warn(KD(`Expected number but observed string: ${e}`)),
              t
            );
        }
        if (typeof e == "number") return e;
        throw new TypeError(`Expected number, got ${typeof e}: ${e}`);
      }
    }, "expectNumber"),
    zUt = Math.ceil(2 ** 127 * (2 - 2 ** -23)),
    zD = le((e) => {
      let t = MC(e);
      if (
        t !== void 0 &&
        !Number.isNaN(t) &&
        t !== 1 / 0 &&
        t !== -1 / 0 &&
        Math.abs(t) > zUt
      )
        throw new TypeError(`Expected 32-bit float, got ${e}`);
      return t;
    }, "expectFloat32"),
    qC = le((e) => {
      if (e != null) {
        if (Number.isInteger(e) && !Number.isNaN(e)) return e;
        throw new TypeError(`Expected integer, got ${typeof e}: ${e}`);
      }
    }, "expectLong"),
    KUt = qC,
    MW = le((e) => BW(e, 32), "expectInt32"),
    qW = le((e) => BW(e, 16), "expectShort"),
    jW = le((e) => BW(e, 8), "expectByte"),
    BW = le((e, t) => {
      let r = qC(e);
      if (r !== void 0 && WUt(r, t) !== r)
        throw new TypeError(`Expected ${t}-bit integer, got ${e}`);
      return r;
    }, "expectSizedInt"),
    WUt = le((e, t) => {
      switch (t) {
        case 32:
          return Int32Array.of(e)[0];
        case 16:
          return Int16Array.of(e)[0];
        case 8:
          return Int8Array.of(e)[0];
      }
    }, "castInt"),
    QUt = le((e, t) => {
      if (e == null)
        throw t
          ? new TypeError(`Expected a non-null value for ${t}`)
          : new TypeError("Expected a non-null value");
      return e;
    }, "expectNonNull"),
    SSe = le((e) => {
      if (e == null) return;
      if (typeof e == "object" && !Array.isArray(e)) return e;
      let t = Array.isArray(e) ? "array" : typeof e;
      throw new TypeError(`Expected object, got ${t}: ${e}`);
    }, "expectObject"),
    YUt = le((e) => {
      if (e != null) {
        if (typeof e == "string") return e;
        if (["boolean", "number", "bigint"].includes(typeof e))
          return (
            jC.warn(KD(`Expected string, got ${typeof e}: ${e}`)), String(e)
          );
        throw new TypeError(`Expected string, got ${typeof e}: ${e}`);
      }
    }, "expectString"),
    XUt = le((e) => {
      if (e == null) return;
      let t = SSe(e),
        r = Object.entries(t)
          .filter(([, n]) => n != null)
          .map(([n]) => n);
      if (r.length === 0)
        throw new TypeError(
          "Unions must have exactly one non-null member. None were found.",
        );
      if (r.length > 1)
        throw new TypeError(
          `Unions must have exactly one non-null member. Keys ${r} were not null.`,
        );
      return t;
    }, "expectUnion"),
    UW = le((e) => MC(typeof e == "string" ? Qy(e) : e), "strictParseDouble"),
    JUt = UW,
    CSe = le((e) => zD(typeof e == "string" ? Qy(e) : e), "strictParseFloat32"),
    ZUt = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    Qy = le((e) => {
      let t = e.match(ZUt);
      if (t === null || t[0].length !== e.length)
        throw new TypeError("Expected real number, got implicit NaN");
      return parseFloat(e);
    }, "parseNumber"),
    HW = le(
      (e) => (typeof e == "string" ? wSe(e) : MC(e)),
      "limitedParseDouble",
    ),
    eHt = HW,
    tHt = HW,
    rHt = le(
      (e) => (typeof e == "string" ? wSe(e) : zD(e)),
      "limitedParseFloat32",
    ),
    wSe = le((e) => {
      switch (e) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw new Error(`Unable to parse float value: ${e}`);
      }
    }, "parseFloatString"),
    OSe = le((e) => qC(typeof e == "string" ? Qy(e) : e), "strictParseLong"),
    nHt = OSe,
    iHt = le((e) => MW(typeof e == "string" ? Qy(e) : e), "strictParseInt32"),
    Ky = le((e) => qW(typeof e == "string" ? Qy(e) : e), "strictParseShort"),
    TSe = le((e) => jW(typeof e == "string" ? Qy(e) : e), "strictParseByte"),
    KD = le(
      (e) =>
        String(new TypeError(e).stack || e)
          .split(
            `
`,
          )
          .slice(0, 5)
          .filter((t) => !t.includes("stackTraceWarning")).join(`
`),
      "stackTraceWarning",
    ),
    jC = { warn: console.warn },
    oHt = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    GW = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
  function ASe(e) {
    let t = e.getUTCFullYear(),
      r = e.getUTCMonth(),
      n = e.getUTCDay(),
      i = e.getUTCDate(),
      o = e.getUTCHours(),
      a = e.getUTCMinutes(),
      s = e.getUTCSeconds(),
      u = i < 10 ? `0${i}` : `${i}`,
      l = o < 10 ? `0${o}` : `${o}`,
      d = a < 10 ? `0${a}` : `${a}`,
      f = s < 10 ? `0${s}` : `${s}`;
    return `${oHt[n]}, ${u} ${GW[r]} ${t} ${l}:${d}:${f} GMT`;
  }
  le(ASe, "dateToUtcString");
  var aHt = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/,
    ),
    sHt = le((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      let t = aHt.exec(e);
      if (!t) throw new TypeError("Invalid RFC-3339 date-time value");
      let [r, n, i, o, a, s, u, l] = t,
        d = Ky(Wy(n)),
        f = Vc(i, "month", 1, 12),
        m = Vc(o, "day", 1, 31);
      return LC(d, f, m, {
        hours: a,
        minutes: s,
        seconds: u,
        fractionalMilliseconds: l,
      });
    }, "parseRfc3339DateTime"),
    cHt = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/,
    ),
    uHt = le((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      let t = cHt.exec(e);
      if (!t) throw new TypeError("Invalid RFC-3339 date-time value");
      let [r, n, i, o, a, s, u, l, d] = t,
        f = Ky(Wy(n)),
        m = Vc(i, "month", 1, 12),
        h = Vc(o, "day", 1, 31),
        y = LC(f, m, h, {
          hours: a,
          minutes: s,
          seconds: u,
          fractionalMilliseconds: l,
        });
      return d.toUpperCase() != "Z" && y.setTime(y.getTime() - SHt(d)), y;
    }, "parseRfc3339DateTimeWithOffset"),
    lHt = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    dHt = new RegExp(
      /^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    fHt = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/,
    ),
    pHt = le((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
      let t = lHt.exec(e);
      if (t) {
        let [r, n, i, o, a, s, u, l] = t;
        return LC(Ky(Wy(o)), DW(i), Vc(n, "day", 1, 31), {
          hours: a,
          minutes: s,
          seconds: u,
          fractionalMilliseconds: l,
        });
      }
      if (((t = dHt.exec(e)), t)) {
        let [r, n, i, o, a, s, u, l] = t;
        return vHt(
          LC(hHt(o), DW(i), Vc(n, "day", 1, 31), {
            hours: a,
            minutes: s,
            seconds: u,
            fractionalMilliseconds: l,
          }),
        );
      }
      if (((t = fHt.exec(e)), t)) {
        let [r, n, i, o, a, s, u, l] = t;
        return LC(Ky(Wy(l)), DW(n), Vc(i.trimLeft(), "day", 1, 31), {
          hours: o,
          minutes: a,
          seconds: s,
          fractionalMilliseconds: u,
        });
      }
      throw new TypeError("Invalid RFC-7231 date-time value");
    }, "parseRfc7231DateTime"),
    mHt = le((e) => {
      if (e == null) return;
      let t;
      if (typeof e == "number") t = e;
      else if (typeof e == "string") t = UW(e);
      else if (typeof e == "object" && e.tag === 1) t = e.value;
      else
        throw new TypeError(
          "Epoch timestamps must be expressed as floating point numbers or their string representation",
        );
      if (Number.isNaN(t) || t === 1 / 0 || t === -1 / 0)
        throw new TypeError(
          "Epoch timestamps must be valid, non-Infinite, non-NaN numerics",
        );
      return new Date(Math.round(t * 1e3));
    }, "parseEpochTimestamp"),
    LC = le((e, t, r, n) => {
      let i = t - 1;
      return (
        _Ht(e, i, r),
        new Date(
          Date.UTC(
            e,
            i,
            r,
            Vc(n.hours, "hour", 0, 23),
            Vc(n.minutes, "minute", 0, 59),
            Vc(n.seconds, "seconds", 0, 60),
            bHt(n.fractionalMilliseconds),
          ),
        )
      );
    }, "buildDate"),
    hHt = le((e) => {
      let t = new Date().getUTCFullYear(),
        r = Math.floor(t / 100) * 100 + Ky(Wy(e));
      return r < t ? r + 100 : r;
    }, "parseTwoDigitYear"),
    gHt = 50 * 365 * 24 * 60 * 60 * 1e3,
    vHt = le(
      (e) =>
        e.getTime() - new Date().getTime() > gHt
          ? new Date(
              Date.UTC(
                e.getUTCFullYear() - 100,
                e.getUTCMonth(),
                e.getUTCDate(),
                e.getUTCHours(),
                e.getUTCMinutes(),
                e.getUTCSeconds(),
                e.getUTCMilliseconds(),
              ),
            )
          : e,
      "adjustRfc850Year",
    ),
    DW = le((e) => {
      let t = GW.indexOf(e);
      if (t < 0) throw new TypeError(`Invalid month: ${e}`);
      return t + 1;
    }, "parseMonthByShortName"),
    yHt = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    _Ht = le((e, t, r) => {
      let n = yHt[t];
      if ((t === 1 && EHt(e) && (n = 29), r > n))
        throw new TypeError(`Invalid day for ${GW[t]} in ${e}: ${r}`);
    }, "validateDayOfMonth"),
    EHt = le(
      (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0),
      "isLeapYear",
    ),
    Vc = le((e, t, r, n) => {
      let i = TSe(Wy(e));
      if (i < r || i > n)
        throw new TypeError(`${t} must be between ${r} and ${n}, inclusive`);
      return i;
    }, "parseDateValue"),
    bHt = le((e) => (e == null ? 0 : CSe("0." + e) * 1e3), "parseMilliseconds"),
    SHt = le((e) => {
      let t = e[0],
        r = 1;
      if (t == "+") r = 1;
      else if (t == "-") r = -1;
      else throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`);
      let n = Number(e.substring(1, 3)),
        i = Number(e.substring(4, 6));
      return r * (n * 60 + i) * 60 * 1e3;
    }, "parseOffsetToMilliseconds"),
    Wy = le((e) => {
      let t = 0;
      for (; t < e.length - 1 && e.charAt(t) === "0"; ) t++;
      return t === 0 ? e : e.slice(t);
    }, "stripLeadingZeroes"),
    CHt = class DC extends Error {
      static {
        le(this, "ServiceException");
      }
      constructor(t) {
        super(t.message),
          Object.setPrototypeOf(
            this,
            Object.getPrototypeOf(this).constructor.prototype,
          ),
          (this.name = t.name),
          (this.$fault = t.$fault),
          (this.$metadata = t.$metadata);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          DC.prototype.isPrototypeOf(r) ||
          (!!r.$fault &&
            !!r.$metadata &&
            (r.$fault === "client" || r.$fault === "server"))
        );
      }
      static [Symbol.hasInstance](t) {
        if (!t) return !1;
        let r = t;
        return this === DC
          ? DC.isInstance(t)
          : DC.isInstance(t)
            ? r.name && this.name
              ? this.prototype.isPrototypeOf(t) || r.name === this.name
              : this.prototype.isPrototypeOf(t)
            : !1;
      }
    },
    PSe = le((e, t = {}) => {
      Object.entries(t)
        .filter(([, n]) => n !== void 0)
        .forEach(([n, i]) => {
          (e[n] == null || e[n] === "") && (e[n] = i);
        });
      let r = e.message || e.Message || "UnknownError";
      return (e.message = r), delete e.Message, e;
    }, "decorateServiceException"),
    RSe = le(({ output: e, parsedBody: t, exceptionCtor: r, errorCode: n }) => {
      let i = OHt(e),
        o = i.httpStatusCode ? i.httpStatusCode + "" : void 0,
        a = new r({
          name: t?.code || t?.Code || n || o || "UnknownError",
          $fault: "client",
          $metadata: i,
        });
      throw PSe(a, t);
    }, "throwDefaultError"),
    wHt = le(
      (e) =>
        ({ output: t, parsedBody: r, errorCode: n }) => {
          RSe({ output: t, parsedBody: r, exceptionCtor: e, errorCode: n });
        },
      "withBaseException",
    ),
    OHt = le(
      (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }),
      "deserializeMetadata",
    ),
    THt = le((e) => {
      switch (e) {
        case "standard":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "in-region":
          return { retryMode: "standard", connectionTimeout: 1100 };
        case "cross-region":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "mobile":
          return { retryMode: "standard", connectionTimeout: 3e4 };
        default:
          return {};
      }
    }, "loadConfigsForDefaultMode"),
    ySe = !1,
    AHt = le((e) => {
      e && !ySe && parseInt(e.substring(1, e.indexOf("."))) < 16 && (ySe = !0);
    }, "emitWarningIfUnsupportedVersion"),
    PHt = le((e) => {
      let t = [];
      for (let r in LW.AlgorithmId) {
        let n = LW.AlgorithmId[r];
        e[n] !== void 0 &&
          t.push({ algorithmId: () => n, checksumConstructor: () => e[n] });
      }
      return {
        addChecksumAlgorithm(r) {
          t.push(r);
        },
        checksumAlgorithms() {
          return t;
        },
      };
    }, "getChecksumConfiguration"),
    RHt = le((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    IHt = le(
      (e) => ({
        setRetryStrategy(t) {
          e.retryStrategy = t;
        },
        retryStrategy() {
          return e.retryStrategy;
        },
      }),
      "getRetryConfiguration",
    ),
    xHt = le((e) => {
      let t = {};
      return (t.retryStrategy = e.retryStrategy()), t;
    }, "resolveRetryRuntimeConfig"),
    ISe = le(
      (e) => Object.assign(PHt(e), IHt(e)),
      "getDefaultExtensionConfiguration",
    ),
    NHt = ISe,
    kHt = le(
      (e) => Object.assign(RHt(e), xHt(e)),
      "resolveDefaultRuntimeConfig",
    ),
    DHt = le((e) => (Array.isArray(e) ? e : [e]), "getArrayIfSingleItem"),
    xSe = le((e) => {
      let t = "#text";
      for (let r in e)
        e.hasOwnProperty(r) && e[r][t] !== void 0
          ? (e[r] = e[r][t])
          : typeof e[r] == "object" && e[r] !== null && (e[r] = xSe(e[r]));
      return e;
    }, "getValueFromTextNode"),
    LHt = le((e) => e != null, "isSerializableHeaderValue"),
    ch = le(function (t) {
      return Object.assign(new String(t), {
        deserializeJSON() {
          return JSON.parse(String(t));
        },
        toString() {
          return String(t);
        },
        toJSON() {
          return String(t);
        },
      });
    }, "LazyJsonString");
  ch.from = (e) =>
    e && typeof e == "object" && (e instanceof ch || "deserializeJSON" in e)
      ? e
      : typeof e == "string" || Object.getPrototypeOf(e) === String.prototype
        ? ch(String(e))
        : ch(JSON.stringify(e));
  ch.fromObject = ch.from;
  var MHt = class {
    static {
      le(this, "NoOpLogger");
    }
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  };
  function VW(e, t, r) {
    let n, i, o;
    if (typeof t > "u" && typeof r > "u") (n = {}), (o = e);
    else {
      if (((n = e), typeof t == "function"))
        return (i = t), (o = r), FHt(n, i, o);
      o = t;
    }
    for (let a of Object.keys(o)) {
      if (!Array.isArray(o[a])) {
        n[a] = o[a];
        continue;
      }
      NSe(n, null, o, a);
    }
    return n;
  }
  le(VW, "map");
  var qHt = le((e) => {
      let t = {};
      for (let [r, n] of Object.entries(e || {})) t[r] = [, n];
      return t;
    }, "convertMap"),
    jHt = le((e, t) => {
      let r = {};
      for (let n in t) NSe(r, e, t, n);
      return r;
    }, "take"),
    FHt = le(
      (e, t, r) =>
        VW(
          e,
          Object.entries(r).reduce(
            (n, [i, o]) => (
              Array.isArray(o)
                ? (n[i] = o)
                : typeof o == "function"
                  ? (n[i] = [t, o()])
                  : (n[i] = [t, o]),
              n
            ),
            {},
          ),
        ),
      "mapWithFilter",
    ),
    NSe = le((e, t, r, n) => {
      if (t !== null) {
        let a = r[n];
        typeof a == "function" && (a = [, a]);
        let [s = BHt, u = UHt, l = n] = a;
        ((typeof s == "function" && s(t[l])) ||
          (typeof s != "function" && s)) &&
          (e[n] = u(t[l]));
        return;
      }
      let [i, o] = r[n];
      if (typeof o == "function") {
        let a,
          s = i === void 0 && (a = o()) != null,
          u =
            (typeof i == "function" && !!i(void 0)) ||
            (typeof i != "function" && !!i);
        s ? (e[n] = a) : u && (e[n] = o());
      } else {
        let a = i === void 0 && o != null,
          s =
            (typeof i == "function" && !!i(o)) ||
            (typeof i != "function" && !!i);
        (a || s) && (e[n] = o);
      }
    }, "applyInstruction"),
    BHt = le((e) => e != null, "nonNullish"),
    UHt = le((e) => e, "pass");
  function kSe(e) {
    return (
      (e.includes(",") || e.includes('"')) &&
        (e = `"${e.replace(/"/g, '\\"')}"`),
      e
    );
  }
  le(kSe, "quoteHeader");
  var HHt = le((e) => {
      if (e !== e) return "NaN";
      switch (e) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return e;
      }
    }, "serializeFloat"),
    GHt = le((e) => e.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    FW = le((e) => {
      if (e == null) return {};
      if (Array.isArray(e)) return e.filter((t) => t != null).map(FW);
      if (typeof e == "object") {
        let t = {};
        for (let r of Object.keys(e)) e[r] != null && (t[r] = FW(e[r]));
        return t;
      }
      return e;
    }, "_json");
  function DSe(e, t, r) {
    if (r <= 0 || !Number.isInteger(r))
      throw new Error(
        "Invalid number of delimiters (" + r + ") for splitEvery.",
      );
    let n = e.split(t);
    if (r === 1) return n;
    let i = [],
      o = "";
    for (let a = 0; a < n.length; a++)
      o === "" ? (o = n[a]) : (o += t + n[a]),
        (a + 1) % r === 0 && (i.push(o), (o = ""));
    return o !== "" && i.push(o), i;
  }
  le(DSe, "splitEvery");
  var VHt = le((e) => {
    let t = e.length,
      r = [],
      n = !1,
      i,
      o = 0;
    for (let a = 0; a < t; ++a) {
      let s = e[a];
      switch (s) {
        case '"':
          i !== "\\" && (n = !n);
          break;
        case ",":
          n || (r.push(e.slice(o, a)), (o = a + 1));
          break;
        default:
      }
      i = s;
    }
    return (
      r.push(e.slice(o)),
      r.map((a) => {
        a = a.trim();
        let s = a.length;
        return s < 2
          ? a
          : (a[0] === '"' && a[s - 1] === '"' && (a = a.slice(1, s - 1)),
            a.replace(/\\"/g, '"'));
      })
    );
  }, "splitHeader");
});
var MSe,
  $Ht,
  qSe = w(() => {
    c();
    (MSe = A(vt())),
      ($Ht = (e) => {
        if (e != null)
          return (
            typeof e == "object" && "__type" in e && delete e.__type,
            (0, MSe.expectUnion)(e)
          );
      });
  });
var jSe,
  QD,
  $W = w(() => {
    c();
    (jSe = A(vt())),
      (QD = (e, t) => (0, jSe.collectBody)(e, t).then((r) => t.utf8Encoder(r)));
  });
var YD,
  zW,
  KW,
  FSe = w(() => {
    c();
    $W();
    (YD = (e, t) =>
      QD(e, t).then((r) => {
        if (r.length)
          try {
            return JSON.parse(r);
          } catch (n) {
            throw (
              (n?.name === "SyntaxError" &&
                Object.defineProperty(n, "$responseBodyText", { value: r }),
              n)
            );
          }
        return {};
      })),
      (zW = async (e, t) => {
        let r = await YD(e, t);
        return (r.message = r.message ?? r.Message), r;
      }),
      (KW = (e, t) => {
        let r = (o, a) =>
            Object.keys(o).find((s) => s.toLowerCase() === a.toLowerCase()),
          n = (o) => {
            let a = o;
            return (
              typeof a == "number" && (a = a.toString()),
              a.indexOf(",") >= 0 && (a = a.split(",")[0]),
              a.indexOf(":") >= 0 && (a = a.split(":")[0]),
              a.indexOf("#") >= 0 && (a = a.split("#")[1]),
              a
            );
          },
          i = r(e.headers, "x-amzn-errortype");
        if (i !== void 0) return n(e.headers[i]);
        if (t.code !== void 0) return n(t.code);
        if (t.__type !== void 0) return n(t.__type);
      });
  });
var XD = g((ml) => {
  "use strict";
  c();
  var BSe =
      ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD",
    zHt = BSe + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040",
    USe = "[" + BSe + "][" + zHt + "]*",
    KHt = new RegExp("^" + USe + "$"),
    WHt = function (e, t) {
      let r = [],
        n = t.exec(e);
      for (; n; ) {
        let i = [];
        i.startIndex = t.lastIndex - n[0].length;
        let o = n.length;
        for (let a = 0; a < o; a++) i.push(n[a]);
        r.push(i), (n = t.exec(e));
      }
      return r;
    },
    QHt = function (e) {
      let t = KHt.exec(e);
      return !(t === null || typeof t > "u");
    };
  ml.isExist = function (e) {
    return typeof e < "u";
  };
  ml.isEmptyObject = function (e) {
    return Object.keys(e).length === 0;
  };
  ml.merge = function (e, t, r) {
    if (t) {
      let n = Object.keys(t),
        i = n.length;
      for (let o = 0; o < i; o++)
        r === "strict" ? (e[n[o]] = [t[n[o]]]) : (e[n[o]] = t[n[o]]);
    }
  };
  ml.getValue = function (e) {
    return ml.isExist(e) ? e : "";
  };
  ml.isName = QHt;
  ml.getAllMatches = WHt;
  ml.nameRegexp = USe;
});
var QW = g((zSe) => {
  "use strict";
  c();
  var WW = XD(),
    YHt = { allowBooleanAttributes: !1, unpairedTags: [] };
  zSe.validate = function (e, t) {
    t = Object.assign({}, YHt, t);
    let r = [],
      n = !1,
      i = !1;
    e[0] === "\uFEFF" && (e = e.substr(1));
    for (let o = 0; o < e.length; o++)
      if (e[o] === "<" && e[o + 1] === "?") {
        if (((o += 2), (o = GSe(e, o)), o.err)) return o;
      } else if (e[o] === "<") {
        let a = o;
        if ((o++, e[o] === "!")) {
          o = VSe(e, o);
          continue;
        } else {
          let s = !1;
          e[o] === "/" && ((s = !0), o++);
          let u = "";
          for (
            ;
            o < e.length &&
            e[o] !== ">" &&
            e[o] !== " " &&
            e[o] !== "	" &&
            e[o] !==
              `
` &&
            e[o] !== "\r";
            o++
          )
            u += e[o];
          if (
            ((u = u.trim()),
            u[u.length - 1] === "/" &&
              ((u = u.substring(0, u.length - 1)), o--),
            !i3t(u))
          ) {
            let f;
            return (
              u.trim().length === 0
                ? (f = "Invalid space after '<'.")
                : (f = "Tag '" + u + "' is an invalid name."),
              hn("InvalidTag", f, to(e, o))
            );
          }
          let l = ZHt(e, o);
          if (l === !1)
            return hn(
              "InvalidAttr",
              "Attributes for '" + u + "' have open quote.",
              to(e, o),
            );
          let d = l.value;
          if (((o = l.index), d[d.length - 1] === "/")) {
            let f = o - d.length;
            d = d.substring(0, d.length - 1);
            let m = $Se(d, t);
            if (m === !0) n = !0;
            else return hn(m.err.code, m.err.msg, to(e, f + m.err.line));
          } else if (s)
            if (l.tagClosed) {
              if (d.trim().length > 0)
                return hn(
                  "InvalidTag",
                  "Closing tag '" +
                    u +
                    "' can't have attributes or invalid starting.",
                  to(e, a),
                );
              if (r.length === 0)
                return hn(
                  "InvalidTag",
                  "Closing tag '" + u + "' has not been opened.",
                  to(e, a),
                );
              {
                let f = r.pop();
                if (u !== f.tagName) {
                  let m = to(e, f.tagStartPos);
                  return hn(
                    "InvalidTag",
                    "Expected closing tag '" +
                      f.tagName +
                      "' (opened in line " +
                      m.line +
                      ", col " +
                      m.col +
                      ") instead of closing tag '" +
                      u +
                      "'.",
                    to(e, a),
                  );
                }
                r.length == 0 && (i = !0);
              }
            } else
              return hn(
                "InvalidTag",
                "Closing tag '" + u + "' doesn't have proper closing.",
                to(e, o),
              );
          else {
            let f = $Se(d, t);
            if (f !== !0)
              return hn(
                f.err.code,
                f.err.msg,
                to(e, o - d.length + f.err.line),
              );
            if (i === !0)
              return hn(
                "InvalidXml",
                "Multiple possible root nodes found.",
                to(e, o),
              );
            t.unpairedTags.indexOf(u) !== -1 ||
              r.push({ tagName: u, tagStartPos: a }),
              (n = !0);
          }
          for (o++; o < e.length; o++)
            if (e[o] === "<")
              if (e[o + 1] === "!") {
                o++, (o = VSe(e, o));
                continue;
              } else if (e[o + 1] === "?") {
                if (((o = GSe(e, ++o)), o.err)) return o;
              } else break;
            else if (e[o] === "&") {
              let f = r3t(e, o);
              if (f == -1)
                return hn("InvalidChar", "char '&' is not expected.", to(e, o));
              o = f;
            } else if (i === !0 && !HSe(e[o]))
              return hn("InvalidXml", "Extra text at the end", to(e, o));
          e[o] === "<" && o--;
        }
      } else {
        if (HSe(e[o])) continue;
        return hn(
          "InvalidChar",
          "char '" + e[o] + "' is not expected.",
          to(e, o),
        );
      }
    if (n) {
      if (r.length == 1)
        return hn(
          "InvalidTag",
          "Unclosed tag '" + r[0].tagName + "'.",
          to(e, r[0].tagStartPos),
        );
      if (r.length > 0)
        return hn(
          "InvalidXml",
          "Invalid '" +
            JSON.stringify(
              r.map((o) => o.tagName),
              null,
              4,
            ).replace(/\r?\n/g, "") +
            "' found.",
          { line: 1, col: 1 },
        );
    } else return hn("InvalidXml", "Start tag expected.", 1);
    return !0;
  };
  function HSe(e) {
    return (
      e === " " ||
      e === "	" ||
      e ===
        `
` ||
      e === "\r"
    );
  }
  function GSe(e, t) {
    let r = t;
    for (; t < e.length; t++)
      if (e[t] == "?" || e[t] == " ") {
        let n = e.substr(r, t - r);
        if (t > 5 && n === "xml")
          return hn(
            "InvalidXml",
            "XML declaration allowed only at the start of the document.",
            to(e, t),
          );
        if (e[t] == "?" && e[t + 1] == ">") {
          t++;
          break;
        } else continue;
      }
    return t;
  }
  function VSe(e, t) {
    if (e.length > t + 5 && e[t + 1] === "-" && e[t + 2] === "-") {
      for (t += 3; t < e.length; t++)
        if (e[t] === "-" && e[t + 1] === "-" && e[t + 2] === ">") {
          t += 2;
          break;
        }
    } else if (
      e.length > t + 8 &&
      e[t + 1] === "D" &&
      e[t + 2] === "O" &&
      e[t + 3] === "C" &&
      e[t + 4] === "T" &&
      e[t + 5] === "Y" &&
      e[t + 6] === "P" &&
      e[t + 7] === "E"
    ) {
      let r = 1;
      for (t += 8; t < e.length; t++)
        if (e[t] === "<") r++;
        else if (e[t] === ">" && (r--, r === 0)) break;
    } else if (
      e.length > t + 9 &&
      e[t + 1] === "[" &&
      e[t + 2] === "C" &&
      e[t + 3] === "D" &&
      e[t + 4] === "A" &&
      e[t + 5] === "T" &&
      e[t + 6] === "A" &&
      e[t + 7] === "["
    ) {
      for (t += 8; t < e.length; t++)
        if (e[t] === "]" && e[t + 1] === "]" && e[t + 2] === ">") {
          t += 2;
          break;
        }
    }
    return t;
  }
  var XHt = '"',
    JHt = "'";
  function ZHt(e, t) {
    let r = "",
      n = "",
      i = !1;
    for (; t < e.length; t++) {
      if (e[t] === XHt || e[t] === JHt)
        n === "" ? (n = e[t]) : n !== e[t] || (n = "");
      else if (e[t] === ">" && n === "") {
        i = !0;
        break;
      }
      r += e[t];
    }
    return n !== "" ? !1 : { value: r, index: t, tagClosed: i };
  }
  var e3t = new RegExp(
    `(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`,
    "g",
  );
  function $Se(e, t) {
    let r = WW.getAllMatches(e, e3t),
      n = {};
    for (let i = 0; i < r.length; i++) {
      if (r[i][1].length === 0)
        return hn(
          "InvalidAttr",
          "Attribute '" + r[i][2] + "' has no space in starting.",
          FC(r[i]),
        );
      if (r[i][3] !== void 0 && r[i][4] === void 0)
        return hn(
          "InvalidAttr",
          "Attribute '" + r[i][2] + "' is without value.",
          FC(r[i]),
        );
      if (r[i][3] === void 0 && !t.allowBooleanAttributes)
        return hn(
          "InvalidAttr",
          "boolean attribute '" + r[i][2] + "' is not allowed.",
          FC(r[i]),
        );
      let o = r[i][2];
      if (!n3t(o))
        return hn(
          "InvalidAttr",
          "Attribute '" + o + "' is an invalid name.",
          FC(r[i]),
        );
      if (!n.hasOwnProperty(o)) n[o] = 1;
      else
        return hn(
          "InvalidAttr",
          "Attribute '" + o + "' is repeated.",
          FC(r[i]),
        );
    }
    return !0;
  }
  function t3t(e, t) {
    let r = /\d/;
    for (e[t] === "x" && (t++, (r = /[\da-fA-F]/)); t < e.length; t++) {
      if (e[t] === ";") return t;
      if (!e[t].match(r)) break;
    }
    return -1;
  }
  function r3t(e, t) {
    if ((t++, e[t] === ";")) return -1;
    if (e[t] === "#") return t++, t3t(e, t);
    let r = 0;
    for (; t < e.length; t++, r++)
      if (!(e[t].match(/\w/) && r < 20)) {
        if (e[t] === ";") break;
        return -1;
      }
    return t;
  }
  function hn(e, t, r) {
    return { err: { code: e, msg: t, line: r.line || r, col: r.col } };
  }
  function n3t(e) {
    return WW.isName(e);
  }
  function i3t(e) {
    return WW.isName(e);
  }
  function to(e, t) {
    let r = e.substring(0, t).split(/\r?\n/);
    return { line: r.length, col: r[r.length - 1].length + 1 };
  }
  function FC(e) {
    return e.startIndex + e[1].length;
  }
});
var WSe = g((YW) => {
  c();
  var KSe = {
      preserveOrder: !1,
      attributeNamePrefix: "@_",
      attributesGroupName: !1,
      textNodeName: "#text",
      ignoreAttributes: !0,
      removeNSPrefix: !1,
      allowBooleanAttributes: !1,
      parseTagValue: !0,
      parseAttributeValue: !1,
      trimValues: !0,
      cdataPropName: !1,
      numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 },
      tagValueProcessor: function (e, t) {
        return t;
      },
      attributeValueProcessor: function (e, t) {
        return t;
      },
      stopNodes: [],
      alwaysCreateTextNode: !1,
      isArray: () => !1,
      commentPropName: !1,
      unpairedTags: [],
      processEntities: !0,
      htmlEntities: !1,
      ignoreDeclaration: !1,
      ignorePiTags: !1,
      transformTagName: !1,
      transformAttributeName: !1,
      updateTag: function (e, t, r) {
        return e;
      },
    },
    o3t = function (e) {
      return Object.assign({}, KSe, e);
    };
  YW.buildOptions = o3t;
  YW.defaultOptions = KSe;
});
var YSe = g((tCn, QSe) => {
  "use strict";
  c();
  var XW = class {
    constructor(t) {
      (this.tagname = t), (this.child = []), (this[":@"] = {});
    }
    add(t, r) {
      t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: r });
    }
    addChild(t) {
      t.tagname === "__proto__" && (t.tagname = "#__proto__"),
        t[":@"] && Object.keys(t[":@"]).length > 0
          ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] })
          : this.child.push({ [t.tagname]: t.child });
    }
  };
  QSe.exports = XW;
});
var JSe = g((nCn, XSe) => {
  c();
  var a3t = XD();
  function s3t(e, t) {
    let r = {};
    if (
      e[t + 3] === "O" &&
      e[t + 4] === "C" &&
      e[t + 5] === "T" &&
      e[t + 6] === "Y" &&
      e[t + 7] === "P" &&
      e[t + 8] === "E"
    ) {
      t = t + 9;
      let n = 1,
        i = !1,
        o = !1,
        a = "";
      for (; t < e.length; t++)
        if (e[t] === "<" && !o) {
          if (i && l3t(e, t))
            (t += 7),
              ([entityName, val, t] = c3t(e, t + 1)),
              val.indexOf("&") === -1 &&
                (r[m3t(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val,
                });
          else if (i && d3t(e, t)) t += 8;
          else if (i && f3t(e, t)) t += 8;
          else if (i && p3t(e, t)) t += 9;
          else if (u3t) o = !0;
          else throw new Error("Invalid DOCTYPE");
          n++, (a = "");
        } else if (e[t] === ">") {
          if (
            (o ? e[t - 1] === "-" && e[t - 2] === "-" && ((o = !1), n--) : n--,
            n === 0)
          )
            break;
        } else e[t] === "[" ? (i = !0) : (a += e[t]);
      if (n !== 0) throw new Error("Unclosed DOCTYPE");
    } else throw new Error("Invalid Tag instead of DOCTYPE");
    return { entities: r, i: t };
  }
  function c3t(e, t) {
    let r = "";
    for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++) r += e[t];
    if (((r = r.trim()), r.indexOf(" ") !== -1))
      throw new Error("External entites are not supported");
    let n = e[t++],
      i = "";
    for (; t < e.length && e[t] !== n; t++) i += e[t];
    return [r, i, t];
  }
  function u3t(e, t) {
    return e[t + 1] === "!" && e[t + 2] === "-" && e[t + 3] === "-";
  }
  function l3t(e, t) {
    return (
      e[t + 1] === "!" &&
      e[t + 2] === "E" &&
      e[t + 3] === "N" &&
      e[t + 4] === "T" &&
      e[t + 5] === "I" &&
      e[t + 6] === "T" &&
      e[t + 7] === "Y"
    );
  }
  function d3t(e, t) {
    return (
      e[t + 1] === "!" &&
      e[t + 2] === "E" &&
      e[t + 3] === "L" &&
      e[t + 4] === "E" &&
      e[t + 5] === "M" &&
      e[t + 6] === "E" &&
      e[t + 7] === "N" &&
      e[t + 8] === "T"
    );
  }
  function f3t(e, t) {
    return (
      e[t + 1] === "!" &&
      e[t + 2] === "A" &&
      e[t + 3] === "T" &&
      e[t + 4] === "T" &&
      e[t + 5] === "L" &&
      e[t + 6] === "I" &&
      e[t + 7] === "S" &&
      e[t + 8] === "T"
    );
  }
  function p3t(e, t) {
    return (
      e[t + 1] === "!" &&
      e[t + 2] === "N" &&
      e[t + 3] === "O" &&
      e[t + 4] === "T" &&
      e[t + 5] === "A" &&
      e[t + 6] === "T" &&
      e[t + 7] === "I" &&
      e[t + 8] === "O" &&
      e[t + 9] === "N"
    );
  }
  function m3t(e) {
    if (a3t.isName(e)) return e;
    throw new Error(`Invalid entity name ${e}`);
  }
  XSe.exports = s3t;
});
var e0e = g((oCn, ZSe) => {
  c();
  var h3t = /^[-+]?0x[a-fA-F0-9]+$/,
    g3t = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/,
    v3t = { hex: !0, leadingZeros: !0, decimalPoint: ".", eNotation: !0 };
  function y3t(e, t = {}) {
    if (((t = Object.assign({}, v3t, t)), !e || typeof e != "string")) return e;
    let r = e.trim();
    if (t.skipLike !== void 0 && t.skipLike.test(r)) return e;
    if (e === "0") return 0;
    if (t.hex && h3t.test(r)) return E3t(r, 16);
    if (r.search(/[eE]/) !== -1) {
      let n = r.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
      if (n) {
        if (t.leadingZeros) r = (n[1] || "") + n[3];
        else if (!(n[2] === "0" && n[3][0] === ".")) return e;
        return t.eNotation ? Number(r) : e;
      } else return e;
    } else {
      let n = g3t.exec(r);
      if (n) {
        let i = n[1],
          o = n[2],
          a = _3t(n[3]);
        if (!t.leadingZeros && o.length > 0 && i && r[2] !== ".") return e;
        if (!t.leadingZeros && o.length > 0 && !i && r[1] !== ".") return e;
        if (t.leadingZeros && o === e) return 0;
        {
          let s = Number(r),
            u = "" + s;
          return u.search(/[eE]/) !== -1
            ? t.eNotation
              ? s
              : e
            : r.indexOf(".") !== -1
              ? (u === "0" && a === "") || u === a || (i && u === "-" + a)
                ? s
                : e
              : o
                ? a === u || i + a === u
                  ? s
                  : e
                : r === u || r === i + u
                  ? s
                  : e;
        }
      } else return e;
    }
  }
  function _3t(e) {
    return (
      e &&
        e.indexOf(".") !== -1 &&
        ((e = e.replace(/0+$/, "")),
        e === "."
          ? (e = "0")
          : e[0] === "."
            ? (e = "0" + e)
            : e[e.length - 1] === "." && (e = e.substr(0, e.length - 1))),
      e
    );
  }
  function E3t(e, t) {
    if (parseInt) return parseInt(e, t);
    if (Number.parseInt) return Number.parseInt(e, t);
    if (window && window.parseInt) return window.parseInt(e, t);
    throw new Error(
      "parseInt, Number.parseInt, window.parseInt are not supported",
    );
  }
  ZSe.exports = y3t;
});
var n0e = g((sCn, r0e) => {
  "use strict";
  c();
  var t0e = XD(),
    BC = YSe(),
    b3t = JSe(),
    S3t = e0e(),
    JW = class {
      constructor(t) {
        (this.options = t),
          (this.currentNode = null),
          (this.tagsNodeStack = []),
          (this.docTypeEntities = {}),
          (this.lastEntities = {
            apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
            gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
            lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
            quot: { regex: /&(quot|#34|#x22);/g, val: '"' },
          }),
          (this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }),
          (this.htmlEntities = {
            space: { regex: /&(nbsp|#160);/g, val: " " },
            cent: { regex: /&(cent|#162);/g, val: "\xA2" },
            pound: { regex: /&(pound|#163);/g, val: "\xA3" },
            yen: { regex: /&(yen|#165);/g, val: "\xA5" },
            euro: { regex: /&(euro|#8364);/g, val: "\u20AC" },
            copyright: { regex: /&(copy|#169);/g, val: "\xA9" },
            reg: { regex: /&(reg|#174);/g, val: "\xAE" },
            inr: { regex: /&(inr|#8377);/g, val: "\u20B9" },
            num_dec: {
              regex: /&#([0-9]{1,7});/g,
              val: (r, n) => String.fromCharCode(Number.parseInt(n, 10)),
            },
            num_hex: {
              regex: /&#x([0-9a-fA-F]{1,6});/g,
              val: (r, n) => String.fromCharCode(Number.parseInt(n, 16)),
            },
          }),
          (this.addExternalEntities = C3t),
          (this.parseXml = P3t),
          (this.parseTextData = w3t),
          (this.resolveNameSpace = O3t),
          (this.buildAttributesMap = A3t),
          (this.isItStopNode = N3t),
          (this.replaceEntitiesValue = I3t),
          (this.readStopNodeData = D3t),
          (this.saveTextToParentTag = x3t),
          (this.addChild = R3t);
      }
    };
  function C3t(e) {
    let t = Object.keys(e);
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      this.lastEntities[n] = {
        regex: new RegExp("&" + n + ";", "g"),
        val: e[n],
      };
    }
  }
  function w3t(e, t, r, n, i, o, a) {
    if (
      e !== void 0 &&
      (this.options.trimValues && !n && (e = e.trim()), e.length > 0)
    ) {
      a || (e = this.replaceEntitiesValue(e));
      let s = this.options.tagValueProcessor(t, e, r, i, o);
      return s == null
        ? e
        : typeof s != typeof e || s !== e
          ? s
          : this.options.trimValues
            ? e6(e, this.options.parseTagValue, this.options.numberParseOptions)
            : e.trim() === e
              ? e6(
                  e,
                  this.options.parseTagValue,
                  this.options.numberParseOptions,
                )
              : e;
    }
  }
  function O3t(e) {
    if (this.options.removeNSPrefix) {
      let t = e.split(":"),
        r = e.charAt(0) === "/" ? "/" : "";
      if (t[0] === "xmlns") return "";
      t.length === 2 && (e = r + t[1]);
    }
    return e;
  }
  var T3t = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
  function A3t(e, t, r) {
    if (!this.options.ignoreAttributes && typeof e == "string") {
      let n = t0e.getAllMatches(e, T3t),
        i = n.length,
        o = {};
      for (let a = 0; a < i; a++) {
        let s = this.resolveNameSpace(n[a][1]),
          u = n[a][4],
          l = this.options.attributeNamePrefix + s;
        if (s.length)
          if (
            (this.options.transformAttributeName &&
              (l = this.options.transformAttributeName(l)),
            l === "__proto__" && (l = "#__proto__"),
            u !== void 0)
          ) {
            this.options.trimValues && (u = u.trim()),
              (u = this.replaceEntitiesValue(u));
            let d = this.options.attributeValueProcessor(s, u, t);
            d == null
              ? (o[l] = u)
              : typeof d != typeof u || d !== u
                ? (o[l] = d)
                : (o[l] = e6(
                    u,
                    this.options.parseAttributeValue,
                    this.options.numberParseOptions,
                  ));
          } else this.options.allowBooleanAttributes && (o[l] = !0);
      }
      if (!Object.keys(o).length) return;
      if (this.options.attributesGroupName) {
        let a = {};
        return (a[this.options.attributesGroupName] = o), a;
      }
      return o;
    }
  }
  var P3t = function (e) {
    e = e.replace(
      /\r\n?/g,
      `
`,
    );
    let t = new BC("!xml"),
      r = t,
      n = "",
      i = "";
    for (let o = 0; o < e.length; o++)
      if (e[o] === "<")
        if (e[o + 1] === "/") {
          let s = uh(e, ">", o, "Closing Tag is not closed."),
            u = e.substring(o + 2, s).trim();
          if (this.options.removeNSPrefix) {
            let f = u.indexOf(":");
            f !== -1 && (u = u.substr(f + 1));
          }
          this.options.transformTagName &&
            (u = this.options.transformTagName(u)),
            r && (n = this.saveTextToParentTag(n, r, i));
          let l = i.substring(i.lastIndexOf(".") + 1);
          if (u && this.options.unpairedTags.indexOf(u) !== -1)
            throw new Error(
              `Unpaired tag can not be used as closing tag: </${u}>`,
            );
          let d = 0;
          l && this.options.unpairedTags.indexOf(l) !== -1
            ? ((d = i.lastIndexOf(".", i.lastIndexOf(".") - 1)),
              this.tagsNodeStack.pop())
            : (d = i.lastIndexOf(".")),
            (i = i.substring(0, d)),
            (r = this.tagsNodeStack.pop()),
            (n = ""),
            (o = s);
        } else if (e[o + 1] === "?") {
          let s = ZW(e, o, !1, "?>");
          if (!s) throw new Error("Pi Tag is not closed.");
          if (
            ((n = this.saveTextToParentTag(n, r, i)),
            !(
              (this.options.ignoreDeclaration && s.tagName === "?xml") ||
              this.options.ignorePiTags
            ))
          ) {
            let u = new BC(s.tagName);
            u.add(this.options.textNodeName, ""),
              s.tagName !== s.tagExp &&
                s.attrExpPresent &&
                (u[":@"] = this.buildAttributesMap(s.tagExp, i, s.tagName)),
              this.addChild(r, u, i);
          }
          o = s.closeIndex + 1;
        } else if (e.substr(o + 1, 3) === "!--") {
          let s = uh(e, "-->", o + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            let u = e.substring(o + 4, s - 2);
            (n = this.saveTextToParentTag(n, r, i)),
              r.add(this.options.commentPropName, [
                { [this.options.textNodeName]: u },
              ]);
          }
          o = s;
        } else if (e.substr(o + 1, 2) === "!D") {
          let s = b3t(e, o);
          (this.docTypeEntities = s.entities), (o = s.i);
        } else if (e.substr(o + 1, 2) === "![") {
          let s = uh(e, "]]>", o, "CDATA is not closed.") - 2,
            u = e.substring(o + 9, s);
          n = this.saveTextToParentTag(n, r, i);
          let l = this.parseTextData(u, r.tagname, i, !0, !1, !0, !0);
          l == null && (l = ""),
            this.options.cdataPropName
              ? r.add(this.options.cdataPropName, [
                  { [this.options.textNodeName]: u },
                ])
              : r.add(this.options.textNodeName, l),
            (o = s + 2);
        } else {
          let s = ZW(e, o, this.options.removeNSPrefix),
            u = s.tagName,
            l = s.rawTagName,
            d = s.tagExp,
            f = s.attrExpPresent,
            m = s.closeIndex;
          this.options.transformTagName &&
            (u = this.options.transformTagName(u)),
            r &&
              n &&
              r.tagname !== "!xml" &&
              (n = this.saveTextToParentTag(n, r, i, !1));
          let h = r;
          if (
            (h &&
              this.options.unpairedTags.indexOf(h.tagname) !== -1 &&
              ((r = this.tagsNodeStack.pop()),
              (i = i.substring(0, i.lastIndexOf(".")))),
            u !== t.tagname && (i += i ? "." + u : u),
            this.isItStopNode(this.options.stopNodes, i, u))
          ) {
            let y = "";
            if (d.length > 0 && d.lastIndexOf("/") === d.length - 1)
              u[u.length - 1] === "/"
                ? ((u = u.substr(0, u.length - 1)),
                  (i = i.substr(0, i.length - 1)),
                  (d = u))
                : (d = d.substr(0, d.length - 1)),
                (o = s.closeIndex);
            else if (this.options.unpairedTags.indexOf(u) !== -1)
              o = s.closeIndex;
            else {
              let E = this.readStopNodeData(e, l, m + 1);
              if (!E) throw new Error(`Unexpected end of ${l}`);
              (o = E.i), (y = E.tagContent);
            }
            let _ = new BC(u);
            u !== d && f && (_[":@"] = this.buildAttributesMap(d, i, u)),
              y && (y = this.parseTextData(y, u, i, !0, f, !0, !0)),
              (i = i.substr(0, i.lastIndexOf("."))),
              _.add(this.options.textNodeName, y),
              this.addChild(r, _, i);
          } else {
            if (d.length > 0 && d.lastIndexOf("/") === d.length - 1) {
              u[u.length - 1] === "/"
                ? ((u = u.substr(0, u.length - 1)),
                  (i = i.substr(0, i.length - 1)),
                  (d = u))
                : (d = d.substr(0, d.length - 1)),
                this.options.transformTagName &&
                  (u = this.options.transformTagName(u));
              let y = new BC(u);
              u !== d && f && (y[":@"] = this.buildAttributesMap(d, i, u)),
                this.addChild(r, y, i),
                (i = i.substr(0, i.lastIndexOf(".")));
            } else {
              let y = new BC(u);
              this.tagsNodeStack.push(r),
                u !== d && f && (y[":@"] = this.buildAttributesMap(d, i, u)),
                this.addChild(r, y, i),
                (r = y);
            }
            (n = ""), (o = m);
          }
        }
      else n += e[o];
    return t.child;
  };
  function R3t(e, t, r) {
    let n = this.options.updateTag(t.tagname, r, t[":@"]);
    n === !1 || (typeof n == "string" && (t.tagname = n), e.addChild(t));
  }
  var I3t = function (e) {
    if (this.options.processEntities) {
      for (let t in this.docTypeEntities) {
        let r = this.docTypeEntities[t];
        e = e.replace(r.regx, r.val);
      }
      for (let t in this.lastEntities) {
        let r = this.lastEntities[t];
        e = e.replace(r.regex, r.val);
      }
      if (this.options.htmlEntities)
        for (let t in this.htmlEntities) {
          let r = this.htmlEntities[t];
          e = e.replace(r.regex, r.val);
        }
      e = e.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return e;
  };
  function x3t(e, t, r, n) {
    return (
      e &&
        (n === void 0 && (n = Object.keys(t.child).length === 0),
        (e = this.parseTextData(
          e,
          t.tagname,
          r,
          !1,
          t[":@"] ? Object.keys(t[":@"]).length !== 0 : !1,
          n,
        )),
        e !== void 0 && e !== "" && t.add(this.options.textNodeName, e),
        (e = "")),
      e
    );
  }
  function N3t(e, t, r) {
    let n = "*." + r;
    for (let i in e) {
      let o = e[i];
      if (n === o || t === o) return !0;
    }
    return !1;
  }
  function k3t(e, t, r = ">") {
    let n,
      i = "";
    for (let o = t; o < e.length; o++) {
      let a = e[o];
      if (n) a === n && (n = "");
      else if (a === '"' || a === "'") n = a;
      else if (a === r[0])
        if (r[1]) {
          if (e[o + 1] === r[1]) return { data: i, index: o };
        } else return { data: i, index: o };
      else a === "	" && (a = " ");
      i += a;
    }
  }
  function uh(e, t, r, n) {
    let i = e.indexOf(t, r);
    if (i === -1) throw new Error(n);
    return i + t.length - 1;
  }
  function ZW(e, t, r, n = ">") {
    let i = k3t(e, t + 1, n);
    if (!i) return;
    let o = i.data,
      a = i.index,
      s = o.search(/\s/),
      u = o,
      l = !0;
    s !== -1 && ((u = o.substring(0, s)), (o = o.substring(s + 1).trimStart()));
    let d = u;
    if (r) {
      let f = u.indexOf(":");
      f !== -1 && ((u = u.substr(f + 1)), (l = u !== i.data.substr(f + 1)));
    }
    return {
      tagName: u,
      tagExp: o,
      closeIndex: a,
      attrExpPresent: l,
      rawTagName: d,
    };
  }
  function D3t(e, t, r) {
    let n = r,
      i = 1;
    for (; r < e.length; r++)
      if (e[r] === "<")
        if (e[r + 1] === "/") {
          let o = uh(e, ">", r, `${t} is not closed`);
          if (e.substring(r + 2, o).trim() === t && (i--, i === 0))
            return { tagContent: e.substring(n, r), i: o };
          r = o;
        } else if (e[r + 1] === "?")
          r = uh(e, "?>", r + 1, "StopNode is not closed.");
        else if (e.substr(r + 1, 3) === "!--")
          r = uh(e, "-->", r + 3, "StopNode is not closed.");
        else if (e.substr(r + 1, 2) === "![")
          r = uh(e, "]]>", r, "StopNode is not closed.") - 2;
        else {
          let o = ZW(e, r, ">");
          o &&
            ((o && o.tagName) === t &&
              o.tagExp[o.tagExp.length - 1] !== "/" &&
              i++,
            (r = o.closeIndex));
        }
  }
  function e6(e, t, r) {
    if (t && typeof e == "string") {
      let n = e.trim();
      return n === "true" ? !0 : n === "false" ? !1 : S3t(e, r);
    } else return t0e.isExist(e) ? e : "";
  }
  r0e.exports = JW;
});
var a0e = g((o0e) => {
  "use strict";
  c();
  function L3t(e, t) {
    return i0e(e, t);
  }
  function i0e(e, t, r) {
    let n,
      i = {};
    for (let o = 0; o < e.length; o++) {
      let a = e[o],
        s = M3t(a),
        u = "";
      if ((r === void 0 ? (u = s) : (u = r + "." + s), s === t.textNodeName))
        n === void 0 ? (n = a[s]) : (n += "" + a[s]);
      else {
        if (s === void 0) continue;
        if (a[s]) {
          let l = i0e(a[s], t, u),
            d = j3t(l, t);
          a[":@"]
            ? q3t(l, a[":@"], u, t)
            : Object.keys(l).length === 1 &&
                l[t.textNodeName] !== void 0 &&
                !t.alwaysCreateTextNode
              ? (l = l[t.textNodeName])
              : Object.keys(l).length === 0 &&
                (t.alwaysCreateTextNode ? (l[t.textNodeName] = "") : (l = "")),
            i[s] !== void 0 && i.hasOwnProperty(s)
              ? (Array.isArray(i[s]) || (i[s] = [i[s]]), i[s].push(l))
              : t.isArray(s, u, d)
                ? (i[s] = [l])
                : (i[s] = l);
        }
      }
    }
    return (
      typeof n == "string"
        ? n.length > 0 && (i[t.textNodeName] = n)
        : n !== void 0 && (i[t.textNodeName] = n),
      i
    );
  }
  function M3t(e) {
    let t = Object.keys(e);
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      if (n !== ":@") return n;
    }
  }
  function q3t(e, t, r, n) {
    if (t) {
      let i = Object.keys(t),
        o = i.length;
      for (let a = 0; a < o; a++) {
        let s = i[a];
        n.isArray(s, r + "." + s, !0, !0) ? (e[s] = [t[s]]) : (e[s] = t[s]);
      }
    }
  }
  function j3t(e, t) {
    let { textNodeName: r } = t,
      n = Object.keys(e).length;
    return !!(
      n === 0 ||
      (n === 1 && (e[r] || typeof e[r] == "boolean" || e[r] === 0))
    );
  }
  o0e.prettify = L3t;
});
var c0e = g((dCn, s0e) => {
  c();
  var { buildOptions: F3t } = WSe(),
    B3t = n0e(),
    { prettify: U3t } = a0e(),
    H3t = QW(),
    t6 = class {
      constructor(t) {
        (this.externalEntities = {}), (this.options = F3t(t));
      }
      parse(t, r) {
        if (typeof t != "string")
          if (t.toString) t = t.toString();
          else
            throw new Error("XML data is accepted in String or Bytes[] form.");
        if (r) {
          r === !0 && (r = {});
          let o = H3t.validate(t, r);
          if (o !== !0) throw Error(`${o.err.msg}:${o.err.line}:${o.err.col}`);
        }
        let n = new B3t(this.options);
        n.addExternalEntities(this.externalEntities);
        let i = n.parseXml(t);
        return this.options.preserveOrder || i === void 0
          ? i
          : U3t(i, this.options);
      }
      addEntity(t, r) {
        if (r.indexOf("&") !== -1)
          throw new Error("Entity value can't have '&'");
        if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
          throw new Error(
            "An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'",
          );
        if (r === "&")
          throw new Error("An entity with value '&' is not permitted");
        this.externalEntities[t] = r;
      }
    };
  s0e.exports = t6;
});
var p0e = g((pCn, f0e) => {
  c();
  var G3t = `
`;
  function V3t(e, t) {
    let r = "";
    return t.format && t.indentBy.length > 0 && (r = G3t), l0e(e, t, "", r);
  }
  function l0e(e, t, r, n) {
    let i = "",
      o = !1;
    for (let a = 0; a < e.length; a++) {
      let s = e[a],
        u = $3t(s);
      if (u === void 0) continue;
      let l = "";
      if (
        (r.length === 0 ? (l = u) : (l = `${r}.${u}`), u === t.textNodeName)
      ) {
        let y = s[u];
        z3t(l, t) || ((y = t.tagValueProcessor(u, y)), (y = d0e(y, t))),
          o && (i += n),
          (i += y),
          (o = !1);
        continue;
      } else if (u === t.cdataPropName) {
        o && (i += n),
          (i += `<![CDATA[${s[u][0][t.textNodeName]}]]>`),
          (o = !1);
        continue;
      } else if (u === t.commentPropName) {
        (i += n + `<!--${s[u][0][t.textNodeName]}-->`), (o = !0);
        continue;
      } else if (u[0] === "?") {
        let y = u0e(s[":@"], t),
          _ = u === "?xml" ? "" : n,
          E = s[u][0][t.textNodeName];
        (E = E.length !== 0 ? " " + E : ""),
          (i += _ + `<${u}${E}${y}?>`),
          (o = !0);
        continue;
      }
      let d = n;
      d !== "" && (d += t.indentBy);
      let f = u0e(s[":@"], t),
        m = n + `<${u}${f}`,
        h = l0e(s[u], t, l, d);
      t.unpairedTags.indexOf(u) !== -1
        ? t.suppressUnpairedNode
          ? (i += m + ">")
          : (i += m + "/>")
        : (!h || h.length === 0) && t.suppressEmptyNode
          ? (i += m + "/>")
          : h && h.endsWith(">")
            ? (i += m + `>${h}${n}</${u}>`)
            : ((i += m + ">"),
              h && n !== "" && (h.includes("/>") || h.includes("</"))
                ? (i += n + t.indentBy + h + n)
                : (i += h),
              (i += `</${u}>`)),
        (o = !0);
    }
    return i;
  }
  function $3t(e) {
    let t = Object.keys(e);
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      if (e.hasOwnProperty(n) && n !== ":@") return n;
    }
  }
  function u0e(e, t) {
    let r = "";
    if (e && !t.ignoreAttributes)
      for (let n in e) {
        if (!e.hasOwnProperty(n)) continue;
        let i = t.attributeValueProcessor(n, e[n]);
        (i = d0e(i, t)),
          i === !0 && t.suppressBooleanAttributes
            ? (r += ` ${n.substr(t.attributeNamePrefix.length)}`)
            : (r += ` ${n.substr(t.attributeNamePrefix.length)}="${i}"`);
      }
    return r;
  }
  function z3t(e, t) {
    e = e.substr(0, e.length - t.textNodeName.length - 1);
    let r = e.substr(e.lastIndexOf(".") + 1);
    for (let n in t.stopNodes)
      if (t.stopNodes[n] === e || t.stopNodes[n] === "*." + r) return !0;
    return !1;
  }
  function d0e(e, t) {
    if (e && e.length > 0 && t.processEntities)
      for (let r = 0; r < t.entities.length; r++) {
        let n = t.entities[r];
        e = e.replace(n.regex, n.val);
      }
    return e;
  }
  f0e.exports = V3t;
});
var h0e = g((hCn, m0e) => {
  "use strict";
  c();
  var K3t = p0e(),
    W3t = {
      attributeNamePrefix: "@_",
      attributesGroupName: !1,
      textNodeName: "#text",
      ignoreAttributes: !0,
      cdataPropName: !1,
      format: !1,
      indentBy: "  ",
      suppressEmptyNode: !1,
      suppressUnpairedNode: !0,
      suppressBooleanAttributes: !0,
      tagValueProcessor: function (e, t) {
        return t;
      },
      attributeValueProcessor: function (e, t) {
        return t;
      },
      preserveOrder: !1,
      commentPropName: !1,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" },
      ],
      processEntities: !0,
      stopNodes: [],
      oneListGroup: !1,
    };
  function Cf(e) {
    (this.options = Object.assign({}, W3t, e)),
      this.options.ignoreAttributes || this.options.attributesGroupName
        ? (this.isAttribute = function () {
            return !1;
          })
        : ((this.attrPrefixLen = this.options.attributeNamePrefix.length),
          (this.isAttribute = X3t)),
      (this.processTextOrObjNode = Q3t),
      this.options.format
        ? ((this.indentate = Y3t),
          (this.tagEndChar = `>
`),
          (this.newLine = `
`))
        : ((this.indentate = function () {
            return "";
          }),
          (this.tagEndChar = ">"),
          (this.newLine = ""));
  }
  Cf.prototype.build = function (e) {
    return this.options.preserveOrder
      ? K3t(e, this.options)
      : (Array.isArray(e) &&
          this.options.arrayNodeName &&
          this.options.arrayNodeName.length > 1 &&
          (e = { [this.options.arrayNodeName]: e }),
        this.j2x(e, 0).val);
  };
  Cf.prototype.j2x = function (e, t) {
    let r = "",
      n = "";
    for (let i in e)
      if (Object.prototype.hasOwnProperty.call(e, i))
        if (typeof e[i] > "u") this.isAttribute(i) && (n += "");
        else if (e[i] === null)
          this.isAttribute(i)
            ? (n += "")
            : i[0] === "?"
              ? (n += this.indentate(t) + "<" + i + "?" + this.tagEndChar)
              : (n += this.indentate(t) + "<" + i + "/" + this.tagEndChar);
        else if (e[i] instanceof Date)
          n += this.buildTextValNode(e[i], i, "", t);
        else if (typeof e[i] != "object") {
          let o = this.isAttribute(i);
          if (o) r += this.buildAttrPairStr(o, "" + e[i]);
          else if (i === this.options.textNodeName) {
            let a = this.options.tagValueProcessor(i, "" + e[i]);
            n += this.replaceEntitiesValue(a);
          } else n += this.buildTextValNode(e[i], i, "", t);
        } else if (Array.isArray(e[i])) {
          let o = e[i].length,
            a = "",
            s = "";
          for (let u = 0; u < o; u++) {
            let l = e[i][u];
            if (!(typeof l > "u"))
              if (l === null)
                i[0] === "?"
                  ? (n += this.indentate(t) + "<" + i + "?" + this.tagEndChar)
                  : (n += this.indentate(t) + "<" + i + "/" + this.tagEndChar);
              else if (typeof l == "object")
                if (this.options.oneListGroup) {
                  let d = this.j2x(l, t + 1);
                  (a += d.val),
                    this.options.attributesGroupName &&
                      l.hasOwnProperty(this.options.attributesGroupName) &&
                      (s += d.attrStr);
                } else a += this.processTextOrObjNode(l, i, t);
              else if (this.options.oneListGroup) {
                let d = this.options.tagValueProcessor(i, l);
                (d = this.replaceEntitiesValue(d)), (a += d);
              } else a += this.buildTextValNode(l, i, "", t);
          }
          this.options.oneListGroup && (a = this.buildObjectNode(a, i, s, t)),
            (n += a);
        } else if (
          this.options.attributesGroupName &&
          i === this.options.attributesGroupName
        ) {
          let o = Object.keys(e[i]),
            a = o.length;
          for (let s = 0; s < a; s++)
            r += this.buildAttrPairStr(o[s], "" + e[i][o[s]]);
        } else n += this.processTextOrObjNode(e[i], i, t);
    return { attrStr: r, val: n };
  };
  Cf.prototype.buildAttrPairStr = function (e, t) {
    return (
      (t = this.options.attributeValueProcessor(e, "" + t)),
      (t = this.replaceEntitiesValue(t)),
      this.options.suppressBooleanAttributes && t === "true"
        ? " " + e
        : " " + e + '="' + t + '"'
    );
  };
  function Q3t(e, t, r) {
    let n = this.j2x(e, r + 1);
    return e[this.options.textNodeName] !== void 0 &&
      Object.keys(e).length === 1
      ? this.buildTextValNode(e[this.options.textNodeName], t, n.attrStr, r)
      : this.buildObjectNode(n.val, t, n.attrStr, r);
  }
  Cf.prototype.buildObjectNode = function (e, t, r, n) {
    if (e === "")
      return t[0] === "?"
        ? this.indentate(n) + "<" + t + r + "?" + this.tagEndChar
        : this.indentate(n) + "<" + t + r + this.closeTag(t) + this.tagEndChar;
    {
      let i = "</" + t + this.tagEndChar,
        o = "";
      return (
        t[0] === "?" && ((o = "?"), (i = "")),
        (r || r === "") && e.indexOf("<") === -1
          ? this.indentate(n) + "<" + t + r + o + ">" + e + i
          : this.options.commentPropName !== !1 &&
              t === this.options.commentPropName &&
              o.length === 0
            ? this.indentate(n) + `<!--${e}-->` + this.newLine
            : this.indentate(n) +
              "<" +
              t +
              r +
              o +
              this.tagEndChar +
              e +
              this.indentate(n) +
              i
      );
    }
  };
  Cf.prototype.closeTag = function (e) {
    let t = "";
    return (
      this.options.unpairedTags.indexOf(e) !== -1
        ? this.options.suppressUnpairedNode || (t = "/")
        : this.options.suppressEmptyNode
          ? (t = "/")
          : (t = `></${e}`),
      t
    );
  };
  Cf.prototype.buildTextValNode = function (e, t, r, n) {
    if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName)
      return this.indentate(n) + `<![CDATA[${e}]]>` + this.newLine;
    if (
      this.options.commentPropName !== !1 &&
      t === this.options.commentPropName
    )
      return this.indentate(n) + `<!--${e}-->` + this.newLine;
    if (t[0] === "?")
      return this.indentate(n) + "<" + t + r + "?" + this.tagEndChar;
    {
      let i = this.options.tagValueProcessor(t, e);
      return (
        (i = this.replaceEntitiesValue(i)),
        i === ""
          ? this.indentate(n) + "<" + t + r + this.closeTag(t) + this.tagEndChar
          : this.indentate(n) +
            "<" +
            t +
            r +
            ">" +
            i +
            "</" +
            t +
            this.tagEndChar
      );
    }
  };
  Cf.prototype.replaceEntitiesValue = function (e) {
    if (e && e.length > 0 && this.options.processEntities)
      for (let t = 0; t < this.options.entities.length; t++) {
        let r = this.options.entities[t];
        e = e.replace(r.regex, r.val);
      }
    return e;
  };
  function Y3t(e) {
    return this.options.indentBy.repeat(e);
  }
  function X3t(e) {
    return e.startsWith(this.options.attributeNamePrefix) &&
      e !== this.options.textNodeName
      ? e.substr(this.attrPrefixLen)
      : !1;
  }
  m0e.exports = Cf;
});
var UC = g((vCn, g0e) => {
  "use strict";
  c();
  var J3t = QW(),
    Z3t = c0e(),
    eGt = h0e();
  g0e.exports = { XMLParser: Z3t, XMLValidator: J3t, XMLBuilder: eGt };
});
var v0e,
  y0e,
  HC,
  r6,
  tGt,
  _0e = w(() => {
    c();
    (v0e = A(vt())), (y0e = A(UC()));
    $W();
    (HC = (e, t) =>
      QD(e, t).then((r) => {
        if (r.length) {
          let n = new y0e.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: (u, l) =>
              l.trim() === "" &&
              l.includes(`
`)
                ? ""
                : void 0,
          });
          n.addEntity("#xD", "\r"),
            n.addEntity(
              "#10",
              `
`,
            );
          let i;
          try {
            i = n.parse(r, !0);
          } catch (u) {
            throw (
              (u &&
                typeof u == "object" &&
                Object.defineProperty(u, "$responseBodyText", { value: r }),
              u)
            );
          }
          let o = "#text",
            a = Object.keys(i)[0],
            s = i[a];
          return (
            s[o] && ((s[a] = s[o]), delete s[o]),
            (0, v0e.getValueFromTextNode)(s)
          );
        }
        return {};
      })),
      (r6 = async (e, t) => {
        let r = await HC(e, t);
        return (
          r.Error && (r.Error.message = r.Error.message ?? r.Error.Message), r
        );
      }),
      (tGt = (e, t) => {
        if (t?.Error?.Code !== void 0) return t.Error.Code;
        if (t?.Code !== void 0) return t.Code;
        if (e.statusCode == 404) return "NotFound";
      });
  });
var E0e = w(() => {
  c();
  fSe();
  qSe();
  FSe();
  _0e();
});
var $c = {};
bn($c, {
  AWSSDKSigV4Signer: () => bbe,
  AwsSdkSigV4ASigner: () => LD,
  AwsSdkSigV4Signer: () => da,
  NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => kC,
  NODE_SIGV4A_CONFIG_OPTIONS: () => ZBt,
  _toBool: () => TUt,
  _toNum: () => AUt,
  _toStr: () => OUt,
  awsExpectUnion: () => $Ht,
  emitWarningIfUnsupportedVersion: () => Gy,
  loadRestJsonErrorCode: () => KW,
  loadRestXmlErrorCode: () => tGt,
  parseJsonBody: () => YD,
  parseJsonErrorBody: () => zW,
  parseXmlBody: () => HC,
  parseXmlErrorBody: () => r6,
  resolveAWSSDKSigV4Config: () => SUt,
  resolveAwsSdkSigV4AConfig: () => JBt,
  resolveAwsSdkSigV4Config: () => zy,
  setCredentialFeature: () => _f,
  setFeature: () => pbe,
  state: () => DD,
  validateSigningProperties: () => NC,
});
var Jn = w(() => {
  c();
  Ks();
  dSe();
  E0e();
});
var Yy = g((NCn, N0e) => {
  "use strict";
  c();
  var ZD = Object.defineProperty,
    rGt = Object.getOwnPropertyDescriptor,
    nGt = Object.getOwnPropertyNames,
    iGt = Object.prototype.hasOwnProperty,
    hl = (e, t) => ZD(e, "name", { value: t, configurable: !0 }),
    oGt = (e, t) => {
      for (var r in t) ZD(e, r, { get: t[r], enumerable: !0 });
    },
    aGt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of nGt(t))
          !iGt.call(e, i) &&
            i !== r &&
            ZD(e, i, {
              get: () => t[i],
              enumerable: !(n = rGt(t, i)) || n.enumerable,
            });
      return e;
    },
    sGt = (e) => aGt(ZD({}, "__esModule", { value: !0 }), e),
    w0e = {};
  oGt(w0e, {
    DEFAULT_UA_APP_ID: () => O0e,
    getUserAgentMiddlewareOptions: () => x0e,
    getUserAgentPlugin: () => hGt,
    resolveUserAgentConfig: () => A0e,
    userAgentMiddleware: () => I0e,
  });
  N0e.exports = sGt(w0e);
  var cGt = (Gi(), ue(yf)),
    O0e = void 0;
  function T0e(e) {
    return e === void 0 ? !0 : typeof e == "string" && e.length <= 50;
  }
  hl(T0e, "isValidUserAgentAppId");
  function A0e(e) {
    let t = (0, cGt.normalizeProvider)(e.userAgentAppId ?? O0e),
      { customUserAgent: r } = e;
    return Object.assign(e, {
      customUserAgent: typeof r == "string" ? [[r]] : r,
      userAgentAppId: hl(async () => {
        let n = await t();
        if (!T0e(n)) {
          let i =
            e.logger?.constructor?.name === "NoOpLogger" || !e.logger
              ? console
              : e.logger;
          typeof n != "string"
            ? i?.warn("userAgentAppId must be a string or undefined.")
            : n.length > 50 &&
              i?.warn(
                "The provided userAgentAppId exceeds the maximum length of 50 characters.",
              );
        }
        return n;
      }, "userAgentAppId"),
    });
  }
  hl(A0e, "resolveUserAgentConfig");
  var uGt = Hy(),
    lGt = Jr(),
    zc = (Jn(), ue($c)),
    dGt = /\d{12}\.ddb/;
  async function P0e(e, t, r) {
    if (
      (r.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" &&
        (0, zc.setFeature)(e, "PROTOCOL_RPC_V2_CBOR", "M"),
      typeof t.retryStrategy == "function")
    ) {
      let o = await t.retryStrategy();
      typeof o.acquireInitialRetryToken == "function"
        ? o.constructor?.name?.includes("Adaptive")
          ? (0, zc.setFeature)(e, "RETRY_MODE_ADAPTIVE", "F")
          : (0, zc.setFeature)(e, "RETRY_MODE_STANDARD", "E")
        : (0, zc.setFeature)(e, "RETRY_MODE_LEGACY", "D");
    }
    if (typeof t.accountIdEndpointMode == "function") {
      let o = e.endpointV2;
      switch (
        (String(o?.url?.hostname).match(dGt) &&
          (0, zc.setFeature)(e, "ACCOUNT_ID_ENDPOINT", "O"),
        await t.accountIdEndpointMode?.())
      ) {
        case "disabled":
          (0, zc.setFeature)(e, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          (0, zc.setFeature)(e, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          (0, zc.setFeature)(e, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break;
      }
    }
    let i = e.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (i?.$source) {
      let o = i;
      o.accountId && (0, zc.setFeature)(e, "RESOLVED_ACCOUNT_ID", "T");
      for (let [a, s] of Object.entries(o.$source ?? {}))
        (0, zc.setFeature)(e, a, s);
    }
  }
  hl(P0e, "checkFeatures");
  var b0e = "user-agent",
    n6 = "x-amz-user-agent",
    S0e = " ",
    i6 = "/",
    fGt = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g,
    pGt = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g,
    C0e = "-",
    mGt = 1024;
  function R0e(e) {
    let t = "";
    for (let r in e) {
      let n = e[r];
      if (t.length + n.length + 1 <= mGt) {
        t.length ? (t += "," + n) : (t += n);
        continue;
      }
      break;
    }
    return t;
  }
  hl(R0e, "encodeFeatures");
  var I0e = hl(
      (e) => (t, r) => async (n) => {
        let { request: i } = n;
        if (!lGt.HttpRequest.isInstance(i)) return t(n);
        let { headers: o } = i,
          a = r?.userAgent?.map(JD) || [],
          s = (await e.defaultUserAgentProvider()).map(JD);
        await P0e(r, e, n);
        let u = r;
        s.push(
          `m/${R0e(Object.assign({}, r.__smithy_context?.features, u.__aws_sdk_context?.features))}`,
        );
        let l = e?.customUserAgent?.map(JD) || [],
          d = await e.userAgentAppId();
        d && s.push(JD([`app/${d}`]));
        let f = (0, uGt.getUserAgentPrefix)(),
          m = (f ? [f] : []).concat([...s, ...a, ...l]).join(S0e),
          h = [...s.filter((y) => y.startsWith("aws-sdk-")), ...l].join(S0e);
        return (
          e.runtime !== "browser"
            ? (h && (o[n6] = o[n6] ? `${o[b0e]} ${h}` : h), (o[b0e] = m))
            : (o[n6] = m),
          t({ ...n, request: i })
        );
      },
      "userAgentMiddleware",
    ),
    JD = hl((e) => {
      let t = e[0]
          .split(i6)
          .map((a) => a.replace(fGt, C0e))
          .join(i6),
        r = e[1]?.replace(pGt, C0e),
        n = t.indexOf(i6),
        i = t.substring(0, n),
        o = t.substring(n + 1);
      return (
        i === "api" && (o = o.toLowerCase()),
        [i, o, r]
          .filter((a) => a && a.length > 0)
          .reduce((a, s, u) => {
            switch (u) {
              case 0:
                return s;
              case 1:
                return `${a}/${s}`;
              default:
                return `${a}#${s}`;
            }
          }, "")
      );
    }, "escapeUserAgent"),
    x0e = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: !0,
    },
    hGt = hl(
      (e) => ({
        applyToStack: hl((t) => {
          t.add(I0e(e), x0e);
        }, "applyToStack"),
      }),
      "getUserAgentPlugin",
    );
});
var GC = g((DCn, M0e) => {
  c();
  var eL = Object.defineProperty,
    gGt = Object.getOwnPropertyDescriptor,
    vGt = Object.getOwnPropertyNames,
    yGt = Object.prototype.hasOwnProperty,
    k0e = (e, t) => eL(e, "name", { value: t, configurable: !0 }),
    _Gt = (e, t) => {
      for (var r in t) eL(e, r, { get: t[r], enumerable: !0 });
    },
    EGt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of vGt(t))
          !yGt.call(e, i) &&
            i !== r &&
            eL(e, i, {
              get: () => t[i],
              enumerable: !(n = gGt(t, i)) || n.enumerable,
            });
      return e;
    },
    bGt = (e) => EGt(eL({}, "__esModule", { value: !0 }), e),
    D0e = {};
  _Gt(D0e, {
    SelectorType: () => L0e,
    booleanSelector: () => SGt,
    numberSelector: () => CGt,
  });
  M0e.exports = bGt(D0e);
  var SGt = k0e((e, t, r) => {
      if (t in e) {
        if (e[t] === "true") return !0;
        if (e[t] === "false") return !1;
        throw new Error(
          `Cannot load ${r} "${t}". Expected "true" or "false", got ${e[t]}.`,
        );
      }
    }, "booleanSelector"),
    CGt = k0e((e, t, r) => {
      if (!(t in e)) return;
      let n = parseInt(e[t], 10);
      if (Number.isNaN(n))
        throw new TypeError(
          `Cannot load ${r} '${t}'. Expected number, got '${e[t]}'.`,
        );
      return n;
    }, "numberSelector"),
    L0e = ((e) => ((e.ENV = "env"), (e.CONFIG = "shared config entry"), e))(
      L0e || {},
    );
});
var Kc = g((MCn, K0e) => {
  c();
  var rL = Object.defineProperty,
    wGt = Object.getOwnPropertyDescriptor,
    OGt = Object.getOwnPropertyNames,
    TGt = Object.prototype.hasOwnProperty,
    Ws = (e, t) => rL(e, "name", { value: t, configurable: !0 }),
    AGt = (e, t) => {
      for (var r in t) rL(e, r, { get: t[r], enumerable: !0 });
    },
    PGt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of OGt(t))
          !TGt.call(e, i) &&
            i !== r &&
            rL(e, i, {
              get: () => t[i],
              enumerable: !(n = wGt(t, i)) || n.enumerable,
            });
      return e;
    },
    RGt = (e) => PGt(rL({}, "__esModule", { value: !0 }), e),
    F0e = {};
  AGt(F0e, {
    CONFIG_USE_DUALSTACK_ENDPOINT: () => U0e,
    CONFIG_USE_FIPS_ENDPOINT: () => G0e,
    DEFAULT_USE_DUALSTACK_ENDPOINT: () => IGt,
    DEFAULT_USE_FIPS_ENDPOINT: () => NGt,
    ENV_USE_DUALSTACK_ENDPOINT: () => B0e,
    ENV_USE_FIPS_ENDPOINT: () => H0e,
    NODE_REGION_CONFIG_FILE_OPTIONS: () => jGt,
    NODE_REGION_CONFIG_OPTIONS: () => qGt,
    NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS: () => xGt,
    NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS: () => kGt,
    REGION_ENV_NAME: () => V0e,
    REGION_INI_NAME: () => $0e,
    getRegionInfo: () => GGt,
    resolveCustomEndpointsConfig: () => DGt,
    resolveEndpointsConfig: () => MGt,
    resolveRegionConfig: () => FGt,
  });
  K0e.exports = RGt(F0e);
  var wf = GC(),
    B0e = "AWS_USE_DUALSTACK_ENDPOINT",
    U0e = "use_dualstack_endpoint",
    IGt = !1,
    xGt = {
      environmentVariableSelector: (e) =>
        (0, wf.booleanSelector)(e, B0e, wf.SelectorType.ENV),
      configFileSelector: (e) =>
        (0, wf.booleanSelector)(e, U0e, wf.SelectorType.CONFIG),
      default: !1,
    },
    H0e = "AWS_USE_FIPS_ENDPOINT",
    G0e = "use_fips_endpoint",
    NGt = !1,
    kGt = {
      environmentVariableSelector: (e) =>
        (0, wf.booleanSelector)(e, H0e, wf.SelectorType.ENV),
      configFileSelector: (e) =>
        (0, wf.booleanSelector)(e, G0e, wf.SelectorType.CONFIG),
      default: !1,
    },
    tL = $s(),
    DGt = Ws((e) => {
      let { tls: t, endpoint: r, urlParser: n, useDualstackEndpoint: i } = e;
      return Object.assign(e, {
        tls: t ?? !0,
        endpoint: (0, tL.normalizeProvider)(typeof r == "string" ? n(r) : r),
        isCustomEndpoint: !0,
        useDualstackEndpoint: (0, tL.normalizeProvider)(i ?? !1),
      });
    }, "resolveCustomEndpointsConfig"),
    LGt = Ws(async (e) => {
      let { tls: t = !0 } = e,
        r = await e.region();
      if (
        !new RegExp(
          /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/,
        ).test(r)
      )
        throw new Error("Invalid region in client config");
      let i = await e.useDualstackEndpoint(),
        o = await e.useFipsEndpoint(),
        { hostname: a } =
          (await e.regionInfoProvider(r, {
            useDualstackEndpoint: i,
            useFipsEndpoint: o,
          })) ?? {};
      if (!a) throw new Error("Cannot resolve hostname from client config");
      return e.urlParser(`${t ? "https:" : "http:"}//${a}`);
    }, "getEndpointFromRegion"),
    MGt = Ws((e) => {
      let t = (0, tL.normalizeProvider)(e.useDualstackEndpoint ?? !1),
        { endpoint: r, useFipsEndpoint: n, urlParser: i, tls: o } = e;
      return Object.assign(e, {
        tls: o ?? !0,
        endpoint: r
          ? (0, tL.normalizeProvider)(typeof r == "string" ? i(r) : r)
          : () => LGt({ ...e, useDualstackEndpoint: t, useFipsEndpoint: n }),
        isCustomEndpoint: !!r,
        useDualstackEndpoint: t,
      });
    }, "resolveEndpointsConfig"),
    V0e = "AWS_REGION",
    $0e = "region",
    qGt = {
      environmentVariableSelector: (e) => e[V0e],
      configFileSelector: (e) => e[$0e],
      default: () => {
        throw new Error("Region is missing");
      },
    },
    jGt = { preferredFile: "credentials" },
    z0e = Ws(
      (e) =>
        typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips")),
      "isFipsRegion",
    ),
    q0e = Ws(
      (e) =>
        z0e(e)
          ? ["fips-aws-global", "aws-fips"].includes(e)
            ? "us-east-1"
            : e.replace(/fips-(dkr-|prod-)?|-fips/, "")
          : e,
      "getRealRegion",
    ),
    FGt = Ws((e) => {
      let { region: t, useFipsEndpoint: r } = e;
      if (!t) throw new Error("Region is missing");
      return Object.assign(e, {
        region: async () => {
          if (typeof t == "string") return q0e(t);
          let n = await t();
          return q0e(n);
        },
        useFipsEndpoint: async () => {
          let n = typeof t == "string" ? t : await t();
          return z0e(n)
            ? !0
            : typeof r != "function"
              ? Promise.resolve(!!r)
              : r();
        },
      });
    }, "resolveRegionConfig"),
    j0e = Ws(
      (e = [], { useFipsEndpoint: t, useDualstackEndpoint: r }) =>
        e.find(
          ({ tags: n }) =>
            t === n.includes("fips") && r === n.includes("dualstack"),
        )?.hostname,
      "getHostnameFromVariants",
    ),
    BGt = Ws(
      (e, { regionHostname: t, partitionHostname: r }) =>
        t || (r ? r.replace("{region}", e) : void 0),
      "getResolvedHostname",
    ),
    UGt = Ws(
      (e, { partitionHash: t }) =>
        Object.keys(t || {}).find((r) => t[r].regions.includes(e)) ?? "aws",
      "getResolvedPartition",
    ),
    HGt = Ws((e, { signingRegion: t, regionRegex: r, useFipsEndpoint: n }) => {
      if (t) return t;
      if (n) {
        let i = r
            .replace("\\\\", "\\")
            .replace(/^\^/g, "\\.")
            .replace(/\$$/g, "\\."),
          o = e.match(i);
        if (o) return o[0].slice(1, -1);
      }
    }, "getResolvedSigningRegion"),
    GGt = Ws(
      (
        e,
        {
          useFipsEndpoint: t = !1,
          useDualstackEndpoint: r = !1,
          signingService: n,
          regionHash: i,
          partitionHash: o,
        },
      ) => {
        let a = UGt(e, { partitionHash: o }),
          s = e in i ? e : (o[a]?.endpoint ?? e),
          u = { useFipsEndpoint: t, useDualstackEndpoint: r },
          l = j0e(i[s]?.variants, u),
          d = j0e(o[a]?.variants, u),
          f = BGt(s, { regionHostname: l, partitionHostname: d });
        if (f === void 0)
          throw new Error(
            `Endpoint resolution failed for: ${{ resolvedRegion: s, useFipsEndpoint: t, useDualstackEndpoint: r }}`,
          );
        let m = HGt(f, {
          signingRegion: i[s]?.signingRegion,
          regionRegex: o[a].regionRegex,
          useFipsEndpoint: t,
        });
        return {
          partition: a,
          signingService: n,
          hostname: f,
          ...(m && { signingRegion: m }),
          ...(i[s]?.signingService && { signingService: i[s].signingService }),
        };
      },
      "getRegionInfo",
    );
});
var VC = g((jCn, J0e) => {
  c();
  var nL = Object.defineProperty,
    VGt = Object.getOwnPropertyDescriptor,
    $Gt = Object.getOwnPropertyNames,
    zGt = Object.prototype.hasOwnProperty,
    Q0e = (e, t) => nL(e, "name", { value: t, configurable: !0 }),
    KGt = (e, t) => {
      for (var r in t) nL(e, r, { get: t[r], enumerable: !0 });
    },
    WGt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of $Gt(t))
          !zGt.call(e, i) &&
            i !== r &&
            nL(e, i, {
              get: () => t[i],
              enumerable: !(n = VGt(t, i)) || n.enumerable,
            });
      return e;
    },
    QGt = (e) => WGt(nL({}, "__esModule", { value: !0 }), e),
    Y0e = {};
  KGt(Y0e, {
    contentLengthMiddleware: () => o6,
    contentLengthMiddlewareOptions: () => X0e,
    getContentLengthPlugin: () => XGt,
  });
  J0e.exports = QGt(Y0e);
  var YGt = Jr(),
    W0e = "content-length";
  function o6(e) {
    return (t) => async (r) => {
      let n = r.request;
      if (YGt.HttpRequest.isInstance(n)) {
        let { body: i, headers: o } = n;
        if (
          i &&
          Object.keys(o)
            .map((a) => a.toLowerCase())
            .indexOf(W0e) === -1
        )
          try {
            let a = e(i);
            n.headers = { ...n.headers, [W0e]: String(a) };
          } catch {}
      }
      return t({ ...r, request: n });
    };
  }
  Q0e(o6, "contentLengthMiddleware");
  var X0e = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: !0,
    },
    XGt = Q0e(
      (e) => ({
        applyToStack: (t) => {
          t.add(o6(e.bodyLengthChecker), X0e);
        },
      }),
      "getContentLengthPlugin",
    );
});
var iCe = g((BCn, nCe) => {
  c();
  var iL = Object.defineProperty,
    JGt = Object.getOwnPropertyDescriptor,
    ZGt = Object.getOwnPropertyNames,
    eVt = Object.prototype.hasOwnProperty,
    lh = (e, t) => iL(e, "name", { value: t, configurable: !0 }),
    tVt = (e, t) => {
      for (var r in t) iL(e, r, { get: t[r], enumerable: !0 });
    },
    rVt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of ZGt(t))
          !eVt.call(e, i) &&
            i !== r &&
            iL(e, i, {
              get: () => t[i],
              enumerable: !(n = JGt(t, i)) || n.enumerable,
            });
      return e;
    },
    nVt = (e) => rVt(iL({}, "__esModule", { value: !0 }), e),
    Z0e = {};
  tVt(Z0e, {
    CredentialsProviderError: () => iVt,
    ProviderError: () => oL,
    TokenProviderError: () => oVt,
    chain: () => aVt,
    fromStatic: () => sVt,
    memoize: () => cVt,
  });
  nCe.exports = nVt(Z0e);
  var oL = class eCe extends Error {
      constructor(t, r = !0) {
        let n,
          i = !0;
        typeof r == "boolean"
          ? ((n = void 0), (i = r))
          : r != null &&
            typeof r == "object" &&
            ((n = r.logger), (i = r.tryNextLink ?? !0)),
          super(t),
          (this.name = "ProviderError"),
          (this.tryNextLink = i),
          Object.setPrototypeOf(this, eCe.prototype),
          n?.debug?.(`@smithy/property-provider ${i ? "->" : "(!)"} ${t}`);
      }
      static {
        lh(this, "ProviderError");
      }
      static from(t, r = !0) {
        return Object.assign(new this(t.message, r), t);
      }
    },
    iVt = class tCe extends oL {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "CredentialsProviderError"),
          Object.setPrototypeOf(this, tCe.prototype);
      }
      static {
        lh(this, "CredentialsProviderError");
      }
    },
    oVt = class rCe extends oL {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "TokenProviderError"),
          Object.setPrototypeOf(this, rCe.prototype);
      }
      static {
        lh(this, "TokenProviderError");
      }
    },
    aVt = lh(
      (...e) =>
        async () => {
          if (e.length === 0) throw new oL("No providers in chain");
          let t;
          for (let r of e)
            try {
              return await r();
            } catch (n) {
              if (((t = n), n?.tryNextLink)) continue;
              throw n;
            }
          throw t;
        },
      "chain",
    ),
    sVt = lh((e) => () => Promise.resolve(e), "fromStatic"),
    cVt = lh((e, t, r) => {
      let n,
        i,
        o,
        a = !1,
        s = lh(async () => {
          i || (i = e());
          try {
            (n = await i), (o = !0), (a = !1);
          } finally {
            i = void 0;
          }
          return n;
        }, "coalesceProvider");
      return t === void 0
        ? async (u) => ((!o || u?.forceRefresh) && (n = await s()), n)
        : async (u) => (
            (!o || u?.forceRefresh) && (n = await s()),
            a ? n : r && !r(n) ? ((a = !0), n) : (t(n) && (await s()), n)
          );
    }, "memoize");
});
var Xy = g((aL) => {
  "use strict";
  c();
  Object.defineProperty(aL, "__esModule", { value: !0 });
  aL.getHomeDir = void 0;
  var uVt = G("os"),
    lVt = G("path"),
    a6 = {},
    dVt = () =>
      process && process.geteuid ? `${process.geteuid()}` : "DEFAULT",
    fVt = () => {
      let {
        HOME: e,
        USERPROFILE: t,
        HOMEPATH: r,
        HOMEDRIVE: n = `C:${lVt.sep}`,
      } = process.env;
      if (e) return e;
      if (t) return t;
      if (r) return `${n}${r}`;
      let i = dVt();
      return a6[i] || (a6[i] = (0, uVt.homedir)()), a6[i];
    };
  aL.getHomeDir = fVt;
});
var s6 = g((sL) => {
  "use strict";
  c();
  Object.defineProperty(sL, "__esModule", { value: !0 });
  sL.getSSOTokenFilepath = void 0;
  var pVt = G("crypto"),
    mVt = G("path"),
    hVt = Xy(),
    gVt = (e) => {
      let r = (0, pVt.createHash)("sha1").update(e).digest("hex");
      return (0, mVt.join)(
        (0, hVt.getHomeDir)(),
        ".aws",
        "sso",
        "cache",
        `${r}.json`,
      );
    };
  sL.getSSOTokenFilepath = gVt;
});
var oCe = g((cL) => {
  "use strict";
  c();
  Object.defineProperty(cL, "__esModule", { value: !0 });
  cL.getSSOTokenFromFile = void 0;
  var vVt = G("fs"),
    yVt = s6(),
    { readFile: _Vt } = vVt.promises,
    EVt = async (e) => {
      let t = (0, yVt.getSSOTokenFilepath)(e),
        r = await _Vt(t, "utf8");
      return JSON.parse(r);
    };
  cL.getSSOTokenFromFile = EVt;
});
var hCe = g((WCn, mCe) => {
  c();
  var uL = Object.defineProperty,
    bVt = Object.getOwnPropertyDescriptor,
    SVt = Object.getOwnPropertyNames,
    CVt = Object.prototype.hasOwnProperty,
    lL = (e, t) => uL(e, "name", { value: t, configurable: !0 }),
    wVt = (e, t) => {
      for (var r in t) uL(e, r, { get: t[r], enumerable: !0 });
    },
    OVt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of SVt(t))
          !CVt.call(e, i) &&
            i !== r &&
            uL(e, i, {
              get: () => t[i],
              enumerable: !(n = bVt(t, i)) || n.enumerable,
            });
      return e;
    },
    TVt = (e) => OVt(uL({}, "__esModule", { value: !0 }), e),
    aCe = {};
  wVt(aCe, {
    AlgorithmId: () => lCe,
    EndpointURLScheme: () => uCe,
    FieldPosition: () => dCe,
    HttpApiKeyAuthLocation: () => cCe,
    HttpAuthLocation: () => sCe,
    IniSectionType: () => fCe,
    RequestHandlerProtocol: () => pCe,
    SMITHY_CONTEXT_KEY: () => xVt,
    getDefaultClientConfiguration: () => RVt,
    resolveDefaultRuntimeConfig: () => IVt,
  });
  mCe.exports = TVt(aCe);
  var sCe = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(sCe || {}),
    cCe = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(cCe || {}),
    uCe = ((e) => ((e.HTTP = "http"), (e.HTTPS = "https"), e))(uCe || {}),
    lCe = ((e) => (
      (e.MD5 = "md5"),
      (e.CRC32 = "crc32"),
      (e.CRC32C = "crc32c"),
      (e.SHA1 = "sha1"),
      (e.SHA256 = "sha256"),
      e
    ))(lCe || {}),
    AVt = lL((e) => {
      let t = [];
      return (
        e.sha256 !== void 0 &&
          t.push({
            algorithmId: () => "sha256",
            checksumConstructor: () => e.sha256,
          }),
        e.md5 != null &&
          t.push({
            algorithmId: () => "md5",
            checksumConstructor: () => e.md5,
          }),
        {
          addChecksumAlgorithm(r) {
            t.push(r);
          },
          checksumAlgorithms() {
            return t;
          },
        }
      );
    }, "getChecksumConfiguration"),
    PVt = lL((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    RVt = lL((e) => AVt(e), "getDefaultClientConfiguration"),
    IVt = lL((e) => PVt(e), "resolveDefaultRuntimeConfig"),
    dCe = ((e) => (
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER"), e
    ))(dCe || {}),
    xVt = "__smithy_context",
    fCe = ((e) => (
      (e.PROFILE = "profile"),
      (e.SSO_SESSION = "sso-session"),
      (e.SERVICES = "services"),
      e
    ))(fCe || {}),
    pCe = ((e) => (
      (e.HTTP_0_9 = "http/0.9"),
      (e.HTTP_1_0 = "http/1.0"),
      (e.TDS_8_0 = "tds/8.0"),
      e
    ))(pCe || {});
});
var u6 = g((dL) => {
  "use strict";
  c();
  Object.defineProperty(dL, "__esModule", { value: !0 });
  dL.slurpFile = void 0;
  var NVt = G("fs"),
    { readFile: kVt } = NVt.promises,
    c6 = {},
    DVt = (e, t) => (
      (!c6[e] || t?.ignoreCache) && (c6[e] = kVt(e, "utf8")), c6[e]
    );
  dL.slurpFile = DVt;
});
var No = g((JCn, zC) => {
  c();
  var mL = Object.defineProperty,
    LVt = Object.getOwnPropertyDescriptor,
    MVt = Object.getOwnPropertyNames,
    qVt = Object.prototype.hasOwnProperty,
    Ba = (e, t) => mL(e, "name", { value: t, configurable: !0 }),
    jVt = (e, t) => {
      for (var r in t) mL(e, r, { get: t[r], enumerable: !0 });
    },
    l6 = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of MVt(t))
          !qVt.call(e, i) &&
            i !== r &&
            mL(e, i, {
              get: () => t[i],
              enumerable: !(n = LVt(t, i)) || n.enumerable,
            });
      return e;
    },
    f6 = (e, t, r) => (l6(e, t, "default"), r && l6(r, t, "default")),
    FVt = (e) => l6(mL({}, "__esModule", { value: !0 }), e),
    $C = {};
  jVt($C, {
    CONFIG_PREFIX_SEPARATOR: () => dh,
    DEFAULT_PROFILE: () => _Ce,
    ENV_PROFILE: () => yCe,
    getProfileName: () => BVt,
    loadSharedConfigFiles: () => bCe,
    loadSsoSessionData: () => ZVt,
    parseKnownFiles: () => t$t,
  });
  zC.exports = FVt($C);
  f6($C, Xy(), zC.exports);
  var yCe = "AWS_PROFILE",
    _Ce = "default",
    BVt = Ba((e) => e.profile || process.env[yCe] || _Ce, "getProfileName");
  f6($C, s6(), zC.exports);
  f6($C, oCe(), zC.exports);
  var fL = hCe(),
    UVt = Ba(
      (e) =>
        Object.entries(e)
          .filter(([t]) => {
            let r = t.indexOf(dh);
            return r === -1
              ? !1
              : Object.values(fL.IniSectionType).includes(t.substring(0, r));
          })
          .reduce(
            (t, [r, n]) => {
              let i = r.indexOf(dh),
                o =
                  r.substring(0, i) === fL.IniSectionType.PROFILE
                    ? r.substring(i + 1)
                    : r;
              return (t[o] = n), t;
            },
            { ...(e.default && { default: e.default }) },
          ),
      "getConfigData",
    ),
    pL = G("path"),
    HVt = Xy(),
    GVt = "AWS_CONFIG_FILE",
    ECe = Ba(
      () =>
        process.env[GVt] ||
        (0, pL.join)((0, HVt.getHomeDir)(), ".aws", "config"),
      "getConfigFilepath",
    ),
    VVt = Xy(),
    $Vt = "AWS_SHARED_CREDENTIALS_FILE",
    zVt = Ba(
      () =>
        process.env[$Vt] ||
        (0, pL.join)((0, VVt.getHomeDir)(), ".aws", "credentials"),
      "getCredentialsFilepath",
    ),
    KVt = Xy(),
    WVt = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/,
    QVt = ["__proto__", "profile __proto__"],
    d6 = Ba((e) => {
      let t = {},
        r,
        n;
      for (let i of e.split(/\r?\n/)) {
        let o = i.split(/(^|\s)[;#]/)[0].trim();
        if (o[0] === "[" && o[o.length - 1] === "]") {
          (r = void 0), (n = void 0);
          let s = o.substring(1, o.length - 1),
            u = WVt.exec(s);
          if (u) {
            let [, l, , d] = u;
            Object.values(fL.IniSectionType).includes(l) &&
              (r = [l, d].join(dh));
          } else r = s;
          if (QVt.includes(s))
            throw new Error(`Found invalid profile name "${s}"`);
        } else if (r) {
          let s = o.indexOf("=");
          if (![0, -1].includes(s)) {
            let [u, l] = [o.substring(0, s).trim(), o.substring(s + 1).trim()];
            if (l === "") n = u;
            else {
              n && i.trimStart() === i && (n = void 0), (t[r] = t[r] || {});
              let d = n ? [n, u].join(dh) : u;
              t[r][d] = l;
            }
          }
        }
      }
      return t;
    }, "parseIni"),
    gCe = u6(),
    vCe = Ba(() => ({}), "swallowError"),
    dh = ".",
    bCe = Ba(async (e = {}) => {
      let { filepath: t = zVt(), configFilepath: r = ECe() } = e,
        n = (0, KVt.getHomeDir)(),
        i = "~/",
        o = t;
      t.startsWith(i) && (o = (0, pL.join)(n, t.slice(2)));
      let a = r;
      r.startsWith(i) && (a = (0, pL.join)(n, r.slice(2)));
      let s = await Promise.all([
        (0, gCe.slurpFile)(a, { ignoreCache: e.ignoreCache })
          .then(d6)
          .then(UVt)
          .catch(vCe),
        (0, gCe.slurpFile)(o, { ignoreCache: e.ignoreCache })
          .then(d6)
          .catch(vCe),
      ]);
      return { configFile: s[0], credentialsFile: s[1] };
    }, "loadSharedConfigFiles"),
    YVt = Ba(
      (e) =>
        Object.entries(e)
          .filter(([t]) => t.startsWith(fL.IniSectionType.SSO_SESSION + dh))
          .reduce(
            (t, [r, n]) => ({ ...t, [r.substring(r.indexOf(dh) + 1)]: n }),
            {},
          ),
      "getSsoSessionData",
    ),
    XVt = u6(),
    JVt = Ba(() => ({}), "swallowError"),
    ZVt = Ba(
      async (e = {}) =>
        (0, XVt.slurpFile)(e.configFilepath ?? ECe())
          .then(d6)
          .then(YVt)
          .catch(JVt),
      "loadSsoSessionData",
    ),
    e$t = Ba((...e) => {
      let t = {};
      for (let r of e)
        for (let [n, i] of Object.entries(r))
          t[n] !== void 0 ? Object.assign(t[n], i) : (t[n] = i);
      return t;
    }, "mergeConfigFiles"),
    t$t = Ba(async (e) => {
      let t = await bCe(e);
      return e$t(t.configFile, t.credentialsFile);
    }, "parseKnownFiles");
});
var ro = g((ewn, wCe) => {
  c();
  var hL = Object.defineProperty,
    r$t = Object.getOwnPropertyDescriptor,
    n$t = Object.getOwnPropertyNames,
    i$t = Object.prototype.hasOwnProperty,
    Jy = (e, t) => hL(e, "name", { value: t, configurable: !0 }),
    o$t = (e, t) => {
      for (var r in t) hL(e, r, { get: t[r], enumerable: !0 });
    },
    a$t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of n$t(t))
          !i$t.call(e, i) &&
            i !== r &&
            hL(e, i, {
              get: () => t[i],
              enumerable: !(n = r$t(t, i)) || n.enumerable,
            });
      return e;
    },
    s$t = (e) => a$t(hL({}, "__esModule", { value: !0 }), e),
    CCe = {};
  o$t(CCe, { loadConfig: () => f$t });
  wCe.exports = s$t(CCe);
  var KC = iCe();
  function p6(e) {
    try {
      let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? []));
      return (
        t.delete("CONFIG"),
        t.delete("CONFIG_PREFIX_SEPARATOR"),
        t.delete("ENV"),
        [...t].join(", ")
      );
    } catch {
      return e;
    }
  }
  Jy(p6, "getSelectorName");
  var c$t = Jy(
      (e, t) => async () => {
        try {
          let r = e(process.env);
          if (r === void 0) throw new Error();
          return r;
        } catch (r) {
          throw new KC.CredentialsProviderError(
            r.message || `Not found in ENV: ${p6(e.toString())}`,
            { logger: t },
          );
        }
      },
      "fromEnv",
    ),
    SCe = No(),
    u$t = Jy(
      (e, { preferredFile: t = "config", ...r } = {}) =>
        async () => {
          let n = (0, SCe.getProfileName)(r),
            { configFile: i, credentialsFile: o } = await (0,
            SCe.loadSharedConfigFiles)(r),
            a = o[n] || {},
            s = i[n] || {},
            u = t === "config" ? { ...a, ...s } : { ...s, ...a };
          try {
            let d = e(u, t === "config" ? i : o);
            if (d === void 0) throw new Error();
            return d;
          } catch (l) {
            throw new KC.CredentialsProviderError(
              l.message ||
                `Not found in config files w/ profile [${n}]: ${p6(e.toString())}`,
              { logger: r.logger },
            );
          }
        },
      "fromSharedConfigFiles",
    ),
    l$t = Jy((e) => typeof e == "function", "isFunction"),
    d$t = Jy(
      (e) => (l$t(e) ? async () => await e() : (0, KC.fromStatic)(e)),
      "fromStatic",
    ),
    f$t = Jy(
      (
        { environmentVariableSelector: e, configFileSelector: t, default: r },
        n = {},
      ) => (0, KC.memoize)((0, KC.chain)(c$t(e), u$t(t, n), d$t(r))),
      "loadConfig",
    );
});
var PCe = g((gL) => {
  "use strict";
  c();
  Object.defineProperty(gL, "__esModule", { value: !0 });
  gL.getEndpointUrlConfig = void 0;
  var OCe = No(),
    TCe = "AWS_ENDPOINT_URL",
    ACe = "endpoint_url",
    p$t = (e) => ({
      environmentVariableSelector: (t) => {
        let r = e.split(" ").map((o) => o.toUpperCase()),
          n = t[[TCe, ...r].join("_")];
        if (n) return n;
        let i = t[TCe];
        if (i) return i;
      },
      configFileSelector: (t, r) => {
        if (r && t.services) {
          let i = r[["services", t.services].join(OCe.CONFIG_PREFIX_SEPARATOR)];
          if (i) {
            let o = e.split(" ").map((s) => s.toLowerCase()),
              a = i[[o.join("_"), ACe].join(OCe.CONFIG_PREFIX_SEPARATOR)];
            if (a) return a;
          }
        }
        let n = t[ACe];
        if (n) return n;
      },
      default: void 0,
    });
  gL.getEndpointUrlConfig = p$t;
});
var m6 = g((vL) => {
  "use strict";
  c();
  Object.defineProperty(vL, "__esModule", { value: !0 });
  vL.getEndpointFromConfig = void 0;
  var m$t = ro(),
    h$t = PCe(),
    g$t = async (e) =>
      (0, m$t.loadConfig)((0, h$t.getEndpointUrlConfig)(e ?? ""))();
  vL.getEndpointFromConfig = g$t;
});
var NCe = g((awn, xCe) => {
  c();
  var yL = Object.defineProperty,
    v$t = Object.getOwnPropertyDescriptor,
    y$t = Object.getOwnPropertyNames,
    _$t = Object.prototype.hasOwnProperty,
    E$t = (e, t) => yL(e, "name", { value: t, configurable: !0 }),
    b$t = (e, t) => {
      for (var r in t) yL(e, r, { get: t[r], enumerable: !0 });
    },
    S$t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of y$t(t))
          !_$t.call(e, i) &&
            i !== r &&
            yL(e, i, {
              get: () => t[i],
              enumerable: !(n = v$t(t, i)) || n.enumerable,
            });
      return e;
    },
    C$t = (e) => S$t(yL({}, "__esModule", { value: !0 }), e),
    RCe = {};
  b$t(RCe, { parseQueryString: () => ICe });
  xCe.exports = C$t(RCe);
  function ICe(e) {
    let t = {};
    if (((e = e.replace(/^\?/, "")), e))
      for (let r of e.split("&")) {
        let [n, i = null] = r.split("=");
        (n = decodeURIComponent(n)),
          i && (i = decodeURIComponent(i)),
          n in t
            ? Array.isArray(t[n])
              ? t[n].push(i)
              : (t[n] = [t[n], i])
            : (t[n] = i);
      }
    return t;
  }
  E$t(ICe, "parseQueryString");
});
var fh = g((cwn, LCe) => {
  c();
  var _L = Object.defineProperty,
    w$t = Object.getOwnPropertyDescriptor,
    O$t = Object.getOwnPropertyNames,
    T$t = Object.prototype.hasOwnProperty,
    A$t = (e, t) => _L(e, "name", { value: t, configurable: !0 }),
    P$t = (e, t) => {
      for (var r in t) _L(e, r, { get: t[r], enumerable: !0 });
    },
    R$t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of O$t(t))
          !T$t.call(e, i) &&
            i !== r &&
            _L(e, i, {
              get: () => t[i],
              enumerable: !(n = w$t(t, i)) || n.enumerable,
            });
      return e;
    },
    I$t = (e) => R$t(_L({}, "__esModule", { value: !0 }), e),
    kCe = {};
  P$t(kCe, { parseUrl: () => DCe });
  LCe.exports = I$t(kCe);
  var x$t = NCe(),
    DCe = A$t((e) => {
      if (typeof e == "string") return DCe(new URL(e));
      let { hostname: t, pathname: r, port: n, protocol: i, search: o } = e,
        a;
      return (
        o && (a = (0, x$t.parseQueryString)(o)),
        {
          hostname: t,
          port: n ? parseInt(n) : void 0,
          protocol: i,
          path: r,
          query: a,
        }
      );
    }, "parseUrl");
});
var gl = g((lwn, HCe) => {
  c();
  var bL = Object.defineProperty,
    N$t = Object.getOwnPropertyDescriptor,
    k$t = Object.getOwnPropertyNames,
    D$t = Object.prototype.hasOwnProperty,
    Qs = (e, t) => bL(e, "name", { value: t, configurable: !0 }),
    L$t = (e, t) => {
      for (var r in t) bL(e, r, { get: t[r], enumerable: !0 });
    },
    M$t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of k$t(t))
          !D$t.call(e, i) &&
            i !== r &&
            bL(e, i, {
              get: () => t[i],
              enumerable: !(n = N$t(t, i)) || n.enumerable,
            });
      return e;
    },
    q$t = (e) => M$t(bL({}, "__esModule", { value: !0 }), e),
    qCe = {};
  L$t(qCe, {
    endpointMiddleware: () => BCe,
    endpointMiddlewareOptions: () => UCe,
    getEndpointFromInstructions: () => jCe,
    getEndpointPlugin: () => W$t,
    resolveEndpointConfig: () => Y$t,
    resolveParams: () => FCe,
    toEndpointV1: () => h6,
  });
  HCe.exports = q$t(qCe);
  var j$t = Qs(async (e) => {
      let t = e?.Bucket || "";
      if (
        (typeof e.Bucket == "string" &&
          (e.Bucket = t
            .replace(/#/g, encodeURIComponent("#"))
            .replace(/\?/g, encodeURIComponent("?"))),
        G$t(t))
      ) {
        if (e.ForcePathStyle === !0)
          throw new Error(
            "Path-style addressing cannot be used with ARN buckets",
          );
      } else
        (!H$t(t) ||
          (t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:")) ||
          t.toLowerCase() !== t ||
          t.length < 3) &&
          (e.ForcePathStyle = !0);
      return (
        e.DisableMultiRegionAccessPoints &&
          ((e.disableMultiRegionAccessPoints = !0), (e.DisableMRAP = !0)),
        e
      );
    }, "resolveParamsForS3"),
    F$t = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/,
    B$t = /(\d+\.){3}\d+/,
    U$t = /\.\./,
    H$t = Qs(
      (e) => F$t.test(e) && !B$t.test(e) && !U$t.test(e),
      "isDnsCompatibleBucketName",
    ),
    G$t = Qs((e) => {
      let [t, r, n, , , i] = e.split(":"),
        o = t === "arn" && e.split(":").length >= 6,
        a = !!(o && r && n && i);
      if (o && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`);
      return a;
    }, "isArnBucketName"),
    V$t = Qs((e, t, r) => {
      let n = Qs(async () => {
        let i = r[e] ?? r[t];
        return typeof i == "function" ? i() : i;
      }, "configProvider");
      return e === "credentialScope" || t === "CredentialScope"
        ? async () => {
            let i =
              typeof r.credentials == "function"
                ? await r.credentials()
                : r.credentials;
            return i?.credentialScope ?? i?.CredentialScope;
          }
        : e === "accountId" || t === "AccountId"
          ? async () => {
              let i =
                typeof r.credentials == "function"
                  ? await r.credentials()
                  : r.credentials;
              return i?.accountId ?? i?.AccountId;
            }
          : e === "endpoint" || t === "endpoint"
            ? async () => {
                let i = await n();
                if (i && typeof i == "object") {
                  if ("url" in i) return i.url.href;
                  if ("hostname" in i) {
                    let { protocol: o, hostname: a, port: s, path: u } = i;
                    return `${o}//${a}${s ? ":" + s : ""}${u}`;
                  }
                }
                return i;
              }
            : n;
    }, "createConfigValueProvider"),
    $$t = m6(),
    MCe = fh(),
    h6 = Qs(
      (e) =>
        typeof e == "object"
          ? "url" in e
            ? (0, MCe.parseUrl)(e.url)
            : e
          : (0, MCe.parseUrl)(e),
      "toEndpointV1",
    ),
    jCe = Qs(async (e, t, r, n) => {
      if (!r.endpoint) {
        let a;
        r.serviceConfiguredEndpoint
          ? (a = await r.serviceConfiguredEndpoint())
          : (a = await (0, $$t.getEndpointFromConfig)(r.serviceId)),
          a && (r.endpoint = () => Promise.resolve(h6(a)));
      }
      let i = await FCe(e, t, r);
      if (typeof r.endpointProvider != "function")
        throw new Error("config.endpointProvider is not set.");
      return r.endpointProvider(i, n);
    }, "getEndpointFromInstructions"),
    FCe = Qs(async (e, t, r) => {
      let n = {},
        i = t?.getEndpointParameterInstructions?.() || {};
      for (let [o, a] of Object.entries(i))
        switch (a.type) {
          case "staticContextParams":
            n[o] = a.value;
            break;
          case "contextParams":
            n[o] = e[a.name];
            break;
          case "clientContextParams":
          case "builtInParams":
            n[o] = await V$t(a.name, o, r)();
            break;
          case "operationContextParams":
            n[o] = a.get(e);
            break;
          default:
            throw new Error(
              "Unrecognized endpoint parameter instruction: " +
                JSON.stringify(a),
            );
        }
      return (
        Object.keys(i).length === 0 && Object.assign(n, r),
        String(r.serviceId).toLowerCase() === "s3" && (await j$t(n)),
        n
      );
    }, "resolveParams"),
    z$t = (Gi(), ue(yf)),
    EL = $s(),
    BCe = Qs(
      ({ config: e, instructions: t }) =>
        (r, n) =>
        async (i) => {
          e.endpoint && (0, z$t.setFeature)(n, "ENDPOINT_OVERRIDE", "N");
          let o = await jCe(
            i.input,
            {
              getEndpointParameterInstructions() {
                return t;
              },
            },
            { ...e },
            n,
          );
          (n.endpointV2 = o), (n.authSchemes = o.properties?.authSchemes);
          let a = n.authSchemes?.[0];
          if (a) {
            (n.signing_region = a.signingRegion),
              (n.signing_service = a.signingName);
            let u = (0, EL.getSmithyContext)(n)?.selectedHttpAuthScheme
              ?.httpAuthOption;
            u &&
              (u.signingProperties = Object.assign(
                u.signingProperties || {},
                {
                  signing_region: a.signingRegion,
                  signingRegion: a.signingRegion,
                  signing_service: a.signingName,
                  signingName: a.signingName,
                  signingRegionSet: a.signingRegionSet,
                },
                a.properties,
              ));
          }
          return r({ ...i });
        },
      "endpointMiddleware",
    ),
    K$t = pf(),
    UCe = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: !0,
      relation: "before",
      toMiddleware: K$t.serializerMiddlewareOption.name,
    },
    W$t = Qs(
      (e, t) => ({
        applyToStack: (r) => {
          r.addRelativeTo(BCe({ config: e, instructions: t }), UCe);
        },
      }),
      "getEndpointPlugin",
    ),
    Q$t = m6(),
    Y$t = Qs((e) => {
      let t = e.tls ?? !0,
        { endpoint: r, useDualstackEndpoint: n, useFipsEndpoint: i } = e,
        o =
          r != null
            ? async () => h6(await (0, EL.normalizeProvider)(r)())
            : void 0,
        s = Object.assign(e, {
          endpoint: o,
          tls: t,
          isCustomEndpoint: !!r,
          useDualstackEndpoint: (0, EL.normalizeProvider)(n ?? !1),
          useFipsEndpoint: (0, EL.normalizeProvider)(i ?? !1),
        }),
        u;
      return (
        (s.serviceConfiguredEndpoint = async () => (
          e.serviceId &&
            !u &&
            (u = (0, Q$t.getEndpointFromConfig)(e.serviceId)),
          u
        )),
        s
      );
    }, "resolveEndpointConfig");
});
import X$t from "crypto";
function WC() {
  return (
    SL > CL.length - 16 && (X$t.randomFillSync(CL), (SL = 0)),
    CL.slice(SL, (SL += 16))
  );
}
var CL,
  SL,
  g6 = w(() => {
    c();
    (CL = new Uint8Array(256)), (SL = CL.length);
  });
var GCe,
  VCe = w(() => {
    c();
    GCe =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  });
function J$t(e) {
  return typeof e == "string" && GCe.test(e);
}
var Of,
  QC = w(() => {
    c();
    VCe();
    Of = J$t;
  });
function ph(e, t = 0) {
  return (
    bi[e[t + 0]] +
    bi[e[t + 1]] +
    bi[e[t + 2]] +
    bi[e[t + 3]] +
    "-" +
    bi[e[t + 4]] +
    bi[e[t + 5]] +
    "-" +
    bi[e[t + 6]] +
    bi[e[t + 7]] +
    "-" +
    bi[e[t + 8]] +
    bi[e[t + 9]] +
    "-" +
    bi[e[t + 10]] +
    bi[e[t + 11]] +
    bi[e[t + 12]] +
    bi[e[t + 13]] +
    bi[e[t + 14]] +
    bi[e[t + 15]]
  );
}
function Z$t(e, t = 0) {
  let r = ph(e, t);
  if (!Of(r)) throw TypeError("Stringified UUID is invalid");
  return r;
}
var bi,
  $Ce,
  YC = w(() => {
    c();
    QC();
    bi = [];
    for (let e = 0; e < 256; ++e) bi.push((e + 256).toString(16).slice(1));
    $Ce = Z$t;
  });
function ezt(e, t, r) {
  let n = (t && r) || 0,
    i = t || new Array(16);
  e = e || {};
  let o = e.node || zCe,
    a = e.clockseq !== void 0 ? e.clockseq : v6;
  if (o == null || a == null) {
    let m = e.random || (e.rng || WC)();
    o == null && (o = zCe = [m[0] | 1, m[1], m[2], m[3], m[4], m[5]]),
      a == null && (a = v6 = ((m[6] << 8) | m[7]) & 16383);
  }
  let s = e.msecs !== void 0 ? e.msecs : Date.now(),
    u = e.nsecs !== void 0 ? e.nsecs : _6 + 1,
    l = s - y6 + (u - _6) / 1e4;
  if (
    (l < 0 && e.clockseq === void 0 && (a = (a + 1) & 16383),
    (l < 0 || s > y6) && e.nsecs === void 0 && (u = 0),
    u >= 1e4)
  )
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  (y6 = s), (_6 = u), (v6 = a), (s += 122192928e5);
  let d = ((s & 268435455) * 1e4 + u) % 4294967296;
  (i[n++] = (d >>> 24) & 255),
    (i[n++] = (d >>> 16) & 255),
    (i[n++] = (d >>> 8) & 255),
    (i[n++] = d & 255);
  let f = ((s / 4294967296) * 1e4) & 268435455;
  (i[n++] = (f >>> 8) & 255),
    (i[n++] = f & 255),
    (i[n++] = ((f >>> 24) & 15) | 16),
    (i[n++] = (f >>> 16) & 255),
    (i[n++] = (a >>> 8) | 128),
    (i[n++] = a & 255);
  for (let m = 0; m < 6; ++m) i[n + m] = o[m];
  return t || ph(i);
}
var zCe,
  v6,
  y6,
  _6,
  KCe,
  WCe = w(() => {
    c();
    g6();
    YC();
    (y6 = 0), (_6 = 0);
    KCe = ezt;
  });
function tzt(e) {
  if (!Of(e)) throw TypeError("Invalid UUID");
  let t,
    r = new Uint8Array(16);
  return (
    (r[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24),
    (r[1] = (t >>> 16) & 255),
    (r[2] = (t >>> 8) & 255),
    (r[3] = t & 255),
    (r[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8),
    (r[5] = t & 255),
    (r[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8),
    (r[7] = t & 255),
    (r[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8),
    (r[9] = t & 255),
    (r[10] = ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255),
    (r[11] = (t / 4294967296) & 255),
    (r[12] = (t >>> 24) & 255),
    (r[13] = (t >>> 16) & 255),
    (r[14] = (t >>> 8) & 255),
    (r[15] = t & 255),
    r
  );
}
var wL,
  E6 = w(() => {
    c();
    QC();
    wL = tzt;
  });
function rzt(e) {
  e = unescape(encodeURIComponent(e));
  let t = [];
  for (let r = 0; r < e.length; ++r) t.push(e.charCodeAt(r));
  return t;
}
function XC(e, t, r) {
  function n(i, o, a, s) {
    var u;
    if (
      (typeof i == "string" && (i = rzt(i)),
      typeof o == "string" && (o = wL(o)),
      ((u = o) === null || u === void 0 ? void 0 : u.length) !== 16)
    )
      throw TypeError(
        "Namespace must be array-like (16 iterable integer values, 0-255)",
      );
    let l = new Uint8Array(16 + i.length);
    if (
      (l.set(o),
      l.set(i, o.length),
      (l = r(l)),
      (l[6] = (l[6] & 15) | t),
      (l[8] = (l[8] & 63) | 128),
      a)
    ) {
      s = s || 0;
      for (let d = 0; d < 16; ++d) a[s + d] = l[d];
      return a;
    }
    return ph(l);
  }
  try {
    n.name = e;
  } catch {}
  return (n.DNS = nzt), (n.URL = izt), n;
}
var nzt,
  izt,
  b6 = w(() => {
    c();
    YC();
    E6();
    (nzt = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"),
      (izt = "6ba7b811-9dad-11d1-80b4-00c04fd430c8");
  });
import ozt from "crypto";
function azt(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == "string" && (e = Buffer.from(e, "utf8")),
    ozt.createHash("md5").update(e).digest()
  );
}
var QCe,
  YCe = w(() => {
    c();
    QCe = azt;
  });
var szt,
  XCe,
  JCe = w(() => {
    c();
    b6();
    YCe();
    (szt = XC("v3", 48, QCe)), (XCe = szt);
  });
import czt from "crypto";
var S6,
  ZCe = w(() => {
    c();
    S6 = { randomUUID: czt.randomUUID };
  });
function uzt(e, t, r) {
  if (S6.randomUUID && !t && !e) return S6.randomUUID();
  e = e || {};
  let n = e.random || (e.rng || WC)();
  if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), t)) {
    r = r || 0;
    for (let i = 0; i < 16; ++i) t[r + i] = n[i];
    return t;
  }
  return ph(n);
}
var ewe,
  twe = w(() => {
    c();
    ZCe();
    g6();
    YC();
    ewe = uzt;
  });
import lzt from "crypto";
function dzt(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == "string" && (e = Buffer.from(e, "utf8")),
    lzt.createHash("sha1").update(e).digest()
  );
}
var rwe,
  nwe = w(() => {
    c();
    rwe = dzt;
  });
var fzt,
  iwe,
  owe = w(() => {
    c();
    b6();
    nwe();
    (fzt = XC("v5", 80, rwe)), (iwe = fzt);
  });
var awe,
  swe = w(() => {
    c();
    awe = "00000000-0000-0000-0000-000000000000";
  });
function pzt(e) {
  if (!Of(e)) throw TypeError("Invalid UUID");
  return parseInt(e.slice(14, 15), 16);
}
var cwe,
  uwe = w(() => {
    c();
    QC();
    cwe = pzt;
  });
var lwe = {};
bn(lwe, {
  NIL: () => awe,
  parse: () => wL,
  stringify: () => $Ce,
  v1: () => KCe,
  v3: () => XCe,
  v4: () => ewe,
  v5: () => iwe,
  validate: () => Of,
  version: () => cwe,
});
var dwe = w(() => {
  c();
  WCe();
  JCe();
  twe();
  owe();
  swe();
  uwe();
  QC();
  YC();
  E6();
});
var w6 = g((vOn, mwe) => {
  c();
  var OL = Object.defineProperty,
    mzt = Object.getOwnPropertyDescriptor,
    hzt = Object.getOwnPropertyNames,
    gzt = Object.prototype.hasOwnProperty,
    Zy = (e, t) => OL(e, "name", { value: t, configurable: !0 }),
    vzt = (e, t) => {
      for (var r in t) OL(e, r, { get: t[r], enumerable: !0 });
    },
    yzt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of hzt(t))
          !gzt.call(e, i) &&
            i !== r &&
            OL(e, i, {
              get: () => t[i],
              enumerable: !(n = mzt(t, i)) || n.enumerable,
            });
      return e;
    },
    _zt = (e) => yzt(OL({}, "__esModule", { value: !0 }), e),
    fwe = {};
  vzt(fwe, {
    isClockSkewCorrectedError: () => pwe,
    isClockSkewError: () => Tzt,
    isRetryableByTrait: () => Ozt,
    isServerError: () => Pzt,
    isThrottlingError: () => Azt,
    isTransientError: () => C6,
  });
  mwe.exports = _zt(fwe);
  var Ezt = [
      "AuthFailure",
      "InvalidSignatureException",
      "RequestExpired",
      "RequestInTheFuture",
      "RequestTimeTooSkewed",
      "SignatureDoesNotMatch",
    ],
    bzt = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException",
    ],
    Szt = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"],
    Czt = [500, 502, 503, 504],
    wzt = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"],
    Ozt = Zy((e) => e.$retryable !== void 0, "isRetryableByTrait"),
    Tzt = Zy((e) => Ezt.includes(e.name), "isClockSkewError"),
    pwe = Zy(
      (e) => e.$metadata?.clockSkewCorrected,
      "isClockSkewCorrectedError",
    ),
    Azt = Zy(
      (e) =>
        e.$metadata?.httpStatusCode === 429 ||
        bzt.includes(e.name) ||
        e.$retryable?.throttling == !0,
      "isThrottlingError",
    ),
    C6 = Zy(
      (e, t = 0) =>
        pwe(e) ||
        Szt.includes(e.name) ||
        wzt.includes(e?.code || "") ||
        Czt.includes(e.$metadata?.httpStatusCode || 0) ||
        (e.cause !== void 0 && t <= 10 && C6(e.cause, t + 1)),
      "isTransientError",
    ),
    Pzt = Zy((e) => {
      if (e.$metadata?.httpStatusCode !== void 0) {
        let t = e.$metadata.httpStatusCode;
        return 500 <= t && t <= 599 && !C6(e);
      }
      return !1;
    }, "isServerError");
});
var e_ = g((_On, wwe) => {
  c();
  var TL = Object.defineProperty,
    Rzt = Object.getOwnPropertyDescriptor,
    Izt = Object.getOwnPropertyNames,
    xzt = Object.prototype.hasOwnProperty,
    Ys = (e, t) => TL(e, "name", { value: t, configurable: !0 }),
    Nzt = (e, t) => {
      for (var r in t) TL(e, r, { get: t[r], enumerable: !0 });
    },
    kzt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Izt(t))
          !xzt.call(e, i) &&
            i !== r &&
            TL(e, i, {
              get: () => t[i],
              enumerable: !(n = Rzt(t, i)) || n.enumerable,
            });
      return e;
    },
    Dzt = (e) => kzt(TL({}, "__esModule", { value: !0 }), e),
    gwe = {};
  Nzt(gwe, {
    AdaptiveRetryStrategy: () => Bzt,
    ConfiguredRetryStrategy: () => Uzt,
    DEFAULT_MAX_ATTEMPTS: () => O6,
    DEFAULT_RETRY_DELAY_BASE: () => JC,
    DEFAULT_RETRY_MODE: () => Lzt,
    DefaultRateLimiter: () => ywe,
    INITIAL_RETRY_TOKENS: () => T6,
    INVOCATION_ID_HEADER: () => qzt,
    MAXIMUM_RETRY_DELAY: () => A6,
    NO_RETRY_INCREMENT: () => Cwe,
    REQUEST_HEADER: () => jzt,
    RETRY_COST: () => bwe,
    RETRY_MODES: () => vwe,
    StandardRetryStrategy: () => P6,
    THROTTLING_RETRY_DELAY_BASE: () => Ewe,
    TIMEOUT_RETRY_COST: () => Swe,
  });
  wwe.exports = Dzt(gwe);
  var vwe = ((e) => ((e.STANDARD = "standard"), (e.ADAPTIVE = "adaptive"), e))(
      vwe || {},
    ),
    O6 = 3,
    Lzt = "standard",
    Mzt = w6(),
    ywe = class _we {
      constructor(t) {
        (this.currentCapacity = 0),
          (this.enabled = !1),
          (this.lastMaxRate = 0),
          (this.measuredTxRate = 0),
          (this.requestCount = 0),
          (this.lastTimestamp = 0),
          (this.timeWindow = 0),
          (this.beta = t?.beta ?? 0.7),
          (this.minCapacity = t?.minCapacity ?? 1),
          (this.minFillRate = t?.minFillRate ?? 0.5),
          (this.scaleConstant = t?.scaleConstant ?? 0.4),
          (this.smooth = t?.smooth ?? 0.8);
        let r = this.getCurrentTimeInSeconds();
        (this.lastThrottleTime = r),
          (this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds())),
          (this.fillRate = this.minFillRate),
          (this.maxCapacity = this.minCapacity);
      }
      static {
        Ys(this, "DefaultRateLimiter");
      }
      static {
        this.setTimeoutFn = setTimeout;
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(t) {
        if (this.enabled) {
          if ((this.refillTokenBucket(), t > this.currentCapacity)) {
            let r = ((t - this.currentCapacity) / this.fillRate) * 1e3;
            await new Promise((n) => _we.setTimeoutFn(n, r));
          }
          this.currentCapacity = this.currentCapacity - t;
        }
      }
      refillTokenBucket() {
        let t = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = t;
          return;
        }
        let r = (t - this.lastTimestamp) * this.fillRate;
        (this.currentCapacity = Math.min(
          this.maxCapacity,
          this.currentCapacity + r,
        )),
          (this.lastTimestamp = t);
      }
      updateClientSendingRate(t) {
        let r;
        if ((this.updateMeasuredRate(), (0, Mzt.isThrottlingError)(t))) {
          let i = this.enabled
            ? Math.min(this.measuredTxRate, this.fillRate)
            : this.measuredTxRate;
          (this.lastMaxRate = i),
            this.calculateTimeWindow(),
            (this.lastThrottleTime = this.getCurrentTimeInSeconds()),
            (r = this.cubicThrottle(i)),
            this.enableTokenBucket();
        } else
          this.calculateTimeWindow(),
            (r = this.cubicSuccess(this.getCurrentTimeInSeconds()));
        let n = Math.min(r, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(n);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(
          Math.pow(
            (this.lastMaxRate * (1 - this.beta)) / this.scaleConstant,
            1 / 3,
          ),
        );
      }
      cubicThrottle(t) {
        return this.getPrecise(t * this.beta);
      }
      cubicSuccess(t) {
        return this.getPrecise(
          this.scaleConstant *
            Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) +
            this.lastMaxRate,
        );
      }
      enableTokenBucket() {
        this.enabled = !0;
      }
      updateTokenBucketRate(t) {
        this.refillTokenBucket(),
          (this.fillRate = Math.max(t, this.minFillRate)),
          (this.maxCapacity = Math.max(t, this.minCapacity)),
          (this.currentCapacity = Math.min(
            this.currentCapacity,
            this.maxCapacity,
          ));
      }
      updateMeasuredRate() {
        let t = this.getCurrentTimeInSeconds(),
          r = Math.floor(t * 2) / 2;
        if ((this.requestCount++, r > this.lastTxRateBucket)) {
          let n = this.requestCount / (r - this.lastTxRateBucket);
          (this.measuredTxRate = this.getPrecise(
            n * this.smooth + this.measuredTxRate * (1 - this.smooth),
          )),
            (this.requestCount = 0),
            (this.lastTxRateBucket = r);
        }
      }
      getPrecise(t) {
        return parseFloat(t.toFixed(8));
      }
    },
    JC = 100,
    A6 = 20 * 1e3,
    Ewe = 500,
    T6 = 500,
    bwe = 5,
    Swe = 10,
    Cwe = 1,
    qzt = "amz-sdk-invocation-id",
    jzt = "amz-sdk-request",
    Fzt = Ys(() => {
      let e = JC;
      return {
        computeNextBackoffDelay: Ys(
          (n) => Math.floor(Math.min(A6, Math.random() * 2 ** n * e)),
          "computeNextBackoffDelay",
        ),
        setDelayBase: Ys((n) => {
          e = n;
        }, "setDelayBase"),
      };
    }, "getDefaultRetryBackoffStrategy"),
    hwe = Ys(
      ({ retryDelay: e, retryCount: t, retryCost: r }) => ({
        getRetryCount: Ys(() => t, "getRetryCount"),
        getRetryDelay: Ys(() => Math.min(A6, e), "getRetryDelay"),
        getRetryCost: Ys(() => r, "getRetryCost"),
      }),
      "createDefaultRetryToken",
    ),
    P6 = class {
      constructor(e) {
        (this.maxAttempts = e),
          (this.mode = "standard"),
          (this.capacity = T6),
          (this.retryBackoffStrategy = Fzt()),
          (this.maxAttemptsProvider =
            typeof e == "function" ? e : async () => e);
      }
      static {
        Ys(this, "StandardRetryStrategy");
      }
      async acquireInitialRetryToken(e) {
        return hwe({ retryDelay: JC, retryCount: 0 });
      }
      async refreshRetryTokenForRetry(e, t) {
        let r = await this.getMaxAttempts();
        if (this.shouldRetry(e, t, r)) {
          let n = t.errorType;
          this.retryBackoffStrategy.setDelayBase(n === "THROTTLING" ? Ewe : JC);
          let i = this.retryBackoffStrategy.computeNextBackoffDelay(
              e.getRetryCount(),
            ),
            o = t.retryAfterHint
              ? Math.max(t.retryAfterHint.getTime() - Date.now() || 0, i)
              : i,
            a = this.getCapacityCost(n);
          return (
            (this.capacity -= a),
            hwe({
              retryDelay: o,
              retryCount: e.getRetryCount() + 1,
              retryCost: a,
            })
          );
        }
        throw new Error("No retry token available");
      }
      recordSuccess(e) {
        this.capacity = Math.max(T6, this.capacity + (e.getRetryCost() ?? Cwe));
      }
      getCapacity() {
        return this.capacity;
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider();
        } catch {
          return (
            console.warn(
              `Max attempts provider could not resolve. Using default of ${O6}`,
            ),
            O6
          );
        }
      }
      shouldRetry(e, t, r) {
        return (
          e.getRetryCount() + 1 < r &&
          this.capacity >= this.getCapacityCost(t.errorType) &&
          this.isRetryableError(t.errorType)
        );
      }
      getCapacityCost(e) {
        return e === "TRANSIENT" ? Swe : bwe;
      }
      isRetryableError(e) {
        return e === "THROTTLING" || e === "TRANSIENT";
      }
    },
    Bzt = class {
      constructor(e, t) {
        (this.maxAttemptsProvider = e), (this.mode = "adaptive");
        let { rateLimiter: r } = t ?? {};
        (this.rateLimiter = r ?? new ywe()),
          (this.standardRetryStrategy = new P6(e));
      }
      static {
        Ys(this, "AdaptiveRetryStrategy");
      }
      async acquireInitialRetryToken(e) {
        return (
          await this.rateLimiter.getSendToken(),
          this.standardRetryStrategy.acquireInitialRetryToken(e)
        );
      }
      async refreshRetryTokenForRetry(e, t) {
        return (
          this.rateLimiter.updateClientSendingRate(t),
          this.standardRetryStrategy.refreshRetryTokenForRetry(e, t)
        );
      }
      recordSuccess(e) {
        this.rateLimiter.updateClientSendingRate({}),
          this.standardRetryStrategy.recordSuccess(e);
      }
    },
    Uzt = class extends P6 {
      static {
        Ys(this, "ConfiguredRetryStrategy");
      }
      constructor(e, t = JC) {
        super(typeof e == "function" ? e : async () => e),
          typeof t == "number"
            ? (this.computeNextBackoffDelay = () => t)
            : (this.computeNextBackoffDelay = t);
      }
      async refreshRetryTokenForRetry(e, t) {
        let r = await super.refreshRetryTokenForRetry(e, t);
        return (
          (r.getRetryDelay = () =>
            this.computeNextBackoffDelay(r.getRetryCount())),
          r
        );
      }
    };
});
var Owe = g((AL) => {
  "use strict";
  c();
  Object.defineProperty(AL, "__esModule", { value: !0 });
  AL.isStreamingPayload = void 0;
  var Hzt = G("stream"),
    Gzt = (e) =>
      e?.body instanceof Hzt.Readable ||
      (typeof ReadableStream < "u" && e?.body instanceof ReadableStream);
  AL.isStreamingPayload = Gzt;
});
var vl = g((TOn, Bwe) => {
  c();
  var PL = Object.defineProperty,
    Vzt = Object.getOwnPropertyDescriptor,
    $zt = Object.getOwnPropertyNames,
    zzt = Object.prototype.hasOwnProperty,
    An = (e, t) => PL(e, "name", { value: t, configurable: !0 }),
    Kzt = (e, t) => {
      for (var r in t) PL(e, r, { get: t[r], enumerable: !0 });
    },
    Wzt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of $zt(t))
          !zzt.call(e, i) &&
            i !== r &&
            PL(e, i, {
              get: () => t[i],
              enumerable: !(n = Vzt(t, i)) || n.enumerable,
            });
      return e;
    },
    Qzt = (e) => Wzt(PL({}, "__esModule", { value: !0 }), e),
    Awe = {};
  Kzt(Awe, {
    AdaptiveRetryStrategy: () => Jzt,
    CONFIG_MAX_ATTEMPTS: () => I6,
    CONFIG_RETRY_MODE: () => Dwe,
    ENV_MAX_ATTEMPTS: () => R6,
    ENV_RETRY_MODE: () => kwe,
    NODE_MAX_ATTEMPT_CONFIG_OPTIONS: () => Zzt,
    NODE_RETRY_MODE_CONFIG_OPTIONS: () => t2t,
    StandardRetryStrategy: () => Nwe,
    defaultDelayDecider: () => Rwe,
    defaultRetryDecider: () => Iwe,
    getOmitRetryHeadersPlugin: () => r2t,
    getRetryAfterHint: () => Fwe,
    getRetryPlugin: () => c2t,
    omitRetryHeadersMiddleware: () => Lwe,
    omitRetryHeadersMiddlewareOptions: () => Mwe,
    resolveRetryConfig: () => e2t,
    retryMiddleware: () => qwe,
    retryMiddlewareOptions: () => jwe,
  });
  Bwe.exports = Qzt(Awe);
  var t_ = Jr(),
    Pwe = (dwe(), ue(lwe)),
    Zr = e_(),
    Yzt = An((e, t) => {
      let r = e,
        n = t?.noRetryIncrement ?? Zr.NO_RETRY_INCREMENT,
        i = t?.retryCost ?? Zr.RETRY_COST,
        o = t?.timeoutRetryCost ?? Zr.TIMEOUT_RETRY_COST,
        a = e,
        s = An((f) => (f.name === "TimeoutError" ? o : i), "getCapacityAmount"),
        u = An((f) => s(f) <= a, "hasRetryTokens");
      return Object.freeze({
        hasRetryTokens: u,
        retrieveRetryTokens: An((f) => {
          if (!u(f)) throw new Error("No retry token available");
          let m = s(f);
          return (a -= m), m;
        }, "retrieveRetryTokens"),
        releaseRetryTokens: An((f) => {
          (a += f ?? n), (a = Math.min(a, r));
        }, "releaseRetryTokens"),
      });
    }, "getDefaultRetryQuota"),
    Rwe = An(
      (e, t) =>
        Math.floor(
          Math.min(Zr.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** t * e),
        ),
      "defaultDelayDecider",
    ),
    Tf = w6(),
    Iwe = An(
      (e) =>
        e
          ? (0, Tf.isRetryableByTrait)(e) ||
            (0, Tf.isClockSkewError)(e) ||
            (0, Tf.isThrottlingError)(e) ||
            (0, Tf.isTransientError)(e)
          : !1,
      "defaultRetryDecider",
    ),
    xwe = An(
      (e) =>
        e instanceof Error
          ? e
          : e instanceof Object
            ? Object.assign(new Error(), e)
            : typeof e == "string"
              ? new Error(e)
              : new Error(`AWS SDK error wrapper for ${e}`),
      "asSdkError",
    ),
    Nwe = class {
      constructor(e, t) {
        (this.maxAttemptsProvider = e),
          (this.mode = Zr.RETRY_MODES.STANDARD),
          (this.retryDecider = t?.retryDecider ?? Iwe),
          (this.delayDecider = t?.delayDecider ?? Rwe),
          (this.retryQuota = t?.retryQuota ?? Yzt(Zr.INITIAL_RETRY_TOKENS));
      }
      static {
        An(this, "StandardRetryStrategy");
      }
      shouldRetry(e, t, r) {
        return (
          t < r && this.retryDecider(e) && this.retryQuota.hasRetryTokens(e)
        );
      }
      async getMaxAttempts() {
        let e;
        try {
          e = await this.maxAttemptsProvider();
        } catch {
          e = Zr.DEFAULT_MAX_ATTEMPTS;
        }
        return e;
      }
      async retry(e, t, r) {
        let n,
          i = 0,
          o = 0,
          a = await this.getMaxAttempts(),
          { request: s } = t;
        for (
          t_.HttpRequest.isInstance(s) &&
          (s.headers[Zr.INVOCATION_ID_HEADER] = (0, Pwe.v4)());
          ;

        )
          try {
            t_.HttpRequest.isInstance(s) &&
              (s.headers[Zr.REQUEST_HEADER] = `attempt=${i + 1}; max=${a}`),
              r?.beforeRequest && (await r.beforeRequest());
            let { response: u, output: l } = await e(t);
            return (
              r?.afterRequest && r.afterRequest(u),
              this.retryQuota.releaseRetryTokens(n),
              (l.$metadata.attempts = i + 1),
              (l.$metadata.totalRetryDelay = o),
              { response: u, output: l }
            );
          } catch (u) {
            let l = xwe(u);
            if ((i++, this.shouldRetry(l, i, a))) {
              n = this.retryQuota.retrieveRetryTokens(l);
              let d = this.delayDecider(
                  (0, Tf.isThrottlingError)(l)
                    ? Zr.THROTTLING_RETRY_DELAY_BASE
                    : Zr.DEFAULT_RETRY_DELAY_BASE,
                  i,
                ),
                f = Xzt(l.$response),
                m = Math.max(f || 0, d);
              (o += m), await new Promise((h) => setTimeout(h, m));
              continue;
            }
            throw (
              (l.$metadata || (l.$metadata = {}),
              (l.$metadata.attempts = i),
              (l.$metadata.totalRetryDelay = o),
              l)
            );
          }
      }
    },
    Xzt = An((e) => {
      if (!t_.HttpResponse.isInstance(e)) return;
      let t = Object.keys(e.headers).find(
        (o) => o.toLowerCase() === "retry-after",
      );
      if (!t) return;
      let r = e.headers[t],
        n = Number(r);
      return Number.isNaN(n) ? new Date(r).getTime() - Date.now() : n * 1e3;
    }, "getDelayFromRetryAfterHeader"),
    Jzt = class extends Nwe {
      static {
        An(this, "AdaptiveRetryStrategy");
      }
      constructor(e, t) {
        let { rateLimiter: r, ...n } = t ?? {};
        super(e, n),
          (this.rateLimiter = r ?? new Zr.DefaultRateLimiter()),
          (this.mode = Zr.RETRY_MODES.ADAPTIVE);
      }
      async retry(e, t) {
        return super.retry(e, t, {
          beforeRequest: async () => this.rateLimiter.getSendToken(),
          afterRequest: (r) => {
            this.rateLimiter.updateClientSendingRate(r);
          },
        });
      }
    },
    Twe = $s(),
    R6 = "AWS_MAX_ATTEMPTS",
    I6 = "max_attempts",
    Zzt = {
      environmentVariableSelector: (e) => {
        let t = e[R6];
        if (!t) return;
        let r = parseInt(t);
        if (Number.isNaN(r))
          throw new Error(
            `Environment variable ${R6} mast be a number, got "${t}"`,
          );
        return r;
      },
      configFileSelector: (e) => {
        let t = e[I6];
        if (!t) return;
        let r = parseInt(t);
        if (Number.isNaN(r))
          throw new Error(
            `Shared config file entry ${I6} mast be a number, got "${t}"`,
          );
        return r;
      },
      default: Zr.DEFAULT_MAX_ATTEMPTS,
    },
    e2t = An((e) => {
      let { retryStrategy: t, retryMode: r, maxAttempts: n } = e,
        i = (0, Twe.normalizeProvider)(n ?? Zr.DEFAULT_MAX_ATTEMPTS);
      return Object.assign(e, {
        maxAttempts: i,
        retryStrategy: async () =>
          t ||
          ((await (0, Twe.normalizeProvider)(r)()) === Zr.RETRY_MODES.ADAPTIVE
            ? new Zr.AdaptiveRetryStrategy(i)
            : new Zr.StandardRetryStrategy(i)),
      });
    }, "resolveRetryConfig"),
    kwe = "AWS_RETRY_MODE",
    Dwe = "retry_mode",
    t2t = {
      environmentVariableSelector: (e) => e[kwe],
      configFileSelector: (e) => e[Dwe],
      default: Zr.DEFAULT_RETRY_MODE,
    },
    Lwe = An(
      () => (e) => async (t) => {
        let { request: r } = t;
        return (
          t_.HttpRequest.isInstance(r) &&
            (delete r.headers[Zr.INVOCATION_ID_HEADER],
            delete r.headers[Zr.REQUEST_HEADER]),
          e(t)
        );
      },
      "omitRetryHeadersMiddleware",
    ),
    Mwe = {
      name: "omitRetryHeadersMiddleware",
      tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
      relation: "before",
      toMiddleware: "awsAuthMiddleware",
      override: !0,
    },
    r2t = An(
      (e) => ({
        applyToStack: (t) => {
          t.addRelativeTo(Lwe(), Mwe);
        },
      }),
      "getOmitRetryHeadersPlugin",
    ),
    n2t = vt(),
    i2t = Owe(),
    qwe = An(
      (e) => (t, r) => async (n) => {
        let i = await e.retryStrategy(),
          o = await e.maxAttempts();
        if (o2t(i)) {
          i = i;
          let a = await i.acquireInitialRetryToken(r.partition_id),
            s = new Error(),
            u = 0,
            l = 0,
            { request: d } = n,
            f = t_.HttpRequest.isInstance(d);
          for (f && (d.headers[Zr.INVOCATION_ID_HEADER] = (0, Pwe.v4)()); ; )
            try {
              f &&
                (d.headers[Zr.REQUEST_HEADER] = `attempt=${u + 1}; max=${o}`);
              let { response: m, output: h } = await t(n);
              return (
                i.recordSuccess(a),
                (h.$metadata.attempts = u + 1),
                (h.$metadata.totalRetryDelay = l),
                { response: m, output: h }
              );
            } catch (m) {
              let h = a2t(m);
              if (((s = xwe(m)), f && (0, i2t.isStreamingPayload)(d)))
                throw (
                  ((r.logger instanceof n2t.NoOpLogger
                    ? console
                    : r.logger
                  )?.warn(
                    "An error was encountered in a non-retryable streaming request.",
                  ),
                  s)
                );
              try {
                a = await i.refreshRetryTokenForRetry(a, h);
              } catch {
                throw (
                  (s.$metadata || (s.$metadata = {}),
                  (s.$metadata.attempts = u + 1),
                  (s.$metadata.totalRetryDelay = l),
                  s)
                );
              }
              u = a.getRetryCount();
              let y = a.getRetryDelay();
              (l += y), await new Promise((_) => setTimeout(_, y));
            }
        } else
          return (
            (i = i),
            i?.mode &&
              (r.userAgent = [
                ...(r.userAgent || []),
                ["cfg/retry-mode", i.mode],
              ]),
            i.retry(t, n)
          );
      },
      "retryMiddleware",
    ),
    o2t = An(
      (e) =>
        typeof e.acquireInitialRetryToken < "u" &&
        typeof e.refreshRetryTokenForRetry < "u" &&
        typeof e.recordSuccess < "u",
      "isRetryStrategyV2",
    ),
    a2t = An((e) => {
      let t = { error: e, errorType: s2t(e) },
        r = Fwe(e.$response);
      return r && (t.retryAfterHint = r), t;
    }, "getRetryErrorInfo"),
    s2t = An(
      (e) =>
        (0, Tf.isThrottlingError)(e)
          ? "THROTTLING"
          : (0, Tf.isTransientError)(e)
            ? "TRANSIENT"
            : (0, Tf.isServerError)(e)
              ? "SERVER_ERROR"
              : "CLIENT_ERROR",
      "getRetryErrorType",
    ),
    jwe = {
      name: "retryMiddleware",
      tags: ["RETRY"],
      step: "finalizeRequest",
      priority: "high",
      override: !0,
    },
    c2t = An(
      (e) => ({
        applyToStack: (t) => {
          t.add(qwe(e), jwe);
        },
      }),
      "getRetryPlugin",
    ),
    Fwe = An((e) => {
      if (!t_.HttpResponse.isInstance(e)) return;
      let t = Object.keys(e.headers).find(
        (o) => o.toLowerCase() === "retry-after",
      );
      if (!t) return;
      let r = e.headers[t],
        n = Number(r);
      return Number.isNaN(n) ? new Date(r) : new Date(n * 1e3);
    }, "getRetryAfterHint");
});
var N6 = g((Xs) => {
  "use strict";
  c();
  Object.defineProperty(Xs, "__esModule", { value: !0 });
  Xs.resolveHttpAuthSchemeConfig =
    Xs.resolveStsAuthConfig =
    Xs.defaultSTSHttpAuthSchemeProvider =
    Xs.defaultSTSHttpAuthSchemeParametersProvider =
      void 0;
  var u2t = (Jn(), ue($c)),
    x6 = $s(),
    l2t = ZC(),
    d2t = async (e, t, r) => ({
      operation: (0, x6.getSmithyContext)(t).operation,
      region:
        (await (0, x6.normalizeProvider)(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`",
          );
        })(),
    });
  Xs.defaultSTSHttpAuthSchemeParametersProvider = d2t;
  function f2t(e) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: { name: "sts", region: e.region },
      propertiesExtractor: (t, r) => ({
        signingProperties: { config: t, context: r },
      }),
    };
  }
  function Uwe(e) {
    return { schemeId: "smithy.api#noAuth" };
  }
  var p2t = (e) => {
    let t = [];
    switch (e.operation) {
      case "AssumeRoleWithSAML": {
        t.push(Uwe(e));
        break;
      }
      case "AssumeRoleWithWebIdentity": {
        t.push(Uwe(e));
        break;
      }
      default:
        t.push(f2t(e));
    }
    return t;
  };
  Xs.defaultSTSHttpAuthSchemeProvider = p2t;
  var m2t = (e) => Object.assign(e, { stsClientCtor: l2t.STSClient });
  Xs.resolveStsAuthConfig = m2t;
  var h2t = (e) => {
    let t = (0, Xs.resolveStsAuthConfig)(e),
      r = (0, u2t.resolveAwsSdkSigV4Config)(t);
    return Object.assign(r, {
      authSchemePreference: (0, x6.normalizeProvider)(
        e.authSchemePreference ?? [],
      ),
    });
  };
  Xs.resolveHttpAuthSchemeConfig = h2t;
});
var Ua = g((r_) => {
  "use strict";
  c();
  Object.defineProperty(r_, "__esModule", { value: !0 });
  r_.commonParams = r_.resolveClientEndpointParameters = void 0;
  var g2t = (e) =>
    Object.assign(e, {
      useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
      useFipsEndpoint: e.useFipsEndpoint ?? !1,
      useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
      defaultSigningName: "sts",
    });
  r_.resolveClientEndpointParameters = g2t;
  r_.commonParams = {
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
  };
});
var Hwe = g((DOn, v2t) => {
  v2t.exports = {
    name: "@aws-sdk/client-sts",
    description:
      "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
    version: "3.799.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sts",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps":
        "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types":
        "rimraf ./dist-types tsconfig.types.tsbuildinfo && tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client":
        "node ../../scripts/generate-clients/single-service --solo sts",
      test: "yarn g:vitest run",
      "test:watch": "yarn g:vitest watch",
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.799.0",
      "@aws-sdk/credential-provider-node": "3.799.0",
      "@aws-sdk/middleware-host-header": "3.775.0",
      "@aws-sdk/middleware-logger": "3.775.0",
      "@aws-sdk/middleware-recursion-detection": "3.775.0",
      "@aws-sdk/middleware-user-agent": "3.799.0",
      "@aws-sdk/region-config-resolver": "3.775.0",
      "@aws-sdk/types": "3.775.0",
      "@aws-sdk/util-endpoints": "3.787.0",
      "@aws-sdk/util-user-agent-browser": "3.775.0",
      "@aws-sdk/util-user-agent-node": "3.799.0",
      "@smithy/config-resolver": "^4.1.0",
      "@smithy/core": "^3.3.0",
      "@smithy/fetch-http-handler": "^5.0.2",
      "@smithy/hash-node": "^4.0.2",
      "@smithy/invalid-dependency": "^4.0.2",
      "@smithy/middleware-content-length": "^4.0.2",
      "@smithy/middleware-endpoint": "^4.1.1",
      "@smithy/middleware-retry": "^4.1.1",
      "@smithy/middleware-serde": "^4.0.3",
      "@smithy/middleware-stack": "^4.0.2",
      "@smithy/node-config-provider": "^4.0.2",
      "@smithy/node-http-handler": "^4.0.4",
      "@smithy/protocol-http": "^5.1.0",
      "@smithy/smithy-client": "^4.2.1",
      "@smithy/types": "^4.2.0",
      "@smithy/url-parser": "^4.0.2",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.9",
      "@smithy/util-defaults-mode-node": "^4.0.9",
      "@smithy/util-endpoints": "^3.0.2",
      "@smithy/util-middleware": "^4.0.2",
      "@smithy/util-retry": "^4.0.2",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2",
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.2.2",
    },
    engines: { node: ">=18.0.0" },
    typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/",
    },
    license: "Apache-2.0",
    browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native",
    },
    homepage:
      "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sts",
    },
  };
});
var k6 = g((LOn, Ywe) => {
  "use strict";
  c();
  var RL = Object.defineProperty,
    y2t = Object.getOwnPropertyDescriptor,
    _2t = Object.getOwnPropertyNames,
    E2t = Object.prototype.hasOwnProperty,
    b2t = (e, t) => RL(e, "name", { value: t, configurable: !0 }),
    S2t = (e, t) => {
      for (var r in t) RL(e, r, { get: t[r], enumerable: !0 });
    },
    C2t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of _2t(t))
          !E2t.call(e, i) &&
            i !== r &&
            RL(e, i, {
              get: () => t[i],
              enumerable: !(n = y2t(t, i)) || n.enumerable,
            });
      return e;
    },
    w2t = (e) => C2t(RL({}, "__esModule", { value: !0 }), e),
    Gwe = {};
  S2t(Gwe, {
    ENV_ACCOUNT_ID: () => Qwe,
    ENV_CREDENTIAL_SCOPE: () => Wwe,
    ENV_EXPIRATION: () => Kwe,
    ENV_KEY: () => Vwe,
    ENV_SECRET: () => $we,
    ENV_SESSION: () => zwe,
    fromEnv: () => A2t,
  });
  Ywe.exports = w2t(Gwe);
  var O2t = (Ks(), ue(Ef)),
    T2t = xo(),
    Vwe = "AWS_ACCESS_KEY_ID",
    $we = "AWS_SECRET_ACCESS_KEY",
    zwe = "AWS_SESSION_TOKEN",
    Kwe = "AWS_CREDENTIAL_EXPIRATION",
    Wwe = "AWS_CREDENTIAL_SCOPE",
    Qwe = "AWS_ACCOUNT_ID",
    A2t = b2t(
      (e) => async () => {
        e?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
        let t = process.env[Vwe],
          r = process.env[$we],
          n = process.env[zwe],
          i = process.env[Kwe],
          o = process.env[Wwe],
          a = process.env[Qwe];
        if (t && r) {
          let s = {
            accessKeyId: t,
            secretAccessKey: r,
            ...(n && { sessionToken: n }),
            ...(i && { expiration: new Date(i) }),
            ...(o && { credentialScope: o }),
            ...(a && { accountId: a }),
          };
          return (
            (0, O2t.setCredentialFeature)(s, "CREDENTIALS_ENV_VARS", "g"), s
          );
        }
        throw new T2t.CredentialsProviderError(
          "Unable to find environment variable credentials.",
          { logger: e?.logger },
        );
      },
      "fromEnv",
    );
});
var ew = g((qOn, lOe) => {
  c();
  var NL = Object.defineProperty,
    P2t = Object.getOwnPropertyDescriptor,
    R2t = Object.getOwnPropertyNames,
    I2t = Object.prototype.hasOwnProperty,
    Pn = (e, t) => NL(e, "name", { value: t, configurable: !0 }),
    x2t = (e, t) => {
      for (var r in t) NL(e, r, { get: t[r], enumerable: !0 });
    },
    N2t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of R2t(t))
          !I2t.call(e, i) &&
            i !== r &&
            NL(e, i, {
              get: () => t[i],
              enumerable: !(n = P2t(t, i)) || n.enumerable,
            });
      return e;
    },
    k2t = (e) => N2t(NL({}, "__esModule", { value: !0 }), e),
    eOe = {};
  x2t(eOe, {
    DEFAULT_MAX_RETRIES: () => iOe,
    DEFAULT_TIMEOUT: () => nOe,
    ENV_CMDS_AUTH_TOKEN: () => M6,
    ENV_CMDS_FULL_URI: () => IL,
    ENV_CMDS_RELATIVE_URI: () => xL,
    Endpoint: () => aOe,
    fromContainerMetadata: () => q2t,
    fromInstanceMetadata: () => iKt,
    getInstanceMetadataEndpoint: () => cOe,
    httpRequest: () => n_,
    providerConfigFromInit: () => q6,
  });
  lOe.exports = k2t(eOe);
  var D2t = G("url"),
    Wc = xo(),
    L2t = G("buffer"),
    M2t = G("http");
  function n_(e) {
    return new Promise((t, r) => {
      let n = (0, M2t.request)({
        method: "GET",
        ...e,
        hostname: e.hostname?.replace(/^\[(.+)\]$/, "$1"),
      });
      n.on("error", (i) => {
        r(
          Object.assign(
            new Wc.ProviderError(
              "Unable to connect to instance metadata service",
            ),
            i,
          ),
        ),
          n.destroy();
      }),
        n.on("timeout", () => {
          r(
            new Wc.ProviderError("TimeoutError from instance metadata service"),
          ),
            n.destroy();
        }),
        n.on("response", (i) => {
          let { statusCode: o = 400 } = i;
          (o < 200 || 300 <= o) &&
            (r(
              Object.assign(
                new Wc.ProviderError(
                  "Error response received from instance metadata service",
                ),
                { statusCode: o },
              ),
            ),
            n.destroy());
          let a = [];
          i.on("data", (s) => {
            a.push(s);
          }),
            i.on("end", () => {
              t(L2t.Buffer.concat(a)), n.destroy();
            });
        }),
        n.end();
    });
  }
  Pn(n_, "httpRequest");
  var tOe = Pn(
      (e) =>
        !!e &&
        typeof e == "object" &&
        typeof e.AccessKeyId == "string" &&
        typeof e.SecretAccessKey == "string" &&
        typeof e.Token == "string" &&
        typeof e.Expiration == "string",
      "isImdsCredentials",
    ),
    rOe = Pn(
      (e) => ({
        accessKeyId: e.AccessKeyId,
        secretAccessKey: e.SecretAccessKey,
        sessionToken: e.Token,
        expiration: new Date(e.Expiration),
        ...(e.AccountId && { accountId: e.AccountId }),
      }),
      "fromImdsCredentials",
    ),
    nOe = 1e3,
    iOe = 0,
    q6 = Pn(
      ({ maxRetries: e = iOe, timeout: t = nOe }) => ({
        maxRetries: e,
        timeout: t,
      }),
      "providerConfigFromInit",
    ),
    L6 = Pn((e, t) => {
      let r = e();
      for (let n = 0; n < t; n++) r = r.catch(e);
      return r;
    }, "retry"),
    IL = "AWS_CONTAINER_CREDENTIALS_FULL_URI",
    xL = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",
    M6 = "AWS_CONTAINER_AUTHORIZATION_TOKEN",
    q2t = Pn((e = {}) => {
      let { timeout: t, maxRetries: r } = q6(e);
      return () =>
        L6(async () => {
          let n = await H2t({ logger: e.logger }),
            i = JSON.parse(await j2t(t, n));
          if (!tOe(i))
            throw new Wc.CredentialsProviderError(
              "Invalid response received from instance metadata service.",
              { logger: e.logger },
            );
          return rOe(i);
        }, r);
    }, "fromContainerMetadata"),
    j2t = Pn(
      async (e, t) => (
        process.env[M6] &&
          (t.headers = { ...t.headers, Authorization: process.env[M6] }),
        (await n_({ ...t, timeout: e })).toString()
      ),
      "requestFromEcsImds",
    ),
    F2t = "169.254.170.2",
    B2t = { localhost: !0, "127.0.0.1": !0 },
    U2t = { "http:": !0, "https:": !0 },
    H2t = Pn(async ({ logger: e }) => {
      if (process.env[xL]) return { hostname: F2t, path: process.env[xL] };
      if (process.env[IL]) {
        let t = (0, D2t.parse)(process.env[IL]);
        if (!t.hostname || !(t.hostname in B2t))
          throw new Wc.CredentialsProviderError(
            `${t.hostname} is not a valid container metadata service hostname`,
            { tryNextLink: !1, logger: e },
          );
        if (!t.protocol || !(t.protocol in U2t))
          throw new Wc.CredentialsProviderError(
            `${t.protocol} is not a valid container metadata service protocol`,
            { tryNextLink: !1, logger: e },
          );
        return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 };
      }
      throw new Wc.CredentialsProviderError(
        `The container metadata credential provider cannot be used unless the ${xL} or ${IL} environment variable is set`,
        { tryNextLink: !1, logger: e },
      );
    }, "getCmdsUri"),
    G2t = class oOe extends Wc.CredentialsProviderError {
      constructor(t, r = !0) {
        super(t, r),
          (this.tryNextLink = r),
          (this.name = "InstanceMetadataV1FallbackError"),
          Object.setPrototypeOf(this, oOe.prototype);
      }
      static {
        Pn(this, "InstanceMetadataV1FallbackError");
      }
    },
    j6 = ro(),
    V2t = fh(),
    aOe = ((e) => (
      (e.IPv4 = "http://169.254.169.254"),
      (e.IPv6 = "http://[fd00:ec2::254]"),
      e
    ))(aOe || {}),
    $2t = "AWS_EC2_METADATA_SERVICE_ENDPOINT",
    z2t = "ec2_metadata_service_endpoint",
    K2t = {
      environmentVariableSelector: (e) => e[$2t],
      configFileSelector: (e) => e[z2t],
      default: void 0,
    },
    sOe = ((e) => ((e.IPv4 = "IPv4"), (e.IPv6 = "IPv6"), e))(sOe || {}),
    W2t = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE",
    Q2t = "ec2_metadata_service_endpoint_mode",
    Y2t = {
      environmentVariableSelector: (e) => e[W2t],
      configFileSelector: (e) => e[Q2t],
      default: "IPv4",
    },
    cOe = Pn(
      async () => (0, V2t.parseUrl)((await X2t()) || (await J2t())),
      "getInstanceMetadataEndpoint",
    ),
    X2t = Pn(async () => (0, j6.loadConfig)(K2t)(), "getFromEndpointConfig"),
    J2t = Pn(async () => {
      let e = await (0, j6.loadConfig)(Y2t)();
      switch (e) {
        case "IPv4":
          return "http://169.254.169.254";
        case "IPv6":
          return "http://[fd00:ec2::254]";
        default:
          throw new Error(
            `Unsupported endpoint mode: ${e}. Select from ${Object.values(sOe)}`,
          );
      }
    }, "getFromEndpointModeConfig"),
    Z2t = 5 * 60,
    eKt = 5 * 60,
    tKt =
      "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html",
    Xwe = Pn((e, t) => {
      let r = Z2t + Math.floor(Math.random() * eKt),
        n = new Date(Date.now() + r * 1e3);
      t.warn(
        `Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(n)}.
For more information, please visit: ` + tKt,
      );
      let i = e.originalExpiration ?? e.expiration;
      return { ...e, ...(i ? { originalExpiration: i } : {}), expiration: n };
    }, "getExtendedInstanceMetadataCredentials"),
    rKt = Pn((e, t = {}) => {
      let r = t?.logger || console,
        n;
      return async () => {
        let i;
        try {
          (i = await e()),
            i.expiration &&
              i.expiration.getTime() < Date.now() &&
              (i = Xwe(i, r));
        } catch (o) {
          if (n) r.warn("Credential renew failed: ", o), (i = Xwe(n, r));
          else throw o;
        }
        return (n = i), i;
      };
    }, "staticStabilityProvider"),
    uOe = "/latest/meta-data/iam/security-credentials/",
    nKt = "/latest/api/token",
    D6 = "AWS_EC2_METADATA_V1_DISABLED",
    Jwe = "ec2_metadata_v1_disabled",
    Zwe = "x-aws-ec2-metadata-token",
    iKt = Pn(
      (e = {}) => rKt(oKt(e), { logger: e.logger }),
      "fromInstanceMetadata",
    ),
    oKt = Pn((e = {}) => {
      let t = !1,
        { logger: r, profile: n } = e,
        { timeout: i, maxRetries: o } = q6(e),
        a = Pn(async (s, u) => {
          if (t || u.headers?.[Zwe] == null) {
            let f = !1,
              m = !1,
              h = await (0, j6.loadConfig)(
                {
                  environmentVariableSelector: (y) => {
                    let _ = y[D6];
                    if (((m = !!_ && _ !== "false"), _ === void 0))
                      throw new Wc.CredentialsProviderError(
                        `${D6} not set in env, checking config file next.`,
                        { logger: e.logger },
                      );
                    return m;
                  },
                  configFileSelector: (y) => {
                    let _ = y[Jwe];
                    return (f = !!_ && _ !== "false"), f;
                  },
                  default: !1,
                },
                { profile: n },
              )();
            if (e.ec2MetadataV1Disabled || h) {
              let y = [];
              throw (
                (e.ec2MetadataV1Disabled &&
                  y.push(
                    "credential provider initialization (runtime option ec2MetadataV1Disabled)",
                  ),
                f && y.push(`config file profile (${Jwe})`),
                m && y.push(`process environment variable (${D6})`),
                new G2t(
                  `AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${y.join(", ")}].`,
                ))
              );
            }
          }
          let d = (
            await L6(async () => {
              let f;
              try {
                f = await sKt(u);
              } catch (m) {
                throw (m.statusCode === 401 && (t = !1), m);
              }
              return f;
            }, s)
          ).trim();
          return L6(async () => {
            let f;
            try {
              f = await cKt(d, u, e);
            } catch (m) {
              throw (m.statusCode === 401 && (t = !1), m);
            }
            return f;
          }, s);
        }, "getCredentials");
      return async () => {
        let s = await cOe();
        if (t)
          return (
            r?.debug(
              "AWS SDK Instance Metadata",
              "using v1 fallback (no token fetch)",
            ),
            a(o, { ...s, timeout: i })
          );
        {
          let u;
          try {
            u = (await aKt({ ...s, timeout: i })).toString();
          } catch (l) {
            if (l?.statusCode === 400)
              throw Object.assign(l, {
                message: "EC2 Metadata token request returned error",
              });
            return (
              (l.message === "TimeoutError" ||
                [403, 404, 405].includes(l.statusCode)) &&
                (t = !0),
              r?.debug(
                "AWS SDK Instance Metadata",
                "using v1 fallback (initial)",
              ),
              a(o, { ...s, timeout: i })
            );
          }
          return a(o, { ...s, headers: { [Zwe]: u }, timeout: i });
        }
      };
    }, "getInstanceMetadataProvider"),
    aKt = Pn(
      async (e) =>
        n_({
          ...e,
          path: nKt,
          method: "PUT",
          headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" },
        }),
      "getMetadataToken",
    ),
    sKt = Pn(
      async (e) => (await n_({ ...e, path: uOe })).toString(),
      "getProfile",
    ),
    cKt = Pn(async (e, t, r) => {
      let n = JSON.parse((await n_({ ...t, path: uOe + e })).toString());
      if (!tOe(n))
        throw new Wc.CredentialsProviderError(
          "Invalid response received from instance metadata service.",
          { logger: r.logger },
        );
      return rOe(n);
    }, "getCredentialsFromProfile");
});
var dOe = g((kL) => {
  "use strict";
  c();
  Object.defineProperty(kL, "__esModule", { value: !0 });
  kL.checkUrl = void 0;
  var uKt = xo(),
    lKt = "169.254.170.2",
    dKt = "169.254.170.23",
    fKt = "[fd00:ec2::23]",
    pKt = (e, t) => {
      if (
        e.protocol !== "https:" &&
        !(e.hostname === lKt || e.hostname === dKt || e.hostname === fKt)
      ) {
        if (e.hostname.includes("[")) {
          if (
            e.hostname === "[::1]" ||
            e.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]"
          )
            return;
        } else {
          if (e.hostname === "localhost") return;
          let r = e.hostname.split("."),
            n = (i) => {
              let o = parseInt(i, 10);
              return 0 <= o && o <= 255;
            };
          if (r[0] === "127" && n(r[1]) && n(r[2]) && n(r[3]) && r.length === 4)
            return;
        }
        throw new uKt.CredentialsProviderError(
          `URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`,
          { logger: t },
        );
      }
    };
  kL.checkUrl = pKt;
});
var fOe = g((i_) => {
  "use strict";
  c();
  Object.defineProperty(i_, "__esModule", { value: !0 });
  i_.getCredentials = i_.createGetRequest = void 0;
  var F6 = xo(),
    mKt = Jr(),
    hKt = vt(),
    gKt = eW();
  function vKt(e) {
    return new mKt.HttpRequest({
      protocol: e.protocol,
      hostname: e.hostname,
      port: Number(e.port),
      path: e.pathname,
      query: Array.from(e.searchParams.entries()).reduce(
        (t, [r, n]) => ((t[r] = n), t),
        {},
      ),
      fragment: e.hash,
    });
  }
  i_.createGetRequest = vKt;
  async function yKt(e, t) {
    let n = await (0, gKt.sdkStreamMixin)(e.body).transformToString();
    if (e.statusCode === 200) {
      let i = JSON.parse(n);
      if (
        typeof i.AccessKeyId != "string" ||
        typeof i.SecretAccessKey != "string" ||
        typeof i.Token != "string" ||
        typeof i.Expiration != "string"
      )
        throw new F6.CredentialsProviderError(
          "HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }",
          { logger: t },
        );
      return {
        accessKeyId: i.AccessKeyId,
        secretAccessKey: i.SecretAccessKey,
        sessionToken: i.Token,
        expiration: (0, hKt.parseRfc3339DateTime)(i.Expiration),
      };
    }
    if (e.statusCode >= 400 && e.statusCode < 500) {
      let i = {};
      try {
        i = JSON.parse(n);
      } catch {}
      throw Object.assign(
        new F6.CredentialsProviderError(
          `Server responded with status: ${e.statusCode}`,
          { logger: t },
        ),
        { Code: i.Code, Message: i.Message },
      );
    }
    throw new F6.CredentialsProviderError(
      `Server responded with status: ${e.statusCode}`,
      { logger: t },
    );
  }
  i_.getCredentials = yKt;
});
var pOe = g((DL) => {
  "use strict";
  c();
  Object.defineProperty(DL, "__esModule", { value: !0 });
  DL.retryWrapper = void 0;
  var _Kt = (e, t, r) => async () => {
    for (let n = 0; n < t; ++n)
      try {
        return await e();
      } catch {
        await new Promise((o) => setTimeout(o, r));
      }
    return await e();
  };
  DL.retryWrapper = _Kt;
});
var gOe = g((LL) => {
  "use strict";
  c();
  Object.defineProperty(LL, "__esModule", { value: !0 });
  LL.fromHttp = void 0;
  var EKt = (go(), ue(ho)),
    bKt = (Ks(), ue(Ef)),
    SKt = ih(),
    mOe = xo(),
    CKt = EKt.__importDefault(G("fs/promises")),
    wKt = dOe(),
    hOe = fOe(),
    OKt = pOe(),
    TKt = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",
    AKt = "http://169.254.170.2",
    PKt = "AWS_CONTAINER_CREDENTIALS_FULL_URI",
    RKt = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE",
    IKt = "AWS_CONTAINER_AUTHORIZATION_TOKEN",
    xKt = (e = {}) => {
      e.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
      let t,
        r = e.awsContainerCredentialsRelativeUri ?? process.env[TKt],
        n = e.awsContainerCredentialsFullUri ?? process.env[PKt],
        i = e.awsContainerAuthorizationToken ?? process.env[IKt],
        o = e.awsContainerAuthorizationTokenFile ?? process.env[RKt],
        a =
          e.logger?.constructor?.name === "NoOpLogger" || !e.logger
            ? console.warn
            : e.logger.warn;
      if (
        (r &&
          n &&
          (a(
            "@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.",
          ),
          a("awsContainerCredentialsFullUri will take precedence.")),
        i &&
          o &&
          (a(
            "@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.",
          ),
          a("awsContainerAuthorizationToken will take precedence.")),
        n)
      )
        t = n;
      else if (r) t = `${AKt}${r}`;
      else
        throw new mOe.CredentialsProviderError(
          `No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`,
          { logger: e.logger },
        );
      let s = new URL(t);
      (0, wKt.checkUrl)(s, e.logger);
      let u = new SKt.NodeHttpHandler({
        requestTimeout: e.timeout ?? 1e3,
        connectionTimeout: e.timeout ?? 1e3,
      });
      return (0, OKt.retryWrapper)(
        async () => {
          let l = (0, hOe.createGetRequest)(s);
          i
            ? (l.headers.Authorization = i)
            : o &&
              (l.headers.Authorization = (
                await CKt.default.readFile(o)
              ).toString());
          try {
            let d = await u.handle(l);
            return (0, hOe.getCredentials)(d.response).then((f) =>
              (0, bKt.setCredentialFeature)(f, "CREDENTIALS_HTTP", "z"),
            );
          } catch (d) {
            throw new mOe.CredentialsProviderError(String(d), {
              logger: e.logger,
            });
          }
        },
        e.maxRetries ?? 3,
        e.timeout ?? 1e3,
      );
    };
  LL.fromHttp = xKt;
});
var B6 = g((ML) => {
  "use strict";
  c();
  Object.defineProperty(ML, "__esModule", { value: !0 });
  ML.fromHttp = void 0;
  var NKt = gOe();
  Object.defineProperty(ML, "fromHttp", {
    enumerable: !0,
    get: function () {
      return NKt.fromHttp;
    },
  });
});
var H6 = g((Af) => {
  "use strict";
  c();
  Object.defineProperty(Af, "__esModule", { value: !0 });
  Af.resolveHttpAuthSchemeConfig =
    Af.defaultSSOHttpAuthSchemeProvider =
    Af.defaultSSOHttpAuthSchemeParametersProvider =
      void 0;
  var kKt = (Jn(), ue($c)),
    U6 = $s(),
    DKt = async (e, t, r) => ({
      operation: (0, U6.getSmithyContext)(t).operation,
      region:
        (await (0, U6.normalizeProvider)(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`",
          );
        })(),
    });
  Af.defaultSSOHttpAuthSchemeParametersProvider = DKt;
  function LKt(e) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: { name: "awsssoportal", region: e.region },
      propertiesExtractor: (t, r) => ({
        signingProperties: { config: t, context: r },
      }),
    };
  }
  function qL(e) {
    return { schemeId: "smithy.api#noAuth" };
  }
  var MKt = (e) => {
    let t = [];
    switch (e.operation) {
      case "GetRoleCredentials": {
        t.push(qL(e));
        break;
      }
      case "ListAccountRoles": {
        t.push(qL(e));
        break;
      }
      case "ListAccounts": {
        t.push(qL(e));
        break;
      }
      case "Logout": {
        t.push(qL(e));
        break;
      }
      default:
        t.push(LKt(e));
    }
    return t;
  };
  Af.defaultSSOHttpAuthSchemeProvider = MKt;
  var qKt = (e) => {
    let t = (0, kKt.resolveAwsSdkSigV4Config)(e);
    return Object.assign(t, {
      authSchemePreference: (0, U6.normalizeProvider)(
        e.authSchemePreference ?? [],
      ),
    });
  };
  Af.resolveHttpAuthSchemeConfig = qKt;
});
var vOe = g((XOn, jKt) => {
  jKt.exports = {
    name: "@aws-sdk/client-sso",
    description:
      "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.799.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps":
        "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client":
        "node ../../scripts/generate-clients/single-service --solo sso",
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.799.0",
      "@aws-sdk/middleware-host-header": "3.775.0",
      "@aws-sdk/middleware-logger": "3.775.0",
      "@aws-sdk/middleware-recursion-detection": "3.775.0",
      "@aws-sdk/middleware-user-agent": "3.799.0",
      "@aws-sdk/region-config-resolver": "3.775.0",
      "@aws-sdk/types": "3.775.0",
      "@aws-sdk/util-endpoints": "3.787.0",
      "@aws-sdk/util-user-agent-browser": "3.775.0",
      "@aws-sdk/util-user-agent-node": "3.799.0",
      "@smithy/config-resolver": "^4.1.0",
      "@smithy/core": "^3.3.0",
      "@smithy/fetch-http-handler": "^5.0.2",
      "@smithy/hash-node": "^4.0.2",
      "@smithy/invalid-dependency": "^4.0.2",
      "@smithy/middleware-content-length": "^4.0.2",
      "@smithy/middleware-endpoint": "^4.1.1",
      "@smithy/middleware-retry": "^4.1.1",
      "@smithy/middleware-serde": "^4.0.3",
      "@smithy/middleware-stack": "^4.0.2",
      "@smithy/node-config-provider": "^4.0.2",
      "@smithy/node-http-handler": "^4.0.4",
      "@smithy/protocol-http": "^5.1.0",
      "@smithy/smithy-client": "^4.2.1",
      "@smithy/types": "^4.2.0",
      "@smithy/url-parser": "^4.0.2",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.9",
      "@smithy/util-defaults-mode-node": "^4.0.9",
      "@smithy/util-endpoints": "^3.0.2",
      "@smithy/util-middleware": "^4.0.2",
      "@smithy/util-retry": "^4.0.2",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2",
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.2.2",
    },
    engines: { node: ">=18.0.0" },
    typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/",
    },
    license: "Apache-2.0",
    browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native",
    },
    homepage:
      "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso",
    },
  };
});
var tw = g((JOn, wOe) => {
  "use strict";
  c();
  var FL = Object.defineProperty,
    FKt = Object.getOwnPropertyDescriptor,
    BKt = Object.getOwnPropertyNames,
    UKt = Object.prototype.hasOwnProperty,
    jL = (e, t) => FL(e, "name", { value: t, configurable: !0 }),
    HKt = (e, t) => {
      for (var r in t) FL(e, r, { get: t[r], enumerable: !0 });
    },
    GKt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of BKt(t))
          !UKt.call(e, i) &&
            i !== r &&
            FL(e, i, {
              get: () => t[i],
              enumerable: !(n = FKt(t, i)) || n.enumerable,
            });
      return e;
    },
    VKt = (e) => GKt(FL({}, "__esModule", { value: !0 }), e),
    _Oe = {};
  HKt(_Oe, {
    NODE_APP_ID_CONFIG_OPTIONS: () => QKt,
    UA_APP_ID_ENV_NAME: () => SOe,
    UA_APP_ID_INI_NAME: () => COe,
    createDefaultUserAgentProvider: () => bOe,
    crtAvailability: () => EOe,
    defaultUserAgent: () => zKt,
  });
  wOe.exports = VKt(_Oe);
  var yOe = G("os"),
    G6 = G("process"),
    EOe = { isCrtAvailable: !1 },
    $Kt = jL(
      () => (EOe.isCrtAvailable ? ["md/crt-avail"] : null),
      "isCrtAvailable",
    ),
    bOe = jL(
      ({ serviceId: e, clientVersion: t }) =>
        async (r) => {
          let n = [
              ["aws-sdk-js", t],
              ["ua", "2.1"],
              [`os/${(0, yOe.platform)()}`, (0, yOe.release)()],
              ["lang/js"],
              ["md/nodejs", `${G6.versions.node}`],
            ],
            i = $Kt();
          i && n.push(i),
            e && n.push([`api/${e}`, t]),
            G6.env.AWS_EXECUTION_ENV &&
              n.push([`exec-env/${G6.env.AWS_EXECUTION_ENV}`]);
          let o = await r?.userAgentAppId?.();
          return o ? [...n, [`app/${o}`]] : [...n];
        },
      "createDefaultUserAgentProvider",
    ),
    zKt = bOe,
    KKt = Yy(),
    SOe = "AWS_SDK_UA_APP_ID",
    COe = "sdk_ua_app_id",
    WKt = "sdk-ua-app-id",
    QKt = {
      environmentVariableSelector: jL(
        (e) => e[SOe],
        "environmentVariableSelector",
      ),
      configFileSelector: jL((e) => e[COe] ?? e[WKt], "configFileSelector"),
      default: KKt.DEFAULT_UA_APP_ID,
    };
});
var rw = g((eTn, POe) => {
  c();
  var BL = Object.defineProperty,
    YKt = Object.getOwnPropertyDescriptor,
    XKt = Object.getOwnPropertyNames,
    JKt = Object.prototype.hasOwnProperty,
    TOe = (e, t) => BL(e, "name", { value: t, configurable: !0 }),
    ZKt = (e, t) => {
      for (var r in t) BL(e, r, { get: t[r], enumerable: !0 });
    },
    e4t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of XKt(t))
          !JKt.call(e, i) &&
            i !== r &&
            BL(e, i, {
              get: () => t[i],
              enumerable: !(n = YKt(t, i)) || n.enumerable,
            });
      return e;
    },
    t4t = (e) => e4t(BL({}, "__esModule", { value: !0 }), e),
    AOe = {};
  ZKt(AOe, { Hash: () => i4t });
  POe.exports = t4t(AOe);
  var V6 = Hi(),
    r4t = Fe(),
    n4t = G("buffer"),
    OOe = G("crypto"),
    i4t = class {
      static {
        TOe(this, "Hash");
      }
      constructor(e, t) {
        (this.algorithmIdentifier = e), (this.secret = t), this.reset();
      }
      update(e, t) {
        this.hash.update((0, r4t.toUint8Array)($6(e, t)));
      }
      digest() {
        return Promise.resolve(this.hash.digest());
      }
      reset() {
        this.hash = this.secret
          ? (0, OOe.createHmac)(this.algorithmIdentifier, $6(this.secret))
          : (0, OOe.createHash)(this.algorithmIdentifier);
      }
    };
  function $6(e, t) {
    return n4t.Buffer.isBuffer(e)
      ? e
      : typeof e == "string"
        ? (0, V6.fromString)(e, t)
        : ArrayBuffer.isView(e)
          ? (0, V6.fromArrayBuffer)(e.buffer, e.byteOffset, e.byteLength)
          : (0, V6.fromArrayBuffer)(e);
  }
  TOe($6, "castSourceData");
});
var yl = g((nTn, xOe) => {
  c();
  var UL = Object.defineProperty,
    o4t = Object.getOwnPropertyDescriptor,
    a4t = Object.getOwnPropertyNames,
    s4t = Object.prototype.hasOwnProperty,
    c4t = (e, t) => UL(e, "name", { value: t, configurable: !0 }),
    u4t = (e, t) => {
      for (var r in t) UL(e, r, { get: t[r], enumerable: !0 });
    },
    l4t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of a4t(t))
          !s4t.call(e, i) &&
            i !== r &&
            UL(e, i, {
              get: () => t[i],
              enumerable: !(n = o4t(t, i)) || n.enumerable,
            });
      return e;
    },
    d4t = (e) => l4t(UL({}, "__esModule", { value: !0 }), e),
    IOe = {};
  u4t(IOe, { calculateBodyLength: () => f4t });
  xOe.exports = d4t(IOe);
  var ROe = G("fs"),
    f4t = c4t((e) => {
      if (!e) return 0;
      if (typeof e == "string") return Buffer.byteLength(e);
      if (typeof e.byteLength == "number") return e.byteLength;
      if (typeof e.size == "number") return e.size;
      if (typeof e.start == "number" && typeof e.end == "number")
        return e.end + 1 - e.start;
      if (typeof e.path == "string" || Buffer.isBuffer(e.path))
        return (0, ROe.lstatSync)(e.path).size;
      if (typeof e.fd == "number") return (0, ROe.fstatSync)(e.fd).size;
      throw new Error(`Body Length computation failed for ${e}`);
    }, "calculateBodyLength");
});
var zOe = g((HL) => {
  "use strict";
  c();
  Object.defineProperty(HL, "__esModule", { value: !0 });
  HL.ruleSet = void 0;
  var HOe = "required",
    Ga = "fn",
    Va = "argv",
    s_ = "ref",
    NOe = !0,
    kOe = "isSet",
    nw = "booleanEquals",
    o_ = "error",
    a_ = "endpoint",
    _l = "tree",
    z6 = "PartitionResult",
    K6 = "getAttr",
    DOe = { [HOe]: !1, type: "String" },
    LOe = { [HOe]: !0, default: !1, type: "Boolean" },
    MOe = { [s_]: "Endpoint" },
    GOe = { [Ga]: nw, [Va]: [{ [s_]: "UseFIPS" }, !0] },
    VOe = { [Ga]: nw, [Va]: [{ [s_]: "UseDualStack" }, !0] },
    Ha = {},
    qOe = { [Ga]: K6, [Va]: [{ [s_]: z6 }, "supportsFIPS"] },
    $Oe = { [s_]: z6 },
    jOe = {
      [Ga]: nw,
      [Va]: [!0, { [Ga]: K6, [Va]: [$Oe, "supportsDualStack"] }],
    },
    FOe = [GOe],
    BOe = [VOe],
    UOe = [{ [s_]: "Region" }],
    p4t = {
      version: "1.0",
      parameters: {
        Region: DOe,
        UseDualStack: LOe,
        UseFIPS: LOe,
        Endpoint: DOe,
      },
      rules: [
        {
          conditions: [{ [Ga]: kOe, [Va]: [MOe] }],
          rules: [
            {
              conditions: FOe,
              error:
                "Invalid Configuration: FIPS and custom endpoint are not supported",
              type: o_,
            },
            {
              conditions: BOe,
              error:
                "Invalid Configuration: Dualstack and custom endpoint are not supported",
              type: o_,
            },
            { endpoint: { url: MOe, properties: Ha, headers: Ha }, type: a_ },
          ],
          type: _l,
        },
        {
          conditions: [{ [Ga]: kOe, [Va]: UOe }],
          rules: [
            {
              conditions: [{ [Ga]: "aws.partition", [Va]: UOe, assign: z6 }],
              rules: [
                {
                  conditions: [GOe, VOe],
                  rules: [
                    {
                      conditions: [{ [Ga]: nw, [Va]: [NOe, qOe] }, jOe],
                      rules: [
                        {
                          endpoint: {
                            url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                            properties: Ha,
                            headers: Ha,
                          },
                          type: a_,
                        },
                      ],
                      type: _l,
                    },
                    {
                      error:
                        "FIPS and DualStack are enabled, but this partition does not support one or both",
                      type: o_,
                    },
                  ],
                  type: _l,
                },
                {
                  conditions: FOe,
                  rules: [
                    {
                      conditions: [{ [Ga]: nw, [Va]: [qOe, NOe] }],
                      rules: [
                        {
                          conditions: [
                            {
                              [Ga]: "stringEquals",
                              [Va]: [
                                { [Ga]: K6, [Va]: [$Oe, "name"] },
                                "aws-us-gov",
                              ],
                            },
                          ],
                          endpoint: {
                            url: "https://portal.sso.{Region}.amazonaws.com",
                            properties: Ha,
                            headers: Ha,
                          },
                          type: a_,
                        },
                        {
                          endpoint: {
                            url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                            properties: Ha,
                            headers: Ha,
                          },
                          type: a_,
                        },
                      ],
                      type: _l,
                    },
                    {
                      error:
                        "FIPS is enabled but this partition does not support FIPS",
                      type: o_,
                    },
                  ],
                  type: _l,
                },
                {
                  conditions: BOe,
                  rules: [
                    {
                      conditions: [jOe],
                      rules: [
                        {
                          endpoint: {
                            url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                            properties: Ha,
                            headers: Ha,
                          },
                          type: a_,
                        },
                      ],
                      type: _l,
                    },
                    {
                      error:
                        "DualStack is enabled but this partition does not support DualStack",
                      type: o_,
                    },
                  ],
                  type: _l,
                },
                {
                  endpoint: {
                    url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
                    properties: Ha,
                    headers: Ha,
                  },
                  type: a_,
                },
              ],
              type: _l,
            },
          ],
          type: _l,
        },
        { error: "Invalid Configuration: Missing Region", type: o_ },
      ],
    };
  HL.ruleSet = p4t;
});
var KOe = g((GL) => {
  "use strict";
  c();
  Object.defineProperty(GL, "__esModule", { value: !0 });
  GL.defaultEndpointResolver = void 0;
  var m4t = Hy(),
    W6 = By(),
    h4t = zOe(),
    g4t = new W6.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
    }),
    v4t = (e, t = {}) =>
      g4t.get(e, () =>
        (0, W6.resolveEndpoint)(h4t.ruleSet, {
          endpointParams: e,
          logger: t.logger,
        }),
      );
  GL.defaultEndpointResolver = v4t;
  W6.customEndpointFunctions.aws = m4t.awsEndpointFunctions;
});
var YOe = g((VL) => {
  "use strict";
  c();
  Object.defineProperty(VL, "__esModule", { value: !0 });
  VL.getRuntimeConfig = void 0;
  var y4t = (Jn(), ue($c)),
    _4t = (Gi(), ue(yf)),
    E4t = vt(),
    b4t = fh(),
    WOe = Bc(),
    QOe = Fe(),
    S4t = H6(),
    C4t = KOe(),
    w4t = (e) => ({
      apiVersion: "2019-06-10",
      base64Decoder: e?.base64Decoder ?? WOe.fromBase64,
      base64Encoder: e?.base64Encoder ?? WOe.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? C4t.defaultEndpointResolver,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider:
        e?.httpAuthSchemeProvider ?? S4t.defaultSSOHttpAuthSchemeProvider,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new y4t.AwsSdkSigV4Signer(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new _4t.NoAuthSigner(),
        },
      ],
      logger: e?.logger ?? new E4t.NoOpLogger(),
      serviceId: e?.serviceId ?? "SSO",
      urlParser: e?.urlParser ?? b4t.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? QOe.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? QOe.toUtf8,
    });
  VL.getRuntimeConfig = w4t;
});
var ow = g((dTn, rTe) => {
  c();
  var O4t = Object.create,
    iw = Object.defineProperty,
    T4t = Object.getOwnPropertyDescriptor,
    A4t = Object.getOwnPropertyNames,
    P4t = Object.getPrototypeOf,
    R4t = Object.prototype.hasOwnProperty,
    Q6 = (e, t) => iw(e, "name", { value: t, configurable: !0 }),
    I4t = (e, t) => {
      for (var r in t) iw(e, r, { get: t[r], enumerable: !0 });
    },
    eTe = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of A4t(t))
          !R4t.call(e, i) &&
            i !== r &&
            iw(e, i, {
              get: () => t[i],
              enumerable: !(n = T4t(t, i)) || n.enumerable,
            });
      return e;
    },
    x4t = (e, t, r) => (
      (r = e != null ? O4t(P4t(e)) : {}),
      eTe(
        t || !e || !e.__esModule
          ? iw(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    N4t = (e) => eTe(iw({}, "__esModule", { value: !0 }), e),
    tTe = {};
  I4t(tTe, { resolveDefaultsModeConfig: () => H4t });
  rTe.exports = N4t(tTe);
  var k4t = Kc(),
    XOe = ro(),
    D4t = xo(),
    L4t = "AWS_EXECUTION_ENV",
    JOe = "AWS_REGION",
    ZOe = "AWS_DEFAULT_REGION",
    M4t = "AWS_EC2_METADATA_DISABLED",
    q4t = ["in-region", "cross-region", "mobile", "standard", "legacy"],
    j4t = "/latest/meta-data/placement/region",
    F4t = "AWS_DEFAULTS_MODE",
    B4t = "defaults_mode",
    U4t = {
      environmentVariableSelector: (e) => e[F4t],
      configFileSelector: (e) => e[B4t],
      default: "legacy",
    },
    H4t = Q6(
      ({
        region: e = (0, XOe.loadConfig)(k4t.NODE_REGION_CONFIG_OPTIONS),
        defaultsMode: t = (0, XOe.loadConfig)(U4t),
      } = {}) =>
        (0, D4t.memoize)(async () => {
          let r = typeof t == "function" ? await t() : t;
          switch (r?.toLowerCase()) {
            case "auto":
              return G4t(e);
            case "in-region":
            case "cross-region":
            case "mobile":
            case "standard":
            case "legacy":
              return Promise.resolve(r?.toLocaleLowerCase());
            case void 0:
              return Promise.resolve("legacy");
            default:
              throw new Error(
                `Invalid parameter for "defaultsMode", expect ${q4t.join(", ")}, got ${r}`,
              );
          }
        }),
      "resolveDefaultsModeConfig",
    ),
    G4t = Q6(async (e) => {
      if (e) {
        let t = typeof e == "function" ? await e() : e,
          r = await V4t();
        return r ? (t === r ? "in-region" : "cross-region") : "standard";
      }
      return "standard";
    }, "resolveNodeDefaultsModeAuto"),
    V4t = Q6(async () => {
      if (process.env[L4t] && (process.env[JOe] || process.env[ZOe]))
        return process.env[JOe] ?? process.env[ZOe];
      if (!process.env[M4t])
        try {
          let { getInstanceMetadataEndpoint: e, httpRequest: t } =
              await Promise.resolve().then(() => x4t(ew())),
            r = await e();
          return (await t({ ...r, path: j4t })).toString();
        } catch {}
    }, "inferPhysicalRegion");
});
var sTe = g((zL) => {
  "use strict";
  c();
  Object.defineProperty(zL, "__esModule", { value: !0 });
  zL.getRuntimeConfig = void 0;
  var $4t = (go(), ue(ho)),
    z4t = $4t.__importDefault(vOe()),
    nTe = (Jn(), ue($c)),
    iTe = tw(),
    $L = Kc(),
    K4t = rw(),
    oTe = vl(),
    mh = ro(),
    aTe = ih(),
    W4t = yl(),
    Q4t = e_(),
    Y4t = YOe(),
    X4t = vt(),
    J4t = ow(),
    Z4t = vt(),
    eWt = (e) => {
      (0, Z4t.emitWarningIfUnsupportedVersion)(process.version);
      let t = (0, J4t.resolveDefaultsModeConfig)(e),
        r = () => t().then(X4t.loadConfigsForDefaultMode),
        n = (0, Y4t.getRuntimeConfig)(e);
      (0, nTe.emitWarningIfUnsupportedVersion)(process.version);
      let i = { profile: e?.profile };
      return {
        ...n,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference:
          e?.authSchemePreference ??
          (0, mh.loadConfig)(nTe.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, i),
        bodyLengthChecker: e?.bodyLengthChecker ?? W4t.calculateBodyLength,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          (0, iTe.createDefaultUserAgentProvider)({
            serviceId: n.serviceId,
            clientVersion: z4t.default.version,
          }),
        maxAttempts:
          e?.maxAttempts ??
          (0, mh.loadConfig)(oTe.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, e),
        region:
          e?.region ??
          (0, mh.loadConfig)($L.NODE_REGION_CONFIG_OPTIONS, {
            ...$L.NODE_REGION_CONFIG_FILE_OPTIONS,
            ...i,
          }),
        requestHandler: aTe.NodeHttpHandler.create(e?.requestHandler ?? r),
        retryMode:
          e?.retryMode ??
          (0, mh.loadConfig)(
            {
              ...oTe.NODE_RETRY_MODE_CONFIG_OPTIONS,
              default: async () =>
                (await r()).retryMode || Q4t.DEFAULT_RETRY_MODE,
            },
            e,
          ),
        sha256: e?.sha256 ?? K4t.Hash.bind(null, "sha256"),
        streamCollector: e?.streamCollector ?? aTe.streamCollector,
        useDualstackEndpoint:
          e?.useDualstackEndpoint ??
          (0, mh.loadConfig)($L.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, i),
        useFipsEndpoint:
          e?.useFipsEndpoint ??
          (0, mh.loadConfig)($L.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, i),
        userAgentAppId:
          e?.userAgentAppId ??
          (0, mh.loadConfig)(iTe.NODE_APP_ID_CONFIG_OPTIONS, i),
      };
    };
  zL.getRuntimeConfig = eWt;
});
var aw = g((hTn, pTe) => {
  "use strict";
  c();
  var KL = Object.defineProperty,
    tWt = Object.getOwnPropertyDescriptor,
    rWt = Object.getOwnPropertyNames,
    nWt = Object.prototype.hasOwnProperty,
    Qc = (e, t) => KL(e, "name", { value: t, configurable: !0 }),
    iWt = (e, t) => {
      for (var r in t) KL(e, r, { get: t[r], enumerable: !0 });
    },
    oWt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of rWt(t))
          !nWt.call(e, i) &&
            i !== r &&
            KL(e, i, {
              get: () => t[i],
              enumerable: !(n = tWt(t, i)) || n.enumerable,
            });
      return e;
    },
    aWt = (e) => oWt(KL({}, "__esModule", { value: !0 }), e),
    uTe = {};
  iWt(uTe, {
    NODE_REGION_CONFIG_FILE_OPTIONS: () => lWt,
    NODE_REGION_CONFIG_OPTIONS: () => uWt,
    REGION_ENV_NAME: () => lTe,
    REGION_INI_NAME: () => dTe,
    getAwsRegionExtensionConfiguration: () => sWt,
    resolveAwsRegionExtensionConfiguration: () => cWt,
    resolveRegionConfig: () => dWt,
  });
  pTe.exports = aWt(uTe);
  var sWt = Qc(
      (e) => ({
        setRegion(t) {
          e.region = t;
        },
        region() {
          return e.region;
        },
      }),
      "getAwsRegionExtensionConfiguration",
    ),
    cWt = Qc(
      (e) => ({ region: e.region() }),
      "resolveAwsRegionExtensionConfiguration",
    ),
    lTe = "AWS_REGION",
    dTe = "region",
    uWt = {
      environmentVariableSelector: Qc(
        (e) => e[lTe],
        "environmentVariableSelector",
      ),
      configFileSelector: Qc((e) => e[dTe], "configFileSelector"),
      default: Qc(() => {
        throw new Error("Region is missing");
      }, "default"),
    },
    lWt = { preferredFile: "credentials" },
    fTe = Qc(
      (e) =>
        typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips")),
      "isFipsRegion",
    ),
    cTe = Qc(
      (e) =>
        fTe(e)
          ? ["fips-aws-global", "aws-fips"].includes(e)
            ? "us-east-1"
            : e.replace(/fips-(dkr-|prod-)?|-fips/, "")
          : e,
      "getRealRegion",
    ),
    dWt = Qc((e) => {
      let { region: t, useFipsEndpoint: r } = e;
      if (!t) throw new Error("Region is missing");
      return Object.assign(e, {
        region: Qc(async () => {
          if (typeof t == "string") return cTe(t);
          let n = await t();
          return cTe(n);
        }, "region"),
        useFipsEndpoint: Qc(async () => {
          let n = typeof t == "string" ? t : await t();
          return fTe(n)
            ? !0
            : typeof r != "function"
              ? Promise.resolve(!!r)
              : r();
        }, "useFipsEndpoint"),
      });
    }, "resolveRegionConfig");
});
var zTe = g((vTn, $Te) => {
  "use strict";
  c();
  var WL = Object.defineProperty,
    fWt = Object.getOwnPropertyDescriptor,
    pWt = Object.getOwnPropertyNames,
    mWt = Object.prototype.hasOwnProperty,
    Et = (e, t) => WL(e, "name", { value: t, configurable: !0 }),
    hWt = (e, t) => {
      for (var r in t) WL(e, r, { get: t[r], enumerable: !0 });
    },
    gWt = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of pWt(t))
          !mWt.call(e, i) &&
            i !== r &&
            WL(e, i, {
              get: () => t[i],
              enumerable: !(n = fWt(t, i)) || n.enumerable,
            });
      return e;
    },
    vWt = (e) => gWt(WL({}, "__esModule", { value: !0 }), e),
    ETe = {};
  hWt(ETe, {
    GetRoleCredentialsCommand: () => HTe,
    GetRoleCredentialsRequestFilterSensitiveLog: () => ITe,
    GetRoleCredentialsResponseFilterSensitiveLog: () => NTe,
    InvalidRequestException: () => STe,
    ListAccountRolesCommand: () => Y6,
    ListAccountRolesRequestFilterSensitiveLog: () => kTe,
    ListAccountsCommand: () => X6,
    ListAccountsRequestFilterSensitiveLog: () => DTe,
    LogoutCommand: () => GTe,
    LogoutRequestFilterSensitiveLog: () => LTe,
    ResourceNotFoundException: () => wTe,
    RoleCredentialsFilterSensitiveLog: () => xTe,
    SSO: () => VTe,
    SSOClient: () => YL,
    SSOServiceException: () => c_,
    TooManyRequestsException: () => TTe,
    UnauthorizedException: () => PTe,
    __Client: () => Oe.Client,
    paginateListAccountRoles: () => GWt,
    paginateListAccounts: () => VWt,
  });
  $Te.exports = vWt(ETe);
  var mTe = SC(),
    yWt = CC(),
    _Wt = wC(),
    hTe = Yy(),
    EWt = Kc(),
    El = (Gi(), ue(yf)),
    bWt = VC(),
    cw = gl(),
    gTe = vl(),
    vTe = H6(),
    SWt = Et(
      (e) =>
        Object.assign(e, {
          useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
          useFipsEndpoint: e.useFipsEndpoint ?? !1,
          defaultSigningName: "awsssoportal",
        }),
      "resolveClientEndpointParameters",
    ),
    QL = {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
    },
    CWt = sTe(),
    yTe = aw(),
    _Te = Jr(),
    Oe = vt(),
    wWt = Et((e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        n = e.credentials;
      return {
        setHttpAuthScheme(i) {
          let o = t.findIndex((a) => a.schemeId === i.schemeId);
          o === -1 ? t.push(i) : t.splice(o, 1, i);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(i) {
          r = i;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(i) {
          n = i;
        },
        credentials() {
          return n;
        },
      };
    }, "getHttpAuthExtensionConfiguration"),
    OWt = Et(
      (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }),
      "resolveHttpAuthRuntimeConfig",
    ),
    TWt = Et((e, t) => {
      let r = Object.assign(
        (0, yTe.getAwsRegionExtensionConfiguration)(e),
        (0, Oe.getDefaultExtensionConfiguration)(e),
        (0, _Te.getHttpHandlerExtensionConfiguration)(e),
        wWt(e),
      );
      return (
        t.forEach((n) => n.configure(r)),
        Object.assign(
          e,
          (0, yTe.resolveAwsRegionExtensionConfiguration)(r),
          (0, Oe.resolveDefaultRuntimeConfig)(r),
          (0, _Te.resolveHttpHandlerRuntimeConfig)(r),
          OWt(r),
        )
      );
    }, "resolveRuntimeExtensions"),
    YL = class extends Oe.Client {
      static {
        Et(this, "SSOClient");
      }
      config;
      constructor(...[e]) {
        let t = (0, CWt.getRuntimeConfig)(e || {});
        super(t), (this.initConfig = t);
        let r = SWt(t),
          n = (0, hTe.resolveUserAgentConfig)(r),
          i = (0, gTe.resolveRetryConfig)(n),
          o = (0, EWt.resolveRegionConfig)(i),
          a = (0, mTe.resolveHostHeaderConfig)(o),
          s = (0, cw.resolveEndpointConfig)(a),
          u = (0, vTe.resolveHttpAuthSchemeConfig)(s),
          l = TWt(u, e?.extensions || []);
        (this.config = l),
          this.middlewareStack.use((0, hTe.getUserAgentPlugin)(this.config)),
          this.middlewareStack.use((0, gTe.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, bWt.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, mTe.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, yWt.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, _Wt.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use(
            (0, El.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
              httpAuthSchemeParametersProvider:
                vTe.defaultSSOHttpAuthSchemeParametersProvider,
              identityProviderConfigProvider: Et(
                async (d) =>
                  new El.DefaultIdentityProviderConfig({
                    "aws.auth#sigv4": d.credentials,
                  }),
                "identityProviderConfigProvider",
              ),
            }),
          ),
          this.middlewareStack.use((0, El.getHttpSigningPlugin)(this.config));
      }
      destroy() {
        super.destroy();
      }
    },
    XL = pf(),
    c_ = class bTe extends Oe.ServiceException {
      static {
        Et(this, "SSOServiceException");
      }
      constructor(t) {
        super(t), Object.setPrototypeOf(this, bTe.prototype);
      }
    },
    STe = class CTe extends c_ {
      static {
        Et(this, "InvalidRequestException");
      }
      name = "InvalidRequestException";
      $fault = "client";
      constructor(t) {
        super({ name: "InvalidRequestException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, CTe.prototype);
      }
    },
    wTe = class OTe extends c_ {
      static {
        Et(this, "ResourceNotFoundException");
      }
      name = "ResourceNotFoundException";
      $fault = "client";
      constructor(t) {
        super({ name: "ResourceNotFoundException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, OTe.prototype);
      }
    },
    TTe = class ATe extends c_ {
      static {
        Et(this, "TooManyRequestsException");
      }
      name = "TooManyRequestsException";
      $fault = "client";
      constructor(t) {
        super({ name: "TooManyRequestsException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, ATe.prototype);
      }
    },
    PTe = class RTe extends c_ {
      static {
        Et(this, "UnauthorizedException");
      }
      name = "UnauthorizedException";
      $fault = "client";
      constructor(t) {
        super({ name: "UnauthorizedException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, RTe.prototype);
      }
    },
    ITe = Et(
      (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: Oe.SENSITIVE_STRING }),
      }),
      "GetRoleCredentialsRequestFilterSensitiveLog",
    ),
    xTe = Et(
      (e) => ({
        ...e,
        ...(e.secretAccessKey && { secretAccessKey: Oe.SENSITIVE_STRING }),
        ...(e.sessionToken && { sessionToken: Oe.SENSITIVE_STRING }),
      }),
      "RoleCredentialsFilterSensitiveLog",
    ),
    NTe = Et(
      (e) => ({
        ...e,
        ...(e.roleCredentials && { roleCredentials: xTe(e.roleCredentials) }),
      }),
      "GetRoleCredentialsResponseFilterSensitiveLog",
    ),
    kTe = Et(
      (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: Oe.SENSITIVE_STRING }),
      }),
      "ListAccountRolesRequestFilterSensitiveLog",
    ),
    DTe = Et(
      (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: Oe.SENSITIVE_STRING }),
      }),
      "ListAccountsRequestFilterSensitiveLog",
    ),
    LTe = Et(
      (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: Oe.SENSITIVE_STRING }),
      }),
      "LogoutRequestFilterSensitiveLog",
    ),
    sw = (Jn(), ue($c)),
    AWt = Et(async (e, t) => {
      let r = (0, El.requestBuilder)(e, t),
        n = (0, Oe.map)({}, Oe.isSerializableHeaderValue, { [eM]: e[ZL] });
      r.bp("/federation/credentials");
      let i = (0, Oe.map)({
        [UWt]: [, (0, Oe.expectNonNull)(e[BWt], "roleName")],
        [qTe]: [, (0, Oe.expectNonNull)(e[MTe], "accountId")],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetRoleCredentialsCommand"),
    PWt = Et(async (e, t) => {
      let r = (0, El.requestBuilder)(e, t),
        n = (0, Oe.map)({}, Oe.isSerializableHeaderValue, { [eM]: e[ZL] });
      r.bp("/assignment/roles");
      let i = (0, Oe.map)({
        [UTe]: [, e[BTe]],
        [FTe]: [() => e.maxResults !== void 0, () => e[jTe].toString()],
        [qTe]: [, (0, Oe.expectNonNull)(e[MTe], "accountId")],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListAccountRolesCommand"),
    RWt = Et(async (e, t) => {
      let r = (0, El.requestBuilder)(e, t),
        n = (0, Oe.map)({}, Oe.isSerializableHeaderValue, { [eM]: e[ZL] });
      r.bp("/assignment/accounts");
      let i = (0, Oe.map)({
        [UTe]: [, e[BTe]],
        [FTe]: [() => e.maxResults !== void 0, () => e[jTe].toString()],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListAccountsCommand"),
    IWt = Et(async (e, t) => {
      let r = (0, El.requestBuilder)(e, t),
        n = (0, Oe.map)({}, Oe.isSerializableHeaderValue, { [eM]: e[ZL] });
      return (
        r.bp("/logout"),
        r
          .m("POST")
          .h(n)
          .b(void 0),
        r.build()
      );
    }, "se_LogoutCommand"),
    xWt = Et(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return JL(e, t);
      let r = (0, Oe.map)({ $metadata: Pf(e) }),
        n = (0, Oe.expectNonNull)(
          (0, Oe.expectObject)(await (0, sw.parseJsonBody)(e.body, t)),
          "body",
        ),
        i = (0, Oe.take)(n, { roleCredentials: Oe._json });
      return Object.assign(r, i), r;
    }, "de_GetRoleCredentialsCommand"),
    NWt = Et(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return JL(e, t);
      let r = (0, Oe.map)({ $metadata: Pf(e) }),
        n = (0, Oe.expectNonNull)(
          (0, Oe.expectObject)(await (0, sw.parseJsonBody)(e.body, t)),
          "body",
        ),
        i = (0, Oe.take)(n, { nextToken: Oe.expectString, roleList: Oe._json });
      return Object.assign(r, i), r;
    }, "de_ListAccountRolesCommand"),
    kWt = Et(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return JL(e, t);
      let r = (0, Oe.map)({ $metadata: Pf(e) }),
        n = (0, Oe.expectNonNull)(
          (0, Oe.expectObject)(await (0, sw.parseJsonBody)(e.body, t)),
          "body",
        ),
        i = (0, Oe.take)(n, {
          accountList: Oe._json,
          nextToken: Oe.expectString,
        });
      return Object.assign(r, i), r;
    }, "de_ListAccountsCommand"),
    DWt = Et(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return JL(e, t);
      let r = (0, Oe.map)({ $metadata: Pf(e) });
      return await (0, Oe.collectBody)(e.body, t), r;
    }, "de_LogoutCommand"),
    JL = Et(async (e, t) => {
      let r = { ...e, body: await (0, sw.parseJsonErrorBody)(e.body, t) },
        n = (0, sw.loadRestJsonErrorCode)(e, r.body);
      switch (n) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
          throw await MWt(r, t);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
          throw await qWt(r, t);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
          throw await jWt(r, t);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
          throw await FWt(r, t);
        default:
          let i = r.body;
          return LWt({ output: e, parsedBody: i, errorCode: n });
      }
    }, "de_CommandError"),
    LWt = (0, Oe.withBaseException)(c_),
    MWt = Et(async (e, t) => {
      let r = (0, Oe.map)({}),
        n = e.body,
        i = (0, Oe.take)(n, { message: Oe.expectString });
      Object.assign(r, i);
      let o = new STe({ $metadata: Pf(e), ...r });
      return (0, Oe.decorateServiceException)(o, e.body);
    }, "de_InvalidRequestExceptionRes"),
    qWt = Et(async (e, t) => {
      let r = (0, Oe.map)({}),
        n = e.body,
        i = (0, Oe.take)(n, { message: Oe.expectString });
      Object.assign(r, i);
      let o = new wTe({ $metadata: Pf(e), ...r });
      return (0, Oe.decorateServiceException)(o, e.body);
    }, "de_ResourceNotFoundExceptionRes"),
    jWt = Et(async (e, t) => {
      let r = (0, Oe.map)({}),
        n = e.body,
        i = (0, Oe.take)(n, { message: Oe.expectString });
      Object.assign(r, i);
      let o = new TTe({ $metadata: Pf(e), ...r });
      return (0, Oe.decorateServiceException)(o, e.body);
    }, "de_TooManyRequestsExceptionRes"),
    FWt = Et(async (e, t) => {
      let r = (0, Oe.map)({}),
        n = e.body,
        i = (0, Oe.take)(n, { message: Oe.expectString });
      Object.assign(r, i);
      let o = new PTe({ $metadata: Pf(e), ...r });
      return (0, Oe.decorateServiceException)(o, e.body);
    }, "de_UnauthorizedExceptionRes"),
    Pf = Et(
      (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }),
      "deserializeMetadata",
    ),
    MTe = "accountId",
    ZL = "accessToken",
    qTe = "account_id",
    jTe = "maxResults",
    FTe = "max_result",
    BTe = "nextToken",
    UTe = "next_token",
    BWt = "roleName",
    UWt = "role_name",
    eM = "x-amz-sso_bearer_token",
    HTe = class extends Oe.Command.classBuilder()
      .ep(QL)
      .m(function (e, t, r, n) {
        return [
          (0, XL.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, cw.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("SWBPortalService", "GetRoleCredentials", {})
      .n("SSOClient", "GetRoleCredentialsCommand")
      .f(ITe, NTe)
      .ser(AWt)
      .de(xWt)
      .build() {
      static {
        Et(this, "GetRoleCredentialsCommand");
      }
    },
    Y6 = class extends Oe.Command.classBuilder()
      .ep(QL)
      .m(function (e, t, r, n) {
        return [
          (0, XL.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, cw.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("SWBPortalService", "ListAccountRoles", {})
      .n("SSOClient", "ListAccountRolesCommand")
      .f(kTe, void 0)
      .ser(PWt)
      .de(NWt)
      .build() {
      static {
        Et(this, "ListAccountRolesCommand");
      }
    },
    X6 = class extends Oe.Command.classBuilder()
      .ep(QL)
      .m(function (e, t, r, n) {
        return [
          (0, XL.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, cw.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("SWBPortalService", "ListAccounts", {})
      .n("SSOClient", "ListAccountsCommand")
      .f(DTe, void 0)
      .ser(RWt)
      .de(kWt)
      .build() {
      static {
        Et(this, "ListAccountsCommand");
      }
    },
    GTe = class extends Oe.Command.classBuilder()
      .ep(QL)
      .m(function (e, t, r, n) {
        return [
          (0, XL.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, cw.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("SWBPortalService", "Logout", {})
      .n("SSOClient", "LogoutCommand")
      .f(LTe, void 0)
      .ser(IWt)
      .de(DWt)
      .build() {
      static {
        Et(this, "LogoutCommand");
      }
    },
    HWt = {
      GetRoleCredentialsCommand: HTe,
      ListAccountRolesCommand: Y6,
      ListAccountsCommand: X6,
      LogoutCommand: GTe,
    },
    VTe = class extends YL {
      static {
        Et(this, "SSO");
      }
    };
  (0, Oe.createAggregatedClient)(HWt, VTe);
  var GWt = (0, El.createPaginator)(
      YL,
      Y6,
      "nextToken",
      "nextToken",
      "maxResults",
    ),
    VWt = (0, El.createPaginator)(
      YL,
      X6,
      "nextToken",
      "nextToken",
      "maxResults",
    );
});
function $Wt(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "sso-oauth", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
function zWt(e) {
  return { schemeId: "smithy.api#noAuth" };
}
var uw,
  KTe,
  WTe,
  QTe,
  J6 = w(() => {
    c();
    Jn();
    (uw = A($s())),
      (KTe = async (e, t, r) => ({
        operation: (0, uw.getSmithyContext)(t).operation,
        region:
          (await (0, uw.normalizeProvider)(e.region)()) ||
          (() => {
            throw new Error(
              "expected `region` to be configured for `aws.auth#sigv4`",
            );
          })(),
      }));
    (WTe = (e) => {
      let t = [];
      switch (e.operation) {
        case "CreateToken": {
          t.push(zWt(e));
          break;
        }
        default:
          t.push($Wt(e));
      }
      return t;
    }),
      (QTe = (e) => {
        let t = zy(e);
        return Object.assign(t, {
          authSchemePreference: (0, uw.normalizeProvider)(
            e.authSchemePreference ?? [],
          ),
        });
      });
  });
var YTe,
  XTe,
  Z6 = w(() => {
    c();
    (YTe = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        defaultSigningName: "sso-oauth",
      })),
      (XTe = {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var tM,
  e8 = w(() => {
    tM = {
      name: "@aws-sdk/nested-clients",
      version: "3.799.0",
      description: "Nested clients for AWS SDK packages.",
      main: "./dist-cjs/index.js",
      module: "./dist-es/index.js",
      types: "./dist-types/index.d.ts",
      scripts: {
        build:
          "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline nested-clients",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps":
          "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
        test: "yarn g:vitest run",
        "test:watch": "yarn g:vitest watch",
      },
      engines: { node: ">=18.0.0" },
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/",
      },
      license: "Apache-2.0",
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.799.0",
        "@aws-sdk/middleware-host-header": "3.775.0",
        "@aws-sdk/middleware-logger": "3.775.0",
        "@aws-sdk/middleware-recursion-detection": "3.775.0",
        "@aws-sdk/middleware-user-agent": "3.799.0",
        "@aws-sdk/region-config-resolver": "3.775.0",
        "@aws-sdk/types": "3.775.0",
        "@aws-sdk/util-endpoints": "3.787.0",
        "@aws-sdk/util-user-agent-browser": "3.775.0",
        "@aws-sdk/util-user-agent-node": "3.799.0",
        "@smithy/config-resolver": "^4.1.0",
        "@smithy/core": "^3.3.0",
        "@smithy/fetch-http-handler": "^5.0.2",
        "@smithy/hash-node": "^4.0.2",
        "@smithy/invalid-dependency": "^4.0.2",
        "@smithy/middleware-content-length": "^4.0.2",
        "@smithy/middleware-endpoint": "^4.1.1",
        "@smithy/middleware-retry": "^4.1.1",
        "@smithy/middleware-serde": "^4.0.3",
        "@smithy/middleware-stack": "^4.0.2",
        "@smithy/node-config-provider": "^4.0.2",
        "@smithy/node-http-handler": "^4.0.4",
        "@smithy/protocol-http": "^5.1.0",
        "@smithy/smithy-client": "^4.2.1",
        "@smithy/types": "^4.2.0",
        "@smithy/url-parser": "^4.0.2",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.9",
        "@smithy/util-defaults-mode-node": "^4.0.9",
        "@smithy/util-endpoints": "^3.0.2",
        "@smithy/util-middleware": "^4.0.2",
        "@smithy/util-retry": "^4.0.2",
        "@smithy/util-utf8": "^4.0.0",
        tslib: "^2.6.2",
      },
      devDependencies: {
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.2.2",
      },
      typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
      files: [
        "./sso-oidc.d.ts",
        "./sso-oidc.js",
        "./sts.d.ts",
        "./sts.js",
        "dist-*/**",
      ],
      browser: {
        "./dist-es/submodules/sso-oidc/runtimeConfig":
          "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
        "./dist-es/submodules/sts/runtimeConfig":
          "./dist-es/submodules/sts/runtimeConfig.browser",
      },
      "react-native": {},
      homepage:
        "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "packages/nested-clients",
      },
      exports: {
        "./sso-oidc": {
          types: "./dist-types/submodules/sso-oidc/index.d.ts",
          module: "./dist-es/submodules/sso-oidc/index.js",
          node: "./dist-cjs/submodules/sso-oidc/index.js",
          import: "./dist-es/submodules/sso-oidc/index.js",
          require: "./dist-cjs/submodules/sso-oidc/index.js",
        },
        "./sts": {
          types: "./dist-types/submodules/sts/index.d.ts",
          module: "./dist-es/submodules/sts/index.js",
          node: "./dist-cjs/submodules/sts/index.js",
          import: "./dist-es/submodules/sts/index.js",
          require: "./dist-cjs/submodules/sts/index.js",
        },
      },
    };
  });
var sAe,
  za,
  Ka,
  d_,
  JTe,
  lw,
  u_,
  l_,
  bl,
  t8,
  r8,
  ZTe,
  eAe,
  tAe,
  cAe,
  uAe,
  $a,
  rAe,
  lAe,
  nAe,
  iAe,
  oAe,
  aAe,
  WWt,
  dAe,
  fAe = w(() => {
    c();
    (sAe = "required"),
      (za = "fn"),
      (Ka = "argv"),
      (d_ = "ref"),
      (JTe = "isSet"),
      (lw = "booleanEquals"),
      (u_ = "error"),
      (l_ = "endpoint"),
      (bl = "tree"),
      (t8 = "PartitionResult"),
      (r8 = "getAttr"),
      (ZTe = { [sAe]: !1, type: "String" }),
      (eAe = { [sAe]: !0, default: !1, type: "Boolean" }),
      (tAe = { [d_]: "Endpoint" }),
      (cAe = { [za]: lw, [Ka]: [{ [d_]: "UseFIPS" }, !0] }),
      (uAe = { [za]: lw, [Ka]: [{ [d_]: "UseDualStack" }, !0] }),
      ($a = {}),
      (rAe = { [za]: r8, [Ka]: [{ [d_]: t8 }, "supportsFIPS"] }),
      (lAe = { [d_]: t8 }),
      (nAe = {
        [za]: lw,
        [Ka]: [!0, { [za]: r8, [Ka]: [lAe, "supportsDualStack"] }],
      }),
      (iAe = [cAe]),
      (oAe = [uAe]),
      (aAe = [{ [d_]: "Region" }]),
      (WWt = {
        version: "1.0",
        parameters: {
          Region: ZTe,
          UseDualStack: eAe,
          UseFIPS: eAe,
          Endpoint: ZTe,
        },
        rules: [
          {
            conditions: [{ [za]: JTe, [Ka]: [tAe] }],
            rules: [
              {
                conditions: iAe,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                type: u_,
              },
              {
                conditions: oAe,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                type: u_,
              },
              { endpoint: { url: tAe, properties: $a, headers: $a }, type: l_ },
            ],
            type: bl,
          },
          {
            conditions: [{ [za]: JTe, [Ka]: aAe }],
            rules: [
              {
                conditions: [{ [za]: "aws.partition", [Ka]: aAe, assign: t8 }],
                rules: [
                  {
                    conditions: [cAe, uAe],
                    rules: [
                      {
                        conditions: [{ [za]: lw, [Ka]: [!0, rAe] }, nAe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: $a,
                              headers: $a,
                            },
                            type: l_,
                          },
                        ],
                        type: bl,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        type: u_,
                      },
                    ],
                    type: bl,
                  },
                  {
                    conditions: iAe,
                    rules: [
                      {
                        conditions: [{ [za]: lw, [Ka]: [rAe, !0] }],
                        rules: [
                          {
                            conditions: [
                              {
                                [za]: "stringEquals",
                                [Ka]: [
                                  { [za]: r8, [Ka]: [lAe, "name"] },
                                  "aws-us-gov",
                                ],
                              },
                            ],
                            endpoint: {
                              url: "https://oidc.{Region}.amazonaws.com",
                              properties: $a,
                              headers: $a,
                            },
                            type: l_,
                          },
                          {
                            endpoint: {
                              url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: $a,
                              headers: $a,
                            },
                            type: l_,
                          },
                        ],
                        type: bl,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        type: u_,
                      },
                    ],
                    type: bl,
                  },
                  {
                    conditions: oAe,
                    rules: [
                      {
                        conditions: [nAe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: $a,
                              headers: $a,
                            },
                            type: l_,
                          },
                        ],
                        type: bl,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        type: u_,
                      },
                    ],
                    type: bl,
                  },
                  {
                    endpoint: {
                      url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}",
                      properties: $a,
                      headers: $a,
                    },
                    type: l_,
                  },
                ],
                type: bl,
              },
            ],
            type: bl,
          },
          { error: "Invalid Configuration: Missing Region", type: u_ },
        ],
      }),
      (dAe = WWt);
  });
var pAe,
  f_,
  QWt,
  mAe,
  hAe = w(() => {
    c();
    (pAe = A(Hy())), (f_ = A(By()));
    fAe();
    (QWt = new f_.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
    })),
      (mAe = (e, t = {}) =>
        QWt.get(e, () =>
          (0, f_.resolveEndpoint)(dAe, { endpointParams: e, logger: t.logger }),
        ));
    f_.customEndpointFunctions.aws = pAe.awsEndpointFunctions;
  });
var gAe,
  vAe,
  rM,
  nM,
  yAe,
  _Ae = w(() => {
    c();
    Jn();
    Gi();
    (gAe = A(vt())), (vAe = A(fh())), (rM = A(Bc())), (nM = A(Fe()));
    J6();
    hAe();
    yAe = (e) => ({
      apiVersion: "2019-06-10",
      base64Decoder: e?.base64Decoder ?? rM.fromBase64,
      base64Encoder: e?.base64Encoder ?? rM.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? mAe,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? WTe,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new da(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new fl(),
        },
      ],
      logger: e?.logger ?? new gAe.NoOpLogger(),
      serviceId: e?.serviceId ?? "SSO OIDC",
      urlParser: e?.urlParser ?? vAe.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? nM.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? nM.toUtf8,
    });
  });
var iM,
  If,
  EAe,
  oM,
  Rf,
  aM,
  bAe,
  SAe,
  CAe,
  wAe,
  OAe,
  TAe,
  AAe = w(() => {
    c();
    e8();
    Jn();
    (iM = A(tw())),
      (If = A(Kc())),
      (EAe = A(rw())),
      (oM = A(vl())),
      (Rf = A(ro())),
      (aM = A(ih())),
      (bAe = A(yl())),
      (SAe = A(e_()));
    _Ae();
    (CAe = A(vt())),
      (wAe = A(ow())),
      (OAe = A(vt())),
      (TAe = (e) => {
        (0, OAe.emitWarningIfUnsupportedVersion)(process.version);
        let t = (0, wAe.resolveDefaultsModeConfig)(e),
          r = () => t().then(CAe.loadConfigsForDefaultMode),
          n = yAe(e);
        Gy(process.version);
        let i = { profile: e?.profile };
        return {
          ...n,
          ...e,
          runtime: "node",
          defaultsMode: t,
          authSchemePreference:
            e?.authSchemePreference ?? (0, Rf.loadConfig)(kC, i),
          bodyLengthChecker: e?.bodyLengthChecker ?? bAe.calculateBodyLength,
          defaultUserAgentProvider:
            e?.defaultUserAgentProvider ??
            (0, iM.createDefaultUserAgentProvider)({
              serviceId: n.serviceId,
              clientVersion: tM.version,
            }),
          maxAttempts:
            e?.maxAttempts ??
            (0, Rf.loadConfig)(oM.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, e),
          region:
            e?.region ??
            (0, Rf.loadConfig)(If.NODE_REGION_CONFIG_OPTIONS, {
              ...If.NODE_REGION_CONFIG_FILE_OPTIONS,
              ...i,
            }),
          requestHandler: aM.NodeHttpHandler.create(e?.requestHandler ?? r),
          retryMode:
            e?.retryMode ??
            (0, Rf.loadConfig)(
              {
                ...oM.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () =>
                  (await r()).retryMode || SAe.DEFAULT_RETRY_MODE,
              },
              e,
            ),
          sha256: e?.sha256 ?? EAe.Hash.bind(null, "sha256"),
          streamCollector: e?.streamCollector ?? aM.streamCollector,
          useDualstackEndpoint:
            e?.useDualstackEndpoint ??
            (0, Rf.loadConfig)(
              If.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS,
              i,
            ),
          useFipsEndpoint:
            e?.useFipsEndpoint ??
            (0, Rf.loadConfig)(If.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, i),
          userAgentAppId:
            e?.userAgentAppId ??
            (0, Rf.loadConfig)(iM.NODE_APP_ID_CONFIG_OPTIONS, i),
        };
      });
  });
var PAe,
  RAe,
  IAe = w(() => {
    c();
    (PAe = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        n = e.credentials;
      return {
        setHttpAuthScheme(i) {
          let o = t.findIndex((a) => a.schemeId === i.schemeId);
          o === -1 ? t.push(i) : t.splice(o, 1, i);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(i) {
          r = i;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(i) {
          n = i;
        },
        credentials() {
          return n;
        },
      };
    }),
      (RAe = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var sM,
  cM,
  uM,
  xAe,
  NAe = w(() => {
    c();
    (sM = A(aw())), (cM = A(Jr())), (uM = A(vt()));
    IAe();
    xAe = (e, t) => {
      let r = Object.assign(
        (0, sM.getAwsRegionExtensionConfiguration)(e),
        (0, uM.getDefaultExtensionConfiguration)(e),
        (0, cM.getHttpHandlerExtensionConfiguration)(e),
        PAe(e),
      );
      return (
        t.forEach((n) => n.configure(r)),
        Object.assign(
          e,
          (0, sM.resolveAwsRegionExtensionConfiguration)(r),
          (0, uM.resolveDefaultRuntimeConfig)(r),
          (0, cM.resolveHttpHandlerRuntimeConfig)(r),
          RAe(r),
        )
      );
    };
  });
var lM,
  kAe,
  DAe,
  dM,
  LAe,
  MAe,
  qAe,
  fM,
  n8,
  dw,
  i8 = w(() => {
    c();
    (lM = A(SC())),
      (kAe = A(CC())),
      (DAe = A(wC())),
      (dM = A(Yy())),
      (LAe = A(Kc()));
    Gi();
    (MAe = A(VC())), (qAe = A(gl())), (fM = A(vl())), (n8 = A(vt()));
    J6();
    Z6();
    AAe();
    NAe();
    dw = class extends n8.Client {
      config;
      constructor(...[t]) {
        let r = TAe(t || {});
        super(r), (this.initConfig = r);
        let n = YTe(r),
          i = (0, dM.resolveUserAgentConfig)(n),
          o = (0, fM.resolveRetryConfig)(i),
          a = (0, LAe.resolveRegionConfig)(o),
          s = (0, lM.resolveHostHeaderConfig)(a),
          u = (0, qAe.resolveEndpointConfig)(s),
          l = QTe(u),
          d = xAe(l, t?.extensions || []);
        (this.config = d),
          this.middlewareStack.use((0, dM.getUserAgentPlugin)(this.config)),
          this.middlewareStack.use((0, fM.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, MAe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, lM.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, kAe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, DAe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use(
            TC(this.config, {
              httpAuthSchemeParametersProvider: KTe,
              identityProviderConfigProvider: async (f) =>
                new oh({ "aws.auth#sigv4": f.credentials }),
            }),
          ),
          this.middlewareStack.use(AC(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var jAe,
  Zn,
  pM = w(() => {
    c();
    (jAe = A(vt())),
      (Zn = class e extends jAe.ServiceException {
        constructor(t) {
          super(t), Object.setPrototypeOf(this, e.prototype);
        }
      });
  });
var hh,
  fw,
  pw,
  o8,
  a8,
  mw,
  hw,
  gw,
  vw,
  yw,
  _w,
  Ew,
  bw,
  Sw,
  mM = w(() => {
    c();
    hh = A(vt());
    pM();
    (fw = class e extends Zn {
      name = "AccessDeniedException";
      $fault = "client";
      error;
      error_description;
      constructor(t) {
        super({ name: "AccessDeniedException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description);
      }
    }),
      (pw = class e extends Zn {
        name = "AuthorizationPendingException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({
            name: "AuthorizationPendingException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (o8 = (e) => ({
        ...e,
        ...(e.clientSecret && { clientSecret: hh.SENSITIVE_STRING }),
        ...(e.refreshToken && { refreshToken: hh.SENSITIVE_STRING }),
        ...(e.codeVerifier && { codeVerifier: hh.SENSITIVE_STRING }),
      })),
      (a8 = (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: hh.SENSITIVE_STRING }),
        ...(e.refreshToken && { refreshToken: hh.SENSITIVE_STRING }),
        ...(e.idToken && { idToken: hh.SENSITIVE_STRING }),
      })),
      (mw = class e extends Zn {
        name = "ExpiredTokenException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "ExpiredTokenException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (hw = class e extends Zn {
        name = "InternalServerException";
        $fault = "server";
        error;
        error_description;
        constructor(t) {
          super({ name: "InternalServerException", $fault: "server", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (gw = class e extends Zn {
        name = "InvalidClientException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidClientException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (vw = class e extends Zn {
        name = "InvalidGrantException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidGrantException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (yw = class e extends Zn {
        name = "InvalidRequestException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidRequestException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (_w = class e extends Zn {
        name = "InvalidScopeException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidScopeException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (Ew = class e extends Zn {
        name = "SlowDownException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "SlowDownException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (bw = class e extends Zn {
        name = "UnauthorizedClientException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({
            name: "UnauthorizedClientException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (Sw = class e extends Zn {
        name = "UnsupportedGrantTypeException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({
            name: "UnsupportedGrantTypeException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      });
  });
var de,
  FAe,
  BAe,
  YWt,
  XWt,
  JWt,
  ZWt,
  e6t,
  t6t,
  r6t,
  n6t,
  i6t,
  o6t,
  a6t,
  s6t,
  c6t,
  Wa,
  UAe = w(() => {
    c();
    Jn();
    Gi();
    de = A(vt());
    mM();
    pM();
    (FAe = async (e, t) => {
      let r = RC(e, t),
        n = { "content-type": "application/json" };
      r.bp("/token");
      let i;
      return (
        (i = JSON.stringify(
          (0, de.take)(e, {
            clientId: [],
            clientSecret: [],
            code: [],
            codeVerifier: [],
            deviceCode: [],
            grantType: [],
            redirectUri: [],
            refreshToken: [],
            scope: (o) => (0, de._json)(o),
          }),
        )),
        r.m("POST").h(n).b(i),
        r.build()
      );
    }),
      (BAe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return YWt(e, t);
        let r = (0, de.map)({ $metadata: Wa(e) }),
          n = (0, de.expectNonNull)(
            (0, de.expectObject)(await YD(e.body, t)),
            "body",
          ),
          i = (0, de.take)(n, {
            accessToken: de.expectString,
            expiresIn: de.expectInt32,
            idToken: de.expectString,
            refreshToken: de.expectString,
            tokenType: de.expectString,
          });
        return Object.assign(r, i), r;
      }),
      (YWt = async (e, t) => {
        let r = { ...e, body: await zW(e.body, t) },
          n = KW(e, r.body);
        switch (n) {
          case "AccessDeniedException":
          case "com.amazonaws.ssooidc#AccessDeniedException":
            throw await JWt(r, t);
          case "AuthorizationPendingException":
          case "com.amazonaws.ssooidc#AuthorizationPendingException":
            throw await ZWt(r, t);
          case "ExpiredTokenException":
          case "com.amazonaws.ssooidc#ExpiredTokenException":
            throw await e6t(r, t);
          case "InternalServerException":
          case "com.amazonaws.ssooidc#InternalServerException":
            throw await t6t(r, t);
          case "InvalidClientException":
          case "com.amazonaws.ssooidc#InvalidClientException":
            throw await r6t(r, t);
          case "InvalidGrantException":
          case "com.amazonaws.ssooidc#InvalidGrantException":
            throw await n6t(r, t);
          case "InvalidRequestException":
          case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await i6t(r, t);
          case "InvalidScopeException":
          case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await o6t(r, t);
          case "SlowDownException":
          case "com.amazonaws.ssooidc#SlowDownException":
            throw await a6t(r, t);
          case "UnauthorizedClientException":
          case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await s6t(r, t);
          case "UnsupportedGrantTypeException":
          case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
            throw await c6t(r, t);
          default:
            let i = r.body;
            return XWt({ output: e, parsedBody: i, errorCode: n });
        }
      }),
      (XWt = (0, de.withBaseException)(Zn)),
      (JWt = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new fw({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (ZWt = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new pw({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (e6t = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new mw({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (t6t = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new hw({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (r6t = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new gw({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (n6t = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new vw({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (i6t = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new yw({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (o6t = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new _w({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (a6t = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new Ew({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (s6t = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new bw({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (c6t = async (e, t) => {
        let r = (0, de.map)({}),
          n = e.body,
          i = (0, de.take)(n, {
            error: de.expectString,
            error_description: de.expectString,
          });
        Object.assign(r, i);
        let o = new Sw({ $metadata: Wa(e), ...r });
        return (0, de.decorateServiceException)(o, e.body);
      }),
      (Wa = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }));
  });
var HAe,
  GAe,
  s8,
  Cw,
  c8 = w(() => {
    c();
    (HAe = A(gl())), (GAe = A(pf())), (s8 = A(vt()));
    Z6();
    mM();
    UAe();
    Cw = class extends (
      s8.Command.classBuilder()
        .ep(XTe)
        .m(function (t, r, n, i) {
          return [
            (0, GAe.getSerdePlugin)(n, this.serialize, this.deserialize),
            (0, HAe.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AWSSSOOIDCService", "CreateToken", {})
        .n("SSOOIDCClient", "CreateTokenCommand")
        .f(o8, a8)
        .ser(FAe)
        .de(BAe)
        .build()
    ) {};
  });
var VAe,
  u6t,
  hM,
  $Ae = w(() => {
    c();
    VAe = A(vt());
    c8();
    i8();
    (u6t = { CreateTokenCommand: Cw }), (hM = class extends dw {});
    (0, VAe.createAggregatedClient)(u6t, hM);
  });
var zAe = w(() => {
  c();
  c8();
});
var KAe = w(() => {
  c();
  mM();
});
var u8 = {};
bn(u8, {
  $Command: () => s8.Command,
  AccessDeniedException: () => fw,
  AuthorizationPendingException: () => pw,
  CreateTokenCommand: () => Cw,
  CreateTokenRequestFilterSensitiveLog: () => o8,
  CreateTokenResponseFilterSensitiveLog: () => a8,
  ExpiredTokenException: () => mw,
  InternalServerException: () => hw,
  InvalidClientException: () => gw,
  InvalidGrantException: () => vw,
  InvalidRequestException: () => yw,
  InvalidScopeException: () => _w,
  SSOOIDC: () => hM,
  SSOOIDCClient: () => dw,
  SSOOIDCServiceException: () => Zn,
  SlowDownException: () => Ew,
  UnauthorizedClientException: () => bw,
  UnsupportedGrantTypeException: () => Sw,
  __Client: () => n8.Client,
});
var l8 = w(() => {
  c();
  i8();
  $Ae();
  zAe();
  KAe();
  pM();
});
var tPe = g((qAn, ePe) => {
  "use strict";
  c();
  var l6t = Object.create,
    Ow = Object.defineProperty,
    d6t = Object.getOwnPropertyDescriptor,
    f6t = Object.getOwnPropertyNames,
    p6t = Object.getPrototypeOf,
    m6t = Object.prototype.hasOwnProperty,
    xf = (e, t) => Ow(e, "name", { value: t, configurable: !0 }),
    h6t = (e, t) => {
      for (var r in t) Ow(e, r, { get: t[r], enumerable: !0 });
    },
    YAe = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of f6t(t))
          !m6t.call(e, i) &&
            i !== r &&
            Ow(e, i, {
              get: () => t[i],
              enumerable: !(n = d6t(t, i)) || n.enumerable,
            });
      return e;
    },
    XAe = (e, t, r) => (
      (r = e != null ? l6t(p6t(e)) : {}),
      YAe(
        t || !e || !e.__esModule
          ? Ow(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    g6t = (e) => YAe(Ow({}, "__esModule", { value: !0 }), e),
    JAe = {};
  h6t(JAe, {
    fromSso: () => ZAe,
    fromStatic: () => C6t,
    nodeProvider: () => w6t,
  });
  ePe.exports = g6t(JAe);
  var v6t = 5 * 60 * 1e3,
    d8 =
      "To refresh this SSO session run 'aws sso login' with the corresponding profile.",
    y6t = xf(async (e, t = {}) => {
      let { SSOOIDCClient: r } = await Promise.resolve().then(() =>
        XAe((l8(), ue(u8))),
      );
      return new r(
        Object.assign({}, t.clientConfig ?? {}, {
          region: e ?? t.clientConfig?.region,
          logger: t.clientConfig?.logger ?? t.parentClientConfig?.logger,
        }),
      );
    }, "getSsoOidcClient"),
    _6t = xf(async (e, t, r = {}) => {
      let { CreateTokenCommand: n } = await Promise.resolve().then(() =>
        XAe((l8(), ue(u8))),
      );
      return (await y6t(t, r)).send(
        new n({
          clientId: e.clientId,
          clientSecret: e.clientSecret,
          refreshToken: e.refreshToken,
          grantType: "refresh_token",
        }),
      );
    }, "getNewSsoOidcToken"),
    Js = xo(),
    WAe = xf((e) => {
      if (e.expiration && e.expiration.getTime() < Date.now())
        throw new Js.TokenProviderError(`Token is expired. ${d8}`, !1);
    }, "validateTokenExpiry"),
    gh = xf((e, t, r = !1) => {
      if (typeof t > "u")
        throw new Js.TokenProviderError(
          `Value not present for '${e}' in SSO Token${r ? ". Cannot refresh" : ""}. ${d8}`,
          !1,
        );
    }, "validateTokenKey"),
    ww = No(),
    E6t = G("fs"),
    { writeFile: b6t } = E6t.promises,
    S6t = xf((e, t) => {
      let r = (0, ww.getSSOTokenFilepath)(e),
        n = JSON.stringify(t, null, 2);
      return b6t(r, n);
    }, "writeSSOTokenToFile"),
    QAe = new Date(0),
    ZAe = xf(
      (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          let r = {
            ...e,
            parentClientConfig: { ...t, ...e.parentClientConfig },
          };
          r.logger?.debug("@aws-sdk/token-providers - fromSso");
          let n = await (0, ww.parseKnownFiles)(r),
            i = (0, ww.getProfileName)({ profile: r.profile ?? t?.profile }),
            o = n[i];
          if (o) {
            if (!o.sso_session)
              throw new Js.TokenProviderError(
                `Profile '${i}' is missing required property 'sso_session'.`,
              );
          } else
            throw new Js.TokenProviderError(
              `Profile '${i}' could not be found in shared credentials file.`,
              !1,
            );
          let a = o.sso_session,
            u = (await (0, ww.loadSsoSessionData)(r))[a];
          if (!u)
            throw new Js.TokenProviderError(
              `Sso session '${a}' could not be found in shared credentials file.`,
              !1,
            );
          for (let _ of ["sso_start_url", "sso_region"])
            if (!u[_])
              throw new Js.TokenProviderError(
                `Sso session '${a}' is missing required property '${_}'.`,
                !1,
              );
          let l = u.sso_start_url,
            d = u.sso_region,
            f;
          try {
            f = await (0, ww.getSSOTokenFromFile)(a);
          } catch {
            throw new Js.TokenProviderError(
              `The SSO session token associated with profile=${i} was not found or is invalid. ${d8}`,
              !1,
            );
          }
          gh("accessToken", f.accessToken), gh("expiresAt", f.expiresAt);
          let { accessToken: m, expiresAt: h } = f,
            y = { token: m, expiration: new Date(h) };
          if (y.expiration.getTime() - Date.now() > v6t) return y;
          if (Date.now() - QAe.getTime() < 30 * 1e3) return WAe(y), y;
          gh("clientId", f.clientId, !0),
            gh("clientSecret", f.clientSecret, !0),
            gh("refreshToken", f.refreshToken, !0);
          try {
            QAe.setTime(Date.now());
            let _ = await _6t(f, d, r);
            gh("accessToken", _.accessToken), gh("expiresIn", _.expiresIn);
            let E = new Date(Date.now() + _.expiresIn * 1e3);
            try {
              await S6t(a, {
                ...f,
                accessToken: _.accessToken,
                expiresAt: E.toISOString(),
                refreshToken: _.refreshToken,
              });
            } catch {}
            return { token: _.accessToken, expiration: E };
          } catch {
            return WAe(y), y;
          }
        },
      "fromSso",
    ),
    C6t = xf(
      ({ token: e, logger: t }) =>
        async () => {
          if (
            (t?.debug("@aws-sdk/token-providers - fromStatic"), !e || !e.token)
          )
            throw new Js.TokenProviderError(
              "Please pass a valid token to fromStatic",
              !1,
            );
          return e;
        },
      "fromStatic",
    ),
    w6t = xf(
      (e = {}) =>
        (0, Js.memoize)(
          (0, Js.chain)(ZAe(e), async () => {
            throw new Js.TokenProviderError(
              "Could not load token from any providers",
              !1,
            );
          }),
          (t) =>
            t.expiration !== void 0 &&
            t.expiration.getTime() - Date.now() < 3e5,
          (t) => t.expiration !== void 0,
        ),
      "nodeProvider",
    );
});
var p8 = g((FAn, lPe) => {
  "use strict";
  c();
  var vM = Object.defineProperty,
    O6t = Object.getOwnPropertyDescriptor,
    iPe = Object.getOwnPropertyNames,
    T6t = Object.prototype.hasOwnProperty,
    yM = (e, t) => vM(e, "name", { value: t, configurable: !0 }),
    A6t = (e, t) =>
      function () {
        return e && (t = (0, e[iPe(e)[0]])((e = 0))), t;
      },
    oPe = (e, t) => {
      for (var r in t) vM(e, r, { get: t[r], enumerable: !0 });
    },
    P6t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of iPe(t))
          !T6t.call(e, i) &&
            i !== r &&
            vM(e, i, {
              get: () => t[i],
              enumerable: !(n = O6t(t, i)) || n.enumerable,
            });
      return e;
    },
    R6t = (e) => P6t(vM({}, "__esModule", { value: !0 }), e),
    aPe = {};
  oPe(aPe, {
    GetRoleCredentialsCommand: () => f8.GetRoleCredentialsCommand,
    SSOClient: () => f8.SSOClient,
  });
  var f8,
    I6t = A6t({
      "src/loadSso.ts"() {
        "use strict";
        f8 = zTe();
      },
    }),
    sPe = {};
  oPe(sPe, {
    fromSSO: () => N6t,
    isSsoProfile: () => cPe,
    validateSsoProfile: () => uPe,
  });
  lPe.exports = R6t(sPe);
  var cPe = yM(
      (e) =>
        e &&
        (typeof e.sso_start_url == "string" ||
          typeof e.sso_account_id == "string" ||
          typeof e.sso_session == "string" ||
          typeof e.sso_region == "string" ||
          typeof e.sso_role_name == "string"),
      "isSsoProfile",
    ),
    rPe = (Ks(), ue(Ef)),
    x6t = tPe(),
    Zs = xo(),
    gM = No(),
    Tw = !1,
    nPe = yM(
      async ({
        ssoStartUrl: e,
        ssoSession: t,
        ssoAccountId: r,
        ssoRegion: n,
        ssoRoleName: i,
        ssoClient: o,
        clientConfig: a,
        parentClientConfig: s,
        profile: u,
        logger: l,
      }) => {
        let d,
          f =
            "To refresh this SSO session run aws sso login with the corresponding profile.";
        if (t)
          try {
            let L = await (0, x6t.fromSso)({ profile: u })();
            d = {
              accessToken: L.token,
              expiresAt: new Date(L.expiration).toISOString(),
            };
          } catch (L) {
            throw new Zs.CredentialsProviderError(L.message, {
              tryNextLink: Tw,
              logger: l,
            });
          }
        else
          try {
            d = await (0, gM.getSSOTokenFromFile)(e);
          } catch {
            throw new Zs.CredentialsProviderError(
              `The SSO session associated with this profile is invalid. ${f}`,
              { tryNextLink: Tw, logger: l },
            );
          }
        if (new Date(d.expiresAt).getTime() - Date.now() <= 0)
          throw new Zs.CredentialsProviderError(
            `The SSO session associated with this profile has expired. ${f}`,
            { tryNextLink: Tw, logger: l },
          );
        let { accessToken: m } = d,
          { SSOClient: h, GetRoleCredentialsCommand: y } =
            await Promise.resolve().then(() => (I6t(), aPe)),
          _ =
            o ||
            new h(
              Object.assign({}, a ?? {}, {
                logger: a?.logger ?? s?.logger,
                region: a?.region ?? n,
              }),
            ),
          E;
        try {
          E = await _.send(
            new y({ accountId: r, roleName: i, accessToken: m }),
          );
        } catch (L) {
          throw new Zs.CredentialsProviderError(L, {
            tryNextLink: Tw,
            logger: l,
          });
        }
        let {
          roleCredentials: {
            accessKeyId: b,
            secretAccessKey: O,
            sessionToken: C,
            expiration: P,
            credentialScope: k,
            accountId: H,
          } = {},
        } = E;
        if (!b || !O || !C || !P)
          throw new Zs.CredentialsProviderError(
            "SSO returns an invalid temporary credential.",
            { tryNextLink: Tw, logger: l },
          );
        let B = {
          accessKeyId: b,
          secretAccessKey: O,
          sessionToken: C,
          expiration: new Date(P),
          ...(k && { credentialScope: k }),
          ...(H && { accountId: H }),
        };
        return (
          t
            ? (0, rPe.setCredentialFeature)(B, "CREDENTIALS_SSO", "s")
            : (0, rPe.setCredentialFeature)(B, "CREDENTIALS_SSO_LEGACY", "u"),
          B
        );
      },
      "resolveSSOCredentials",
    ),
    uPe = yM((e, t) => {
      let {
        sso_start_url: r,
        sso_account_id: n,
        sso_region: i,
        sso_role_name: o,
      } = e;
      if (!r || !n || !i || !o)
        throw new Zs.CredentialsProviderError(
          `Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(e).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`,
          { tryNextLink: !1, logger: t },
        );
      return e;
    }, "validateSsoProfile"),
    N6t = yM(
      (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          e.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
          let {
              ssoStartUrl: r,
              ssoAccountId: n,
              ssoRegion: i,
              ssoRoleName: o,
              ssoSession: a,
            } = e,
            { ssoClient: s } = e,
            u = (0, gM.getProfileName)({ profile: e.profile ?? t?.profile });
          if (!r && !n && !i && !o && !a) {
            let d = (await (0, gM.parseKnownFiles)(e))[u];
            if (!d)
              throw new Zs.CredentialsProviderError(
                `Profile ${u} was not found.`,
                { logger: e.logger },
              );
            if (!cPe(d))
              throw new Zs.CredentialsProviderError(
                `Profile ${u} is not configured with SSO credentials.`,
                { logger: e.logger },
              );
            if (d?.sso_session) {
              let b = (await (0, gM.loadSsoSessionData)(e))[d.sso_session],
                O = ` configurations in profile ${u} and sso-session ${d.sso_session}`;
              if (i && i !== b.sso_region)
                throw new Zs.CredentialsProviderError(
                  "Conflicting SSO region" + O,
                  { tryNextLink: !1, logger: e.logger },
                );
              if (r && r !== b.sso_start_url)
                throw new Zs.CredentialsProviderError(
                  "Conflicting SSO start_url" + O,
                  { tryNextLink: !1, logger: e.logger },
                );
              (d.sso_region = b.sso_region),
                (d.sso_start_url = b.sso_start_url);
            }
            let {
              sso_start_url: f,
              sso_account_id: m,
              sso_region: h,
              sso_role_name: y,
              sso_session: _,
            } = uPe(d, e.logger);
            return nPe({
              ssoStartUrl: f,
              ssoSession: _,
              ssoAccountId: m,
              ssoRegion: h,
              ssoRoleName: y,
              ssoClient: s,
              clientConfig: e.clientConfig,
              parentClientConfig: e.parentClientConfig,
              profile: u,
            });
          } else {
            if (!r || !n || !i || !o)
              throw new Zs.CredentialsProviderError(
                'Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"',
                { tryNextLink: !1, logger: e.logger },
              );
            return nPe({
              ssoStartUrl: r,
              ssoSession: a,
              ssoAccountId: n,
              ssoRegion: i,
              ssoRoleName: o,
              ssoClient: s,
              clientConfig: e.clientConfig,
              parentClientConfig: e.parentClientConfig,
              profile: u,
            });
          }
        },
      "fromSSO",
    );
});
function k6t(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "sts", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
function D6t(e) {
  return { schemeId: "smithy.api#noAuth" };
}
var Aw,
  dPe,
  fPe,
  L6t,
  pPe,
  m8 = w(() => {
    c();
    Jn();
    Aw = A($s());
    Pw();
    dPe = async (e, t, r) => ({
      operation: (0, Aw.getSmithyContext)(t).operation,
      region:
        (await (0, Aw.normalizeProvider)(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`",
          );
        })(),
    });
    (fPe = (e) => {
      let t = [];
      switch (e.operation) {
        case "AssumeRoleWithWebIdentity": {
          t.push(D6t(e));
          break;
        }
        default:
          t.push(k6t(e));
      }
      return t;
    }),
      (L6t = (e) => Object.assign(e, { stsClientCtor: Yc })),
      (pPe = (e) => {
        let t = L6t(e),
          r = zy(t);
        return Object.assign(r, {
          authSchemePreference: (0, Aw.normalizeProvider)(
            e.authSchemePreference ?? [],
          ),
        });
      });
  });
var mPe,
  _M,
  EM = w(() => {
    c();
    (mPe = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
        defaultSigningName: "sts",
      })),
      (_M = {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var OPe,
  nt,
  Ft,
  Bt,
  kf,
  Nf,
  Si,
  TPe,
  APe,
  PPe,
  $r,
  hPe,
  Xc,
  p_,
  g8,
  gPe,
  h8,
  RPe,
  vPe,
  Ci,
  yPe,
  IPe,
  xPe,
  Vi,
  fa,
  _Pe,
  NPe,
  kPe,
  EPe,
  DPe,
  bPe,
  SPe,
  CPe,
  wPe,
  M6t,
  LPe,
  MPe = w(() => {
    c();
    (OPe = "required"),
      (nt = "type"),
      (Ft = "fn"),
      (Bt = "argv"),
      (kf = "ref"),
      (Nf = "booleanEquals"),
      (Si = "stringEquals"),
      (TPe = "sigv4"),
      (APe = "sts"),
      (PPe = "us-east-1"),
      ($r = "endpoint"),
      (hPe = "https://sts.{Region}.{PartitionResult#dnsSuffix}"),
      (Xc = "tree"),
      (p_ = "error"),
      (g8 = "getAttr"),
      (gPe = { [OPe]: !1, [nt]: "String" }),
      (h8 = { [OPe]: !0, default: !1, [nt]: "Boolean" }),
      (RPe = { [kf]: "Endpoint" }),
      (vPe = { [Ft]: "isSet", [Bt]: [{ [kf]: "Region" }] }),
      (Ci = { [kf]: "Region" }),
      (yPe = { [Ft]: "aws.partition", [Bt]: [Ci], assign: "PartitionResult" }),
      (IPe = { [kf]: "UseFIPS" }),
      (xPe = { [kf]: "UseDualStack" }),
      (Vi = {
        url: "https://sts.amazonaws.com",
        properties: {
          authSchemes: [{ name: TPe, signingName: APe, signingRegion: PPe }],
        },
        headers: {},
      }),
      (fa = {}),
      (_Pe = {
        conditions: [{ [Ft]: Si, [Bt]: [Ci, "aws-global"] }],
        [$r]: Vi,
        [nt]: $r,
      }),
      (NPe = { [Ft]: Nf, [Bt]: [IPe, !0] }),
      (kPe = { [Ft]: Nf, [Bt]: [xPe, !0] }),
      (EPe = { [Ft]: g8, [Bt]: [{ [kf]: "PartitionResult" }, "supportsFIPS"] }),
      (DPe = { [kf]: "PartitionResult" }),
      (bPe = {
        [Ft]: Nf,
        [Bt]: [!0, { [Ft]: g8, [Bt]: [DPe, "supportsDualStack"] }],
      }),
      (SPe = [{ [Ft]: "isSet", [Bt]: [RPe] }]),
      (CPe = [NPe]),
      (wPe = [kPe]),
      (M6t = {
        version: "1.0",
        parameters: {
          Region: gPe,
          UseDualStack: h8,
          UseFIPS: h8,
          Endpoint: gPe,
          UseGlobalEndpoint: h8,
        },
        rules: [
          {
            conditions: [
              { [Ft]: Nf, [Bt]: [{ [kf]: "UseGlobalEndpoint" }, !0] },
              { [Ft]: "not", [Bt]: SPe },
              vPe,
              yPe,
              { [Ft]: Nf, [Bt]: [IPe, !1] },
              { [Ft]: Nf, [Bt]: [xPe, !1] },
            ],
            rules: [
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "ap-northeast-1"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "ap-south-1"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "ap-southeast-1"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "ap-southeast-2"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              _Pe,
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "ca-central-1"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "eu-central-1"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "eu-north-1"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "eu-west-1"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "eu-west-2"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "eu-west-3"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "sa-east-1"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, PPe] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "us-east-2"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "us-west-1"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                conditions: [{ [Ft]: Si, [Bt]: [Ci, "us-west-2"] }],
                endpoint: Vi,
                [nt]: $r,
              },
              {
                endpoint: {
                  url: hPe,
                  properties: {
                    authSchemes: [
                      {
                        name: TPe,
                        signingName: APe,
                        signingRegion: "{Region}",
                      },
                    ],
                  },
                  headers: fa,
                },
                [nt]: $r,
              },
            ],
            [nt]: Xc,
          },
          {
            conditions: SPe,
            rules: [
              {
                conditions: CPe,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                [nt]: p_,
              },
              {
                conditions: wPe,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                [nt]: p_,
              },
              { endpoint: { url: RPe, properties: fa, headers: fa }, [nt]: $r },
            ],
            [nt]: Xc,
          },
          {
            conditions: [vPe],
            rules: [
              {
                conditions: [yPe],
                rules: [
                  {
                    conditions: [NPe, kPe],
                    rules: [
                      {
                        conditions: [{ [Ft]: Nf, [Bt]: [!0, EPe] }, bPe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: fa,
                              headers: fa,
                            },
                            [nt]: $r,
                          },
                        ],
                        [nt]: Xc,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        [nt]: p_,
                      },
                    ],
                    [nt]: Xc,
                  },
                  {
                    conditions: CPe,
                    rules: [
                      {
                        conditions: [{ [Ft]: Nf, [Bt]: [EPe, !0] }],
                        rules: [
                          {
                            conditions: [
                              {
                                [Ft]: Si,
                                [Bt]: [
                                  { [Ft]: g8, [Bt]: [DPe, "name"] },
                                  "aws-us-gov",
                                ],
                              },
                            ],
                            endpoint: {
                              url: "https://sts.{Region}.amazonaws.com",
                              properties: fa,
                              headers: fa,
                            },
                            [nt]: $r,
                          },
                          {
                            endpoint: {
                              url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: fa,
                              headers: fa,
                            },
                            [nt]: $r,
                          },
                        ],
                        [nt]: Xc,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        [nt]: p_,
                      },
                    ],
                    [nt]: Xc,
                  },
                  {
                    conditions: wPe,
                    rules: [
                      {
                        conditions: [bPe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: fa,
                              headers: fa,
                            },
                            [nt]: $r,
                          },
                        ],
                        [nt]: Xc,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        [nt]: p_,
                      },
                    ],
                    [nt]: Xc,
                  },
                  _Pe,
                  {
                    endpoint: { url: hPe, properties: fa, headers: fa },
                    [nt]: $r,
                  },
                ],
                [nt]: Xc,
              },
            ],
            [nt]: Xc,
          },
          { error: "Invalid Configuration: Missing Region", [nt]: p_ },
        ],
      }),
      (LPe = M6t);
  });
var qPe,
  m_,
  q6t,
  jPe,
  FPe = w(() => {
    c();
    (qPe = A(Hy())), (m_ = A(By()));
    MPe();
    (q6t = new m_.EndpointCache({
      size: 50,
      params: [
        "Endpoint",
        "Region",
        "UseDualStack",
        "UseFIPS",
        "UseGlobalEndpoint",
      ],
    })),
      (jPe = (e, t = {}) =>
        q6t.get(e, () =>
          (0, m_.resolveEndpoint)(LPe, { endpointParams: e, logger: t.logger }),
        ));
    m_.customEndpointFunctions.aws = qPe.awsEndpointFunctions;
  });
var BPe,
  UPe,
  bM,
  SM,
  HPe,
  GPe = w(() => {
    c();
    Jn();
    Gi();
    (BPe = A(vt())), (UPe = A(fh())), (bM = A(Bc())), (SM = A(Fe()));
    m8();
    FPe();
    HPe = (e) => ({
      apiVersion: "2011-06-15",
      base64Decoder: e?.base64Decoder ?? bM.fromBase64,
      base64Encoder: e?.base64Encoder ?? bM.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? jPe,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? fPe,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new da(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new fl(),
        },
      ],
      logger: e?.logger ?? new BPe.NoOpLogger(),
      serviceId: e?.serviceId ?? "STS",
      urlParser: e?.urlParser ?? UPe.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? SM.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? SM.toUtf8,
    });
  });
var CM,
  Lf,
  VPe,
  wM,
  Df,
  OM,
  $Pe,
  zPe,
  KPe,
  WPe,
  QPe,
  YPe,
  XPe = w(() => {
    c();
    e8();
    Jn();
    (CM = A(tw())), (Lf = A(Kc()));
    Gi();
    (VPe = A(rw())),
      (wM = A(vl())),
      (Df = A(ro())),
      (OM = A(ih())),
      ($Pe = A(yl())),
      (zPe = A(e_()));
    GPe();
    (KPe = A(vt())),
      (WPe = A(ow())),
      (QPe = A(vt())),
      (YPe = (e) => {
        (0, QPe.emitWarningIfUnsupportedVersion)(process.version);
        let t = (0, WPe.resolveDefaultsModeConfig)(e),
          r = () => t().then(KPe.loadConfigsForDefaultMode),
          n = HPe(e);
        Gy(process.version);
        let i = { profile: e?.profile };
        return {
          ...n,
          ...e,
          runtime: "node",
          defaultsMode: t,
          authSchemePreference:
            e?.authSchemePreference ?? (0, Df.loadConfig)(kC, i),
          bodyLengthChecker: e?.bodyLengthChecker ?? $Pe.calculateBodyLength,
          defaultUserAgentProvider:
            e?.defaultUserAgentProvider ??
            (0, CM.createDefaultUserAgentProvider)({
              serviceId: n.serviceId,
              clientVersion: tM.version,
            }),
          httpAuthSchemes: e?.httpAuthSchemes ?? [
            {
              schemeId: "aws.auth#sigv4",
              identityProvider: (o) =>
                o.getIdentityProvider("aws.auth#sigv4") ||
                (async (a) =>
                  await e.credentialDefaultProvider(a?.__config || {})()),
              signer: new da(),
            },
            {
              schemeId: "smithy.api#noAuth",
              identityProvider: (o) =>
                o.getIdentityProvider("smithy.api#noAuth") ||
                (async () => ({})),
              signer: new fl(),
            },
          ],
          maxAttempts:
            e?.maxAttempts ??
            (0, Df.loadConfig)(wM.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, e),
          region:
            e?.region ??
            (0, Df.loadConfig)(Lf.NODE_REGION_CONFIG_OPTIONS, {
              ...Lf.NODE_REGION_CONFIG_FILE_OPTIONS,
              ...i,
            }),
          requestHandler: OM.NodeHttpHandler.create(e?.requestHandler ?? r),
          retryMode:
            e?.retryMode ??
            (0, Df.loadConfig)(
              {
                ...wM.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () =>
                  (await r()).retryMode || zPe.DEFAULT_RETRY_MODE,
              },
              e,
            ),
          sha256: e?.sha256 ?? VPe.Hash.bind(null, "sha256"),
          streamCollector: e?.streamCollector ?? OM.streamCollector,
          useDualstackEndpoint:
            e?.useDualstackEndpoint ??
            (0, Df.loadConfig)(
              Lf.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS,
              i,
            ),
          useFipsEndpoint:
            e?.useFipsEndpoint ??
            (0, Df.loadConfig)(Lf.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, i),
          userAgentAppId:
            e?.userAgentAppId ??
            (0, Df.loadConfig)(CM.NODE_APP_ID_CONFIG_OPTIONS, i),
        };
      });
  });
var JPe,
  ZPe,
  eRe = w(() => {
    c();
    (JPe = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        n = e.credentials;
      return {
        setHttpAuthScheme(i) {
          let o = t.findIndex((a) => a.schemeId === i.schemeId);
          o === -1 ? t.push(i) : t.splice(o, 1, i);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(i) {
          r = i;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(i) {
          n = i;
        },
        credentials() {
          return n;
        },
      };
    }),
      (ZPe = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var TM,
  AM,
  PM,
  tRe,
  rRe = w(() => {
    c();
    (TM = A(aw())), (AM = A(Jr())), (PM = A(vt()));
    eRe();
    tRe = (e, t) => {
      let r = Object.assign(
        (0, TM.getAwsRegionExtensionConfiguration)(e),
        (0, PM.getDefaultExtensionConfiguration)(e),
        (0, AM.getHttpHandlerExtensionConfiguration)(e),
        JPe(e),
      );
      return (
        t.forEach((n) => n.configure(r)),
        Object.assign(
          e,
          (0, TM.resolveAwsRegionExtensionConfiguration)(r),
          (0, PM.resolveDefaultRuntimeConfig)(r),
          (0, AM.resolveHttpHandlerRuntimeConfig)(r),
          ZPe(r),
        )
      );
    };
  });
var RM,
  nRe,
  iRe,
  IM,
  oRe,
  aRe,
  sRe,
  xM,
  v8,
  Yc,
  Pw = w(() => {
    c();
    (RM = A(SC())),
      (nRe = A(CC())),
      (iRe = A(wC())),
      (IM = A(Yy())),
      (oRe = A(Kc()));
    Gi();
    (aRe = A(VC())), (sRe = A(gl())), (xM = A(vl())), (v8 = A(vt()));
    m8();
    EM();
    XPe();
    rRe();
    Yc = class extends v8.Client {
      config;
      constructor(...[t]) {
        let r = YPe(t || {});
        super(r), (this.initConfig = r);
        let n = mPe(r),
          i = (0, IM.resolveUserAgentConfig)(n),
          o = (0, xM.resolveRetryConfig)(i),
          a = (0, oRe.resolveRegionConfig)(o),
          s = (0, RM.resolveHostHeaderConfig)(a),
          u = (0, sRe.resolveEndpointConfig)(s),
          l = pPe(u),
          d = tRe(l, t?.extensions || []);
        (this.config = d),
          this.middlewareStack.use((0, IM.getUserAgentPlugin)(this.config)),
          this.middlewareStack.use((0, xM.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, aRe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, RM.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, nRe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, iRe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use(
            TC(this.config, {
              httpAuthSchemeParametersProvider: dPe,
              identityProviderConfigProvider: async (f) =>
                new oh({ "aws.auth#sigv4": f.credentials }),
            }),
          ),
          this.middlewareStack.use(AC(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var cRe,
  ko,
  NM = w(() => {
    c();
    (cRe = A(vt())),
      (ko = class e extends cRe.ServiceException {
        constructor(t) {
          super(t), Object.setPrototypeOf(this, e.prototype);
        }
      });
  });
var y8,
  _8,
  E8,
  Rw,
  Iw,
  xw,
  Nw,
  kw,
  Dw,
  b8,
  S8,
  Lw,
  Mw = w(() => {
    c();
    y8 = A(vt());
    NM();
    (_8 = (e) => ({
      ...e,
      ...(e.SecretAccessKey && { SecretAccessKey: y8.SENSITIVE_STRING }),
    })),
      (E8 = (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: _8(e.Credentials) }),
      })),
      (Rw = class e extends ko {
        name = "ExpiredTokenException";
        $fault = "client";
        constructor(t) {
          super({ name: "ExpiredTokenException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (Iw = class e extends ko {
        name = "MalformedPolicyDocumentException";
        $fault = "client";
        constructor(t) {
          super({
            name: "MalformedPolicyDocumentException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (xw = class e extends ko {
        name = "PackedPolicyTooLargeException";
        $fault = "client";
        constructor(t) {
          super({
            name: "PackedPolicyTooLargeException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (Nw = class e extends ko {
        name = "RegionDisabledException";
        $fault = "client";
        constructor(t) {
          super({ name: "RegionDisabledException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (kw = class e extends ko {
        name = "IDPRejectedClaimException";
        $fault = "client";
        constructor(t) {
          super({ name: "IDPRejectedClaimException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (Dw = class e extends ko {
        name = "InvalidIdentityTokenException";
        $fault = "client";
        constructor(t) {
          super({
            name: "InvalidIdentityTokenException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (b8 = (e) => ({
        ...e,
        ...(e.WebIdentityToken && { WebIdentityToken: y8.SENSITIVE_STRING }),
      })),
      (S8 = (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: _8(e.Credentials) }),
      })),
      (Lw = class e extends ko {
        name = "IDPCommunicationErrorException";
        $fault = "client";
        constructor(t) {
          super({
            name: "IDPCommunicationErrorException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      });
  });
var uRe,
  mt,
  lRe,
  dRe,
  fRe,
  pRe,
  mRe,
  j6t,
  F6t,
  B6t,
  U6t,
  H6t,
  G6t,
  V6t,
  $6t,
  z6t,
  hRe,
  K6t,
  W6t,
  Q6t,
  Y6t,
  X6t,
  J6t,
  gRe,
  Z6t,
  e8t,
  vRe,
  t8t,
  r8t,
  n8t,
  i8t,
  o8t,
  a8t,
  s8t,
  Cl,
  c8t,
  yRe,
  _Re,
  ERe,
  bRe,
  C8,
  u8t,
  w8,
  h_,
  l8t,
  O8,
  T8,
  g_,
  A8,
  v_,
  P8,
  R8,
  I8,
  y_,
  __,
  x8,
  N8,
  k8,
  E_,
  D8,
  b_,
  S_,
  L8,
  M8,
  Sl,
  q8,
  j8,
  F8,
  B8,
  U8,
  SRe,
  H8,
  G8,
  V8,
  gn,
  CRe,
  d8t,
  $8 = w(() => {
    c();
    Jn();
    (uRe = A(Jr())), (mt = A(vt()));
    Mw();
    NM();
    (lRe = async (e, t) => {
      let r = _Re,
        n;
      return (
        (n = CRe({ ...$6t(e, t), [bRe]: u8t, [SRe]: ERe })),
        yRe(t, r, "/", void 0, n)
      );
    }),
      (dRe = async (e, t) => {
        let r = _Re,
          n;
        return (
          (n = CRe({ ...z6t(e, t), [bRe]: l8t, [SRe]: ERe })),
          yRe(t, r, "/", void 0, n)
        );
      }),
      (fRe = async (e, t) => {
        if (e.statusCode >= 300) return mRe(e, t);
        let r = await HC(e.body, t),
          n = {};
        return (n = Z6t(r.AssumeRoleResult, t)), { $metadata: Cl(e), ...n };
      }),
      (pRe = async (e, t) => {
        if (e.statusCode >= 300) return mRe(e, t);
        let r = await HC(e.body, t),
          n = {};
        return (
          (n = e8t(r.AssumeRoleWithWebIdentityResult, t)),
          { $metadata: Cl(e), ...n }
        );
      }),
      (mRe = async (e, t) => {
        let r = { ...e, body: await r6(e.body, t) },
          n = d8t(e, r.body);
        switch (n) {
          case "ExpiredTokenException":
          case "com.amazonaws.sts#ExpiredTokenException":
            throw await j6t(r, t);
          case "MalformedPolicyDocument":
          case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await H6t(r, t);
          case "PackedPolicyTooLarge":
          case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await G6t(r, t);
          case "RegionDisabledException":
          case "com.amazonaws.sts#RegionDisabledException":
            throw await V6t(r, t);
          case "IDPCommunicationError":
          case "com.amazonaws.sts#IDPCommunicationErrorException":
            throw await F6t(r, t);
          case "IDPRejectedClaim":
          case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await B6t(r, t);
          case "InvalidIdentityToken":
          case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await U6t(r, t);
          default:
            let i = r.body;
            return c8t({ output: e, parsedBody: i.Error, errorCode: n });
        }
      }),
      (j6t = async (e, t) => {
        let r = e.body,
          n = t8t(r.Error, t),
          i = new Rw({ $metadata: Cl(e), ...n });
        return (0, mt.decorateServiceException)(i, r);
      }),
      (F6t = async (e, t) => {
        let r = e.body,
          n = r8t(r.Error, t),
          i = new Lw({ $metadata: Cl(e), ...n });
        return (0, mt.decorateServiceException)(i, r);
      }),
      (B6t = async (e, t) => {
        let r = e.body,
          n = n8t(r.Error, t),
          i = new kw({ $metadata: Cl(e), ...n });
        return (0, mt.decorateServiceException)(i, r);
      }),
      (U6t = async (e, t) => {
        let r = e.body,
          n = i8t(r.Error, t),
          i = new Dw({ $metadata: Cl(e), ...n });
        return (0, mt.decorateServiceException)(i, r);
      }),
      (H6t = async (e, t) => {
        let r = e.body,
          n = o8t(r.Error, t),
          i = new Iw({ $metadata: Cl(e), ...n });
        return (0, mt.decorateServiceException)(i, r);
      }),
      (G6t = async (e, t) => {
        let r = e.body,
          n = a8t(r.Error, t),
          i = new xw({ $metadata: Cl(e), ...n });
        return (0, mt.decorateServiceException)(i, r);
      }),
      (V6t = async (e, t) => {
        let r = e.body,
          n = s8t(r.Error, t),
          i = new Nw({ $metadata: Cl(e), ...n });
        return (0, mt.decorateServiceException)(i, r);
      }),
      ($6t = (e, t) => {
        let r = {};
        if (
          (e[b_] != null && (r[b_] = e[b_]),
          e[S_] != null && (r[S_] = e[S_]),
          e[__] != null)
        ) {
          let n = hRe(e[__], t);
          e[__]?.length === 0 && (r.PolicyArns = []),
            Object.entries(n).forEach(([i, o]) => {
              let a = `PolicyArns.${i}`;
              r[a] = o;
            });
        }
        if (
          (e[y_] != null && (r[y_] = e[y_]),
          e[v_] != null && (r[v_] = e[v_]),
          e[F8] != null)
        ) {
          let n = J6t(e[F8], t);
          e[F8]?.length === 0 && (r.Tags = []),
            Object.entries(n).forEach(([i, o]) => {
              let a = `Tags.${i}`;
              r[a] = o;
            });
        }
        if (e[U8] != null) {
          let n = X6t(e[U8], t);
          e[U8]?.length === 0 && (r.TransitiveTagKeys = []),
            Object.entries(n).forEach(([i, o]) => {
              let a = `TransitiveTagKeys.${i}`;
              r[a] = o;
            });
        }
        if (
          (e[R8] != null && (r[R8] = e[R8]),
          e[q8] != null && (r[q8] = e[q8]),
          e[B8] != null && (r[B8] = e[B8]),
          e[Sl] != null && (r[Sl] = e[Sl]),
          e[N8] != null)
        ) {
          let n = Q6t(e[N8], t);
          e[N8]?.length === 0 && (r.ProvidedContexts = []),
            Object.entries(n).forEach(([i, o]) => {
              let a = `ProvidedContexts.${i}`;
              r[a] = o;
            });
        }
        return r;
      }),
      (z6t = (e, t) => {
        let r = {};
        if (
          (e[b_] != null && (r[b_] = e[b_]),
          e[S_] != null && (r[S_] = e[S_]),
          e[G8] != null && (r[G8] = e[G8]),
          e[k8] != null && (r[k8] = e[k8]),
          e[__] != null)
        ) {
          let n = hRe(e[__], t);
          e[__]?.length === 0 && (r.PolicyArns = []),
            Object.entries(n).forEach(([i, o]) => {
              let a = `PolicyArns.${i}`;
              r[a] = o;
            });
        }
        return (
          e[y_] != null && (r[y_] = e[y_]), e[v_] != null && (r[v_] = e[v_]), r
        );
      }),
      (hRe = (e, t) => {
        let r = {},
          n = 1;
        for (let i of e) {
          if (i === null) continue;
          let o = K6t(i, t);
          Object.entries(o).forEach(([a, s]) => {
            r[`member.${n}.${a}`] = s;
          }),
            n++;
        }
        return r;
      }),
      (K6t = (e, t) => {
        let r = {};
        return e[V8] != null && (r[V8] = e[V8]), r;
      }),
      (W6t = (e, t) => {
        let r = {};
        return (
          e[x8] != null && (r[x8] = e[x8]), e[A8] != null && (r[A8] = e[A8]), r
        );
      }),
      (Q6t = (e, t) => {
        let r = {},
          n = 1;
        for (let i of e) {
          if (i === null) continue;
          let o = W6t(i, t);
          Object.entries(o).forEach(([a, s]) => {
            r[`member.${n}.${a}`] = s;
          }),
            n++;
        }
        return r;
      }),
      (Y6t = (e, t) => {
        let r = {};
        return (
          e[I8] != null && (r[I8] = e[I8]), e[H8] != null && (r[H8] = e[H8]), r
        );
      }),
      (X6t = (e, t) => {
        let r = {},
          n = 1;
        for (let i of e) i !== null && ((r[`member.${n}`] = i), n++);
        return r;
      }),
      (J6t = (e, t) => {
        let r = {},
          n = 1;
        for (let i of e) {
          if (i === null) continue;
          let o = Y6t(i, t);
          Object.entries(o).forEach(([a, s]) => {
            r[`member.${n}.${a}`] = s;
          }),
            n++;
        }
        return r;
      }),
      (gRe = (e, t) => {
        let r = {};
        return (
          e[w8] != null && (r[w8] = (0, mt.expectString)(e[w8])),
          e[O8] != null && (r[O8] = (0, mt.expectString)(e[O8])),
          r
        );
      }),
      (Z6t = (e, t) => {
        let r = {};
        return (
          e[g_] != null && (r[g_] = vRe(e[g_], t)),
          e[h_] != null && (r[h_] = gRe(e[h_], t)),
          e[E_] != null && (r[E_] = (0, mt.strictParseInt32)(e[E_])),
          e[Sl] != null && (r[Sl] = (0, mt.expectString)(e[Sl])),
          r
        );
      }),
      (e8t = (e, t) => {
        let r = {};
        return (
          e[g_] != null && (r[g_] = vRe(e[g_], t)),
          e[M8] != null && (r[M8] = (0, mt.expectString)(e[M8])),
          e[h_] != null && (r[h_] = gRe(e[h_], t)),
          e[E_] != null && (r[E_] = (0, mt.strictParseInt32)(e[E_])),
          e[D8] != null && (r[D8] = (0, mt.expectString)(e[D8])),
          e[T8] != null && (r[T8] = (0, mt.expectString)(e[T8])),
          e[Sl] != null && (r[Sl] = (0, mt.expectString)(e[Sl])),
          r
        );
      }),
      (vRe = (e, t) => {
        let r = {};
        return (
          e[C8] != null && (r[C8] = (0, mt.expectString)(e[C8])),
          e[L8] != null && (r[L8] = (0, mt.expectString)(e[L8])),
          e[j8] != null && (r[j8] = (0, mt.expectString)(e[j8])),
          e[P8] != null &&
            (r[P8] = (0, mt.expectNonNull)(
              (0, mt.parseRfc3339DateTimeWithOffset)(e[P8]),
            )),
          r
        );
      }),
      (t8t = (e, t) => {
        let r = {};
        return e[gn] != null && (r[gn] = (0, mt.expectString)(e[gn])), r;
      }),
      (r8t = (e, t) => {
        let r = {};
        return e[gn] != null && (r[gn] = (0, mt.expectString)(e[gn])), r;
      }),
      (n8t = (e, t) => {
        let r = {};
        return e[gn] != null && (r[gn] = (0, mt.expectString)(e[gn])), r;
      }),
      (i8t = (e, t) => {
        let r = {};
        return e[gn] != null && (r[gn] = (0, mt.expectString)(e[gn])), r;
      }),
      (o8t = (e, t) => {
        let r = {};
        return e[gn] != null && (r[gn] = (0, mt.expectString)(e[gn])), r;
      }),
      (a8t = (e, t) => {
        let r = {};
        return e[gn] != null && (r[gn] = (0, mt.expectString)(e[gn])), r;
      }),
      (s8t = (e, t) => {
        let r = {};
        return e[gn] != null && (r[gn] = (0, mt.expectString)(e[gn])), r;
      }),
      (Cl = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      })),
      (c8t = (0, mt.withBaseException)(ko)),
      (yRe = async (e, t, r, n, i) => {
        let {
            hostname: o,
            protocol: a = "https",
            port: s,
            path: u,
          } = await e.endpoint(),
          l = {
            protocol: a,
            hostname: o,
            port: s,
            method: "POST",
            path: u.endsWith("/") ? u.slice(0, -1) + r : u + r,
            headers: t,
          };
        return (
          n !== void 0 && (l.hostname = n),
          i !== void 0 && (l.body = i),
          new uRe.HttpRequest(l)
        );
      }),
      (_Re = { "content-type": "application/x-www-form-urlencoded" }),
      (ERe = "2011-06-15"),
      (bRe = "Action"),
      (C8 = "AccessKeyId"),
      (u8t = "AssumeRole"),
      (w8 = "AssumedRoleId"),
      (h_ = "AssumedRoleUser"),
      (l8t = "AssumeRoleWithWebIdentity"),
      (O8 = "Arn"),
      (T8 = "Audience"),
      (g_ = "Credentials"),
      (A8 = "ContextAssertion"),
      (v_ = "DurationSeconds"),
      (P8 = "Expiration"),
      (R8 = "ExternalId"),
      (I8 = "Key"),
      (y_ = "Policy"),
      (__ = "PolicyArns"),
      (x8 = "ProviderArn"),
      (N8 = "ProvidedContexts"),
      (k8 = "ProviderId"),
      (E_ = "PackedPolicySize"),
      (D8 = "Provider"),
      (b_ = "RoleArn"),
      (S_ = "RoleSessionName"),
      (L8 = "SecretAccessKey"),
      (M8 = "SubjectFromWebIdentityToken"),
      (Sl = "SourceIdentity"),
      (q8 = "SerialNumber"),
      (j8 = "SessionToken"),
      (F8 = "Tags"),
      (B8 = "TokenCode"),
      (U8 = "TransitiveTagKeys"),
      (SRe = "Version"),
      (H8 = "Value"),
      (G8 = "WebIdentityToken"),
      (V8 = "arn"),
      (gn = "message"),
      (CRe = (e) =>
        Object.entries(e)
          .map(
            ([t, r]) =>
              (0, mt.extendedEncodeURIComponent)(t) +
              "=" +
              (0, mt.extendedEncodeURIComponent)(r),
          )
          .join("&")),
      (d8t = (e, t) => {
        if (t.Error?.Code !== void 0) return t.Error.Code;
        if (e.statusCode == 404) return "NotFound";
      });
  });
var wRe,
  ORe,
  TRe,
  vh,
  kM = w(() => {
    c();
    (wRe = A(gl())), (ORe = A(pf())), (TRe = A(vt()));
    EM();
    Mw();
    $8();
    vh = class extends (
      TRe.Command.classBuilder()
        .ep(_M)
        .m(function (t, r, n, i) {
          return [
            (0, ORe.getSerdePlugin)(n, this.serialize, this.deserialize),
            (0, wRe.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AWSSecurityTokenServiceV20110615", "AssumeRole", {})
        .n("STSClient", "AssumeRoleCommand")
        .f(void 0, E8)
        .ser(lRe)
        .de(fRe)
        .build()
    ) {};
  });
var ARe,
  PRe,
  RRe,
  yh,
  DM = w(() => {
    c();
    (ARe = A(gl())), (PRe = A(pf())), (RRe = A(vt()));
    EM();
    Mw();
    $8();
    yh = class extends (
      RRe.Command.classBuilder()
        .ep(_M)
        .m(function (t, r, n, i) {
          return [
            (0, PRe.getSerdePlugin)(n, this.serialize, this.deserialize),
            (0, ARe.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {})
        .n("STSClient", "AssumeRoleWithWebIdentityCommand")
        .f(b8, S8)
        .ser(dRe)
        .de(pRe)
        .build()
    ) {};
  });
var IRe,
  f8t,
  LM,
  xRe = w(() => {
    c();
    IRe = A(vt());
    kM();
    DM();
    Pw();
    (f8t = { AssumeRoleCommand: vh, AssumeRoleWithWebIdentityCommand: yh }),
      (LM = class extends Yc {});
    (0, IRe.createAggregatedClient)(f8t, LM);
  });
var NRe = w(() => {
  c();
  kM();
  DM();
});
var kRe = w(() => {
  c();
  Mw();
});
var DRe,
  LRe,
  MRe,
  qRe,
  jRe,
  FRe,
  BRe = w(() => {
    c();
    Ks();
    kM();
    DM();
    (DRe = "us-east-1"),
      (LRe = (e) => {
        if (typeof e?.Arn == "string") {
          let t = e.Arn.split(":");
          if (t.length > 4 && t[4] !== "") return t[4];
        }
      }),
      (MRe = async (e, t, r) => {
        let n = typeof e == "function" ? await e() : e,
          i = typeof t == "function" ? await t() : t;
        return (
          r?.debug?.(
            "@aws-sdk/client-sts::resolveRegion",
            "accepting first of:",
            `${n} (provider)`,
            `${i} (parent client)`,
            `${DRe} (STS default)`,
          ),
          n ?? i ?? DRe
        );
      }),
      (qRe = (e, t) => {
        let r, n;
        return async (i, o) => {
          if (((n = i), !r)) {
            let {
                logger: d = e?.parentClientConfig?.logger,
                region: f,
                requestHandler: m = e?.parentClientConfig?.requestHandler,
                credentialProviderLogger: h,
              } = e,
              y = await MRe(f, e?.parentClientConfig?.region, h),
              _ = !FRe(m);
            r = new t({
              profile: e?.parentClientConfig?.profile,
              credentialDefaultProvider: () => async () => n,
              region: y,
              requestHandler: _ ? m : void 0,
              logger: d,
            });
          }
          let { Credentials: a, AssumedRoleUser: s } = await r.send(new vh(o));
          if (!a || !a.AccessKeyId || !a.SecretAccessKey)
            throw new Error(
              `Invalid response from STS.assumeRole call with role ${o.RoleArn}`,
            );
          let u = LRe(s),
            l = {
              accessKeyId: a.AccessKeyId,
              secretAccessKey: a.SecretAccessKey,
              sessionToken: a.SessionToken,
              expiration: a.Expiration,
              ...(a.CredentialScope && { credentialScope: a.CredentialScope }),
              ...(u && { accountId: u }),
            };
          return _f(l, "CREDENTIALS_STS_ASSUME_ROLE", "i"), l;
        };
      }),
      (jRe = (e, t) => {
        let r;
        return async (n) => {
          if (!r) {
            let {
                logger: u = e?.parentClientConfig?.logger,
                region: l,
                requestHandler: d = e?.parentClientConfig?.requestHandler,
                credentialProviderLogger: f,
              } = e,
              m = await MRe(l, e?.parentClientConfig?.region, f),
              h = !FRe(d);
            r = new t({
              profile: e?.parentClientConfig?.profile,
              region: m,
              requestHandler: h ? d : void 0,
              logger: u,
            });
          }
          let { Credentials: i, AssumedRoleUser: o } = await r.send(new yh(n));
          if (!i || !i.AccessKeyId || !i.SecretAccessKey)
            throw new Error(
              `Invalid response from STS.assumeRoleWithWebIdentity call with role ${n.RoleArn}`,
            );
          let a = LRe(o),
            s = {
              accessKeyId: i.AccessKeyId,
              secretAccessKey: i.SecretAccessKey,
              sessionToken: i.SessionToken,
              expiration: i.Expiration,
              ...(i.CredentialScope && { credentialScope: i.CredentialScope }),
              ...(a && { accountId: a }),
            };
          return (
            a && _f(s, "RESOLVED_ACCOUNT_ID", "T"),
            _f(s, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k"),
            s
          );
        };
      }),
      (FRe = (e) => e?.metadata?.handlerProtocol === "h2");
  });
var URe,
  HRe,
  GRe,
  p8t,
  VRe = w(() => {
    c();
    BRe();
    Pw();
    (URe = (e, t) =>
      t
        ? class extends e {
            constructor(n) {
              super(n);
              for (let i of t) this.middlewareStack.use(i);
            }
          }
        : e),
      (HRe = (e = {}, t) => qRe(e, URe(Yc, t))),
      (GRe = (e = {}, t) => jRe(e, URe(Yc, t))),
      (p8t = (e) => (t) =>
        e({ roleAssumer: HRe(t), roleAssumerWithWebIdentity: GRe(t), ...t }));
  });
var z8 = {};
bn(z8, {
  AssumeRoleCommand: () => vh,
  AssumeRoleResponseFilterSensitiveLog: () => E8,
  AssumeRoleWithWebIdentityCommand: () => yh,
  AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => b8,
  AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => S8,
  CredentialsFilterSensitiveLog: () => _8,
  ExpiredTokenException: () => Rw,
  IDPCommunicationErrorException: () => Lw,
  IDPRejectedClaimException: () => kw,
  InvalidIdentityTokenException: () => Dw,
  MalformedPolicyDocumentException: () => Iw,
  PackedPolicyTooLargeException: () => xw,
  RegionDisabledException: () => Nw,
  STS: () => LM,
  STSClient: () => Yc,
  STSServiceException: () => ko,
  __Client: () => v8.Client,
  decorateDefaultCredentialProvider: () => p8t,
  getDefaultRoleAssumer: () => HRe,
  getDefaultRoleAssumerWithWebIdentity: () => GRe,
});
var K8 = w(() => {
  c();
  Pw();
  xRe();
  NRe();
  kRe();
  VRe();
  NM();
});
var Y8 = g((vRn, KRe) => {
  "use strict";
  c();
  var MM = Object.defineProperty,
    m8t = Object.getOwnPropertyDescriptor,
    h8t = Object.getOwnPropertyNames,
    g8t = Object.prototype.hasOwnProperty,
    Q8 = (e, t) => MM(e, "name", { value: t, configurable: !0 }),
    v8t = (e, t) => {
      for (var r in t) MM(e, r, { get: t[r], enumerable: !0 });
    },
    y8t = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of h8t(t))
          !g8t.call(e, i) &&
            i !== r &&
            MM(e, i, {
              get: () => t[i],
              enumerable: !(n = m8t(t, i)) || n.enumerable,
            });
      return e;
    },
    _8t = (e) => y8t(MM({}, "__esModule", { value: !0 }), e),
    zRe = {};
  v8t(zRe, { fromProcess: () => O8t });
  KRe.exports = _8t(zRe);
  var $Re = No(),
    W8 = xo(),
    E8t = G("child_process"),
    b8t = G("util"),
    S8t = (Ks(), ue(Ef)),
    C8t = Q8((e, t, r) => {
      if (t.Version !== 1)
        throw Error(
          `Profile ${e} credential_process did not return Version 1.`,
        );
      if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0)
        throw Error(
          `Profile ${e} credential_process returned invalid credentials.`,
        );
      if (t.Expiration) {
        let o = new Date();
        if (new Date(t.Expiration) < o)
          throw Error(
            `Profile ${e} credential_process returned expired credentials.`,
          );
      }
      let n = t.AccountId;
      !n && r?.[e]?.aws_account_id && (n = r[e].aws_account_id);
      let i = {
        accessKeyId: t.AccessKeyId,
        secretAccessKey: t.SecretAccessKey,
        ...(t.SessionToken && { sessionToken: t.SessionToken }),
        ...(t.Expiration && { expiration: new Date(t.Expiration) }),
        ...(t.CredentialScope && { credentialScope: t.CredentialScope }),
        ...(n && { accountId: n }),
      };
      return (0, S8t.setCredentialFeature)(i, "CREDENTIALS_PROCESS", "w"), i;
    }, "getValidatedProcessCredentials"),
    w8t = Q8(async (e, t, r) => {
      let n = t[e];
      if (t[e]) {
        let i = n.credential_process;
        if (i !== void 0) {
          let o = (0, b8t.promisify)(E8t.exec);
          try {
            let { stdout: a } = await o(i),
              s;
            try {
              s = JSON.parse(a.trim());
            } catch {
              throw Error(
                `Profile ${e} credential_process returned invalid JSON.`,
              );
            }
            return C8t(e, s, t);
          } catch (a) {
            throw new W8.CredentialsProviderError(a.message, { logger: r });
          }
        } else
          throw new W8.CredentialsProviderError(
            `Profile ${e} did not contain credential_process.`,
            { logger: r },
          );
      } else
        throw new W8.CredentialsProviderError(
          `Profile ${e} could not be found in shared credentials file.`,
          { logger: r },
        );
    }, "resolveProcessCredentials"),
    O8t = Q8(
      (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          e.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
          let r = await (0, $Re.parseKnownFiles)(e);
          return w8t(
            (0, $Re.getProfileName)({ profile: e.profile ?? t?.profile }),
            r,
            e.logger,
          );
        },
      "fromProcess",
    );
});
var X8 = g((Jc) => {
  "use strict";
  c();
  var T8t =
      (Jc && Jc.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r);
            var i = Object.getOwnPropertyDescriptor(t, r);
            (!i ||
              ("get" in i ? !t.__esModule : i.writable || i.configurable)) &&
              (i = {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              }),
              Object.defineProperty(e, n, i);
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    A8t =
      (Jc && Jc.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: !0, value: t });
          }
        : function (e, t) {
            e.default = t;
          }),
    P8t =
      (Jc && Jc.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null)
          for (var r in e)
            r !== "default" &&
              Object.prototype.hasOwnProperty.call(e, r) &&
              T8t(t, e, r);
        return A8t(t, e), t;
      };
  Object.defineProperty(Jc, "__esModule", { value: !0 });
  Jc.fromWebToken = void 0;
  var R8t = (e) => async (t) => {
    e.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
    let {
        roleArn: r,
        roleSessionName: n,
        webIdentityToken: i,
        providerId: o,
        policyArns: a,
        policy: s,
        durationSeconds: u,
      } = e,
      { roleAssumerWithWebIdentity: l } = e;
    if (!l) {
      let { getDefaultRoleAssumerWithWebIdentity: d } =
        await Promise.resolve().then(() => P8t((K8(), ue(z8))));
      l = d(
        {
          ...e.clientConfig,
          credentialProviderLogger: e.logger,
          parentClientConfig: {
            ...t?.callerClientConfig,
            ...e.parentClientConfig,
          },
        },
        e.clientPlugins,
      );
    }
    return l({
      RoleArn: r,
      RoleSessionName: n ?? `aws-sdk-js-session-${Date.now()}`,
      WebIdentityToken: i,
      ProviderId: o,
      PolicyArns: a,
      Policy: s,
      DurationSeconds: u,
    });
  };
  Jc.fromWebToken = R8t;
});
var QRe = g((qM) => {
  "use strict";
  c();
  Object.defineProperty(qM, "__esModule", { value: !0 });
  qM.fromTokenFile = void 0;
  var I8t = (Ks(), ue(Ef)),
    x8t = xo(),
    N8t = G("fs"),
    k8t = X8(),
    WRe = "AWS_WEB_IDENTITY_TOKEN_FILE",
    D8t = "AWS_ROLE_ARN",
    L8t = "AWS_ROLE_SESSION_NAME",
    M8t =
      (e = {}) =>
      async () => {
        e.logger?.debug(
          "@aws-sdk/credential-provider-web-identity - fromTokenFile",
        );
        let t = e?.webIdentityTokenFile ?? process.env[WRe],
          r = e?.roleArn ?? process.env[D8t],
          n = e?.roleSessionName ?? process.env[L8t];
        if (!t || !r)
          throw new x8t.CredentialsProviderError(
            "Web identity configuration not specified",
            { logger: e.logger },
          );
        let i = await (0, k8t.fromWebToken)({
          ...e,
          webIdentityToken: (0, N8t.readFileSync)(t, { encoding: "ascii" }),
          roleArn: r,
          roleSessionName: n,
        })();
        return (
          t === process.env[WRe] &&
            (0, I8t.setCredentialFeature)(
              i,
              "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN",
              "h",
            ),
          i
        );
      };
  qM.fromTokenFile = M8t;
});
var e5 = g((CRn, jM) => {
  "use strict";
  c();
  var YRe = Object.defineProperty,
    q8t = Object.getOwnPropertyDescriptor,
    j8t = Object.getOwnPropertyNames,
    F8t = Object.prototype.hasOwnProperty,
    J8 = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of j8t(t))
          !F8t.call(e, i) &&
            i !== r &&
            YRe(e, i, {
              get: () => t[i],
              enumerable: !(n = q8t(t, i)) || n.enumerable,
            });
      return e;
    },
    XRe = (e, t, r) => (J8(e, t, "default"), r && J8(r, t, "default")),
    B8t = (e) => J8(YRe({}, "__esModule", { value: !0 }), e),
    Z8 = {};
  jM.exports = B8t(Z8);
  XRe(Z8, QRe(), jM.exports);
  XRe(Z8, X8(), jM.exports);
});
var oIe = g((ORn, iIe) => {
  "use strict";
  c();
  var U8t = Object.create,
    jw = Object.defineProperty,
    H8t = Object.getOwnPropertyDescriptor,
    G8t = Object.getOwnPropertyNames,
    V8t = Object.getPrototypeOf,
    $8t = Object.prototype.hasOwnProperty,
    Rn = (e, t) => jw(e, "name", { value: t, configurable: !0 }),
    z8t = (e, t) => {
      for (var r in t) jw(e, r, { get: t[r], enumerable: !0 });
    },
    tIe = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of G8t(t))
          !$8t.call(e, i) &&
            i !== r &&
            jw(e, i, {
              get: () => t[i],
              enumerable: !(n = H8t(t, i)) || n.enumerable,
            });
      return e;
    },
    Mf = (e, t, r) => (
      (r = e != null ? U8t(V8t(e)) : {}),
      tIe(
        t || !e || !e.__esModule
          ? jw(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    K8t = (e) => tIe(jw({}, "__esModule", { value: !0 }), e),
    rIe = {};
  z8t(rIe, { fromIni: () => o5t });
  iIe.exports = K8t(rIe);
  var r5 = No(),
    qf = (Ks(), ue(Ef)),
    qw = xo(),
    W8t = Rn((e, t, r) => {
      let n = {
        EcsContainer: Rn(async (i) => {
          let { fromHttp: o } = await Promise.resolve().then(() => Mf(B6())),
            { fromContainerMetadata: a } = await Promise.resolve().then(() =>
              Mf(ew()),
            );
          return (
            r?.debug(
              "@aws-sdk/credential-provider-ini - credential_source is EcsContainer",
            ),
            async () => (0, qw.chain)(o(i ?? {}), a(i))().then(t5)
          );
        }, "EcsContainer"),
        Ec2InstanceMetadata: Rn(async (i) => {
          r?.debug(
            "@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata",
          );
          let { fromInstanceMetadata: o } = await Promise.resolve().then(() =>
            Mf(ew()),
          );
          return async () => o(i)().then(t5);
        }, "Ec2InstanceMetadata"),
        Environment: Rn(async (i) => {
          r?.debug(
            "@aws-sdk/credential-provider-ini - credential_source is Environment",
          );
          let { fromEnv: o } = await Promise.resolve().then(() => Mf(k6()));
          return async () => o(i)().then(t5);
        }, "Environment"),
      };
      if (e in n) return n[e];
      throw new qw.CredentialsProviderError(
        `Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`,
        { logger: r },
      );
    }, "resolveCredentialSource"),
    t5 = Rn(
      (e) =>
        (0, qf.setCredentialFeature)(
          e,
          "CREDENTIALS_PROFILE_NAMED_PROVIDER",
          "p",
        ),
      "setNamedProvider",
    ),
    Q8t = Rn(
      (e, { profile: t = "default", logger: r } = {}) =>
        !!e &&
        typeof e == "object" &&
        typeof e.role_arn == "string" &&
        ["undefined", "string"].indexOf(typeof e.role_session_name) > -1 &&
        ["undefined", "string"].indexOf(typeof e.external_id) > -1 &&
        ["undefined", "string"].indexOf(typeof e.mfa_serial) > -1 &&
        (Y8t(e, { profile: t, logger: r }) ||
          X8t(e, { profile: t, logger: r })),
      "isAssumeRoleProfile",
    ),
    Y8t = Rn((e, { profile: t, logger: r }) => {
      let n =
        typeof e.source_profile == "string" && typeof e.credential_source > "u";
      return (
        n &&
          r?.debug?.(
            `    ${t} isAssumeRoleWithSourceProfile source_profile=${e.source_profile}`,
          ),
        n
      );
    }, "isAssumeRoleWithSourceProfile"),
    X8t = Rn((e, { profile: t, logger: r }) => {
      let n =
        typeof e.credential_source == "string" && typeof e.source_profile > "u";
      return (
        n &&
          r?.debug?.(
            `    ${t} isCredentialSourceProfile credential_source=${e.credential_source}`,
          ),
        n
      );
    }, "isCredentialSourceProfile"),
    J8t = Rn(async (e, t, r, n = {}) => {
      r.logger?.debug(
        "@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)",
      );
      let i = t[e],
        { source_profile: o, region: a } = i;
      if (!r.roleAssumer) {
        let { getDefaultRoleAssumer: u } = await Promise.resolve().then(() =>
          Mf((K8(), ue(z8))),
        );
        r.roleAssumer = u(
          {
            ...r.clientConfig,
            credentialProviderLogger: r.logger,
            parentClientConfig: {
              ...r?.parentClientConfig,
              region: a ?? r?.parentClientConfig?.region,
            },
          },
          r.clientPlugins,
        );
      }
      if (o && o in n)
        throw new qw.CredentialsProviderError(
          `Detected a cycle attempting to resolve credentials for profile ${(0, r5.getProfileName)(r)}. Profiles visited: ` +
            Object.keys(n).join(", "),
          { logger: r.logger },
        );
      r.logger?.debug(
        `@aws-sdk/credential-provider-ini - finding credential resolver using ${o ? `source_profile=[${o}]` : `profile=[${e}]`}`,
      );
      let s = o
        ? nIe(o, t, r, { ...n, [o]: !0 }, JRe(t[o] ?? {}))
        : (await W8t(i.credential_source, e, r.logger)(r))();
      if (JRe(i))
        return s.then((u) =>
          (0, qf.setCredentialFeature)(
            u,
            "CREDENTIALS_PROFILE_SOURCE_PROFILE",
            "o",
          ),
        );
      {
        let u = {
            RoleArn: i.role_arn,
            RoleSessionName: i.role_session_name || `aws-sdk-js-${Date.now()}`,
            ExternalId: i.external_id,
            DurationSeconds: parseInt(i.duration_seconds || "3600", 10),
          },
          { mfa_serial: l } = i;
        if (l) {
          if (!r.mfaCodeProvider)
            throw new qw.CredentialsProviderError(
              `Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`,
              { logger: r.logger, tryNextLink: !1 },
            );
          (u.SerialNumber = l), (u.TokenCode = await r.mfaCodeProvider(l));
        }
        let d = await s;
        return r
          .roleAssumer(d, u)
          .then((f) =>
            (0, qf.setCredentialFeature)(
              f,
              "CREDENTIALS_PROFILE_SOURCE_PROFILE",
              "o",
            ),
          );
      }
    }, "resolveAssumeRoleCredentials"),
    JRe = Rn(
      (e) => !e.role_arn && !!e.credential_source,
      "isCredentialSourceWithoutRoleArn",
    ),
    Z8t = Rn(
      (e) =>
        !!e && typeof e == "object" && typeof e.credential_process == "string",
      "isProcessProfile",
    ),
    e5t = Rn(
      async (e, t) =>
        Promise.resolve()
          .then(() => Mf(Y8()))
          .then(({ fromProcess: r }) =>
            r({ ...e, profile: t })().then((n) =>
              (0, qf.setCredentialFeature)(
                n,
                "CREDENTIALS_PROFILE_PROCESS",
                "v",
              ),
            ),
          ),
      "resolveProcessCredentials",
    ),
    t5t = Rn(async (e, t, r = {}) => {
      let { fromSSO: n } = await Promise.resolve().then(() => Mf(p8()));
      return n({
        profile: e,
        logger: r.logger,
        parentClientConfig: r.parentClientConfig,
        clientConfig: r.clientConfig,
      })().then((i) =>
        t.sso_session
          ? (0, qf.setCredentialFeature)(i, "CREDENTIALS_PROFILE_SSO", "r")
          : (0, qf.setCredentialFeature)(
              i,
              "CREDENTIALS_PROFILE_SSO_LEGACY",
              "t",
            ),
      );
    }, "resolveSsoCredentials"),
    r5t = Rn(
      (e) =>
        e &&
        (typeof e.sso_start_url == "string" ||
          typeof e.sso_account_id == "string" ||
          typeof e.sso_session == "string" ||
          typeof e.sso_region == "string" ||
          typeof e.sso_role_name == "string"),
      "isSsoProfile",
    ),
    ZRe = Rn(
      (e) =>
        !!e &&
        typeof e == "object" &&
        typeof e.aws_access_key_id == "string" &&
        typeof e.aws_secret_access_key == "string" &&
        ["undefined", "string"].indexOf(typeof e.aws_session_token) > -1 &&
        ["undefined", "string"].indexOf(typeof e.aws_account_id) > -1,
      "isStaticCredsProfile",
    ),
    eIe = Rn(async (e, t) => {
      t?.logger?.debug(
        "@aws-sdk/credential-provider-ini - resolveStaticCredentials",
      );
      let r = {
        accessKeyId: e.aws_access_key_id,
        secretAccessKey: e.aws_secret_access_key,
        sessionToken: e.aws_session_token,
        ...(e.aws_credential_scope && {
          credentialScope: e.aws_credential_scope,
        }),
        ...(e.aws_account_id && { accountId: e.aws_account_id }),
      };
      return (0, qf.setCredentialFeature)(r, "CREDENTIALS_PROFILE", "n");
    }, "resolveStaticCredentials"),
    n5t = Rn(
      (e) =>
        !!e &&
        typeof e == "object" &&
        typeof e.web_identity_token_file == "string" &&
        typeof e.role_arn == "string" &&
        ["undefined", "string"].indexOf(typeof e.role_session_name) > -1,
      "isWebIdentityProfile",
    ),
    i5t = Rn(
      async (e, t) =>
        Promise.resolve()
          .then(() => Mf(e5()))
          .then(({ fromTokenFile: r }) =>
            r({
              webIdentityTokenFile: e.web_identity_token_file,
              roleArn: e.role_arn,
              roleSessionName: e.role_session_name,
              roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity,
              logger: t.logger,
              parentClientConfig: t.parentClientConfig,
            })().then((n) =>
              (0, qf.setCredentialFeature)(
                n,
                "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN",
                "q",
              ),
            ),
          ),
      "resolveWebIdentityCredentials",
    ),
    nIe = Rn(async (e, t, r, n = {}, i = !1) => {
      let o = t[e];
      if (Object.keys(n).length > 0 && ZRe(o)) return eIe(o, r);
      if (i || Q8t(o, { profile: e, logger: r.logger })) return J8t(e, t, r, n);
      if (ZRe(o)) return eIe(o, r);
      if (n5t(o)) return i5t(o, r);
      if (Z8t(o)) return e5t(r, e);
      if (r5t(o)) return await t5t(e, o, r);
      throw new qw.CredentialsProviderError(
        `Could not resolve credentials using profile: [${e}] in configuration/credentials file(s).`,
        { logger: r.logger },
      );
    }, "resolveProfileData"),
    o5t = Rn(
      (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          let r = {
            ...e,
            parentClientConfig: { ...t, ...e.parentClientConfig },
          };
          r.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
          let n = await (0, r5.parseKnownFiles)(r);
          return nIe(
            (0, r5.getProfileName)({ profile: e.profile ?? t?.profile }),
            n,
            r,
          );
        },
      "fromIni",
    );
});
var pIe = g((ARn, fIe) => {
  "use strict";
  c();
  var a5t = Object.create,
    Fw = Object.defineProperty,
    s5t = Object.getOwnPropertyDescriptor,
    c5t = Object.getOwnPropertyNames,
    u5t = Object.getPrototypeOf,
    l5t = Object.prototype.hasOwnProperty,
    FM = (e, t) => Fw(e, "name", { value: t, configurable: !0 }),
    d5t = (e, t) => {
      for (var r in t) Fw(e, r, { get: t[r], enumerable: !0 });
    },
    cIe = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of c5t(t))
          !l5t.call(e, i) &&
            i !== r &&
            Fw(e, i, {
              get: () => t[i],
              enumerable: !(n = s5t(t, i)) || n.enumerable,
            });
      return e;
    },
    C_ = (e, t, r) => (
      (r = e != null ? a5t(u5t(e)) : {}),
      cIe(
        t || !e || !e.__esModule
          ? Fw(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    f5t = (e) => cIe(Fw({}, "__esModule", { value: !0 }), e),
    uIe = {};
  d5t(uIe, {
    credentialsTreatedAsExpired: () => dIe,
    credentialsWillNeedRefresh: () => lIe,
    defaultProvider: () => h5t,
  });
  fIe.exports = f5t(uIe);
  var n5 = k6(),
    p5t = No(),
    _h = xo(),
    aIe = "AWS_EC2_METADATA_DISABLED",
    m5t = FM(async (e) => {
      let {
        ENV_CMDS_FULL_URI: t,
        ENV_CMDS_RELATIVE_URI: r,
        fromContainerMetadata: n,
        fromInstanceMetadata: i,
      } = await Promise.resolve().then(() => C_(ew()));
      if (process.env[r] || process.env[t]) {
        e.logger?.debug(
          "@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata",
        );
        let { fromHttp: o } = await Promise.resolve().then(() => C_(B6()));
        return (0, _h.chain)(o(e), n(e));
      }
      return process.env[aIe] && process.env[aIe] !== "false"
        ? async () => {
            throw new _h.CredentialsProviderError(
              "EC2 Instance Metadata Service access disabled",
              { logger: e.logger },
            );
          }
        : (e.logger?.debug(
            "@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata",
          ),
          i(e));
    }, "remoteProvider"),
    sIe = !1,
    h5t = FM(
      (e = {}) =>
        (0, _h.memoize)(
          (0, _h.chain)(
            async () => {
              if (e.profile ?? process.env[p5t.ENV_PROFILE])
                throw (
                  (process.env[n5.ENV_KEY] &&
                    process.env[n5.ENV_SECRET] &&
                    (sIe ||
                      ((e.logger?.warn &&
                        e.logger?.constructor?.name !== "NoOpLogger"
                        ? e.logger.warn
                        : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`),
                      (sIe = !0))),
                  new _h.CredentialsProviderError(
                    "AWS_PROFILE is set, skipping fromEnv provider.",
                    { logger: e.logger, tryNextLink: !0 },
                  ))
                );
              return (
                e.logger?.debug(
                  "@aws-sdk/credential-provider-node - defaultProvider::fromEnv",
                ),
                (0, n5.fromEnv)(e)()
              );
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromSSO",
              );
              let {
                ssoStartUrl: t,
                ssoAccountId: r,
                ssoRegion: n,
                ssoRoleName: i,
                ssoSession: o,
              } = e;
              if (!t && !r && !n && !i && !o)
                throw new _h.CredentialsProviderError(
                  "Skipping SSO provider in default chain (inputs do not include SSO fields).",
                  { logger: e.logger },
                );
              let { fromSSO: a } = await Promise.resolve().then(() => C_(p8()));
              return a(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromIni",
              );
              let { fromIni: t } = await Promise.resolve().then(() =>
                C_(oIe()),
              );
              return t(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromProcess",
              );
              let { fromProcess: t } = await Promise.resolve().then(() =>
                C_(Y8()),
              );
              return t(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile",
              );
              let { fromTokenFile: t } = await Promise.resolve().then(() =>
                C_(e5()),
              );
              return t(e)();
            },
            async () => (
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::remoteProvider",
              ),
              (await m5t(e))()
            ),
            async () => {
              throw new _h.CredentialsProviderError(
                "Could not load credentials from any providers",
                { tryNextLink: !1, logger: e.logger },
              );
            },
          ),
          dIe,
          lIe,
        ),
      "defaultProvider",
    ),
    lIe = FM((e) => e?.expiration !== void 0, "credentialsWillNeedRefresh"),
    dIe = FM(
      (e) =>
        e?.expiration !== void 0 && e.expiration.getTime() - Date.now() < 3e5,
      "credentialsTreatedAsExpired",
    );
});
var LIe = g((BM) => {
  "use strict";
  c();
  Object.defineProperty(BM, "__esModule", { value: !0 });
  BM.ruleSet = void 0;
  var OIe = "required",
    it = "type",
    Ut = "fn",
    Ht = "argv",
    Ff = "ref",
    mIe = !1,
    i5 = !0,
    jf = "booleanEquals",
    wi = "stringEquals",
    TIe = "sigv4",
    AIe = "sts",
    PIe = "us-east-1",
    zr = "endpoint",
    hIe = "https://sts.{Region}.{PartitionResult#dnsSuffix}",
    Zc = "tree",
    w_ = "error",
    a5 = "getAttr",
    gIe = { [OIe]: !1, [it]: "String" },
    o5 = { [OIe]: !0, default: !1, [it]: "Boolean" },
    RIe = { [Ff]: "Endpoint" },
    vIe = { [Ut]: "isSet", [Ht]: [{ [Ff]: "Region" }] },
    Oi = { [Ff]: "Region" },
    yIe = { [Ut]: "aws.partition", [Ht]: [Oi], assign: "PartitionResult" },
    IIe = { [Ff]: "UseFIPS" },
    xIe = { [Ff]: "UseDualStack" },
    $i = {
      url: "https://sts.amazonaws.com",
      properties: {
        authSchemes: [{ name: TIe, signingName: AIe, signingRegion: PIe }],
      },
      headers: {},
    },
    pa = {},
    _Ie = {
      conditions: [{ [Ut]: wi, [Ht]: [Oi, "aws-global"] }],
      [zr]: $i,
      [it]: zr,
    },
    NIe = { [Ut]: jf, [Ht]: [IIe, !0] },
    kIe = { [Ut]: jf, [Ht]: [xIe, !0] },
    EIe = { [Ut]: a5, [Ht]: [{ [Ff]: "PartitionResult" }, "supportsFIPS"] },
    DIe = { [Ff]: "PartitionResult" },
    bIe = {
      [Ut]: jf,
      [Ht]: [!0, { [Ut]: a5, [Ht]: [DIe, "supportsDualStack"] }],
    },
    SIe = [{ [Ut]: "isSet", [Ht]: [RIe] }],
    CIe = [NIe],
    wIe = [kIe],
    g5t = {
      version: "1.0",
      parameters: {
        Region: gIe,
        UseDualStack: o5,
        UseFIPS: o5,
        Endpoint: gIe,
        UseGlobalEndpoint: o5,
      },
      rules: [
        {
          conditions: [
            { [Ut]: jf, [Ht]: [{ [Ff]: "UseGlobalEndpoint" }, i5] },
            { [Ut]: "not", [Ht]: SIe },
            vIe,
            yIe,
            { [Ut]: jf, [Ht]: [IIe, mIe] },
            { [Ut]: jf, [Ht]: [xIe, mIe] },
          ],
          rules: [
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "ap-northeast-1"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "ap-south-1"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "ap-southeast-1"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "ap-southeast-2"] }],
              endpoint: $i,
              [it]: zr,
            },
            _Ie,
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "ca-central-1"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "eu-central-1"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "eu-north-1"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "eu-west-1"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "eu-west-2"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "eu-west-3"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "sa-east-1"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, PIe] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "us-east-2"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "us-west-1"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              conditions: [{ [Ut]: wi, [Ht]: [Oi, "us-west-2"] }],
              endpoint: $i,
              [it]: zr,
            },
            {
              endpoint: {
                url: hIe,
                properties: {
                  authSchemes: [
                    { name: TIe, signingName: AIe, signingRegion: "{Region}" },
                  ],
                },
                headers: pa,
              },
              [it]: zr,
            },
          ],
          [it]: Zc,
        },
        {
          conditions: SIe,
          rules: [
            {
              conditions: CIe,
              error:
                "Invalid Configuration: FIPS and custom endpoint are not supported",
              [it]: w_,
            },
            {
              conditions: wIe,
              error:
                "Invalid Configuration: Dualstack and custom endpoint are not supported",
              [it]: w_,
            },
            { endpoint: { url: RIe, properties: pa, headers: pa }, [it]: zr },
          ],
          [it]: Zc,
        },
        {
          conditions: [vIe],
          rules: [
            {
              conditions: [yIe],
              rules: [
                {
                  conditions: [NIe, kIe],
                  rules: [
                    {
                      conditions: [{ [Ut]: jf, [Ht]: [i5, EIe] }, bIe],
                      rules: [
                        {
                          endpoint: {
                            url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                            properties: pa,
                            headers: pa,
                          },
                          [it]: zr,
                        },
                      ],
                      [it]: Zc,
                    },
                    {
                      error:
                        "FIPS and DualStack are enabled, but this partition does not support one or both",
                      [it]: w_,
                    },
                  ],
                  [it]: Zc,
                },
                {
                  conditions: CIe,
                  rules: [
                    {
                      conditions: [{ [Ut]: jf, [Ht]: [EIe, i5] }],
                      rules: [
                        {
                          conditions: [
                            {
                              [Ut]: wi,
                              [Ht]: [
                                { [Ut]: a5, [Ht]: [DIe, "name"] },
                                "aws-us-gov",
                              ],
                            },
                          ],
                          endpoint: {
                            url: "https://sts.{Region}.amazonaws.com",
                            properties: pa,
                            headers: pa,
                          },
                          [it]: zr,
                        },
                        {
                          endpoint: {
                            url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                            properties: pa,
                            headers: pa,
                          },
                          [it]: zr,
                        },
                      ],
                      [it]: Zc,
                    },
                    {
                      error:
                        "FIPS is enabled but this partition does not support FIPS",
                      [it]: w_,
                    },
                  ],
                  [it]: Zc,
                },
                {
                  conditions: wIe,
                  rules: [
                    {
                      conditions: [bIe],
                      rules: [
                        {
                          endpoint: {
                            url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                            properties: pa,
                            headers: pa,
                          },
                          [it]: zr,
                        },
                      ],
                      [it]: Zc,
                    },
                    {
                      error:
                        "DualStack is enabled but this partition does not support DualStack",
                      [it]: w_,
                    },
                  ],
                  [it]: Zc,
                },
                _Ie,
                {
                  endpoint: { url: hIe, properties: pa, headers: pa },
                  [it]: zr,
                },
              ],
              [it]: Zc,
            },
          ],
          [it]: Zc,
        },
        { error: "Invalid Configuration: Missing Region", [it]: w_ },
      ],
    };
  BM.ruleSet = g5t;
});
var MIe = g((UM) => {
  "use strict";
  c();
  Object.defineProperty(UM, "__esModule", { value: !0 });
  UM.defaultEndpointResolver = void 0;
  var v5t = Hy(),
    s5 = By(),
    y5t = LIe(),
    _5t = new s5.EndpointCache({
      size: 50,
      params: [
        "Endpoint",
        "Region",
        "UseDualStack",
        "UseFIPS",
        "UseGlobalEndpoint",
      ],
    }),
    E5t = (e, t = {}) =>
      _5t.get(e, () =>
        (0, s5.resolveEndpoint)(y5t.ruleSet, {
          endpointParams: e,
          logger: t.logger,
        }),
      );
  UM.defaultEndpointResolver = E5t;
  s5.customEndpointFunctions.aws = v5t.awsEndpointFunctions;
});
var FIe = g((HM) => {
  "use strict";
  c();
  Object.defineProperty(HM, "__esModule", { value: !0 });
  HM.getRuntimeConfig = void 0;
  var b5t = (Jn(), ue($c)),
    S5t = (Gi(), ue(yf)),
    C5t = vt(),
    w5t = fh(),
    qIe = Bc(),
    jIe = Fe(),
    O5t = N6(),
    T5t = MIe(),
    A5t = (e) => ({
      apiVersion: "2011-06-15",
      base64Decoder: e?.base64Decoder ?? qIe.fromBase64,
      base64Encoder: e?.base64Encoder ?? qIe.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? T5t.defaultEndpointResolver,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider:
        e?.httpAuthSchemeProvider ?? O5t.defaultSTSHttpAuthSchemeProvider,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new b5t.AwsSdkSigV4Signer(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new S5t.NoAuthSigner(),
        },
      ],
      logger: e?.logger ?? new C5t.NoOpLogger(),
      serviceId: e?.serviceId ?? "STS",
      urlParser: e?.urlParser ?? w5t.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? jIe.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? jIe.toUtf8,
    });
  HM.getRuntimeConfig = A5t;
});
var VIe = g((VM) => {
  "use strict";
  c();
  Object.defineProperty(VM, "__esModule", { value: !0 });
  VM.getRuntimeConfig = void 0;
  var P5t = (go(), ue(ho)),
    R5t = P5t.__importDefault(Hwe()),
    c5 = (Jn(), ue($c)),
    BIe = pIe(),
    UIe = tw(),
    GM = Kc(),
    I5t = (Gi(), ue(yf)),
    x5t = rw(),
    HIe = vl(),
    Eh = ro(),
    GIe = ih(),
    N5t = yl(),
    k5t = e_(),
    D5t = FIe(),
    L5t = vt(),
    M5t = ow(),
    q5t = vt(),
    j5t = (e) => {
      (0, q5t.emitWarningIfUnsupportedVersion)(process.version);
      let t = (0, M5t.resolveDefaultsModeConfig)(e),
        r = () => t().then(L5t.loadConfigsForDefaultMode),
        n = (0, D5t.getRuntimeConfig)(e);
      (0, c5.emitWarningIfUnsupportedVersion)(process.version);
      let i = { profile: e?.profile };
      return {
        ...n,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference:
          e?.authSchemePreference ??
          (0, Eh.loadConfig)(c5.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, i),
        bodyLengthChecker: e?.bodyLengthChecker ?? N5t.calculateBodyLength,
        credentialDefaultProvider:
          e?.credentialDefaultProvider ?? BIe.defaultProvider,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          (0, UIe.createDefaultUserAgentProvider)({
            serviceId: n.serviceId,
            clientVersion: R5t.default.version,
          }),
        httpAuthSchemes: e?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (o) =>
              o.getIdentityProvider("aws.auth#sigv4") ||
              (async (a) =>
                await (0, BIe.defaultProvider)(a?.__config || {})()),
            signer: new c5.AwsSdkSigV4Signer(),
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (o) =>
              o.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new I5t.NoAuthSigner(),
          },
        ],
        maxAttempts:
          e?.maxAttempts ??
          (0, Eh.loadConfig)(HIe.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, e),
        region:
          e?.region ??
          (0, Eh.loadConfig)(GM.NODE_REGION_CONFIG_OPTIONS, {
            ...GM.NODE_REGION_CONFIG_FILE_OPTIONS,
            ...i,
          }),
        requestHandler: GIe.NodeHttpHandler.create(e?.requestHandler ?? r),
        retryMode:
          e?.retryMode ??
          (0, Eh.loadConfig)(
            {
              ...HIe.NODE_RETRY_MODE_CONFIG_OPTIONS,
              default: async () =>
                (await r()).retryMode || k5t.DEFAULT_RETRY_MODE,
            },
            e,
          ),
        sha256: e?.sha256 ?? x5t.Hash.bind(null, "sha256"),
        streamCollector: e?.streamCollector ?? GIe.streamCollector,
        useDualstackEndpoint:
          e?.useDualstackEndpoint ??
          (0, Eh.loadConfig)(GM.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, i),
        useFipsEndpoint:
          e?.useFipsEndpoint ??
          (0, Eh.loadConfig)(GM.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, i),
        userAgentAppId:
          e?.userAgentAppId ??
          (0, Eh.loadConfig)(UIe.NODE_APP_ID_CONFIG_OPTIONS, i),
      };
    };
  VM.getRuntimeConfig = j5t;
});
var $Ie = g((O_) => {
  "use strict";
  c();
  Object.defineProperty(O_, "__esModule", { value: !0 });
  O_.resolveHttpAuthRuntimeConfig = O_.getHttpAuthExtensionConfiguration =
    void 0;
  var F5t = (e) => {
    let t = e.httpAuthSchemes,
      r = e.httpAuthSchemeProvider,
      n = e.credentials;
    return {
      setHttpAuthScheme(i) {
        let o = t.findIndex((a) => a.schemeId === i.schemeId);
        o === -1 ? t.push(i) : t.splice(o, 1, i);
      },
      httpAuthSchemes() {
        return t;
      },
      setHttpAuthSchemeProvider(i) {
        r = i;
      },
      httpAuthSchemeProvider() {
        return r;
      },
      setCredentials(i) {
        n = i;
      },
      credentials() {
        return n;
      },
    };
  };
  O_.getHttpAuthExtensionConfiguration = F5t;
  var B5t = (e) => ({
    httpAuthSchemes: e.httpAuthSchemes(),
    httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
    credentials: e.credentials(),
  });
  O_.resolveHttpAuthRuntimeConfig = B5t;
});
var YIe = g(($M) => {
  "use strict";
  c();
  Object.defineProperty($M, "__esModule", { value: !0 });
  $M.resolveRuntimeExtensions = void 0;
  var zIe = aw(),
    KIe = Jr(),
    WIe = vt(),
    QIe = $Ie(),
    U5t = (e, t) => {
      let r = Object.assign(
        (0, zIe.getAwsRegionExtensionConfiguration)(e),
        (0, WIe.getDefaultExtensionConfiguration)(e),
        (0, KIe.getHttpHandlerExtensionConfiguration)(e),
        (0, QIe.getHttpAuthExtensionConfiguration)(e),
      );
      return (
        t.forEach((n) => n.configure(r)),
        Object.assign(
          e,
          (0, zIe.resolveAwsRegionExtensionConfiguration)(r),
          (0, WIe.resolveDefaultRuntimeConfig)(r),
          (0, KIe.resolveHttpHandlerRuntimeConfig)(r),
          (0, QIe.resolveHttpAuthRuntimeConfig)(r),
        )
      );
    };
  $M.resolveRuntimeExtensions = U5t;
});
var ZC = g((T_) => {
  "use strict";
  c();
  Object.defineProperty(T_, "__esModule", { value: !0 });
  T_.STSClient = T_.__Client = void 0;
  var XIe = SC(),
    H5t = CC(),
    G5t = wC(),
    JIe = Yy(),
    V5t = Kc(),
    u5 = (Gi(), ue(yf)),
    $5t = VC(),
    z5t = gl(),
    ZIe = vl(),
    txe = vt();
  Object.defineProperty(T_, "__Client", {
    enumerable: !0,
    get: function () {
      return txe.Client;
    },
  });
  var exe = N6(),
    K5t = Ua(),
    W5t = VIe(),
    Q5t = YIe(),
    l5 = class extends txe.Client {
      config;
      constructor(...[t]) {
        let r = (0, W5t.getRuntimeConfig)(t || {});
        super(r), (this.initConfig = r);
        let n = (0, K5t.resolveClientEndpointParameters)(r),
          i = (0, JIe.resolveUserAgentConfig)(n),
          o = (0, ZIe.resolveRetryConfig)(i),
          a = (0, V5t.resolveRegionConfig)(o),
          s = (0, XIe.resolveHostHeaderConfig)(a),
          u = (0, z5t.resolveEndpointConfig)(s),
          l = (0, exe.resolveHttpAuthSchemeConfig)(u),
          d = (0, Q5t.resolveRuntimeExtensions)(l, t?.extensions || []);
        (this.config = d),
          this.middlewareStack.use((0, JIe.getUserAgentPlugin)(this.config)),
          this.middlewareStack.use((0, ZIe.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, $5t.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, XIe.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, H5t.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, G5t.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use(
            (0, u5.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
              httpAuthSchemeParametersProvider:
                exe.defaultSTSHttpAuthSchemeParametersProvider,
              identityProviderConfigProvider: async (f) =>
                new u5.DefaultIdentityProviderConfig({
                  "aws.auth#sigv4": f.credentials,
                }),
            }),
          ),
          this.middlewareStack.use((0, u5.getHttpSigningPlugin)(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  T_.STSClient = l5;
});
var zxe = g((VRn, z5) => {
  "use strict";
  c();
  var zM = Object.defineProperty,
    Y5t = Object.getOwnPropertyDescriptor,
    X5t = Object.getOwnPropertyNames,
    J5t = Object.prototype.hasOwnProperty,
    $ = (e, t) => zM(e, "name", { value: t, configurable: !0 }),
    Z5t = (e, t) => {
      for (var r in t) zM(e, r, { get: t[r], enumerable: !0 });
    },
    B5 = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of X5t(t))
          !J5t.call(e, i) &&
            i !== r &&
            zM(e, i, {
              get: () => t[i],
              enumerable: !(n = Y5t(t, i)) || n.enumerable,
            });
      return e;
    },
    eQt = (e, t, r) => (B5(e, t, "default"), r && B5(r, t, "default")),
    tQt = (e) => B5(zM({}, "__esModule", { value: !0 }), e),
    H5 = {};
  Z5t(H5, {
    AssumeRoleCommand: () => V5,
    AssumeRoleResponseFilterSensitiveLog: () => bxe,
    AssumeRoleWithSAMLCommand: () => xxe,
    AssumeRoleWithSAMLRequestFilterSensitiveLog: () => Sxe,
    AssumeRoleWithSAMLResponseFilterSensitiveLog: () => Cxe,
    AssumeRoleWithWebIdentityCommand: () => $5,
    AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => wxe,
    AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => Oxe,
    AssumeRootCommand: () => Nxe,
    AssumeRootResponseFilterSensitiveLog: () => Txe,
    ClientInputEndpointParameters: () => P9t.ClientInputEndpointParameters,
    CredentialsFilterSensitiveLog: () => bh,
    DecodeAuthorizationMessageCommand: () => kxe,
    ExpiredTokenException: () => oxe,
    GetAccessKeyInfoCommand: () => Dxe,
    GetCallerIdentityCommand: () => Lxe,
    GetFederationTokenCommand: () => Mxe,
    GetFederationTokenResponseFilterSensitiveLog: () => Axe,
    GetSessionTokenCommand: () => qxe,
    GetSessionTokenResponseFilterSensitiveLog: () => Pxe,
    IDPCommunicationErrorException: () => vxe,
    IDPRejectedClaimException: () => pxe,
    InvalidAuthorizationMessageException: () => _xe,
    InvalidIdentityTokenException: () => hxe,
    MalformedPolicyDocumentException: () => sxe,
    PackedPolicyTooLargeException: () => uxe,
    RegionDisabledException: () => dxe,
    STS: () => jxe,
    STSServiceException: () => eu,
    decorateDefaultCredentialProvider: () => x9t,
    getDefaultRoleAssumer: () => Vxe,
    getDefaultRoleAssumerWithWebIdentity: () => $xe,
  });
  z5.exports = tQt(H5);
  eQt(H5, ZC(), z5.exports);
  var Al = gl(),
    Pl = pf(),
    rQt = Ua(),
    Ie = vt(),
    eu = class ixe extends Ie.ServiceException {
      static {
        $(this, "STSServiceException");
      }
      constructor(t) {
        super(t), Object.setPrototypeOf(this, ixe.prototype);
      }
    },
    oxe = class axe extends eu {
      static {
        $(this, "ExpiredTokenException");
      }
      name = "ExpiredTokenException";
      $fault = "client";
      constructor(t) {
        super({ name: "ExpiredTokenException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, axe.prototype);
      }
    },
    sxe = class cxe extends eu {
      static {
        $(this, "MalformedPolicyDocumentException");
      }
      name = "MalformedPolicyDocumentException";
      $fault = "client";
      constructor(t) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...t,
        }),
          Object.setPrototypeOf(this, cxe.prototype);
      }
    },
    uxe = class lxe extends eu {
      static {
        $(this, "PackedPolicyTooLargeException");
      }
      name = "PackedPolicyTooLargeException";
      $fault = "client";
      constructor(t) {
        super({
          name: "PackedPolicyTooLargeException",
          $fault: "client",
          ...t,
        }),
          Object.setPrototypeOf(this, lxe.prototype);
      }
    },
    dxe = class fxe extends eu {
      static {
        $(this, "RegionDisabledException");
      }
      name = "RegionDisabledException";
      $fault = "client";
      constructor(t) {
        super({ name: "RegionDisabledException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, fxe.prototype);
      }
    },
    pxe = class mxe extends eu {
      static {
        $(this, "IDPRejectedClaimException");
      }
      name = "IDPRejectedClaimException";
      $fault = "client";
      constructor(t) {
        super({ name: "IDPRejectedClaimException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, mxe.prototype);
      }
    },
    hxe = class gxe extends eu {
      static {
        $(this, "InvalidIdentityTokenException");
      }
      name = "InvalidIdentityTokenException";
      $fault = "client";
      constructor(t) {
        super({
          name: "InvalidIdentityTokenException",
          $fault: "client",
          ...t,
        }),
          Object.setPrototypeOf(this, gxe.prototype);
      }
    },
    vxe = class yxe extends eu {
      static {
        $(this, "IDPCommunicationErrorException");
      }
      name = "IDPCommunicationErrorException";
      $fault = "client";
      constructor(t) {
        super({
          name: "IDPCommunicationErrorException",
          $fault: "client",
          ...t,
        }),
          Object.setPrototypeOf(this, yxe.prototype);
      }
    },
    _xe = class Exe extends eu {
      static {
        $(this, "InvalidAuthorizationMessageException");
      }
      name = "InvalidAuthorizationMessageException";
      $fault = "client";
      constructor(t) {
        super({
          name: "InvalidAuthorizationMessageException",
          $fault: "client",
          ...t,
        }),
          Object.setPrototypeOf(this, Exe.prototype);
      }
    },
    bh = $(
      (e) => ({
        ...e,
        ...(e.SecretAccessKey && { SecretAccessKey: Ie.SENSITIVE_STRING }),
      }),
      "CredentialsFilterSensitiveLog",
    ),
    bxe = $(
      (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: bh(e.Credentials) }),
      }),
      "AssumeRoleResponseFilterSensitiveLog",
    ),
    Sxe = $(
      (e) => ({
        ...e,
        ...(e.SAMLAssertion && { SAMLAssertion: Ie.SENSITIVE_STRING }),
      }),
      "AssumeRoleWithSAMLRequestFilterSensitiveLog",
    ),
    Cxe = $(
      (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: bh(e.Credentials) }),
      }),
      "AssumeRoleWithSAMLResponseFilterSensitiveLog",
    ),
    wxe = $(
      (e) => ({
        ...e,
        ...(e.WebIdentityToken && { WebIdentityToken: Ie.SENSITIVE_STRING }),
      }),
      "AssumeRoleWithWebIdentityRequestFilterSensitiveLog",
    ),
    Oxe = $(
      (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: bh(e.Credentials) }),
      }),
      "AssumeRoleWithWebIdentityResponseFilterSensitiveLog",
    ),
    Txe = $(
      (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: bh(e.Credentials) }),
      }),
      "AssumeRootResponseFilterSensitiveLog",
    ),
    Axe = $(
      (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: bh(e.Credentials) }),
      }),
      "GetFederationTokenResponseFilterSensitiveLog",
    ),
    Pxe = $(
      (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: bh(e.Credentials) }),
      }),
      "GetSessionTokenResponseFilterSensitiveLog",
    ),
    tu = (Jn(), ue($c)),
    nQt = Jr(),
    iQt = $(async (e, t) => {
      let r = xl,
        n;
      return (
        (n = Ll({ ...IQt(e, t), [kl]: c9t, [Dl]: Nl })),
        Il(t, r, "/", void 0, n)
      );
    }, "se_AssumeRoleCommand"),
    oQt = $(async (e, t) => {
      let r = xl,
        n;
      return (
        (n = Ll({ ...xQt(e, t), [kl]: u9t, [Dl]: Nl })),
        Il(t, r, "/", void 0, n)
      );
    }, "se_AssumeRoleWithSAMLCommand"),
    aQt = $(async (e, t) => {
      let r = xl,
        n;
      return (
        (n = Ll({ ...NQt(e, t), [kl]: l9t, [Dl]: Nl })),
        Il(t, r, "/", void 0, n)
      );
    }, "se_AssumeRoleWithWebIdentityCommand"),
    sQt = $(async (e, t) => {
      let r = xl,
        n;
      return (
        (n = Ll({ ...kQt(e, t), [kl]: d9t, [Dl]: Nl })),
        Il(t, r, "/", void 0, n)
      );
    }, "se_AssumeRootCommand"),
    cQt = $(async (e, t) => {
      let r = xl,
        n;
      return (
        (n = Ll({ ...DQt(e, t), [kl]: f9t, [Dl]: Nl })),
        Il(t, r, "/", void 0, n)
      );
    }, "se_DecodeAuthorizationMessageCommand"),
    uQt = $(async (e, t) => {
      let r = xl,
        n;
      return (
        (n = Ll({ ...LQt(e, t), [kl]: p9t, [Dl]: Nl })),
        Il(t, r, "/", void 0, n)
      );
    }, "se_GetAccessKeyInfoCommand"),
    lQt = $(async (e, t) => {
      let r = xl,
        n;
      return (
        (n = Ll({ ...MQt(e, t), [kl]: m9t, [Dl]: Nl })),
        Il(t, r, "/", void 0, n)
      );
    }, "se_GetCallerIdentityCommand"),
    dQt = $(async (e, t) => {
      let r = xl,
        n;
      return (
        (n = Ll({ ...qQt(e, t), [kl]: h9t, [Dl]: Nl })),
        Il(t, r, "/", void 0, n)
      );
    }, "se_GetFederationTokenCommand"),
    fQt = $(async (e, t) => {
      let r = xl,
        n;
      return (
        (n = Ll({ ...jQt(e, t), [kl]: g9t, [Dl]: Nl })),
        Il(t, r, "/", void 0, n)
      );
    }, "se_GetSessionTokenCommand"),
    pQt = $(async (e, t) => {
      if (e.statusCode >= 300) return Rl(e, t);
      let r = await (0, tu.parseXmlBody)(e.body, t),
        n = {};
      return (n = GQt(r.AssumeRoleResult, t)), { $metadata: Ti(e), ...n };
    }, "de_AssumeRoleCommand"),
    mQt = $(async (e, t) => {
      if (e.statusCode >= 300) return Rl(e, t);
      let r = await (0, tu.parseXmlBody)(e.body, t),
        n = {};
      return (
        (n = VQt(r.AssumeRoleWithSAMLResult, t)), { $metadata: Ti(e), ...n }
      );
    }, "de_AssumeRoleWithSAMLCommand"),
    hQt = $(async (e, t) => {
      if (e.statusCode >= 300) return Rl(e, t);
      let r = await (0, tu.parseXmlBody)(e.body, t),
        n = {};
      return (
        (n = $Qt(r.AssumeRoleWithWebIdentityResult, t)),
        { $metadata: Ti(e), ...n }
      );
    }, "de_AssumeRoleWithWebIdentityCommand"),
    gQt = $(async (e, t) => {
      if (e.statusCode >= 300) return Rl(e, t);
      let r = await (0, tu.parseXmlBody)(e.body, t),
        n = {};
      return (n = zQt(r.AssumeRootResult, t)), { $metadata: Ti(e), ...n };
    }, "de_AssumeRootCommand"),
    vQt = $(async (e, t) => {
      if (e.statusCode >= 300) return Rl(e, t);
      let r = await (0, tu.parseXmlBody)(e.body, t),
        n = {};
      return (
        (n = KQt(r.DecodeAuthorizationMessageResult, t)),
        { $metadata: Ti(e), ...n }
      );
    }, "de_DecodeAuthorizationMessageCommand"),
    yQt = $(async (e, t) => {
      if (e.statusCode >= 300) return Rl(e, t);
      let r = await (0, tu.parseXmlBody)(e.body, t),
        n = {};
      return (n = YQt(r.GetAccessKeyInfoResult, t)), { $metadata: Ti(e), ...n };
    }, "de_GetAccessKeyInfoCommand"),
    _Qt = $(async (e, t) => {
      if (e.statusCode >= 300) return Rl(e, t);
      let r = await (0, tu.parseXmlBody)(e.body, t),
        n = {};
      return (
        (n = XQt(r.GetCallerIdentityResult, t)), { $metadata: Ti(e), ...n }
      );
    }, "de_GetCallerIdentityCommand"),
    EQt = $(async (e, t) => {
      if (e.statusCode >= 300) return Rl(e, t);
      let r = await (0, tu.parseXmlBody)(e.body, t),
        n = {};
      return (
        (n = JQt(r.GetFederationTokenResult, t)), { $metadata: Ti(e), ...n }
      );
    }, "de_GetFederationTokenCommand"),
    bQt = $(async (e, t) => {
      if (e.statusCode >= 300) return Rl(e, t);
      let r = await (0, tu.parseXmlBody)(e.body, t),
        n = {};
      return (n = ZQt(r.GetSessionTokenResult, t)), { $metadata: Ti(e), ...n };
    }, "de_GetSessionTokenCommand"),
    Rl = $(async (e, t) => {
      let r = { ...e, body: await (0, tu.parseXmlErrorBody)(e.body, t) },
        n = v9t(e, r.body);
      switch (n) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
          throw await SQt(r, t);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
          throw await AQt(r, t);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
          throw await PQt(r, t);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
          throw await RQt(r, t);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
          throw await wQt(r, t);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
          throw await TQt(r, t);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
          throw await CQt(r, t);
        case "InvalidAuthorizationMessageException":
        case "com.amazonaws.sts#InvalidAuthorizationMessageException":
          throw await OQt(r, t);
        default:
          let i = r.body;
          return s9t({ output: e, parsedBody: i.Error, errorCode: n });
      }
    }, "de_CommandError"),
    SQt = $(async (e, t) => {
      let r = e.body,
        n = WQt(r.Error, t),
        i = new oxe({ $metadata: Ti(e), ...n });
      return (0, Ie.decorateServiceException)(i, r);
    }, "de_ExpiredTokenExceptionRes"),
    CQt = $(async (e, t) => {
      let r = e.body,
        n = e9t(r.Error, t),
        i = new vxe({ $metadata: Ti(e), ...n });
      return (0, Ie.decorateServiceException)(i, r);
    }, "de_IDPCommunicationErrorExceptionRes"),
    wQt = $(async (e, t) => {
      let r = e.body,
        n = t9t(r.Error, t),
        i = new pxe({ $metadata: Ti(e), ...n });
      return (0, Ie.decorateServiceException)(i, r);
    }, "de_IDPRejectedClaimExceptionRes"),
    OQt = $(async (e, t) => {
      let r = e.body,
        n = r9t(r.Error, t),
        i = new _xe({ $metadata: Ti(e), ...n });
      return (0, Ie.decorateServiceException)(i, r);
    }, "de_InvalidAuthorizationMessageExceptionRes"),
    TQt = $(async (e, t) => {
      let r = e.body,
        n = n9t(r.Error, t),
        i = new hxe({ $metadata: Ti(e), ...n });
      return (0, Ie.decorateServiceException)(i, r);
    }, "de_InvalidIdentityTokenExceptionRes"),
    AQt = $(async (e, t) => {
      let r = e.body,
        n = i9t(r.Error, t),
        i = new sxe({ $metadata: Ti(e), ...n });
      return (0, Ie.decorateServiceException)(i, r);
    }, "de_MalformedPolicyDocumentExceptionRes"),
    PQt = $(async (e, t) => {
      let r = e.body,
        n = o9t(r.Error, t),
        i = new uxe({ $metadata: Ti(e), ...n });
      return (0, Ie.decorateServiceException)(i, r);
    }, "de_PackedPolicyTooLargeExceptionRes"),
    RQt = $(async (e, t) => {
      let r = e.body,
        n = a9t(r.Error, t),
        i = new dxe({ $metadata: Ti(e), ...n });
      return (0, Ie.decorateServiceException)(i, r);
    }, "de_RegionDisabledExceptionRes"),
    IQt = $((e, t) => {
      let r = {};
      if (
        (e[Tl] != null && (r[Tl] = e[Tl]),
        e[I_] != null && (r[I_] = e[I_]),
        e[Ya] != null)
      ) {
        let n = KM(e[Ya], t);
        e[Ya]?.length === 0 && (r.PolicyArns = []),
          Object.entries(n).forEach(([i, o]) => {
            let a = `PolicyArns.${i}`;
            r[a] = o;
          });
      }
      if (
        (e[Qa] != null && (r[Qa] = e[Qa]),
        e[ti] != null && (r[ti] = e[ti]),
        e[N_] != null)
      ) {
        let n = Ixe(e[N_], t);
        e[N_]?.length === 0 && (r.Tags = []),
          Object.entries(n).forEach(([i, o]) => {
            let a = `Tags.${i}`;
            r[a] = o;
          });
      }
      if (e[L5] != null) {
        let n = HQt(e[L5], t);
        e[L5]?.length === 0 && (r.TransitiveTagKeys = []),
          Object.entries(n).forEach(([i, o]) => {
            let a = `TransitiveTagKeys.${i}`;
            r[a] = o;
          });
      }
      if (
        (e[h5] != null && (r[h5] = e[h5]),
        e[x_] != null && (r[x_] = e[x_]),
        e[k_] != null && (r[k_] = e[k_]),
        e[no] != null && (r[no] = e[no]),
        e[O5] != null)
      ) {
        let n = BQt(e[O5], t);
        e[O5]?.length === 0 && (r.ProvidedContexts = []),
          Object.entries(n).forEach(([i, o]) => {
            let a = `ProvidedContexts.${i}`;
            r[a] = o;
          });
      }
      return r;
    }, "se_AssumeRoleRequest"),
    xQt = $((e, t) => {
      let r = {};
      if (
        (e[Tl] != null && (r[Tl] = e[Tl]),
        e[C5] != null && (r[C5] = e[C5]),
        e[I5] != null && (r[I5] = e[I5]),
        e[Ya] != null)
      ) {
        let n = KM(e[Ya], t);
        e[Ya]?.length === 0 && (r.PolicyArns = []),
          Object.entries(n).forEach(([i, o]) => {
            let a = `PolicyArns.${i}`;
            r[a] = o;
          });
      }
      return (
        e[Qa] != null && (r[Qa] = e[Qa]), e[ti] != null && (r[ti] = e[ti]), r
      );
    }, "se_AssumeRoleWithSAMLRequest"),
    NQt = $((e, t) => {
      let r = {};
      if (
        (e[Tl] != null && (r[Tl] = e[Tl]),
        e[I_] != null && (r[I_] = e[I_]),
        e[j5] != null && (r[j5] = e[j5]),
        e[T5] != null && (r[T5] = e[T5]),
        e[Ya] != null)
      ) {
        let n = KM(e[Ya], t);
        e[Ya]?.length === 0 && (r.PolicyArns = []),
          Object.entries(n).forEach(([i, o]) => {
            let a = `PolicyArns.${i}`;
            r[a] = o;
          });
      }
      return (
        e[Qa] != null && (r[Qa] = e[Qa]), e[ti] != null && (r[ti] = e[ti]), r
      );
    }, "se_AssumeRoleWithWebIdentityRequest"),
    kQt = $((e, t) => {
      let r = {};
      if ((e[D5] != null && (r[D5] = e[D5]), e[rxe] != null)) {
        let n = Rxe(e[rxe], t);
        Object.entries(n).forEach(([i, o]) => {
          let a = `TaskPolicyArn.${i}`;
          r[a] = o;
        });
      }
      return e[ti] != null && (r[ti] = e[ti]), r;
    }, "se_AssumeRootRequest"),
    DQt = $((e, t) => {
      let r = {};
      return e[g5] != null && (r[g5] = e[g5]), r;
    }, "se_DecodeAuthorizationMessageRequest"),
    LQt = $((e, t) => {
      let r = {};
      return e[A_] != null && (r[A_] = e[A_]), r;
    }, "se_GetAccessKeyInfoRequest"),
    MQt = $((e, t) => ({}), "se_GetCallerIdentityRequest"),
    qQt = $((e, t) => {
      let r = {};
      if (
        (e[b5] != null && (r[b5] = e[b5]),
        e[Qa] != null && (r[Qa] = e[Qa]),
        e[Ya] != null)
      ) {
        let n = KM(e[Ya], t);
        e[Ya]?.length === 0 && (r.PolicyArns = []),
          Object.entries(n).forEach(([i, o]) => {
            let a = `PolicyArns.${i}`;
            r[a] = o;
          });
      }
      if ((e[ti] != null && (r[ti] = e[ti]), e[N_] != null)) {
        let n = Ixe(e[N_], t);
        e[N_]?.length === 0 && (r.Tags = []),
          Object.entries(n).forEach(([i, o]) => {
            let a = `Tags.${i}`;
            r[a] = o;
          });
      }
      return r;
    }, "se_GetFederationTokenRequest"),
    jQt = $((e, t) => {
      let r = {};
      return (
        e[ti] != null && (r[ti] = e[ti]),
        e[x_] != null && (r[x_] = e[x_]),
        e[k_] != null && (r[k_] = e[k_]),
        r
      );
    }, "se_GetSessionTokenRequest"),
    KM = $((e, t) => {
      let r = {},
        n = 1;
      for (let i of e) {
        if (i === null) continue;
        let o = Rxe(i, t);
        Object.entries(o).forEach(([a, s]) => {
          r[`member.${n}.${a}`] = s;
        }),
          n++;
      }
      return r;
    }, "se_policyDescriptorListType"),
    Rxe = $((e, t) => {
      let r = {};
      return e[F5] != null && (r[F5] = e[F5]), r;
    }, "se_PolicyDescriptorType"),
    FQt = $((e, t) => {
      let r = {};
      return (
        e[w5] != null && (r[w5] = e[w5]), e[f5] != null && (r[f5] = e[f5]), r
      );
    }, "se_ProvidedContext"),
    BQt = $((e, t) => {
      let r = {},
        n = 1;
      for (let i of e) {
        if (i === null) continue;
        let o = FQt(i, t);
        Object.entries(o).forEach(([a, s]) => {
          r[`member.${n}.${a}`] = s;
        }),
          n++;
      }
      return r;
    }, "se_ProvidedContextsListType"),
    UQt = $((e, t) => {
      let r = {};
      return (
        e[E5] != null && (r[E5] = e[E5]), e[q5] != null && (r[q5] = e[q5]), r
      );
    }, "se_Tag"),
    HQt = $((e, t) => {
      let r = {},
        n = 1;
      for (let i of e) i !== null && ((r[`member.${n}`] = i), n++);
      return r;
    }, "se_tagKeyListType"),
    Ixe = $((e, t) => {
      let r = {},
        n = 1;
      for (let i of e) {
        if (i === null) continue;
        let o = UQt(i, t);
        Object.entries(o).forEach(([a, s]) => {
          r[`member.${n}.${a}`] = s;
        }),
          n++;
      }
      return r;
    }, "se_tagListType"),
    G5 = $((e, t) => {
      let r = {};
      return (
        e[d5] != null && (r[d5] = (0, Ie.expectString)(e[d5])),
        e[Ol] != null && (r[Ol] = (0, Ie.expectString)(e[Ol])),
        r
      );
    }, "de_AssumedRoleUser"),
    GQt = $((e, t) => {
      let r = {};
      return (
        e[ei] != null && (r[ei] = D_(e[ei], t)),
        e[wl] != null && (r[wl] = G5(e[wl], t)),
        e[Xa] != null && (r[Xa] = (0, Ie.strictParseInt32)(e[Xa])),
        e[no] != null && (r[no] = (0, Ie.expectString)(e[no])),
        r
      );
    }, "de_AssumeRoleResponse"),
    VQt = $((e, t) => {
      let r = {};
      return (
        e[ei] != null && (r[ei] = D_(e[ei], t)),
        e[wl] != null && (r[wl] = G5(e[wl], t)),
        e[Xa] != null && (r[Xa] = (0, Ie.strictParseInt32)(e[Xa])),
        e[P5] != null && (r[P5] = (0, Ie.expectString)(e[P5])),
        e[N5] != null && (r[N5] = (0, Ie.expectString)(e[N5])),
        e[_5] != null && (r[_5] = (0, Ie.expectString)(e[_5])),
        e[R_] != null && (r[R_] = (0, Ie.expectString)(e[R_])),
        e[S5] != null && (r[S5] = (0, Ie.expectString)(e[S5])),
        e[no] != null && (r[no] = (0, Ie.expectString)(e[no])),
        r
      );
    }, "de_AssumeRoleWithSAMLResponse"),
    $Qt = $((e, t) => {
      let r = {};
      return (
        e[ei] != null && (r[ei] = D_(e[ei], t)),
        e[x5] != null && (r[x5] = (0, Ie.expectString)(e[x5])),
        e[wl] != null && (r[wl] = G5(e[wl], t)),
        e[Xa] != null && (r[Xa] = (0, Ie.strictParseInt32)(e[Xa])),
        e[A5] != null && (r[A5] = (0, Ie.expectString)(e[A5])),
        e[R_] != null && (r[R_] = (0, Ie.expectString)(e[R_])),
        e[no] != null && (r[no] = (0, Ie.expectString)(e[no])),
        r
      );
    }, "de_AssumeRoleWithWebIdentityResponse"),
    zQt = $((e, t) => {
      let r = {};
      return (
        e[ei] != null && (r[ei] = D_(e[ei], t)),
        e[no] != null && (r[no] = (0, Ie.expectString)(e[no])),
        r
      );
    }, "de_AssumeRootResponse"),
    D_ = $((e, t) => {
      let r = {};
      return (
        e[A_] != null && (r[A_] = (0, Ie.expectString)(e[A_])),
        e[R5] != null && (r[R5] = (0, Ie.expectString)(e[R5])),
        e[k5] != null && (r[k5] = (0, Ie.expectString)(e[k5])),
        e[m5] != null &&
          (r[m5] = (0, Ie.expectNonNull)(
            (0, Ie.parseRfc3339DateTimeWithOffset)(e[m5]),
          )),
        r
      );
    }, "de_Credentials"),
    KQt = $((e, t) => {
      let r = {};
      return e[p5] != null && (r[p5] = (0, Ie.expectString)(e[p5])), r;
    }, "de_DecodeAuthorizationMessageResponse"),
    WQt = $((e, t) => {
      let r = {};
      return e[Kr] != null && (r[Kr] = (0, Ie.expectString)(e[Kr])), r;
    }, "de_ExpiredTokenException"),
    QQt = $((e, t) => {
      let r = {};
      return (
        e[y5] != null && (r[y5] = (0, Ie.expectString)(e[y5])),
        e[Ol] != null && (r[Ol] = (0, Ie.expectString)(e[Ol])),
        r
      );
    }, "de_FederatedUser"),
    YQt = $((e, t) => {
      let r = {};
      return e[P_] != null && (r[P_] = (0, Ie.expectString)(e[P_])), r;
    }, "de_GetAccessKeyInfoResponse"),
    XQt = $((e, t) => {
      let r = {};
      return (
        e[M5] != null && (r[M5] = (0, Ie.expectString)(e[M5])),
        e[P_] != null && (r[P_] = (0, Ie.expectString)(e[P_])),
        e[Ol] != null && (r[Ol] = (0, Ie.expectString)(e[Ol])),
        r
      );
    }, "de_GetCallerIdentityResponse"),
    JQt = $((e, t) => {
      let r = {};
      return (
        e[ei] != null && (r[ei] = D_(e[ei], t)),
        e[v5] != null && (r[v5] = QQt(e[v5], t)),
        e[Xa] != null && (r[Xa] = (0, Ie.strictParseInt32)(e[Xa])),
        r
      );
    }, "de_GetFederationTokenResponse"),
    ZQt = $((e, t) => {
      let r = {};
      return e[ei] != null && (r[ei] = D_(e[ei], t)), r;
    }, "de_GetSessionTokenResponse"),
    e9t = $((e, t) => {
      let r = {};
      return e[Kr] != null && (r[Kr] = (0, Ie.expectString)(e[Kr])), r;
    }, "de_IDPCommunicationErrorException"),
    t9t = $((e, t) => {
      let r = {};
      return e[Kr] != null && (r[Kr] = (0, Ie.expectString)(e[Kr])), r;
    }, "de_IDPRejectedClaimException"),
    r9t = $((e, t) => {
      let r = {};
      return e[Kr] != null && (r[Kr] = (0, Ie.expectString)(e[Kr])), r;
    }, "de_InvalidAuthorizationMessageException"),
    n9t = $((e, t) => {
      let r = {};
      return e[Kr] != null && (r[Kr] = (0, Ie.expectString)(e[Kr])), r;
    }, "de_InvalidIdentityTokenException"),
    i9t = $((e, t) => {
      let r = {};
      return e[Kr] != null && (r[Kr] = (0, Ie.expectString)(e[Kr])), r;
    }, "de_MalformedPolicyDocumentException"),
    o9t = $((e, t) => {
      let r = {};
      return e[Kr] != null && (r[Kr] = (0, Ie.expectString)(e[Kr])), r;
    }, "de_PackedPolicyTooLargeException"),
    a9t = $((e, t) => {
      let r = {};
      return e[Kr] != null && (r[Kr] = (0, Ie.expectString)(e[Kr])), r;
    }, "de_RegionDisabledException"),
    Ti = $(
      (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }),
      "deserializeMetadata",
    ),
    s9t = (0, Ie.withBaseException)(eu),
    Il = $(async (e, t, r, n, i) => {
      let {
          hostname: o,
          protocol: a = "https",
          port: s,
          path: u,
        } = await e.endpoint(),
        l = {
          protocol: a,
          hostname: o,
          port: s,
          method: "POST",
          path: u.endsWith("/") ? u.slice(0, -1) + r : u + r,
          headers: t,
        };
      return (
        n !== void 0 && (l.hostname = n),
        i !== void 0 && (l.body = i),
        new nQt.HttpRequest(l)
      );
    }, "buildHttpRpcRequest"),
    xl = { "content-type": "application/x-www-form-urlencoded" },
    Nl = "2011-06-15",
    kl = "Action",
    A_ = "AccessKeyId",
    c9t = "AssumeRole",
    d5 = "AssumedRoleId",
    wl = "AssumedRoleUser",
    u9t = "AssumeRoleWithSAML",
    l9t = "AssumeRoleWithWebIdentity",
    d9t = "AssumeRoot",
    P_ = "Account",
    Ol = "Arn",
    R_ = "Audience",
    ei = "Credentials",
    f5 = "ContextAssertion",
    f9t = "DecodeAuthorizationMessage",
    p5 = "DecodedMessage",
    ti = "DurationSeconds",
    m5 = "Expiration",
    h5 = "ExternalId",
    g5 = "EncodedMessage",
    v5 = "FederatedUser",
    y5 = "FederatedUserId",
    p9t = "GetAccessKeyInfo",
    m9t = "GetCallerIdentity",
    h9t = "GetFederationToken",
    g9t = "GetSessionToken",
    _5 = "Issuer",
    E5 = "Key",
    b5 = "Name",
    S5 = "NameQualifier",
    Qa = "Policy",
    Ya = "PolicyArns",
    C5 = "PrincipalArn",
    w5 = "ProviderArn",
    O5 = "ProvidedContexts",
    T5 = "ProviderId",
    Xa = "PackedPolicySize",
    A5 = "Provider",
    Tl = "RoleArn",
    I_ = "RoleSessionName",
    P5 = "Subject",
    R5 = "SecretAccessKey",
    I5 = "SAMLAssertion",
    x5 = "SubjectFromWebIdentityToken",
    no = "SourceIdentity",
    x_ = "SerialNumber",
    N5 = "SubjectType",
    k5 = "SessionToken",
    N_ = "Tags",
    k_ = "TokenCode",
    D5 = "TargetPrincipal",
    rxe = "TaskPolicyArn",
    L5 = "TransitiveTagKeys",
    M5 = "UserId",
    Dl = "Version",
    q5 = "Value",
    j5 = "WebIdentityToken",
    F5 = "arn",
    Kr = "message",
    Ll = $(
      (e) =>
        Object.entries(e)
          .map(
            ([t, r]) =>
              (0, Ie.extendedEncodeURIComponent)(t) +
              "=" +
              (0, Ie.extendedEncodeURIComponent)(r),
          )
          .join("&"),
      "buildFormUrlencodedString",
    ),
    v9t = $((e, t) => {
      if (t.Error?.Code !== void 0) return t.Error.Code;
      if (e.statusCode == 404) return "NotFound";
    }, "loadQueryErrorCode"),
    V5 = class extends Ie.Command.classBuilder()
      .ep(rQt.commonParams)
      .m(function (e, t, r, n) {
        return [
          (0, Pl.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, Al.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AWSSecurityTokenServiceV20110615", "AssumeRole", {})
      .n("STSClient", "AssumeRoleCommand")
      .f(void 0, bxe)
      .ser(iQt)
      .de(pQt)
      .build() {
      static {
        $(this, "AssumeRoleCommand");
      }
    },
    y9t = Ua(),
    xxe = class extends Ie.Command.classBuilder()
      .ep(y9t.commonParams)
      .m(function (e, t, r, n) {
        return [
          (0, Pl.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, Al.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithSAML", {})
      .n("STSClient", "AssumeRoleWithSAMLCommand")
      .f(Sxe, Cxe)
      .ser(oQt)
      .de(mQt)
      .build() {
      static {
        $(this, "AssumeRoleWithSAMLCommand");
      }
    },
    _9t = Ua(),
    $5 = class extends Ie.Command.classBuilder()
      .ep(_9t.commonParams)
      .m(function (e, t, r, n) {
        return [
          (0, Pl.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, Al.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {})
      .n("STSClient", "AssumeRoleWithWebIdentityCommand")
      .f(wxe, Oxe)
      .ser(aQt)
      .de(hQt)
      .build() {
      static {
        $(this, "AssumeRoleWithWebIdentityCommand");
      }
    },
    E9t = Ua(),
    Nxe = class extends Ie.Command.classBuilder()
      .ep(E9t.commonParams)
      .m(function (e, t, r, n) {
        return [
          (0, Pl.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, Al.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AWSSecurityTokenServiceV20110615", "AssumeRoot", {})
      .n("STSClient", "AssumeRootCommand")
      .f(void 0, Txe)
      .ser(sQt)
      .de(gQt)
      .build() {
      static {
        $(this, "AssumeRootCommand");
      }
    },
    b9t = Ua(),
    kxe = class extends Ie.Command.classBuilder()
      .ep(b9t.commonParams)
      .m(function (e, t, r, n) {
        return [
          (0, Pl.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, Al.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AWSSecurityTokenServiceV20110615", "DecodeAuthorizationMessage", {})
      .n("STSClient", "DecodeAuthorizationMessageCommand")
      .f(void 0, void 0)
      .ser(cQt)
      .de(vQt)
      .build() {
      static {
        $(this, "DecodeAuthorizationMessageCommand");
      }
    },
    S9t = Ua(),
    Dxe = class extends Ie.Command.classBuilder()
      .ep(S9t.commonParams)
      .m(function (e, t, r, n) {
        return [
          (0, Pl.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, Al.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AWSSecurityTokenServiceV20110615", "GetAccessKeyInfo", {})
      .n("STSClient", "GetAccessKeyInfoCommand")
      .f(void 0, void 0)
      .ser(uQt)
      .de(yQt)
      .build() {
      static {
        $(this, "GetAccessKeyInfoCommand");
      }
    },
    C9t = Ua(),
    Lxe = class extends Ie.Command.classBuilder()
      .ep(C9t.commonParams)
      .m(function (e, t, r, n) {
        return [
          (0, Pl.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, Al.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AWSSecurityTokenServiceV20110615", "GetCallerIdentity", {})
      .n("STSClient", "GetCallerIdentityCommand")
      .f(void 0, void 0)
      .ser(lQt)
      .de(_Qt)
      .build() {
      static {
        $(this, "GetCallerIdentityCommand");
      }
    },
    w9t = Ua(),
    Mxe = class extends Ie.Command.classBuilder()
      .ep(w9t.commonParams)
      .m(function (e, t, r, n) {
        return [
          (0, Pl.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, Al.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AWSSecurityTokenServiceV20110615", "GetFederationToken", {})
      .n("STSClient", "GetFederationTokenCommand")
      .f(void 0, Axe)
      .ser(dQt)
      .de(EQt)
      .build() {
      static {
        $(this, "GetFederationTokenCommand");
      }
    },
    O9t = Ua(),
    qxe = class extends Ie.Command.classBuilder()
      .ep(O9t.commonParams)
      .m(function (e, t, r, n) {
        return [
          (0, Pl.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, Al.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AWSSecurityTokenServiceV20110615", "GetSessionToken", {})
      .n("STSClient", "GetSessionTokenCommand")
      .f(void 0, Pxe)
      .ser(fQt)
      .de(bQt)
      .build() {
      static {
        $(this, "GetSessionTokenCommand");
      }
    },
    T9t = ZC(),
    A9t = {
      AssumeRoleCommand: V5,
      AssumeRoleWithSAMLCommand: xxe,
      AssumeRoleWithWebIdentityCommand: $5,
      AssumeRootCommand: Nxe,
      DecodeAuthorizationMessageCommand: kxe,
      GetAccessKeyInfoCommand: Dxe,
      GetCallerIdentityCommand: Lxe,
      GetFederationTokenCommand: Mxe,
      GetSessionTokenCommand: qxe,
    },
    jxe = class extends T9t.STSClient {
      static {
        $(this, "STS");
      }
    };
  (0, Ie.createAggregatedClient)(A9t, jxe);
  var P9t = Ua(),
    U5 = (Ks(), ue(Ef)),
    nxe = "us-east-1",
    Fxe = $((e) => {
      if (typeof e?.Arn == "string") {
        let t = e.Arn.split(":");
        if (t.length > 4 && t[4] !== "") return t[4];
      }
    }, "getAccountIdFromAssumedRoleUser"),
    Bxe = $(async (e, t, r) => {
      let n = typeof e == "function" ? await e() : e,
        i = typeof t == "function" ? await t() : t;
      return (
        r?.debug?.(
          "@aws-sdk/client-sts::resolveRegion",
          "accepting first of:",
          `${n} (provider)`,
          `${i} (parent client)`,
          `${nxe} (STS default)`,
        ),
        n ?? i ?? nxe
      );
    }, "resolveRegion"),
    R9t = $((e, t) => {
      let r, n;
      return async (i, o) => {
        if (((n = i), !r)) {
          let {
              logger: d = e?.parentClientConfig?.logger,
              region: f,
              requestHandler: m = e?.parentClientConfig?.requestHandler,
              credentialProviderLogger: h,
            } = e,
            y = await Bxe(f, e?.parentClientConfig?.region, h),
            _ = !Uxe(m);
          r = new t({
            profile: e?.parentClientConfig?.profile,
            credentialDefaultProvider: $(
              () => async () => n,
              "credentialDefaultProvider",
            ),
            region: y,
            requestHandler: _ ? m : void 0,
            logger: d,
          });
        }
        let { Credentials: a, AssumedRoleUser: s } = await r.send(new V5(o));
        if (!a || !a.AccessKeyId || !a.SecretAccessKey)
          throw new Error(
            `Invalid response from STS.assumeRole call with role ${o.RoleArn}`,
          );
        let u = Fxe(s),
          l = {
            accessKeyId: a.AccessKeyId,
            secretAccessKey: a.SecretAccessKey,
            sessionToken: a.SessionToken,
            expiration: a.Expiration,
            ...(a.CredentialScope && { credentialScope: a.CredentialScope }),
            ...(u && { accountId: u }),
          };
        return (
          (0, U5.setCredentialFeature)(l, "CREDENTIALS_STS_ASSUME_ROLE", "i"), l
        );
      };
    }, "getDefaultRoleAssumer"),
    I9t = $((e, t) => {
      let r;
      return async (n) => {
        if (!r) {
          let {
              logger: u = e?.parentClientConfig?.logger,
              region: l,
              requestHandler: d = e?.parentClientConfig?.requestHandler,
              credentialProviderLogger: f,
            } = e,
            m = await Bxe(l, e?.parentClientConfig?.region, f),
            h = !Uxe(d);
          r = new t({
            profile: e?.parentClientConfig?.profile,
            region: m,
            requestHandler: h ? d : void 0,
            logger: u,
          });
        }
        let { Credentials: i, AssumedRoleUser: o } = await r.send(new $5(n));
        if (!i || !i.AccessKeyId || !i.SecretAccessKey)
          throw new Error(
            `Invalid response from STS.assumeRoleWithWebIdentity call with role ${n.RoleArn}`,
          );
        let a = Fxe(o),
          s = {
            accessKeyId: i.AccessKeyId,
            secretAccessKey: i.SecretAccessKey,
            sessionToken: i.SessionToken,
            expiration: i.Expiration,
            ...(i.CredentialScope && { credentialScope: i.CredentialScope }),
            ...(a && { accountId: a }),
          };
        return (
          a && (0, U5.setCredentialFeature)(s, "RESOLVED_ACCOUNT_ID", "T"),
          (0, U5.setCredentialFeature)(
            s,
            "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID",
            "k",
          ),
          s
        );
      };
    }, "getDefaultRoleAssumerWithWebIdentity"),
    Uxe = $((e) => e?.metadata?.handlerProtocol === "h2", "isH2"),
    Hxe = ZC(),
    Gxe = $(
      (e, t) =>
        t
          ? class extends e {
              static {
                $(this, "CustomizableSTSClient");
              }
              constructor(n) {
                super(n);
                for (let i of t) this.middlewareStack.use(i);
              }
            }
          : e,
      "getCustomizableStsClientCtor",
    ),
    Vxe = $(
      (e = {}, t) => R9t(e, Gxe(Hxe.STSClient, t)),
      "getDefaultRoleAssumer",
    ),
    $xe = $(
      (e = {}, t) => I9t(e, Gxe(Hxe.STSClient, t)),
      "getDefaultRoleAssumerWithWebIdentity",
    ),
    x9t = $(
      (e) => (t) =>
        e({ roleAssumer: Vxe(t), roleAssumerWithWebIdentity: $xe(t), ...t }),
      "decorateDefaultCredentialProvider",
    );
});
var Qxe = g((WM) => {
  "use strict";
  c();
  Object.defineProperty(WM, "__esModule", { value: !0 });
  WM.AccountIdFetcher = void 0;
  var Kxe = zxe(),
    N9t = Gk(),
    Wxe = "NO_ACCOUNT_ID",
    k9t = "283cae3e-c611-4659-9044-6796e5d696ec",
    K5 = class {
      stsClient;
      accountId;
      constructor(t = new Kxe.STSClient()) {
        this.stsClient = t;
      }
      fetch = async () => {
        if (this.accountId) return this.accountId;
        try {
          let t = await this.stsClient.send(
            new Kxe.GetCallerIdentityCommand({}),
          );
          if (t && t.Account) {
            let r = t.Account.slice(0, -2);
            return (this.accountId = (0, N9t.v5)(r, k9t)), this.accountId;
          }
          return Wxe;
        } catch {
          return Wxe;
        }
      };
    };
  WM.AccountIdFetcher = K5;
});
var Yxe = g((QM) => {
  "use strict";
  c();
  Object.defineProperty(QM, "__esModule", { value: !0 });
  QM.getInstallationUuid = void 0;
  var D9t = Gk(),
    L9t = G("os"),
    M9t = "e7368840-2eb6-4042-99b4-9d6c2a9370e6",
    q9t = (e = M9t) => (0, D9t.v5)(__dirname + (0, L9t.hostname)(), e);
  QM.getInstallationUuid = q9t;
});
var Bw = g((Bf) => {
  "use strict";
  c();
  Object.defineProperty(Bf, "__esModule", { value: !0 });
  Bf.USAGE_DATA_TRACKING_ENABLED =
    Bf.latestPayloadVersion =
    Bf.latestApiVersion =
      void 0;
  Bf.latestApiVersion = "v1.0";
  Bf.latestPayloadVersion = "1.1.0";
  Bf.USAGE_DATA_TRACKING_ENABLED = "telemetry.enabled";
});
var Xxe = g((L_) => {
  "use strict";
  c();
  var j9t =
    (L_ && L_.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(L_, "__esModule", { value: !0 });
  L_.getUrl = void 0;
  var F9t = j9t(G("node:url")),
    B9t = Bw(),
    W5,
    U9t = `https://api.cli.amplify.aws/${B9t.latestApiVersion}/metrics`,
    H9t = () => (W5 || (W5 = G9t()), W5);
  L_.getUrl = H9t;
  var G9t = () =>
    F9t.default.parse(
      process.env.AMPLIFY_BACKEND_USAGE_TRACKING_ENDPOINT || U9t,
    );
});
var Jxe = g((lIn, V9t) => {
  V9t.exports = [
    {
      name: "Agola CI",
      constant: "AGOLA",
      env: "AGOLA_GIT_REF",
      pr: "AGOLA_PULL_REQUEST_ID",
    },
    {
      name: "Appcircle",
      constant: "APPCIRCLE",
      env: "AC_APPCIRCLE",
      pr: { env: "AC_GIT_PR", ne: "false" },
    },
    {
      name: "AppVeyor",
      constant: "APPVEYOR",
      env: "APPVEYOR",
      pr: "APPVEYOR_PULL_REQUEST_NUMBER",
    },
    {
      name: "AWS CodeBuild",
      constant: "CODEBUILD",
      env: "CODEBUILD_BUILD_ARN",
      pr: {
        env: "CODEBUILD_WEBHOOK_EVENT",
        any: [
          "PULL_REQUEST_CREATED",
          "PULL_REQUEST_UPDATED",
          "PULL_REQUEST_REOPENED",
        ],
      },
    },
    {
      name: "Azure Pipelines",
      constant: "AZURE_PIPELINES",
      env: "TF_BUILD",
      pr: { BUILD_REASON: "PullRequest" },
    },
    { name: "Bamboo", constant: "BAMBOO", env: "bamboo_planKey" },
    {
      name: "Bitbucket Pipelines",
      constant: "BITBUCKET",
      env: "BITBUCKET_COMMIT",
      pr: "BITBUCKET_PR_ID",
    },
    {
      name: "Bitrise",
      constant: "BITRISE",
      env: "BITRISE_IO",
      pr: "BITRISE_PULL_REQUEST",
    },
    {
      name: "Buddy",
      constant: "BUDDY",
      env: "BUDDY_WORKSPACE_ID",
      pr: "BUDDY_EXECUTION_PULL_REQUEST_ID",
    },
    {
      name: "Buildkite",
      constant: "BUILDKITE",
      env: "BUILDKITE",
      pr: { env: "BUILDKITE_PULL_REQUEST", ne: "false" },
    },
    {
      name: "CircleCI",
      constant: "CIRCLE",
      env: "CIRCLECI",
      pr: "CIRCLE_PULL_REQUEST",
    },
    {
      name: "Cirrus CI",
      constant: "CIRRUS",
      env: "CIRRUS_CI",
      pr: "CIRRUS_PR",
    },
    { name: "Cloudflare Pages", constant: "CLOUDFLARE_PAGES", env: "CF_PAGES" },
    {
      name: "Codefresh",
      constant: "CODEFRESH",
      env: "CF_BUILD_ID",
      pr: { any: ["CF_PULL_REQUEST_NUMBER", "CF_PULL_REQUEST_ID"] },
    },
    {
      name: "Codemagic",
      constant: "CODEMAGIC",
      env: "CM_BUILD_ID",
      pr: "CM_PULL_REQUEST",
    },
    { name: "Codeship", constant: "CODESHIP", env: { CI_NAME: "codeship" } },
    {
      name: "Drone",
      constant: "DRONE",
      env: "DRONE",
      pr: { DRONE_BUILD_EVENT: "pull_request" },
    },
    { name: "dsari", constant: "DSARI", env: "DSARI" },
    { name: "Earthly", constant: "EARTHLY", env: "EARTHLY_CI" },
    { name: "Expo Application Services", constant: "EAS", env: "EAS_BUILD" },
    { name: "Gerrit", constant: "GERRIT", env: "GERRIT_PROJECT" },
    { name: "Gitea Actions", constant: "GITEA_ACTIONS", env: "GITEA_ACTIONS" },
    {
      name: "GitHub Actions",
      constant: "GITHUB_ACTIONS",
      env: "GITHUB_ACTIONS",
      pr: { GITHUB_EVENT_NAME: "pull_request" },
    },
    {
      name: "GitLab CI",
      constant: "GITLAB",
      env: "GITLAB_CI",
      pr: "CI_MERGE_REQUEST_ID",
    },
    { name: "GoCD", constant: "GOCD", env: "GO_PIPELINE_LABEL" },
    {
      name: "Google Cloud Build",
      constant: "GOOGLE_CLOUD_BUILD",
      env: "BUILDER_OUTPUT",
    },
    { name: "Harness CI", constant: "HARNESS", env: "HARNESS_BUILD_ID" },
    {
      name: "Heroku",
      constant: "HEROKU",
      env: { env: "NODE", includes: "/app/.heroku/node/bin/node" },
    },
    { name: "Hudson", constant: "HUDSON", env: "HUDSON_URL" },
    {
      name: "Jenkins",
      constant: "JENKINS",
      env: ["JENKINS_URL", "BUILD_ID"],
      pr: { any: ["ghprbPullId", "CHANGE_ID"] },
    },
    {
      name: "LayerCI",
      constant: "LAYERCI",
      env: "LAYERCI",
      pr: "LAYERCI_PULL_REQUEST",
    },
    { name: "Magnum CI", constant: "MAGNUM", env: "MAGNUM" },
    {
      name: "Netlify CI",
      constant: "NETLIFY",
      env: "NETLIFY",
      pr: { env: "PULL_REQUEST", ne: "false" },
    },
    {
      name: "Nevercode",
      constant: "NEVERCODE",
      env: "NEVERCODE",
      pr: { env: "NEVERCODE_PULL_REQUEST", ne: "false" },
    },
    { name: "Prow", constant: "PROW", env: "PROW_JOB_ID" },
    { name: "ReleaseHub", constant: "RELEASEHUB", env: "RELEASE_BUILD_ID" },
    {
      name: "Render",
      constant: "RENDER",
      env: "RENDER",
      pr: { IS_PULL_REQUEST: "true" },
    },
    {
      name: "Sail CI",
      constant: "SAIL",
      env: "SAILCI",
      pr: "SAIL_PULL_REQUEST_NUMBER",
    },
    {
      name: "Screwdriver",
      constant: "SCREWDRIVER",
      env: "SCREWDRIVER",
      pr: { env: "SD_PULL_REQUEST", ne: "false" },
    },
    {
      name: "Semaphore",
      constant: "SEMAPHORE",
      env: "SEMAPHORE",
      pr: "PULL_REQUEST_NUMBER",
    },
    { name: "Sourcehut", constant: "SOURCEHUT", env: { CI_NAME: "sourcehut" } },
    { name: "Strider CD", constant: "STRIDER", env: "STRIDER" },
    {
      name: "TaskCluster",
      constant: "TASKCLUSTER",
      env: ["TASK_ID", "RUN_ID"],
    },
    { name: "TeamCity", constant: "TEAMCITY", env: "TEAMCITY_VERSION" },
    {
      name: "Travis CI",
      constant: "TRAVIS",
      env: "TRAVIS",
      pr: { env: "TRAVIS_PULL_REQUEST", ne: "false" },
    },
    {
      name: "Vela",
      constant: "VELA",
      env: "VELA",
      pr: { VELA_PULL_REQUEST: "1" },
    },
    {
      name: "Vercel",
      constant: "VERCEL",
      env: { any: ["NOW_BUILDER", "VERCEL"] },
      pr: "VERCEL_GIT_PULL_REQUEST_ID",
    },
    {
      name: "Visual Studio App Center",
      constant: "APPCENTER",
      env: "APPCENTER_BUILD_ID",
    },
    {
      name: "Woodpecker",
      constant: "WOODPECKER",
      env: { CI: "woodpecker" },
      pr: { CI_BUILD_EVENT: "pull_request" },
    },
    {
      name: "Xcode Cloud",
      constant: "XCODE_CLOUD",
      env: "CI_XCODE_PROJECT",
      pr: "CI_PULL_REQUEST_NUMBER",
    },
    { name: "Xcode Server", constant: "XCODE_SERVER", env: "XCS" },
  ];
});
var tNe = g((ec) => {
  "use strict";
  c();
  var Zxe = Jxe(),
    In = process.env;
  Object.defineProperty(ec, "_vendors", {
    value: Zxe.map(function (e) {
      return e.constant;
    }),
  });
  ec.name = null;
  ec.isPR = null;
  ec.id = null;
  Zxe.forEach(function (e) {
    let r = (Array.isArray(e.env) ? e.env : [e.env]).every(function (n) {
      return eNe(n);
    });
    (ec[e.constant] = r),
      r && ((ec.name = e.name), (ec.isPR = $9t(e)), (ec.id = e.constant));
  });
  ec.isCI = !!(
    In.CI !== "false" &&
    (In.BUILD_ID ||
      In.BUILD_NUMBER ||
      In.CI ||
      In.CI_APP_ID ||
      In.CI_BUILD_ID ||
      In.CI_BUILD_NUMBER ||
      In.CI_NAME ||
      In.CONTINUOUS_INTEGRATION ||
      In.RUN_ID ||
      ec.name)
  );
  function eNe(e) {
    return typeof e == "string"
      ? !!In[e]
      : "env" in e
        ? In[e.env] && In[e.env].includes(e.includes)
        : "any" in e
          ? e.any.some(function (t) {
              return !!In[t];
            })
          : Object.keys(e).every(function (t) {
              return In[t] === e[t];
            });
  }
  function $9t(e) {
    switch (typeof e.pr) {
      case "string":
        return !!In[e.pr];
      case "object":
        return "env" in e.pr
          ? "any" in e.pr
            ? e.pr.any.some(function (t) {
                return In[e.pr.env] === t;
              })
            : e.pr.env in In && In[e.pr.env] !== e.pr.ne
          : "any" in e.pr
            ? e.pr.any.some(function (t) {
                return !!In[t];
              })
            : eNe(e.pr);
      default:
        return null;
    }
  }
});
var nNe = g((pIn, rNe) => {
  "use strict";
  c();
  rNe.exports = tNe().isCI;
});
var oNe = g((M_) => {
  "use strict";
  c();
  var z9t =
    (M_ && M_.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(M_, "__esModule", { value: !0 });
  M_.SerializableError = void 0;
  var iNe = z9t(G("path")),
    K9t = G("url"),
    W9t = G("os"),
    Q5 = class {
      name;
      message;
      details;
      trace;
      filePathRegex = new RegExp(
        `(file:/+)?${(0, W9t.homedir)().replaceAll("\\", "/")}[\\w.\\-_@\\\\/]+`,
        "g",
      );
      stackTraceRegex =
        /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
      arnRegex =
        /arn:[a-z0-9][-.a-z0-9]{0,62}:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}/g;
      stackRegex = /amplify-[a-zA-Z0-9-]+/g;
      constructor(t) {
        (this.name = "code" in t && t.code ? this.sanitize(t.code) : t.name),
          (this.message = this.anonymizePaths(this.sanitize(t.message))),
          (this.details =
            "details" in t
              ? this.anonymizePaths(this.sanitize(t.details))
              : void 0),
          (this.trace = this.extractStackTrace(t));
      }
      extractStackTrace = (t) => {
        let r = [];
        if (t.stack) {
          t.stack
            .split(
              `
`,
            )
            .forEach((o) => {
              let a = this.stackTraceRegex.exec(o);
              if (a) {
                let [, s, u, l, d] = a;
                r.push({
                  methodName: s,
                  file: u,
                  lineNumber: l,
                  columnNumber: d,
                });
              }
            });
          let i = this.processPaths(r.map((o) => o.file));
          r.forEach((o, a) => {
            o.file = i[a];
          });
        }
        return r;
      };
      anonymizePaths = (t) => {
        let r = t,
          n = [...r.matchAll(this.filePathRegex)];
        for (let i of n) r = r.replace(i[0], this.processPaths([i[0]])[0]);
        return r;
      };
      processPaths = (t) =>
        t.map((r) => {
          let n = r;
          return (
            this.isURLFilePath(n) && (n = (0, K9t.fileURLToPath)(n)),
            iNe.default.isAbsolute(n)
              ? iNe.default.relative(process.cwd(), n)
              : n
          );
        });
      removeARN = (t) => t?.replace(this.arnRegex, "<escaped ARN>") ?? "";
      removeStackIdentifier = (t) =>
        t?.replace(this.stackRegex, "<escaped stack>") ?? "";
      sanitize = (t) => {
        let r = t;
        return (
          (r = this.removeARN(r)),
          (r = this.removeStackIdentifier(r)),
          r.replaceAll(/["❌]/g, "")
        );
      };
      isURLFilePath = (t) => {
        try {
          return new URL(t), t.startsWith("file:");
        } catch {
          return !1;
        }
      };
    };
  M_.SerializableError = Q5;
});
var cNe = g((q_) => {
  "use strict";
  c();
  var X5 =
    (q_ && q_.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(q_, "__esModule", { value: !0 });
  q_.DefaultUsageDataEmitter = void 0;
  var Q9t = Gk(),
    Y9t = Qxe(),
    aNe = X5(G("os")),
    X9t = X5(G("https")),
    J9t = Yxe(),
    Z9t = Bw(),
    eYt = Xxe(),
    tYt = X5(nNe()),
    sNe = oNe(),
    Y5 = class {
      libraryVersion;
      dependencies;
      sessionUuid;
      url;
      accountIdFetcher;
      dependenciesToReport;
      constructor(
        t,
        r,
        n = (0, Q9t.v4)(),
        i = (0, eYt.getUrl)(),
        o = new Y9t.AccountIdFetcher(),
      ) {
        (this.libraryVersion = t),
          (this.dependencies = r),
          (this.sessionUuid = n),
          (this.url = i),
          (this.accountIdFetcher = o);
        let a = ["@aws-cdk/toolkit-lib", "aws-cdk-lib"];
        this.dependenciesToReport = this.dependencies?.filter((s) =>
          a.includes(s.name),
        );
      }
      emitSuccess = async (t, r) => {
        try {
          let n = await this.getUsageData({
            state: "SUCCEEDED",
            metrics: t,
            dimensions: r,
          });
          await this.send(n);
        } catch {}
      };
      emitFailure = async (t, r) => {
        try {
          let n = await this.getUsageData({
            state: "FAILED",
            error: t,
            dimensions: r,
          });
          await this.send(n);
        } catch {}
      };
      getUsageData = async (t) => ({
        accountId: await this.accountIdFetcher.fetch(),
        sessionUuid: this.sessionUuid,
        installationUuid: (0, J9t.getInstallationUuid)(),
        amplifyCliVersion: this.libraryVersion,
        timestamp: new Date().toISOString(),
        error: t.error ? new sNe.SerializableError(t.error) : void 0,
        downstreamException:
          t.error && t.error.cause && t.error.cause instanceof Error
            ? new sNe.SerializableError(t.error.cause)
            : void 0,
        payloadVersion: Z9t.latestPayloadVersion,
        osPlatform: aNe.default.platform(),
        osRelease: aNe.default.release(),
        nodeVersion: process.versions.node,
        state: t.state,
        codePathDurations: this.translateMetricsToUsageData(t.metrics),
        input: this.translateDimensionsToUsageData(t.dimensions),
        isCi: tYt.default,
        projectSetting: {
          editor: process.env.npm_config_user_agent,
          details: JSON.stringify(this.dependenciesToReport),
        },
      });
      send = (t) =>
        new Promise((r) => {
          let n = JSON.stringify(t),
            i = X9t.default.request({
              hostname: this.url.hostname,
              port: this.url.port,
              path: this.url.path,
              method: "POST",
              headers: {
                "content-type": "application/json",
                "content-length": n.length,
              },
            });
          i.on("error", () => {}),
            i.setTimeout(2e3, () => {
              r();
            }),
            i.write(n),
            i.end(() => {
              r();
            });
        });
      translateMetricsToUsageData = (t) => {
        if (!t) return {};
        let r, n;
        for (let [i, o] of Object.entries(t))
          i === "totalTime"
            ? (r = Math.round(o))
            : i === "synthesisTime" && (n = Math.round(o));
        return { totalDuration: r, platformStartup: n };
      };
      translateDimensionsToUsageData = (t) => {
        let r = "";
        if (t) for (let [n, i] of Object.entries(t)) n === "command" && (r = i);
        return { command: r, plugin: "Gen2" };
      };
    };
  q_.DefaultUsageDataEmitter = Y5;
});
var uNe = g((YM) => {
  "use strict";
  c();
  Object.defineProperty(YM, "__esModule", { value: !0 });
  YM.UsageDataEmitterFactory = void 0;
  var rYt = e4(),
    nYt = Dve(),
    iYt = cNe(),
    oYt = Bw(),
    J5 = class {
      getInstance = async (t, r) => {
        let i =
          (await rYt.configControllerFactory
            .getInstance("usage_data_preferences.json")
            .get(oYt.USAGE_DATA_TRACKING_ENABLED)) === !1;
        return process.env.AMPLIFY_DISABLE_TELEMETRY || i
          ? new nYt.NoOpUsageDataEmitter()
          : new iYt.DefaultUsageDataEmitter(t, r);
      };
    };
  YM.UsageDataEmitterFactory = J5;
});
var dNe = g((j_) => {
  "use strict";
  c();
  var lNe =
    (j_ && j_.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(j_, "__esModule", { value: !0 });
  j_.ZodSchemaTypedConfigurationFile = void 0;
  var aYt = JK(),
    sYt = lNe(G("path")),
    cYt = lNe(G("fs/promises")),
    uYt = G("fs"),
    Z5 = class {
      schema;
      defaultValue;
      _fsp;
      _existsSync;
      filePath;
      data;
      constructor(t, r, n, i = cYt.default, o = uYt.existsSync) {
        (this.schema = t),
          (this.defaultValue = n),
          (this._fsp = i),
          (this._existsSync = o),
          (this.filePath = sYt.default.join((0, aYt.getConfigDirPath)(), r));
      }
      read = async () => {
        if (!this.data)
          if (this._existsSync(this.filePath)) {
            let t = await this._fsp.readFile(this.filePath, "utf-8");
            try {
              let r = JSON.parse(t);
              this.data = this.schema.parse(r);
            } catch {
              this.data = this.schema.parse(this.defaultValue);
            }
          } else this.data = this.schema.parse(this.defaultValue);
        return this.schema.parse(this.data);
      };
      write = async (t) => {
        await this._fsp.writeFile(this.filePath, JSON.stringify(t, null, 2)),
          (this.data = t);
      };
      delete = async () => {
        this._existsSync(this.filePath) &&
          (await this._fsp.unlink(this.filePath)),
          (this.data = void 0);
      };
    };
  j_.ZodSchemaTypedConfigurationFile = Z5;
});
var fNe = g((F_) => {
  "use strict";
  c();
  Object.defineProperty(F_, "__esModule", { value: !0 });
  F_.typedConfigurationFileFactory = F_.TypedConfigurationFileFactory = void 0;
  var lYt = dNe(),
    XM = class {
      files;
      constructor() {
        this.files = {};
      }
      getInstance = (t, r, n) =>
        this.files[t]
          ? this.files[t]
          : ((this.files[t] = new lYt.ZodSchemaTypedConfigurationFile(r, t, n)),
            this.files[t]);
    };
  F_.TypedConfigurationFileFactory = XM;
  F_.typedConfigurationFileFactory = new XM();
});
var mNe = g((JM) => {
  "use strict";
  c();
  Object.defineProperty(JM, "__esModule", { value: !0 });
  JM.CDKContextKey = void 0;
  var pNe;
  (function (e) {
    (e.BACKEND_NAME = "amplify-backend-name"),
      (e.BACKEND_NAMESPACE = "amplify-backend-namespace"),
      (e.DEPLOYMENT_TYPE = "amplify-backend-type");
  })(pNe || (JM.CDKContextKey = pNe = {}));
});
var _Ne = g((ZM) => {
  "use strict";
  c();
  Object.defineProperty(ZM, "__esModule", { value: !0 });
  ZM.ParameterPathConversions = void 0;
  var hNe = NK(),
    dYt = Oy(),
    fYt = "shared",
    pYt = "resource_reference",
    eQ = class {
      static toParameterPrefix(t) {
        return typeof t == "object" ? gNe(t) : yNe(t);
      }
      static toParameterFullPath(t, r) {
        return typeof t == "object" ? mYt(t, r) : hYt(t, r);
      }
      static toResourceReferenceFullPath(t, r) {
        return `/amplify/${pYt}/${vNe(t)}/${r}`;
      }
    };
  ZM.ParameterPathConversions = eQ;
  var gNe = (e) => `/amplify/${vNe(e)}`,
    vNe = (e) => {
      let t = hNe.BackendIdentifierConversions.fromStackName(
        hNe.BackendIdentifierConversions.toStackName(e),
      );
      if (!t || !t.hash)
        throw new dYt.AmplifyFault("BackendIdConversionFault", {
          message:
            "Could not sanitize the backendId to construct the parameter path",
        });
      return `${t.namespace}/${t.name}-${t.type}-${t.hash}`;
    },
    mYt = (e, t) => `${gNe(e)}/${t}`,
    yNe = (e) => `/amplify/${fYt}/${e}`,
    hYt = (e, t) => `${yNe(e)}/${t}`;
});
var WNe = g((Uw, B_) => {
  c();
  var gYt = 200,
    RNe = "__lodash_hash_undefined__",
    vYt = 800,
    yYt = 16,
    INe = 9007199254740991,
    xNe = "[object Arguments]",
    _Yt = "[object Array]",
    EYt = "[object AsyncFunction]",
    bYt = "[object Boolean]",
    SYt = "[object Date]",
    CYt = "[object Error]",
    NNe = "[object Function]",
    wYt = "[object GeneratorFunction]",
    OYt = "[object Map]",
    TYt = "[object Number]",
    AYt = "[object Null]",
    kNe = "[object Object]",
    PYt = "[object Proxy]",
    RYt = "[object RegExp]",
    IYt = "[object Set]",
    xYt = "[object String]",
    NYt = "[object Undefined]",
    kYt = "[object WeakMap]",
    DYt = "[object ArrayBuffer]",
    LYt = "[object DataView]",
    MYt = "[object Float32Array]",
    qYt = "[object Float64Array]",
    jYt = "[object Int8Array]",
    FYt = "[object Int16Array]",
    BYt = "[object Int32Array]",
    UYt = "[object Uint8Array]",
    HYt = "[object Uint8ClampedArray]",
    GYt = "[object Uint16Array]",
    VYt = "[object Uint32Array]",
    $Yt = /[\\^$.*+?()[\]{}|]/g,
    zYt = /^\[object .+?Constructor\]$/,
    KYt = /^(?:0|[1-9]\d*)$/,
    qr = {};
  qr[MYt] =
    qr[qYt] =
    qr[jYt] =
    qr[FYt] =
    qr[BYt] =
    qr[UYt] =
    qr[HYt] =
    qr[GYt] =
    qr[VYt] =
      !0;
  qr[xNe] =
    qr[_Yt] =
    qr[DYt] =
    qr[bYt] =
    qr[LYt] =
    qr[SYt] =
    qr[CYt] =
    qr[NNe] =
    qr[OYt] =
    qr[TYt] =
    qr[kNe] =
    qr[RYt] =
    qr[IYt] =
    qr[xYt] =
    qr[kYt] =
      !1;
  var DNe =
      typeof global == "object" && global && global.Object === Object && global,
    WYt = typeof self == "object" && self && self.Object === Object && self,
    Vw = DNe || WYt || Function("return this")(),
    LNe = typeof Uw == "object" && Uw && !Uw.nodeType && Uw,
    Hw = LNe && typeof B_ == "object" && B_ && !B_.nodeType && B_,
    MNe = Hw && Hw.exports === LNe,
    tQ = MNe && DNe.process,
    ENe = (function () {
      try {
        var e = Hw && Hw.require && Hw.require("util").types;
        return e || (tQ && tQ.binding && tQ.binding("util"));
      } catch {}
    })(),
    bNe = ENe && ENe.isTypedArray;
  function QYt(e, t, r) {
    switch (r.length) {
      case 0:
        return e.call(t);
      case 1:
        return e.call(t, r[0]);
      case 2:
        return e.call(t, r[0], r[1]);
      case 3:
        return e.call(t, r[0], r[1], r[2]);
    }
    return e.apply(t, r);
  }
  function YYt(e, t) {
    for (var r = -1, n = Array(e); ++r < e; ) n[r] = t(r);
    return n;
  }
  function XYt(e) {
    return function (t) {
      return e(t);
    };
  }
  function JYt(e, t) {
    return e?.[t];
  }
  function ZYt(e, t) {
    return function (r) {
      return e(t(r));
    };
  }
  var eXt = Array.prototype,
    tXt = Function.prototype,
    rq = Object.prototype,
    rQ = Vw["__core-js_shared__"],
    nq = tXt.toString,
    Ml = rq.hasOwnProperty,
    SNe = (function () {
      var e = /[^.]+$/.exec((rQ && rQ.keys && rQ.keys.IE_PROTO) || "");
      return e ? "Symbol(src)_1." + e : "";
    })(),
    qNe = rq.toString,
    rXt = nq.call(Object),
    nXt = RegExp(
      "^" +
        nq
          .call(Ml)
          .replace($Yt, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?",
          ) +
        "$",
    ),
    eq = MNe ? Vw.Buffer : void 0,
    CNe = Vw.Symbol,
    wNe = Vw.Uint8Array,
    ONe = eq ? eq.allocUnsafe : void 0,
    jNe = ZYt(Object.getPrototypeOf, Object),
    TNe = Object.create,
    iXt = rq.propertyIsEnumerable,
    oXt = eXt.splice,
    Sh = CNe ? CNe.toStringTag : void 0,
    tq = (function () {
      try {
        var e = cQ(Object, "defineProperty");
        return e({}, "", {}), e;
      } catch {}
    })(),
    aXt = eq ? eq.isBuffer : void 0,
    ANe = Math.max,
    sXt = Date.now,
    FNe = cQ(Vw, "Map"),
    Gw = cQ(Object, "create"),
    cXt = (function () {
      function e() {}
      return function (t) {
        if (!wh(t)) return {};
        if (TNe) return TNe(t);
        e.prototype = t;
        var r = new e();
        return (e.prototype = void 0), r;
      };
    })();
  function Ch(e) {
    var t = -1,
      r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  function uXt() {
    (this.__data__ = Gw ? Gw(null) : {}), (this.size = 0);
  }
  function lXt(e) {
    var t = this.has(e) && delete this.__data__[e];
    return (this.size -= t ? 1 : 0), t;
  }
  function dXt(e) {
    var t = this.__data__;
    if (Gw) {
      var r = t[e];
      return r === RNe ? void 0 : r;
    }
    return Ml.call(t, e) ? t[e] : void 0;
  }
  function fXt(e) {
    var t = this.__data__;
    return Gw ? t[e] !== void 0 : Ml.call(t, e);
  }
  function pXt(e, t) {
    var r = this.__data__;
    return (
      (this.size += this.has(e) ? 0 : 1),
      (r[e] = Gw && t === void 0 ? RNe : t),
      this
    );
  }
  Ch.prototype.clear = uXt;
  Ch.prototype.delete = lXt;
  Ch.prototype.get = dXt;
  Ch.prototype.has = fXt;
  Ch.prototype.set = pXt;
  function ql(e) {
    var t = -1,
      r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  function mXt() {
    (this.__data__ = []), (this.size = 0);
  }
  function hXt(e) {
    var t = this.__data__,
      r = iq(t, e);
    if (r < 0) return !1;
    var n = t.length - 1;
    return r == n ? t.pop() : oXt.call(t, r, 1), --this.size, !0;
  }
  function gXt(e) {
    var t = this.__data__,
      r = iq(t, e);
    return r < 0 ? void 0 : t[r][1];
  }
  function vXt(e) {
    return iq(this.__data__, e) > -1;
  }
  function yXt(e, t) {
    var r = this.__data__,
      n = iq(r, e);
    return n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this;
  }
  ql.prototype.clear = mXt;
  ql.prototype.delete = hXt;
  ql.prototype.get = gXt;
  ql.prototype.has = vXt;
  ql.prototype.set = yXt;
  function U_(e) {
    var t = -1,
      r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  function _Xt() {
    (this.size = 0),
      (this.__data__ = {
        hash: new Ch(),
        map: new (FNe || ql)(),
        string: new Ch(),
      });
  }
  function EXt(e) {
    var t = aq(this, e).delete(e);
    return (this.size -= t ? 1 : 0), t;
  }
  function bXt(e) {
    return aq(this, e).get(e);
  }
  function SXt(e) {
    return aq(this, e).has(e);
  }
  function CXt(e, t) {
    var r = aq(this, e),
      n = r.size;
    return r.set(e, t), (this.size += r.size == n ? 0 : 1), this;
  }
  U_.prototype.clear = _Xt;
  U_.prototype.delete = EXt;
  U_.prototype.get = bXt;
  U_.prototype.has = SXt;
  U_.prototype.set = CXt;
  function H_(e) {
    var t = (this.__data__ = new ql(e));
    this.size = t.size;
  }
  function wXt() {
    (this.__data__ = new ql()), (this.size = 0);
  }
  function OXt(e) {
    var t = this.__data__,
      r = t.delete(e);
    return (this.size = t.size), r;
  }
  function TXt(e) {
    return this.__data__.get(e);
  }
  function AXt(e) {
    return this.__data__.has(e);
  }
  function PXt(e, t) {
    var r = this.__data__;
    if (r instanceof ql) {
      var n = r.__data__;
      if (!FNe || n.length < gYt - 1)
        return n.push([e, t]), (this.size = ++r.size), this;
      r = this.__data__ = new U_(n);
    }
    return r.set(e, t), (this.size = r.size), this;
  }
  H_.prototype.clear = wXt;
  H_.prototype.delete = OXt;
  H_.prototype.get = TXt;
  H_.prototype.has = AXt;
  H_.prototype.set = PXt;
  function RXt(e, t) {
    var r = aQ(e),
      n = !r && oQ(e),
      i = !r && !n && GNe(e),
      o = !r && !n && !i && $Ne(e),
      a = r || n || i || o,
      s = a ? YYt(e.length, String) : [],
      u = s.length;
    for (var l in e)
      (t || Ml.call(e, l)) &&
        !(
          a &&
          (l == "length" ||
            (i && (l == "offset" || l == "parent")) ||
            (o && (l == "buffer" || l == "byteLength" || l == "byteOffset")) ||
            UNe(l, u))
        ) &&
        s.push(l);
    return s;
  }
  function nQ(e, t, r) {
    ((r !== void 0 && !sq(e[t], r)) || (r === void 0 && !(t in e))) &&
      sQ(e, t, r);
  }
  function IXt(e, t, r) {
    var n = e[t];
    (!(Ml.call(e, t) && sq(n, r)) || (r === void 0 && !(t in e))) &&
      sQ(e, t, r);
  }
  function iq(e, t) {
    for (var r = e.length; r--; ) if (sq(e[r][0], t)) return r;
    return -1;
  }
  function sQ(e, t, r) {
    t == "__proto__" && tq
      ? tq(e, t, { configurable: !0, enumerable: !0, value: r, writable: !0 })
      : (e[t] = r);
  }
  var xXt = VXt();
  function oq(e) {
    return e == null
      ? e === void 0
        ? NYt
        : AYt
      : Sh && Sh in Object(e)
        ? $Xt(e)
        : XXt(e);
  }
  function PNe(e) {
    return $w(e) && oq(e) == xNe;
  }
  function NXt(e) {
    if (!wh(e) || QXt(e)) return !1;
    var t = lQ(e) ? nXt : zYt;
    return t.test(t7t(e));
  }
  function kXt(e) {
    return $w(e) && VNe(e.length) && !!qr[oq(e)];
  }
  function DXt(e) {
    if (!wh(e)) return YXt(e);
    var t = HNe(e),
      r = [];
    for (var n in e) (n == "constructor" && (t || !Ml.call(e, n))) || r.push(n);
    return r;
  }
  function BNe(e, t, r, n, i) {
    e !== t &&
      xXt(
        t,
        function (o, a) {
          if ((i || (i = new H_()), wh(o))) LXt(e, t, a, r, BNe, n, i);
          else {
            var s = n ? n(iQ(e, a), o, a + "", e, t, i) : void 0;
            s === void 0 && (s = o), nQ(e, a, s);
          }
        },
        zNe,
      );
  }
  function LXt(e, t, r, n, i, o, a) {
    var s = iQ(e, r),
      u = iQ(t, r),
      l = a.get(u);
    if (l) {
      nQ(e, r, l);
      return;
    }
    var d = o ? o(s, u, r + "", e, t, a) : void 0,
      f = d === void 0;
    if (f) {
      var m = aQ(u),
        h = !m && GNe(u),
        y = !m && !h && $Ne(u);
      (d = u),
        m || h || y
          ? aQ(s)
            ? (d = s)
            : r7t(s)
              ? (d = UXt(s))
              : h
                ? ((f = !1), (d = jXt(u, !0)))
                : y
                  ? ((f = !1), (d = BXt(u, !0)))
                  : (d = [])
          : n7t(u) || oQ(u)
            ? ((d = s),
              oQ(s) ? (d = i7t(s)) : (!wh(s) || lQ(s)) && (d = zXt(u)))
            : (f = !1);
    }
    f && (a.set(u, d), i(d, u, n, o, a), a.delete(u)), nQ(e, r, d);
  }
  function MXt(e, t) {
    return ZXt(JXt(e, t, KNe), e + "");
  }
  var qXt = tq
    ? function (e, t) {
        return tq(e, "toString", {
          configurable: !0,
          enumerable: !1,
          value: a7t(t),
          writable: !0,
        });
      }
    : KNe;
  function jXt(e, t) {
    if (t) return e.slice();
    var r = e.length,
      n = ONe ? ONe(r) : new e.constructor(r);
    return e.copy(n), n;
  }
  function FXt(e) {
    var t = new e.constructor(e.byteLength);
    return new wNe(t).set(new wNe(e)), t;
  }
  function BXt(e, t) {
    var r = t ? FXt(e.buffer) : e.buffer;
    return new e.constructor(r, e.byteOffset, e.length);
  }
  function UXt(e, t) {
    var r = -1,
      n = e.length;
    for (t || (t = Array(n)); ++r < n; ) t[r] = e[r];
    return t;
  }
  function HXt(e, t, r, n) {
    var i = !r;
    r || (r = {});
    for (var o = -1, a = t.length; ++o < a; ) {
      var s = t[o],
        u = n ? n(r[s], e[s], s, r, e) : void 0;
      u === void 0 && (u = e[s]), i ? sQ(r, s, u) : IXt(r, s, u);
    }
    return r;
  }
  function GXt(e) {
    return MXt(function (t, r) {
      var n = -1,
        i = r.length,
        o = i > 1 ? r[i - 1] : void 0,
        a = i > 2 ? r[2] : void 0;
      for (
        o = e.length > 3 && typeof o == "function" ? (i--, o) : void 0,
          a && KXt(r[0], r[1], a) && ((o = i < 3 ? void 0 : o), (i = 1)),
          t = Object(t);
        ++n < i;

      ) {
        var s = r[n];
        s && e(t, s, n, o);
      }
      return t;
    });
  }
  function VXt(e) {
    return function (t, r, n) {
      for (var i = -1, o = Object(t), a = n(t), s = a.length; s--; ) {
        var u = a[e ? s : ++i];
        if (r(o[u], u, o) === !1) break;
      }
      return t;
    };
  }
  function aq(e, t) {
    var r = e.__data__;
    return WXt(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
  }
  function cQ(e, t) {
    var r = JYt(e, t);
    return NXt(r) ? r : void 0;
  }
  function $Xt(e) {
    var t = Ml.call(e, Sh),
      r = e[Sh];
    try {
      e[Sh] = void 0;
      var n = !0;
    } catch {}
    var i = qNe.call(e);
    return n && (t ? (e[Sh] = r) : delete e[Sh]), i;
  }
  function zXt(e) {
    return typeof e.constructor == "function" && !HNe(e) ? cXt(jNe(e)) : {};
  }
  function UNe(e, t) {
    var r = typeof e;
    return (
      (t = t ?? INe),
      !!t &&
        (r == "number" || (r != "symbol" && KYt.test(e))) &&
        e > -1 &&
        e % 1 == 0 &&
        e < t
    );
  }
  function KXt(e, t, r) {
    if (!wh(r)) return !1;
    var n = typeof t;
    return (n == "number" ? uQ(r) && UNe(t, r.length) : n == "string" && t in r)
      ? sq(r[t], e)
      : !1;
  }
  function WXt(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean"
      ? e !== "__proto__"
      : e === null;
  }
  function QXt(e) {
    return !!SNe && SNe in e;
  }
  function HNe(e) {
    var t = e && e.constructor,
      r = (typeof t == "function" && t.prototype) || rq;
    return e === r;
  }
  function YXt(e) {
    var t = [];
    if (e != null) for (var r in Object(e)) t.push(r);
    return t;
  }
  function XXt(e) {
    return qNe.call(e);
  }
  function JXt(e, t, r) {
    return (
      (t = ANe(t === void 0 ? e.length - 1 : t, 0)),
      function () {
        for (
          var n = arguments, i = -1, o = ANe(n.length - t, 0), a = Array(o);
          ++i < o;

        )
          a[i] = n[t + i];
        i = -1;
        for (var s = Array(t + 1); ++i < t; ) s[i] = n[i];
        return (s[t] = r(a)), QYt(e, this, s);
      }
    );
  }
  function iQ(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
      return e[t];
  }
  var ZXt = e7t(qXt);
  function e7t(e) {
    var t = 0,
      r = 0;
    return function () {
      var n = sXt(),
        i = yYt - (n - r);
      if (((r = n), i > 0)) {
        if (++t >= vYt) return arguments[0];
      } else t = 0;
      return e.apply(void 0, arguments);
    };
  }
  function t7t(e) {
    if (e != null) {
      try {
        return nq.call(e);
      } catch {}
      try {
        return e + "";
      } catch {}
    }
    return "";
  }
  function sq(e, t) {
    return e === t || (e !== e && t !== t);
  }
  var oQ = PNe(
      (function () {
        return arguments;
      })(),
    )
      ? PNe
      : function (e) {
          return $w(e) && Ml.call(e, "callee") && !iXt.call(e, "callee");
        },
    aQ = Array.isArray;
  function uQ(e) {
    return e != null && VNe(e.length) && !lQ(e);
  }
  function r7t(e) {
    return $w(e) && uQ(e);
  }
  var GNe = aXt || s7t;
  function lQ(e) {
    if (!wh(e)) return !1;
    var t = oq(e);
    return t == NNe || t == wYt || t == EYt || t == PYt;
  }
  function VNe(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= INe;
  }
  function wh(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  function $w(e) {
    return e != null && typeof e == "object";
  }
  function n7t(e) {
    if (!$w(e) || oq(e) != kNe) return !1;
    var t = jNe(e);
    if (t === null) return !0;
    var r = Ml.call(t, "constructor") && t.constructor;
    return typeof r == "function" && r instanceof r && nq.call(r) == rXt;
  }
  var $Ne = bNe ? XYt(bNe) : kXt;
  function i7t(e) {
    return HXt(e, zNe(e));
  }
  function zNe(e) {
    return uQ(e) ? RXt(e, !0) : DXt(e);
  }
  var o7t = GXt(function (e, t, r, n) {
    BNe(e, t, r, n);
  });
  function a7t(e) {
    return function () {
      return e;
    };
  }
  function KNe(e) {
    return e;
  }
  function s7t() {
    return !1;
  }
  B_.exports = o7t;
});
var zw = g((IIn, QNe) => {
  c();
  var c7t = "2.0.0",
    u7t = Number.MAX_SAFE_INTEGER || 9007199254740991,
    l7t = 16,
    d7t = 250,
    f7t = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease",
    ];
  QNe.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: l7t,
    MAX_SAFE_BUILD_LENGTH: d7t,
    MAX_SAFE_INTEGER: u7t,
    RELEASE_TYPES: f7t,
    SEMVER_SPEC_VERSION: c7t,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2,
  };
});
var Kw = g((NIn, YNe) => {
  c();
  var p7t =
    typeof process == "object" &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ? (...e) => console.error("SEMVER", ...e)
      : () => {};
  YNe.exports = p7t;
});
var G_ = g((ru, XNe) => {
  c();
  var {
      MAX_SAFE_COMPONENT_LENGTH: dQ,
      MAX_SAFE_BUILD_LENGTH: m7t,
      MAX_LENGTH: h7t,
    } = zw(),
    g7t = Kw();
  ru = XNe.exports = {};
  var v7t = (ru.re = []),
    y7t = (ru.safeRe = []),
    Ce = (ru.src = []),
    _7t = (ru.safeSrc = []),
    we = (ru.t = {}),
    E7t = 0,
    fQ = "[a-zA-Z0-9-]",
    b7t = [
      ["\\s", 1],
      ["\\d", h7t],
      [fQ, m7t],
    ],
    S7t = (e) => {
      for (let [t, r] of b7t)
        e = e
          .split(`${t}*`)
          .join(`${t}{0,${r}}`)
          .split(`${t}+`)
          .join(`${t}{1,${r}}`);
      return e;
    },
    Xe = (e, t, r) => {
      let n = S7t(t),
        i = E7t++;
      g7t(e, i, t),
        (we[e] = i),
        (Ce[i] = t),
        (_7t[i] = n),
        (v7t[i] = new RegExp(t, r ? "g" : void 0)),
        (y7t[i] = new RegExp(n, r ? "g" : void 0));
    };
  Xe("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  Xe("NUMERICIDENTIFIERLOOSE", "\\d+");
  Xe("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${fQ}*`);
  Xe(
    "MAINVERSION",
    `(${Ce[we.NUMERICIDENTIFIER]})\\.(${Ce[we.NUMERICIDENTIFIER]})\\.(${Ce[we.NUMERICIDENTIFIER]})`,
  );
  Xe(
    "MAINVERSIONLOOSE",
    `(${Ce[we.NUMERICIDENTIFIERLOOSE]})\\.(${Ce[we.NUMERICIDENTIFIERLOOSE]})\\.(${Ce[we.NUMERICIDENTIFIERLOOSE]})`,
  );
  Xe(
    "PRERELEASEIDENTIFIER",
    `(?:${Ce[we.NUMERICIDENTIFIER]}|${Ce[we.NONNUMERICIDENTIFIER]})`,
  );
  Xe(
    "PRERELEASEIDENTIFIERLOOSE",
    `(?:${Ce[we.NUMERICIDENTIFIERLOOSE]}|${Ce[we.NONNUMERICIDENTIFIER]})`,
  );
  Xe(
    "PRERELEASE",
    `(?:-(${Ce[we.PRERELEASEIDENTIFIER]}(?:\\.${Ce[we.PRERELEASEIDENTIFIER]})*))`,
  );
  Xe(
    "PRERELEASELOOSE",
    `(?:-?(${Ce[we.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${Ce[we.PRERELEASEIDENTIFIERLOOSE]})*))`,
  );
  Xe("BUILDIDENTIFIER", `${fQ}+`);
  Xe(
    "BUILD",
    `(?:\\+(${Ce[we.BUILDIDENTIFIER]}(?:\\.${Ce[we.BUILDIDENTIFIER]})*))`,
  );
  Xe(
    "FULLPLAIN",
    `v?${Ce[we.MAINVERSION]}${Ce[we.PRERELEASE]}?${Ce[we.BUILD]}?`,
  );
  Xe("FULL", `^${Ce[we.FULLPLAIN]}$`);
  Xe(
    "LOOSEPLAIN",
    `[v=\\s]*${Ce[we.MAINVERSIONLOOSE]}${Ce[we.PRERELEASELOOSE]}?${Ce[we.BUILD]}?`,
  );
  Xe("LOOSE", `^${Ce[we.LOOSEPLAIN]}$`);
  Xe("GTLT", "((?:<|>)?=?)");
  Xe("XRANGEIDENTIFIERLOOSE", `${Ce[we.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  Xe("XRANGEIDENTIFIER", `${Ce[we.NUMERICIDENTIFIER]}|x|X|\\*`);
  Xe(
    "XRANGEPLAIN",
    `[v=\\s]*(${Ce[we.XRANGEIDENTIFIER]})(?:\\.(${Ce[we.XRANGEIDENTIFIER]})(?:\\.(${Ce[we.XRANGEIDENTIFIER]})(?:${Ce[we.PRERELEASE]})?${Ce[we.BUILD]}?)?)?`,
  );
  Xe(
    "XRANGEPLAINLOOSE",
    `[v=\\s]*(${Ce[we.XRANGEIDENTIFIERLOOSE]})(?:\\.(${Ce[we.XRANGEIDENTIFIERLOOSE]})(?:\\.(${Ce[we.XRANGEIDENTIFIERLOOSE]})(?:${Ce[we.PRERELEASELOOSE]})?${Ce[we.BUILD]}?)?)?`,
  );
  Xe("XRANGE", `^${Ce[we.GTLT]}\\s*${Ce[we.XRANGEPLAIN]}$`);
  Xe("XRANGELOOSE", `^${Ce[we.GTLT]}\\s*${Ce[we.XRANGEPLAINLOOSE]}$`);
  Xe(
    "COERCEPLAIN",
    `(^|[^\\d])(\\d{1,${dQ}})(?:\\.(\\d{1,${dQ}}))?(?:\\.(\\d{1,${dQ}}))?`,
  );
  Xe("COERCE", `${Ce[we.COERCEPLAIN]}(?:$|[^\\d])`);
  Xe(
    "COERCEFULL",
    Ce[we.COERCEPLAIN] +
      `(?:${Ce[we.PRERELEASE]})?(?:${Ce[we.BUILD]})?(?:$|[^\\d])`,
  );
  Xe("COERCERTL", Ce[we.COERCE], !0);
  Xe("COERCERTLFULL", Ce[we.COERCEFULL], !0);
  Xe("LONETILDE", "(?:~>?)");
  Xe("TILDETRIM", `(\\s*)${Ce[we.LONETILDE]}\\s+`, !0);
  ru.tildeTrimReplace = "$1~";
  Xe("TILDE", `^${Ce[we.LONETILDE]}${Ce[we.XRANGEPLAIN]}$`);
  Xe("TILDELOOSE", `^${Ce[we.LONETILDE]}${Ce[we.XRANGEPLAINLOOSE]}$`);
  Xe("LONECARET", "(?:\\^)");
  Xe("CARETTRIM", `(\\s*)${Ce[we.LONECARET]}\\s+`, !0);
  ru.caretTrimReplace = "$1^";
  Xe("CARET", `^${Ce[we.LONECARET]}${Ce[we.XRANGEPLAIN]}$`);
  Xe("CARETLOOSE", `^${Ce[we.LONECARET]}${Ce[we.XRANGEPLAINLOOSE]}$`);
  Xe("COMPARATORLOOSE", `^${Ce[we.GTLT]}\\s*(${Ce[we.LOOSEPLAIN]})$|^$`);
  Xe("COMPARATOR", `^${Ce[we.GTLT]}\\s*(${Ce[we.FULLPLAIN]})$|^$`);
  Xe(
    "COMPARATORTRIM",
    `(\\s*)${Ce[we.GTLT]}\\s*(${Ce[we.LOOSEPLAIN]}|${Ce[we.XRANGEPLAIN]})`,
    !0,
  );
  ru.comparatorTrimReplace = "$1$2$3";
  Xe(
    "HYPHENRANGE",
    `^\\s*(${Ce[we.XRANGEPLAIN]})\\s+-\\s+(${Ce[we.XRANGEPLAIN]})\\s*$`,
  );
  Xe(
    "HYPHENRANGELOOSE",
    `^\\s*(${Ce[we.XRANGEPLAINLOOSE]})\\s+-\\s+(${Ce[we.XRANGEPLAINLOOSE]})\\s*$`,
  );
  Xe("STAR", "(<|>)?=?\\s*\\*");
  Xe("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  Xe("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});
var cq = g((LIn, JNe) => {
  c();
  var C7t = Object.freeze({ loose: !0 }),
    w7t = Object.freeze({}),
    O7t = (e) => (e ? (typeof e != "object" ? C7t : e) : w7t);
  JNe.exports = O7t;
});
var pQ = g((qIn, tke) => {
  c();
  var ZNe = /^[0-9]+$/,
    eke = (e, t) => {
      let r = ZNe.test(e),
        n = ZNe.test(t);
      return (
        r && n && ((e = +e), (t = +t)),
        e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1
      );
    },
    T7t = (e, t) => eke(t, e);
  tke.exports = { compareIdentifiers: eke, rcompareIdentifiers: T7t };
});
var zi = g((FIn, oke) => {
  c();
  var uq = Kw(),
    { MAX_LENGTH: rke, MAX_SAFE_INTEGER: lq } = zw(),
    { safeRe: nke, safeSrc: ike, t: dq } = G_(),
    A7t = cq(),
    { compareIdentifiers: V_ } = pQ(),
    mQ = class e {
      constructor(t, r) {
        if (((r = A7t(r)), t instanceof e)) {
          if (
            t.loose === !!r.loose &&
            t.includePrerelease === !!r.includePrerelease
          )
            return t;
          t = t.version;
        } else if (typeof t != "string")
          throw new TypeError(
            `Invalid version. Must be a string. Got type "${typeof t}".`,
          );
        if (t.length > rke)
          throw new TypeError(`version is longer than ${rke} characters`);
        uq("SemVer", t, r),
          (this.options = r),
          (this.loose = !!r.loose),
          (this.includePrerelease = !!r.includePrerelease);
        let n = t.trim().match(r.loose ? nke[dq.LOOSE] : nke[dq.FULL]);
        if (!n) throw new TypeError(`Invalid Version: ${t}`);
        if (
          ((this.raw = t),
          (this.major = +n[1]),
          (this.minor = +n[2]),
          (this.patch = +n[3]),
          this.major > lq || this.major < 0)
        )
          throw new TypeError("Invalid major version");
        if (this.minor > lq || this.minor < 0)
          throw new TypeError("Invalid minor version");
        if (this.patch > lq || this.patch < 0)
          throw new TypeError("Invalid patch version");
        n[4]
          ? (this.prerelease = n[4].split(".").map((i) => {
              if (/^[0-9]+$/.test(i)) {
                let o = +i;
                if (o >= 0 && o < lq) return o;
              }
              return i;
            }))
          : (this.prerelease = []),
          (this.build = n[5] ? n[5].split(".") : []),
          this.format();
      }
      format() {
        return (
          (this.version = `${this.major}.${this.minor}.${this.patch}`),
          this.prerelease.length &&
            (this.version += `-${this.prerelease.join(".")}`),
          this.version
        );
      }
      toString() {
        return this.version;
      }
      compare(t) {
        if (
          (uq("SemVer.compare", this.version, this.options, t),
          !(t instanceof e))
        ) {
          if (typeof t == "string" && t === this.version) return 0;
          t = new e(t, this.options);
        }
        return t.version === this.version
          ? 0
          : this.compareMain(t) || this.comparePre(t);
      }
      compareMain(t) {
        return (
          t instanceof e || (t = new e(t, this.options)),
          V_(this.major, t.major) ||
            V_(this.minor, t.minor) ||
            V_(this.patch, t.patch)
        );
      }
      comparePre(t) {
        if (
          (t instanceof e || (t = new e(t, this.options)),
          this.prerelease.length && !t.prerelease.length)
        )
          return -1;
        if (!this.prerelease.length && t.prerelease.length) return 1;
        if (!this.prerelease.length && !t.prerelease.length) return 0;
        let r = 0;
        do {
          let n = this.prerelease[r],
            i = t.prerelease[r];
          if ((uq("prerelease compare", r, n, i), n === void 0 && i === void 0))
            return 0;
          if (i === void 0) return 1;
          if (n === void 0) return -1;
          if (n === i) continue;
          return V_(n, i);
        } while (++r);
      }
      compareBuild(t) {
        t instanceof e || (t = new e(t, this.options));
        let r = 0;
        do {
          let n = this.build[r],
            i = t.build[r];
          if ((uq("build compare", r, n, i), n === void 0 && i === void 0))
            return 0;
          if (i === void 0) return 1;
          if (n === void 0) return -1;
          if (n === i) continue;
          return V_(n, i);
        } while (++r);
      }
      inc(t, r, n) {
        if (t.startsWith("pre")) {
          if (!r && n === !1)
            throw new Error("invalid increment argument: identifier is empty");
          if (r) {
            let i = new RegExp(
                `^${this.options.loose ? ike[dq.PRERELEASELOOSE] : ike[dq.PRERELEASE]}$`,
              ),
              o = `-${r}`.match(i);
            if (!o || o[1] !== r) throw new Error(`invalid identifier: ${r}`);
          }
        }
        switch (t) {
          case "premajor":
            (this.prerelease.length = 0),
              (this.patch = 0),
              (this.minor = 0),
              this.major++,
              this.inc("pre", r, n);
            break;
          case "preminor":
            (this.prerelease.length = 0),
              (this.patch = 0),
              this.minor++,
              this.inc("pre", r, n);
            break;
          case "prepatch":
            (this.prerelease.length = 0),
              this.inc("patch", r, n),
              this.inc("pre", r, n);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", r, n),
              this.inc("pre", r, n);
            break;
          case "release":
            if (this.prerelease.length === 0)
              throw new Error(`version ${this.raw} is not a prerelease`);
            this.prerelease.length = 0;
            break;
          case "major":
            (this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0) &&
              this.major++,
              (this.minor = 0),
              (this.patch = 0),
              (this.prerelease = []);
            break;
          case "minor":
            (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
              (this.patch = 0),
              (this.prerelease = []);
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++,
              (this.prerelease = []);
            break;
          case "pre": {
            let i = Number(n) ? 1 : 0;
            if (this.prerelease.length === 0) this.prerelease = [i];
            else {
              let o = this.prerelease.length;
              for (; --o >= 0; )
                typeof this.prerelease[o] == "number" &&
                  (this.prerelease[o]++, (o = -2));
              if (o === -1) {
                if (r === this.prerelease.join(".") && n === !1)
                  throw new Error(
                    "invalid increment argument: identifier already exists",
                  );
                this.prerelease.push(i);
              }
            }
            if (r) {
              let o = [r, i];
              n === !1 && (o = [r]),
                V_(this.prerelease[0], r) === 0
                  ? isNaN(this.prerelease[1]) && (this.prerelease = o)
                  : (this.prerelease = o);
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${t}`);
        }
        return (
          (this.raw = this.format()),
          this.build.length && (this.raw += `+${this.build.join(".")}`),
          this
        );
      }
    };
  oke.exports = mQ;
});
var Oh = g((UIn, ske) => {
  c();
  var ake = zi(),
    P7t = (e, t, r = !1) => {
      if (e instanceof ake) return e;
      try {
        return new ake(e, t);
      } catch (n) {
        if (!r) return null;
        throw n;
      }
    };
  ske.exports = P7t;
});
var uke = g((GIn, cke) => {
  c();
  var R7t = Oh(),
    I7t = (e, t) => {
      let r = R7t(e, t);
      return r ? r.version : null;
    };
  cke.exports = I7t;
});
var dke = g(($In, lke) => {
  c();
  var x7t = Oh(),
    N7t = (e, t) => {
      let r = x7t(e.trim().replace(/^[=v]+/, ""), t);
      return r ? r.version : null;
    };
  lke.exports = N7t;
});
var mke = g((KIn, pke) => {
  c();
  var fke = zi(),
    k7t = (e, t, r, n, i) => {
      typeof r == "string" && ((i = n), (n = r), (r = void 0));
      try {
        return new fke(e instanceof fke ? e.version : e, r).inc(t, n, i)
          .version;
      } catch {
        return null;
      }
    };
  pke.exports = k7t;
});
var vke = g((QIn, gke) => {
  c();
  var hke = Oh(),
    D7t = (e, t) => {
      let r = hke(e, null, !0),
        n = hke(t, null, !0),
        i = r.compare(n);
      if (i === 0) return null;
      let o = i > 0,
        a = o ? r : n,
        s = o ? n : r,
        u = !!a.prerelease.length;
      if (!!s.prerelease.length && !u) {
        if (!s.patch && !s.minor) return "major";
        if (s.compareMain(a) === 0)
          return s.minor && !s.patch ? "minor" : "patch";
      }
      let d = u ? "pre" : "";
      return r.major !== n.major
        ? d + "major"
        : r.minor !== n.minor
          ? d + "minor"
          : r.patch !== n.patch
            ? d + "patch"
            : "prerelease";
    };
  gke.exports = D7t;
});
var _ke = g((XIn, yke) => {
  c();
  var L7t = zi(),
    M7t = (e, t) => new L7t(e, t).major;
  yke.exports = M7t;
});
var bke = g((ZIn, Eke) => {
  c();
  var q7t = zi(),
    j7t = (e, t) => new q7t(e, t).minor;
  Eke.exports = j7t;
});
var Cke = g((txn, Ske) => {
  c();
  var F7t = zi(),
    B7t = (e, t) => new F7t(e, t).patch;
  Ske.exports = B7t;
});
var Oke = g((nxn, wke) => {
  c();
  var U7t = Oh(),
    H7t = (e, t) => {
      let r = U7t(e, t);
      return r && r.prerelease.length ? r.prerelease : null;
    };
  wke.exports = H7t;
});
var Ja = g((oxn, Ake) => {
  c();
  var Tke = zi(),
    G7t = (e, t, r) => new Tke(e, r).compare(new Tke(t, r));
  Ake.exports = G7t;
});
var Rke = g((sxn, Pke) => {
  c();
  var V7t = Ja(),
    $7t = (e, t, r) => V7t(t, e, r);
  Pke.exports = $7t;
});
var xke = g((uxn, Ike) => {
  c();
  var z7t = Ja(),
    K7t = (e, t) => z7t(e, t, !0);
  Ike.exports = K7t;
});
var fq = g((dxn, kke) => {
  c();
  var Nke = zi(),
    W7t = (e, t, r) => {
      let n = new Nke(e, r),
        i = new Nke(t, r);
      return n.compare(i) || n.compareBuild(i);
    };
  kke.exports = W7t;
});
var Lke = g((pxn, Dke) => {
  c();
  var Q7t = fq(),
    Y7t = (e, t) => e.sort((r, n) => Q7t(r, n, t));
  Dke.exports = Y7t;
});
var qke = g((hxn, Mke) => {
  c();
  var X7t = fq(),
    J7t = (e, t) => e.sort((r, n) => X7t(n, r, t));
  Mke.exports = J7t;
});
var Ww = g((vxn, jke) => {
  c();
  var Z7t = Ja(),
    eJt = (e, t, r) => Z7t(e, t, r) > 0;
  jke.exports = eJt;
});
var pq = g((_xn, Fke) => {
  c();
  var tJt = Ja(),
    rJt = (e, t, r) => tJt(e, t, r) < 0;
  Fke.exports = rJt;
});
var hQ = g((bxn, Bke) => {
  c();
  var nJt = Ja(),
    iJt = (e, t, r) => nJt(e, t, r) === 0;
  Bke.exports = iJt;
});
var gQ = g((Cxn, Uke) => {
  c();
  var oJt = Ja(),
    aJt = (e, t, r) => oJt(e, t, r) !== 0;
  Uke.exports = aJt;
});
var mq = g((Oxn, Hke) => {
  c();
  var sJt = Ja(),
    cJt = (e, t, r) => sJt(e, t, r) >= 0;
  Hke.exports = cJt;
});
var hq = g((Axn, Gke) => {
  c();
  var uJt = Ja(),
    lJt = (e, t, r) => uJt(e, t, r) <= 0;
  Gke.exports = lJt;
});
var vQ = g((Rxn, Vke) => {
  c();
  var dJt = hQ(),
    fJt = gQ(),
    pJt = Ww(),
    mJt = mq(),
    hJt = pq(),
    gJt = hq(),
    vJt = (e, t, r, n) => {
      switch (t) {
        case "===":
          return (
            typeof e == "object" && (e = e.version),
            typeof r == "object" && (r = r.version),
            e === r
          );
        case "!==":
          return (
            typeof e == "object" && (e = e.version),
            typeof r == "object" && (r = r.version),
            e !== r
          );
        case "":
        case "=":
        case "==":
          return dJt(e, r, n);
        case "!=":
          return fJt(e, r, n);
        case ">":
          return pJt(e, r, n);
        case ">=":
          return mJt(e, r, n);
        case "<":
          return hJt(e, r, n);
        case "<=":
          return gJt(e, r, n);
        default:
          throw new TypeError(`Invalid operator: ${t}`);
      }
    };
  Vke.exports = vJt;
});
var zke = g((xxn, $ke) => {
  c();
  var yJt = zi(),
    _Jt = Oh(),
    { safeRe: gq, t: vq } = G_(),
    EJt = (e, t) => {
      if (e instanceof yJt) return e;
      if ((typeof e == "number" && (e = String(e)), typeof e != "string"))
        return null;
      t = t || {};
      let r = null;
      if (!t.rtl)
        r = e.match(t.includePrerelease ? gq[vq.COERCEFULL] : gq[vq.COERCE]);
      else {
        let u = t.includePrerelease ? gq[vq.COERCERTLFULL] : gq[vq.COERCERTL],
          l;
        for (; (l = u.exec(e)) && (!r || r.index + r[0].length !== e.length); )
          (!r || l.index + l[0].length !== r.index + r[0].length) && (r = l),
            (u.lastIndex = l.index + l[1].length + l[2].length);
        u.lastIndex = -1;
      }
      if (r === null) return null;
      let n = r[2],
        i = r[3] || "0",
        o = r[4] || "0",
        a = t.includePrerelease && r[5] ? `-${r[5]}` : "",
        s = t.includePrerelease && r[6] ? `+${r[6]}` : "";
      return _Jt(`${n}.${i}.${o}${a}${s}`, t);
    };
  $ke.exports = EJt;
});
var Wke = g((kxn, Kke) => {
  c();
  var yQ = class {
    constructor() {
      (this.max = 1e3), (this.map = new Map());
    }
    get(t) {
      let r = this.map.get(t);
      if (r !== void 0) return this.map.delete(t), this.map.set(t, r), r;
    }
    delete(t) {
      return this.map.delete(t);
    }
    set(t, r) {
      if (!this.delete(t) && r !== void 0) {
        if (this.map.size >= this.max) {
          let i = this.map.keys().next().value;
          this.delete(i);
        }
        this.map.set(t, r);
      }
      return this;
    }
  };
  Kke.exports = yQ;
});
var Za = g((Lxn, Jke) => {
  c();
  var bJt = /\s+/g,
    _Q = class e {
      constructor(t, r) {
        if (((r = CJt(r)), t instanceof e))
          return t.loose === !!r.loose &&
            t.includePrerelease === !!r.includePrerelease
            ? t
            : new e(t.raw, r);
        if (t instanceof EQ)
          return (
            (this.raw = t.value),
            (this.set = [[t]]),
            (this.formatted = void 0),
            this
          );
        if (
          ((this.options = r),
          (this.loose = !!r.loose),
          (this.includePrerelease = !!r.includePrerelease),
          (this.raw = t.trim().replace(bJt, " ")),
          (this.set = this.raw
            .split("||")
            .map((n) => this.parseRange(n.trim()))
            .filter((n) => n.length)),
          !this.set.length)
        )
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        if (this.set.length > 1) {
          let n = this.set[0];
          if (
            ((this.set = this.set.filter((i) => !Yke(i[0]))),
            this.set.length === 0)
          )
            this.set = [n];
          else if (this.set.length > 1) {
            for (let i of this.set)
              if (i.length === 1 && IJt(i[0])) {
                this.set = [i];
                break;
              }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let t = 0; t < this.set.length; t++) {
            t > 0 && (this.formatted += "||");
            let r = this.set[t];
            for (let n = 0; n < r.length; n++)
              n > 0 && (this.formatted += " "),
                (this.formatted += r[n].toString().trim());
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(t) {
        let n =
            ((this.options.includePrerelease && PJt) |
              (this.options.loose && RJt)) +
            ":" +
            t,
          i = Qke.get(n);
        if (i) return i;
        let o = this.options.loose,
          a = o ? Do[io.HYPHENRANGELOOSE] : Do[io.HYPHENRANGE];
        (t = t.replace(a, BJt(this.options.includePrerelease))),
          jr("hyphen replace", t),
          (t = t.replace(Do[io.COMPARATORTRIM], OJt)),
          jr("comparator trim", t),
          (t = t.replace(Do[io.TILDETRIM], TJt)),
          jr("tilde trim", t),
          (t = t.replace(Do[io.CARETTRIM], AJt)),
          jr("caret trim", t);
        let s = t
          .split(" ")
          .map((f) => xJt(f, this.options))
          .join(" ")
          .split(/\s+/)
          .map((f) => FJt(f, this.options));
        o &&
          (s = s.filter(
            (f) => (
              jr("loose invalid filter", f, this.options),
              !!f.match(Do[io.COMPARATORLOOSE])
            ),
          )),
          jr("range list", s);
        let u = new Map(),
          l = s.map((f) => new EQ(f, this.options));
        for (let f of l) {
          if (Yke(f)) return [f];
          u.set(f.value, f);
        }
        u.size > 1 && u.has("") && u.delete("");
        let d = [...u.values()];
        return Qke.set(n, d), d;
      }
      intersects(t, r) {
        if (!(t instanceof e)) throw new TypeError("a Range is required");
        return this.set.some(
          (n) =>
            Xke(n, r) &&
            t.set.some(
              (i) =>
                Xke(i, r) && n.every((o) => i.every((a) => o.intersects(a, r))),
            ),
        );
      }
      test(t) {
        if (!t) return !1;
        if (typeof t == "string")
          try {
            t = new wJt(t, this.options);
          } catch {
            return !1;
          }
        for (let r = 0; r < this.set.length; r++)
          if (UJt(this.set[r], t, this.options)) return !0;
        return !1;
      }
    };
  Jke.exports = _Q;
  var SJt = Wke(),
    Qke = new SJt(),
    CJt = cq(),
    EQ = Qw(),
    jr = Kw(),
    wJt = zi(),
    {
      safeRe: Do,
      t: io,
      comparatorTrimReplace: OJt,
      tildeTrimReplace: TJt,
      caretTrimReplace: AJt,
    } = G_(),
    { FLAG_INCLUDE_PRERELEASE: PJt, FLAG_LOOSE: RJt } = zw(),
    Yke = (e) => e.value === "<0.0.0-0",
    IJt = (e) => e.value === "",
    Xke = (e, t) => {
      let r = !0,
        n = e.slice(),
        i = n.pop();
      for (; r && n.length; )
        (r = n.every((o) => i.intersects(o, t))), (i = n.pop());
      return r;
    },
    xJt = (e, t) => (
      jr("comp", e, t),
      (e = DJt(e, t)),
      jr("caret", e),
      (e = NJt(e, t)),
      jr("tildes", e),
      (e = MJt(e, t)),
      jr("xrange", e),
      (e = jJt(e, t)),
      jr("stars", e),
      e
    ),
    oo = (e) => !e || e.toLowerCase() === "x" || e === "*",
    NJt = (e, t) =>
      e
        .trim()
        .split(/\s+/)
        .map((r) => kJt(r, t))
        .join(" "),
    kJt = (e, t) => {
      let r = t.loose ? Do[io.TILDELOOSE] : Do[io.TILDE];
      return e.replace(r, (n, i, o, a, s) => {
        jr("tilde", e, n, i, o, a, s);
        let u;
        return (
          oo(i)
            ? (u = "")
            : oo(o)
              ? (u = `>=${i}.0.0 <${+i + 1}.0.0-0`)
              : oo(a)
                ? (u = `>=${i}.${o}.0 <${i}.${+o + 1}.0-0`)
                : s
                  ? (jr("replaceTilde pr", s),
                    (u = `>=${i}.${o}.${a}-${s} <${i}.${+o + 1}.0-0`))
                  : (u = `>=${i}.${o}.${a} <${i}.${+o + 1}.0-0`),
          jr("tilde return", u),
          u
        );
      });
    },
    DJt = (e, t) =>
      e
        .trim()
        .split(/\s+/)
        .map((r) => LJt(r, t))
        .join(" "),
    LJt = (e, t) => {
      jr("caret", e, t);
      let r = t.loose ? Do[io.CARETLOOSE] : Do[io.CARET],
        n = t.includePrerelease ? "-0" : "";
      return e.replace(r, (i, o, a, s, u) => {
        jr("caret", e, i, o, a, s, u);
        let l;
        return (
          oo(o)
            ? (l = "")
            : oo(a)
              ? (l = `>=${o}.0.0${n} <${+o + 1}.0.0-0`)
              : oo(s)
                ? o === "0"
                  ? (l = `>=${o}.${a}.0${n} <${o}.${+a + 1}.0-0`)
                  : (l = `>=${o}.${a}.0${n} <${+o + 1}.0.0-0`)
                : u
                  ? (jr("replaceCaret pr", u),
                    o === "0"
                      ? a === "0"
                        ? (l = `>=${o}.${a}.${s}-${u} <${o}.${a}.${+s + 1}-0`)
                        : (l = `>=${o}.${a}.${s}-${u} <${o}.${+a + 1}.0-0`)
                      : (l = `>=${o}.${a}.${s}-${u} <${+o + 1}.0.0-0`))
                  : (jr("no pr"),
                    o === "0"
                      ? a === "0"
                        ? (l = `>=${o}.${a}.${s}${n} <${o}.${a}.${+s + 1}-0`)
                        : (l = `>=${o}.${a}.${s}${n} <${o}.${+a + 1}.0-0`)
                      : (l = `>=${o}.${a}.${s} <${+o + 1}.0.0-0`)),
          jr("caret return", l),
          l
        );
      });
    },
    MJt = (e, t) => (
      jr("replaceXRanges", e, t),
      e
        .split(/\s+/)
        .map((r) => qJt(r, t))
        .join(" ")
    ),
    qJt = (e, t) => {
      e = e.trim();
      let r = t.loose ? Do[io.XRANGELOOSE] : Do[io.XRANGE];
      return e.replace(r, (n, i, o, a, s, u) => {
        jr("xRange", e, n, i, o, a, s, u);
        let l = oo(o),
          d = l || oo(a),
          f = d || oo(s),
          m = f;
        return (
          i === "=" && m && (i = ""),
          (u = t.includePrerelease ? "-0" : ""),
          l
            ? i === ">" || i === "<"
              ? (n = "<0.0.0-0")
              : (n = "*")
            : i && m
              ? (d && (a = 0),
                (s = 0),
                i === ">"
                  ? ((i = ">="),
                    d
                      ? ((o = +o + 1), (a = 0), (s = 0))
                      : ((a = +a + 1), (s = 0)))
                  : i === "<=" && ((i = "<"), d ? (o = +o + 1) : (a = +a + 1)),
                i === "<" && (u = "-0"),
                (n = `${i + o}.${a}.${s}${u}`))
              : d
                ? (n = `>=${o}.0.0${u} <${+o + 1}.0.0-0`)
                : f && (n = `>=${o}.${a}.0${u} <${o}.${+a + 1}.0-0`),
          jr("xRange return", n),
          n
        );
      });
    },
    jJt = (e, t) => (
      jr("replaceStars", e, t), e.trim().replace(Do[io.STAR], "")
    ),
    FJt = (e, t) => (
      jr("replaceGTE0", e, t),
      e.trim().replace(Do[t.includePrerelease ? io.GTE0PRE : io.GTE0], "")
    ),
    BJt = (e) => (t, r, n, i, o, a, s, u, l, d, f, m) => (
      oo(n)
        ? (r = "")
        : oo(i)
          ? (r = `>=${n}.0.0${e ? "-0" : ""}`)
          : oo(o)
            ? (r = `>=${n}.${i}.0${e ? "-0" : ""}`)
            : a
              ? (r = `>=${r}`)
              : (r = `>=${r}${e ? "-0" : ""}`),
      oo(l)
        ? (u = "")
        : oo(d)
          ? (u = `<${+l + 1}.0.0-0`)
          : oo(f)
            ? (u = `<${l}.${+d + 1}.0-0`)
            : m
              ? (u = `<=${l}.${d}.${f}-${m}`)
              : e
                ? (u = `<${l}.${d}.${+f + 1}-0`)
                : (u = `<=${u}`),
      `${r} ${u}`.trim()
    ),
    UJt = (e, t, r) => {
      for (let n = 0; n < e.length; n++) if (!e[n].test(t)) return !1;
      if (t.prerelease.length && !r.includePrerelease) {
        for (let n = 0; n < e.length; n++)
          if (
            (jr(e[n].semver),
            e[n].semver !== EQ.ANY && e[n].semver.prerelease.length > 0)
          ) {
            let i = e[n].semver;
            if (
              i.major === t.major &&
              i.minor === t.minor &&
              i.patch === t.patch
            )
              return !0;
          }
        return !1;
      }
      return !0;
    };
});
var Qw = g((qxn, iDe) => {
  c();
  var Yw = Symbol("SemVer ANY"),
    CQ = class e {
      static get ANY() {
        return Yw;
      }
      constructor(t, r) {
        if (((r = Zke(r)), t instanceof e)) {
          if (t.loose === !!r.loose) return t;
          t = t.value;
        }
        (t = t.trim().split(/\s+/).join(" ")),
          SQ("comparator", t, r),
          (this.options = r),
          (this.loose = !!r.loose),
          this.parse(t),
          this.semver === Yw
            ? (this.value = "")
            : (this.value = this.operator + this.semver.version),
          SQ("comp", this);
      }
      parse(t) {
        let r = this.options.loose
            ? eDe[tDe.COMPARATORLOOSE]
            : eDe[tDe.COMPARATOR],
          n = t.match(r);
        if (!n) throw new TypeError(`Invalid comparator: ${t}`);
        (this.operator = n[1] !== void 0 ? n[1] : ""),
          this.operator === "=" && (this.operator = ""),
          n[2]
            ? (this.semver = new rDe(n[2], this.options.loose))
            : (this.semver = Yw);
      }
      toString() {
        return this.value;
      }
      test(t) {
        if (
          (SQ("Comparator.test", t, this.options.loose),
          this.semver === Yw || t === Yw)
        )
          return !0;
        if (typeof t == "string")
          try {
            t = new rDe(t, this.options);
          } catch {
            return !1;
          }
        return bQ(t, this.operator, this.semver, this.options);
      }
      intersects(t, r) {
        if (!(t instanceof e)) throw new TypeError("a Comparator is required");
        return this.operator === ""
          ? this.value === ""
            ? !0
            : new nDe(t.value, r).test(this.value)
          : t.operator === ""
            ? t.value === ""
              ? !0
              : new nDe(this.value, r).test(t.semver)
            : ((r = Zke(r)),
              (r.includePrerelease &&
                (this.value === "<0.0.0-0" || t.value === "<0.0.0-0")) ||
              (!r.includePrerelease &&
                (this.value.startsWith("<0.0.0") ||
                  t.value.startsWith("<0.0.0")))
                ? !1
                : !!(
                    (this.operator.startsWith(">") &&
                      t.operator.startsWith(">")) ||
                    (this.operator.startsWith("<") &&
                      t.operator.startsWith("<")) ||
                    (this.semver.version === t.semver.version &&
                      this.operator.includes("=") &&
                      t.operator.includes("=")) ||
                    (bQ(this.semver, "<", t.semver, r) &&
                      this.operator.startsWith(">") &&
                      t.operator.startsWith("<")) ||
                    (bQ(this.semver, ">", t.semver, r) &&
                      this.operator.startsWith("<") &&
                      t.operator.startsWith(">"))
                  ));
      }
    };
  iDe.exports = CQ;
  var Zke = cq(),
    { safeRe: eDe, t: tDe } = G_(),
    bQ = vQ(),
    SQ = Kw(),
    rDe = zi(),
    nDe = Za();
});
var Xw = g((Fxn, oDe) => {
  c();
  var HJt = Za(),
    GJt = (e, t, r) => {
      try {
        t = new HJt(t, r);
      } catch {
        return !1;
      }
      return t.test(e);
    };
  oDe.exports = GJt;
});
var sDe = g((Uxn, aDe) => {
  c();
  var VJt = Za(),
    $Jt = (e, t) =>
      new VJt(e, t).set.map((r) =>
        r
          .map((n) => n.value)
          .join(" ")
          .trim()
          .split(" "),
      );
  aDe.exports = $Jt;
});
var uDe = g((Gxn, cDe) => {
  c();
  var zJt = zi(),
    KJt = Za(),
    WJt = (e, t, r) => {
      let n = null,
        i = null,
        o = null;
      try {
        o = new KJt(t, r);
      } catch {
        return null;
      }
      return (
        e.forEach((a) => {
          o.test(a) &&
            (!n || i.compare(a) === -1) &&
            ((n = a), (i = new zJt(n, r)));
        }),
        n
      );
    };
  cDe.exports = WJt;
});
var dDe = g(($xn, lDe) => {
  c();
  var QJt = zi(),
    YJt = Za(),
    XJt = (e, t, r) => {
      let n = null,
        i = null,
        o = null;
      try {
        o = new YJt(t, r);
      } catch {
        return null;
      }
      return (
        e.forEach((a) => {
          o.test(a) &&
            (!n || i.compare(a) === 1) &&
            ((n = a), (i = new QJt(n, r)));
        }),
        n
      );
    };
  lDe.exports = XJt;
});
var mDe = g((Kxn, pDe) => {
  c();
  var wQ = zi(),
    JJt = Za(),
    fDe = Ww(),
    ZJt = (e, t) => {
      e = new JJt(e, t);
      let r = new wQ("0.0.0");
      if (e.test(r) || ((r = new wQ("0.0.0-0")), e.test(r))) return r;
      r = null;
      for (let n = 0; n < e.set.length; ++n) {
        let i = e.set[n],
          o = null;
        i.forEach((a) => {
          let s = new wQ(a.semver.version);
          switch (a.operator) {
            case ">":
              s.prerelease.length === 0 ? s.patch++ : s.prerelease.push(0),
                (s.raw = s.format());
            case "":
            case ">=":
              (!o || fDe(s, o)) && (o = s);
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${a.operator}`);
          }
        }),
          o && (!r || fDe(r, o)) && (r = o);
      }
      return r && e.test(r) ? r : null;
    };
  pDe.exports = ZJt;
});
var gDe = g((Qxn, hDe) => {
  c();
  var eZt = Za(),
    tZt = (e, t) => {
      try {
        return new eZt(e, t).range || "*";
      } catch {
        return null;
      }
    };
  hDe.exports = tZt;
});
var yq = g((Xxn, EDe) => {
  c();
  var rZt = zi(),
    _De = Qw(),
    { ANY: nZt } = _De,
    iZt = Za(),
    oZt = Xw(),
    vDe = Ww(),
    yDe = pq(),
    aZt = hq(),
    sZt = mq(),
    cZt = (e, t, r, n) => {
      (e = new rZt(e, n)), (t = new iZt(t, n));
      let i, o, a, s, u;
      switch (r) {
        case ">":
          (i = vDe), (o = aZt), (a = yDe), (s = ">"), (u = ">=");
          break;
        case "<":
          (i = yDe), (o = sZt), (a = vDe), (s = "<"), (u = "<=");
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (oZt(e, t, n)) return !1;
      for (let l = 0; l < t.set.length; ++l) {
        let d = t.set[l],
          f = null,
          m = null;
        if (
          (d.forEach((h) => {
            h.semver === nZt && (h = new _De(">=0.0.0")),
              (f = f || h),
              (m = m || h),
              i(h.semver, f.semver, n)
                ? (f = h)
                : a(h.semver, m.semver, n) && (m = h);
          }),
          f.operator === s ||
            f.operator === u ||
            ((!m.operator || m.operator === s) && o(e, m.semver)))
        )
          return !1;
        if (m.operator === u && a(e, m.semver)) return !1;
      }
      return !0;
    };
  EDe.exports = cZt;
});
var SDe = g((Zxn, bDe) => {
  c();
  var uZt = yq(),
    lZt = (e, t, r) => uZt(e, t, ">", r);
  bDe.exports = lZt;
});
var wDe = g((tNn, CDe) => {
  c();
  var dZt = yq(),
    fZt = (e, t, r) => dZt(e, t, "<", r);
  CDe.exports = fZt;
});
var ADe = g((nNn, TDe) => {
  c();
  var ODe = Za(),
    pZt = (e, t, r) => (
      (e = new ODe(e, r)), (t = new ODe(t, r)), e.intersects(t, r)
    );
  TDe.exports = pZt;
});
var RDe = g((oNn, PDe) => {
  c();
  var mZt = Xw(),
    hZt = Ja();
  PDe.exports = (e, t, r) => {
    let n = [],
      i = null,
      o = null,
      a = e.sort((d, f) => hZt(d, f, r));
    for (let d of a)
      mZt(d, t, r)
        ? ((o = d), i || (i = d))
        : (o && n.push([i, o]), (o = null), (i = null));
    i && n.push([i, null]);
    let s = [];
    for (let [d, f] of n)
      d === f
        ? s.push(d)
        : !f && d === a[0]
          ? s.push("*")
          : f
            ? d === a[0]
              ? s.push(`<=${f}`)
              : s.push(`${d} - ${f}`)
            : s.push(`>=${d}`);
    let u = s.join(" || "),
      l = typeof t.raw == "string" ? t.raw : String(t);
    return u.length < l.length ? u : t;
  };
});
var LDe = g((sNn, DDe) => {
  c();
  var IDe = Za(),
    TQ = Qw(),
    { ANY: OQ } = TQ,
    Jw = Xw(),
    AQ = Ja(),
    gZt = (e, t, r = {}) => {
      if (e === t) return !0;
      (e = new IDe(e, r)), (t = new IDe(t, r));
      let n = !1;
      e: for (let i of e.set) {
        for (let o of t.set) {
          let a = yZt(i, o, r);
          if (((n = n || a !== null), a)) continue e;
        }
        if (n) return !1;
      }
      return !0;
    },
    vZt = [new TQ(">=0.0.0-0")],
    xDe = [new TQ(">=0.0.0")],
    yZt = (e, t, r) => {
      if (e === t) return !0;
      if (e.length === 1 && e[0].semver === OQ) {
        if (t.length === 1 && t[0].semver === OQ) return !0;
        r.includePrerelease ? (e = vZt) : (e = xDe);
      }
      if (t.length === 1 && t[0].semver === OQ) {
        if (r.includePrerelease) return !0;
        t = xDe;
      }
      let n = new Set(),
        i,
        o;
      for (let h of e)
        h.operator === ">" || h.operator === ">="
          ? (i = NDe(i, h, r))
          : h.operator === "<" || h.operator === "<="
            ? (o = kDe(o, h, r))
            : n.add(h.semver);
      if (n.size > 1) return null;
      let a;
      if (i && o) {
        if (((a = AQ(i.semver, o.semver, r)), a > 0)) return null;
        if (a === 0 && (i.operator !== ">=" || o.operator !== "<="))
          return null;
      }
      for (let h of n) {
        if ((i && !Jw(h, String(i), r)) || (o && !Jw(h, String(o), r)))
          return null;
        for (let y of t) if (!Jw(h, String(y), r)) return !1;
        return !0;
      }
      let s,
        u,
        l,
        d,
        f =
          o && !r.includePrerelease && o.semver.prerelease.length
            ? o.semver
            : !1,
        m =
          i && !r.includePrerelease && i.semver.prerelease.length
            ? i.semver
            : !1;
      f &&
        f.prerelease.length === 1 &&
        o.operator === "<" &&
        f.prerelease[0] === 0 &&
        (f = !1);
      for (let h of t) {
        if (
          ((d = d || h.operator === ">" || h.operator === ">="),
          (l = l || h.operator === "<" || h.operator === "<="),
          i)
        ) {
          if (
            (m &&
              h.semver.prerelease &&
              h.semver.prerelease.length &&
              h.semver.major === m.major &&
              h.semver.minor === m.minor &&
              h.semver.patch === m.patch &&
              (m = !1),
            h.operator === ">" || h.operator === ">=")
          ) {
            if (((s = NDe(i, h, r)), s === h && s !== i)) return !1;
          } else if (i.operator === ">=" && !Jw(i.semver, String(h), r))
            return !1;
        }
        if (o) {
          if (
            (f &&
              h.semver.prerelease &&
              h.semver.prerelease.length &&
              h.semver.major === f.major &&
              h.semver.minor === f.minor &&
              h.semver.patch === f.patch &&
              (f = !1),
            h.operator === "<" || h.operator === "<=")
          ) {
            if (((u = kDe(o, h, r)), u === h && u !== o)) return !1;
          } else if (o.operator === "<=" && !Jw(o.semver, String(h), r))
            return !1;
        }
        if (!h.operator && (o || i) && a !== 0) return !1;
      }
      return !(
        (i && l && !o && a !== 0) ||
        (o && d && !i && a !== 0) ||
        m ||
        f
      );
    },
    NDe = (e, t, r) => {
      if (!e) return t;
      let n = AQ(e.semver, t.semver, r);
      return n > 0
        ? e
        : n < 0 || (t.operator === ">" && e.operator === ">=")
          ? t
          : e;
    },
    kDe = (e, t, r) => {
      if (!e) return t;
      let n = AQ(e.semver, t.semver, r);
      return n < 0
        ? e
        : n > 0 || (t.operator === "<" && e.operator === "<=")
          ? t
          : e;
    };
  DDe.exports = gZt;
});
var FDe = g((uNn, jDe) => {
  c();
  var PQ = G_(),
    MDe = zw(),
    _Zt = zi(),
    qDe = pQ(),
    EZt = Oh(),
    bZt = uke(),
    SZt = dke(),
    CZt = mke(),
    wZt = vke(),
    OZt = _ke(),
    TZt = bke(),
    AZt = Cke(),
    PZt = Oke(),
    RZt = Ja(),
    IZt = Rke(),
    xZt = xke(),
    NZt = fq(),
    kZt = Lke(),
    DZt = qke(),
    LZt = Ww(),
    MZt = pq(),
    qZt = hQ(),
    jZt = gQ(),
    FZt = mq(),
    BZt = hq(),
    UZt = vQ(),
    HZt = zke(),
    GZt = Qw(),
    VZt = Za(),
    $Zt = Xw(),
    zZt = sDe(),
    KZt = uDe(),
    WZt = dDe(),
    QZt = mDe(),
    YZt = gDe(),
    XZt = yq(),
    JZt = SDe(),
    ZZt = wDe(),
    eer = ADe(),
    ter = RDe(),
    rer = LDe();
  jDe.exports = {
    parse: EZt,
    valid: bZt,
    clean: SZt,
    inc: CZt,
    diff: wZt,
    major: OZt,
    minor: TZt,
    patch: AZt,
    prerelease: PZt,
    compare: RZt,
    rcompare: IZt,
    compareLoose: xZt,
    compareBuild: NZt,
    sort: kZt,
    rsort: DZt,
    gt: LZt,
    lt: MZt,
    eq: qZt,
    neq: jZt,
    gte: FZt,
    lte: BZt,
    cmp: UZt,
    coerce: HZt,
    Comparator: GZt,
    Range: VZt,
    satisfies: $Zt,
    toComparators: zZt,
    maxSatisfying: KZt,
    minSatisfying: WZt,
    minVersion: QZt,
    validRange: YZt,
    outside: XZt,
    gtr: JZt,
    ltr: ZZt,
    intersects: eer,
    simplifyRange: ter,
    subset: rer,
    SemVer: _Zt,
    re: PQ.re,
    src: PQ.src,
    tokens: PQ.t,
    SEMVER_SPEC_VERSION: MDe.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: MDe.RELEASE_TYPES,
    compareIdentifiers: qDe.compareIdentifiers,
    rcompareIdentifiers: qDe.rcompareIdentifiers,
  };
});
var UDe = g((nu) => {
  "use strict";
  c();
  var BDe =
    (nu && nu.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(nu, "__esModule", { value: !0 });
  nu.ObjectAccumulator =
    nu.ObjectAccumulatorVersionMismatchError =
    nu.ObjectAccumulatorPropertyAlreadyExistsError =
      void 0;
  var ner = BDe(WNe()),
    RQ = BDe(FDe()),
    _q = class extends Error {
      key;
      existingValue;
      incomingValue;
      constructor(t, r, n) {
        super(`Property ${t} already exists`),
          (this.key = t),
          (this.existingValue = r),
          (this.incomingValue = n);
      }
    };
  nu.ObjectAccumulatorPropertyAlreadyExistsError = _q;
  var Eq = class extends Error {
    existingVersion;
    newVersion;
    constructor(t, r) {
      super(
        `Version mismatch: Cannot accumulate new objects with version ${r} with existing accumulated object with version ${t}`,
      ),
        (this.existingVersion = t),
        (this.newVersion = r);
    }
  };
  nu.ObjectAccumulatorVersionMismatchError = Eq;
  var IQ = class {
    accumulator;
    versionKey;
    constructor(t, r = "version") {
      (this.accumulator = t), (this.versionKey = r);
    }
    accumulate = (t) => (
      (0, ner.default)(this.accumulator, t, (r, n, i) => {
        if (Array.isArray(r)) return r.concat(n);
        if (r && typeof r != "object") {
          if (i === this.versionKey) {
            let o = RQ.default.coerce(n),
              a = RQ.default.coerce(r);
            if (o && a) {
              if (o.major !== a.major) throw new Eq(r, n);
              return RQ.default.gte(o, a) ? n : r;
            }
          } else if (i !== this.versionKey) throw new _q(i, r, n);
        }
      }),
      this
    );
    getAccumulatedObject = () => this.accumulator;
  };
  nu.ObjectAccumulator = IQ;
});
var GDe = g((bq) => {
  "use strict";
  c();
  Object.defineProperty(bq, "__esModule", { value: !0 });
  bq.TagName = void 0;
  var HDe;
  (function (e) {
    e.FRIENDLY_NAME = "amplify:friendly-name";
  })(HDe || (bq.TagName = HDe = {}));
});
var fLe = g((hNn, dLe) => {
  c();
  var ier = 1 / 0,
    oer = "[object Symbol]",
    aer = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
    ser = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
    XDe = "\\ud800-\\udfff",
    cer = "\\u0300-\\u036f\\ufe20-\\ufe23",
    uer = "\\u20d0-\\u20f0",
    JDe = "\\u2700-\\u27bf",
    ZDe = "a-z\\xdf-\\xf6\\xf8-\\xff",
    ler = "\\xac\\xb1\\xd7\\xf7",
    der = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
    fer = "\\u2000-\\u206f",
    per =
      " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
    eLe = "A-Z\\xc0-\\xd6\\xd8-\\xde",
    mer = "\\ufe0e\\ufe0f",
    tLe = ler + der + fer + per,
    xQ = "['\u2019]",
    VDe = "[" + tLe + "]",
    rLe = "[" + cer + uer + "]",
    nLe = "\\d+",
    her = "[" + JDe + "]",
    iLe = "[" + ZDe + "]",
    oLe = "[^" + XDe + tLe + nLe + JDe + ZDe + eLe + "]",
    ger = "\\ud83c[\\udffb-\\udfff]",
    ver = "(?:" + rLe + "|" + ger + ")",
    yer = "[^" + XDe + "]",
    aLe = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    sLe = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    $_ = "[" + eLe + "]",
    _er = "\\u200d",
    $De = "(?:" + iLe + "|" + oLe + ")",
    Eer = "(?:" + $_ + "|" + oLe + ")",
    zDe = "(?:" + xQ + "(?:d|ll|m|re|s|t|ve))?",
    KDe = "(?:" + xQ + "(?:D|LL|M|RE|S|T|VE))?",
    cLe = ver + "?",
    uLe = "[" + mer + "]?",
    ber =
      "(?:" + _er + "(?:" + [yer, aLe, sLe].join("|") + ")" + uLe + cLe + ")*",
    Ser = uLe + cLe + ber,
    Cer = "(?:" + [her, aLe, sLe].join("|") + ")" + Ser,
    wer = RegExp(xQ, "g"),
    Oer = RegExp(rLe, "g"),
    Ter = RegExp(
      [
        $_ + "?" + iLe + "+" + zDe + "(?=" + [VDe, $_, "$"].join("|") + ")",
        Eer + "+" + KDe + "(?=" + [VDe, $_ + $De, "$"].join("|") + ")",
        $_ + "?" + $De + "+" + zDe,
        $_ + "+" + KDe,
        nLe,
        Cer,
      ].join("|"),
      "g",
    ),
    Aer = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
    Per = {
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "ss",
    },
    Rer =
      typeof global == "object" && global && global.Object === Object && global,
    Ier = typeof self == "object" && self && self.Object === Object && self,
    xer = Rer || Ier || Function("return this")();
  function Ner(e, t, r, n) {
    var i = -1,
      o = e ? e.length : 0;
    for (n && o && (r = e[++i]); ++i < o; ) r = t(r, e[i], i, e);
    return r;
  }
  function ker(e) {
    return e.match(aer) || [];
  }
  function Der(e) {
    return function (t) {
      return e?.[t];
    };
  }
  var Ler = Der(Per);
  function Mer(e) {
    return Aer.test(e);
  }
  function qer(e) {
    return e.match(Ter) || [];
  }
  var jer = Object.prototype,
    Fer = jer.toString,
    WDe = xer.Symbol,
    QDe = WDe ? WDe.prototype : void 0,
    YDe = QDe ? QDe.toString : void 0;
  function Ber(e) {
    if (typeof e == "string") return e;
    if (Ger(e)) return YDe ? YDe.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -ier ? "-0" : t;
  }
  function Uer(e) {
    return function (t) {
      return Ner(zer(Ver(t).replace(wer, "")), e, "");
    };
  }
  function Her(e) {
    return !!e && typeof e == "object";
  }
  function Ger(e) {
    return typeof e == "symbol" || (Her(e) && Fer.call(e) == oer);
  }
  function lLe(e) {
    return e == null ? "" : Ber(e);
  }
  function Ver(e) {
    return (e = lLe(e)), e && e.replace(ser, Ler).replace(Oer, "");
  }
  var $er = Uer(function (e, t, r) {
    return e + (r ? "_" : "") + t.toLowerCase();
  });
  function zer(e, t, r) {
    return (
      (e = lLe(e)),
      (t = r ? void 0 : t),
      t === void 0 ? (Mer(e) ? qer(e) : ker(e)) : e.match(t) || []
    );
  }
  dLe.exports = $er;
});
var pLe = g((z_) => {
  "use strict";
  c();
  var Ker =
    (z_ && z_.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(z_, "__esModule", { value: !0 });
  z_.NamingConverter = void 0;
  var Wer = Ker(fLe()),
    NQ = class {
      toScreamingSnakeCase(t) {
        return (0, Wer.default)(t).toUpperCase();
      }
    };
  z_.NamingConverter = NQ;
});
var hLe = g((K_) => {
  "use strict";
  c();
  var Qer =
    (K_ && K_.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  Object.defineProperty(K_, "__esModule", { value: !0 });
  K_.telemetryPayloadSchema = void 0;
  var Ke = Qer(QK()),
    Yer = Ke.default.object({
      payloadVersion: Ke.default.string(),
      sessionUuid: Ke.default.string(),
      eventId: Ke.default.string(),
      timestamp: Ke.default.string(),
      localProjectId: Ke.default.string(),
      accountId: Ke.default.string().optional(),
      awsRegion: Ke.default.string().optional(),
    }),
    Xer = Ke.default.object({
      state: Ke.default.enum(["ABORTED", "FAILED", "SUCCEEDED"]),
      command: Ke.default.object({
        path: Ke.default.array(Ke.default.string()),
        parameters: Ke.default.array(Ke.default.string()),
      }),
    }),
    Jer = Ke.default.object({
      os: Ke.default.object({
        platform: Ke.default.string(),
        release: Ke.default.string(),
      }),
      shell: Ke.default.string(),
      npmUserAgent: Ke.default.string(),
      ci: Ke.default.boolean(),
      memory: Ke.default.object({
        total: Ke.default.number(),
        free: Ke.default.number(),
      }),
    }),
    Zer = Ke.default.object({
      dependencies: Ke.default
        .array(
          Ke.default.object({
            name: Ke.default.string(),
            version: Ke.default.string(),
          }),
        )
        .optional(),
    }),
    etr = Ke.default.object({
      total: Ke.default.number(),
      init: Ke.default.number().optional(),
      synthesis: Ke.default.number().optional(),
      deployment: Ke.default.number().optional(),
      hotSwap: Ke.default.number().optional(),
    }),
    mLe = Ke.default.lazy(() =>
      Ke.default.object({
        name: Ke.default.string(),
        message: Ke.default.string(),
        stack: Ke.default.string(),
        cause: Ke.default.optional(mLe),
      }),
    );
  K_.telemetryPayloadSchema = Ke.default.object({
    identifiers: Yer,
    event: Xer,
    environment: Jer,
    project: Zer,
    latency: etr,
    error: Ke.default.optional(mLe),
  });
});
var gLe = g((Pr) => {
  "use strict";
  c();
  var ttr =
      (Pr && Pr.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r);
            var i = Object.getOwnPropertyDescriptor(t, r);
            (!i ||
              ("get" in i ? !t.__esModule : i.writable || i.configurable)) &&
              (i = {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              }),
              Object.defineProperty(e, n, i);
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    es =
      (Pr && Pr.__exportStar) ||
      function (e, t) {
        for (var r in e)
          r !== "default" &&
            !Object.prototype.hasOwnProperty.call(t, r) &&
            ttr(t, e, r);
      };
  Object.defineProperty(Pr, "__esModule", { value: !0 });
  Pr.telemetryPayloadSchema =
    Pr.TagName =
    Pr.CDKContextKey =
    Pr.USAGE_DATA_TRACKING_ENABLED =
      void 0;
  es(NK(), Pr);
  es(rve(), Pr);
  es(nve(), Pr);
  es(FK(), Pr);
  es(Ive(), Pr);
  es(uNe(), Pr);
  es(e4(), Pr);
  es(fNe(), Pr);
  es(Oy(), Pr);
  var rtr = Bw();
  Object.defineProperty(Pr, "USAGE_DATA_TRACKING_ENABLED", {
    enumerable: !0,
    get: function () {
      return rtr.USAGE_DATA_TRACKING_ENABLED;
    },
  });
  var ntr = mNe();
  Object.defineProperty(Pr, "CDKContextKey", {
    enumerable: !0,
    get: function () {
      return ntr.CDKContextKey;
    },
  });
  es(_Ne(), Pr);
  es(UDe(), Pr);
  var itr = GDe();
  Object.defineProperty(Pr, "TagName", {
    enumerable: !0,
    get: function () {
      return itr.TagName;
    },
  });
  es(pLe(), Pr);
  var otr = hLe();
  Object.defineProperty(Pr, "telemetryPayloadSchema", {
    enumerable: !0,
    get: function () {
      return otr.telemetryPayloadSchema;
    },
  });
});
var TLe = g((CNn, OLe) => {
  c();
  var Sq = Object.defineProperty,
    atr = Object.getOwnPropertyDescriptor,
    str = Object.getOwnPropertyNames,
    ctr = Object.prototype.hasOwnProperty,
    Cq = (e, t) => Sq(e, "name", { value: t, configurable: !0 }),
    utr = (e, t) => {
      for (var r in t) Sq(e, r, { get: t[r], enumerable: !0 });
    },
    ltr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of str(t))
          !ctr.call(e, i) &&
            i !== r &&
            Sq(e, i, {
              get: () => t[i],
              enumerable: !(n = atr(t, i)) || n.enumerable,
            });
      return e;
    },
    dtr = (e) => ltr(Sq({}, "__esModule", { value: !0 }), e),
    vLe = {};
  utr(vLe, {
    AlgorithmId: () => bLe,
    EndpointURLScheme: () => ELe,
    FieldPosition: () => SLe,
    HttpApiKeyAuthLocation: () => _Le,
    HttpAuthLocation: () => yLe,
    IniSectionType: () => CLe,
    RequestHandlerProtocol: () => wLe,
    SMITHY_CONTEXT_KEY: () => gtr,
    getDefaultClientConfiguration: () => mtr,
    resolveDefaultRuntimeConfig: () => htr,
  });
  OLe.exports = dtr(vLe);
  var yLe = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(yLe || {}),
    _Le = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(_Le || {}),
    ELe = ((e) => ((e.HTTP = "http"), (e.HTTPS = "https"), e))(ELe || {}),
    bLe = ((e) => (
      (e.MD5 = "md5"),
      (e.CRC32 = "crc32"),
      (e.CRC32C = "crc32c"),
      (e.SHA1 = "sha1"),
      (e.SHA256 = "sha256"),
      e
    ))(bLe || {}),
    ftr = Cq((e) => {
      let t = [];
      return (
        e.sha256 !== void 0 &&
          t.push({
            algorithmId: () => "sha256",
            checksumConstructor: () => e.sha256,
          }),
        e.md5 != null &&
          t.push({
            algorithmId: () => "md5",
            checksumConstructor: () => e.md5,
          }),
        {
          addChecksumAlgorithm(r) {
            t.push(r);
          },
          checksumAlgorithms() {
            return t;
          },
        }
      );
    }, "getChecksumConfiguration"),
    ptr = Cq((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    mtr = Cq((e) => ftr(e), "getDefaultClientConfiguration"),
    htr = Cq((e) => ptr(e), "resolveDefaultRuntimeConfig"),
    SLe = ((e) => (
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER"), e
    ))(SLe || {}),
    gtr = "__smithy_context",
    CLe = ((e) => (
      (e.PROFILE = "profile"),
      (e.SSO_SESSION = "sso-session"),
      (e.SERVICES = "services"),
      e
    ))(CLe || {}),
    wLe = ((e) => (
      (e.HTTP_0_9 = "http/0.9"),
      (e.HTTP_1_0 = "http/1.0"),
      (e.TDS_8_0 = "tds/8.0"),
      e
    ))(wLe || {});
});
var NLe = g((ONn, xLe) => {
  c();
  var wq = Object.defineProperty,
    vtr = Object.getOwnPropertyDescriptor,
    ytr = Object.getOwnPropertyNames,
    _tr = Object.prototype.hasOwnProperty,
    Uf = (e, t) => wq(e, "name", { value: t, configurable: !0 }),
    Etr = (e, t) => {
      for (var r in t) wq(e, r, { get: t[r], enumerable: !0 });
    },
    btr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of ytr(t))
          !_tr.call(e, i) &&
            i !== r &&
            wq(e, i, {
              get: () => t[i],
              enumerable: !(n = vtr(t, i)) || n.enumerable,
            });
      return e;
    },
    Str = (e) => btr(wq({}, "__esModule", { value: !0 }), e),
    ALe = {};
  Etr(ALe, {
    Field: () => Otr,
    Fields: () => Ttr,
    HttpRequest: () => Atr,
    HttpResponse: () => Ptr,
    IHttpRequest: () => PLe.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => Ctr,
    isValidHostname: () => ILe,
    resolveHttpHandlerRuntimeConfig: () => wtr,
  });
  xLe.exports = Str(ALe);
  var Ctr = Uf(
      (e) => ({
        setHttpHandler(t) {
          e.httpHandler = t;
        },
        httpHandler() {
          return e.httpHandler;
        },
        updateHttpClientConfig(t, r) {
          e.httpHandler?.updateHttpClientConfig(t, r);
        },
        httpHandlerConfigs() {
          return e.httpHandler.httpHandlerConfigs();
        },
      }),
      "getHttpHandlerExtensionConfiguration",
    ),
    wtr = Uf(
      (e) => ({ httpHandler: e.httpHandler() }),
      "resolveHttpHandlerRuntimeConfig",
    ),
    PLe = TLe(),
    Otr = class {
      static {
        Uf(this, "Field");
      }
      constructor({
        name: e,
        kind: t = PLe.FieldPosition.HEADER,
        values: r = [],
      }) {
        (this.name = e), (this.kind = t), (this.values = r);
      }
      add(e) {
        this.values.push(e);
      }
      set(e) {
        this.values = e;
      }
      remove(e) {
        this.values = this.values.filter((t) => t !== e);
      }
      toString() {
        return this.values
          .map((e) => (e.includes(",") || e.includes(" ") ? `"${e}"` : e))
          .join(", ");
      }
      get() {
        return this.values;
      }
    },
    Ttr = class {
      constructor({ fields: e = [], encoding: t = "utf-8" }) {
        (this.entries = {}),
          e.forEach(this.setField.bind(this)),
          (this.encoding = t);
      }
      static {
        Uf(this, "Fields");
      }
      setField(e) {
        this.entries[e.name.toLowerCase()] = e;
      }
      getField(e) {
        return this.entries[e.toLowerCase()];
      }
      removeField(e) {
        delete this.entries[e.toLowerCase()];
      }
      getByType(e) {
        return Object.values(this.entries).filter((t) => t.kind === e);
      }
    },
    Atr = class kQ {
      static {
        Uf(this, "HttpRequest");
      }
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new kQ({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = RLe(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return kQ.clone(this);
      }
    };
  function RLe(e) {
    return Object.keys(e).reduce((t, r) => {
      let n = e[r];
      return { ...t, [r]: Array.isArray(n) ? [...n] : n };
    }, {});
  }
  Uf(RLe, "cloneQuery");
  var Ptr = class {
    static {
      Uf(this, "HttpResponse");
    }
    constructor(e) {
      (this.statusCode = e.statusCode),
        (this.reason = e.reason),
        (this.headers = e.headers || {}),
        (this.body = e.body);
    }
    static isInstance(e) {
      if (!e) return !1;
      let t = e;
      return typeof t.statusCode == "number" && typeof t.headers == "object";
    }
  };
  function ILe(e) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e);
  }
  Uf(ILe, "isValidHostname");
});
var MLe = g((INn, LLe) => {
  "use strict";
  c();
  var Oq = Object.defineProperty,
    Rtr = Object.getOwnPropertyDescriptor,
    Itr = Object.getOwnPropertyNames,
    xtr = Object.prototype.hasOwnProperty,
    DQ = (e, t) => Oq(e, "name", { value: t, configurable: !0 }),
    Ntr = (e, t) => {
      for (var r in t) Oq(e, r, { get: t[r], enumerable: !0 });
    },
    ktr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Itr(t))
          !xtr.call(e, i) &&
            i !== r &&
            Oq(e, i, {
              get: () => t[i],
              enumerable: !(n = Rtr(t, i)) || n.enumerable,
            });
      return e;
    },
    Dtr = (e) => ktr(Oq({}, "__esModule", { value: !0 }), e),
    kLe = {};
  Ntr(kLe, {
    addExpectContinueMiddleware: () => LQ,
    addExpectContinueMiddlewareOptions: () => DLe,
    getAddExpectContinuePlugin: () => Mtr,
  });
  LLe.exports = Dtr(kLe);
  var Ltr = NLe();
  function LQ(e) {
    return (t) => async (r) => {
      let { request: n } = r;
      return (
        Ltr.HttpRequest.isInstance(n) &&
          n.body &&
          e.runtime === "node" &&
          e.requestHandler?.constructor?.name !== "FetchHttpHandler" &&
          (n.headers = { ...n.headers, Expect: "100-continue" }),
        t({ ...r, request: n })
      );
    };
  }
  DQ(LQ, "addExpectContinueMiddleware");
  var DLe = {
      step: "build",
      tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
      name: "addExpectContinueMiddleware",
      override: !0,
    },
    Mtr = DQ(
      (e) => ({
        applyToStack: DQ((t) => {
          t.add(LQ(e), DLe);
        }, "applyToStack"),
      }),
      "getAddExpectContinuePlugin",
    );
});
var MQ,
  qtr,
  qLe = w(() => {
    c();
    (MQ = { warningEmitted: !1 }),
      (qtr = (e) => {
        e &&
          !MQ.warningEmitted &&
          parseInt(e.substring(1, e.indexOf("."))) < 18 &&
          ((MQ.warningEmitted = !0),
          process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`));
      });
  });
function qQ(e, t, r) {
  return e.$source || (e.$source = {}), (e.$source[t] = r), e;
}
var jLe = w(() => {
  c();
});
function jtr(e, t, r) {
  e.__aws_sdk_context
    ? e.__aws_sdk_context.features || (e.__aws_sdk_context.features = {})
    : (e.__aws_sdk_context = { features: {} }),
    (e.__aws_sdk_context.features[t] = r);
}
var FLe = w(() => {
  c();
});
var jQ = w(() => {
  c();
  qLe();
  jLe();
  FLe();
});
var Hf = g((GNn, WLe) => {
  c();
  var Tq = Object.defineProperty,
    Ftr = Object.getOwnPropertyDescriptor,
    Btr = Object.getOwnPropertyNames,
    Utr = Object.prototype.hasOwnProperty,
    Aq = (e, t) => Tq(e, "name", { value: t, configurable: !0 }),
    Htr = (e, t) => {
      for (var r in t) Tq(e, r, { get: t[r], enumerable: !0 });
    },
    Gtr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Btr(t))
          !Utr.call(e, i) &&
            i !== r &&
            Tq(e, i, {
              get: () => t[i],
              enumerable: !(n = Ftr(t, i)) || n.enumerable,
            });
      return e;
    },
    Vtr = (e) => Gtr(Tq({}, "__esModule", { value: !0 }), e),
    BLe = {};
  Htr(BLe, {
    AlgorithmId: () => VLe,
    EndpointURLScheme: () => GLe,
    FieldPosition: () => $Le,
    HttpApiKeyAuthLocation: () => HLe,
    HttpAuthLocation: () => ULe,
    IniSectionType: () => zLe,
    RequestHandlerProtocol: () => KLe,
    SMITHY_CONTEXT_KEY: () => Qtr,
    getDefaultClientConfiguration: () => Ktr,
    resolveDefaultRuntimeConfig: () => Wtr,
  });
  WLe.exports = Vtr(BLe);
  var ULe = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(ULe || {}),
    HLe = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(HLe || {}),
    GLe = ((e) => ((e.HTTP = "http"), (e.HTTPS = "https"), e))(GLe || {}),
    VLe = ((e) => (
      (e.MD5 = "md5"),
      (e.CRC32 = "crc32"),
      (e.CRC32C = "crc32c"),
      (e.SHA1 = "sha1"),
      (e.SHA256 = "sha256"),
      e
    ))(VLe || {}),
    $tr = Aq((e) => {
      let t = [];
      return (
        e.sha256 !== void 0 &&
          t.push({
            algorithmId: () => "sha256",
            checksumConstructor: () => e.sha256,
          }),
        e.md5 != null &&
          t.push({
            algorithmId: () => "md5",
            checksumConstructor: () => e.md5,
          }),
        {
          addChecksumAlgorithm(r) {
            t.push(r);
          },
          checksumAlgorithms() {
            return t;
          },
        }
      );
    }, "getChecksumConfiguration"),
    ztr = Aq((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    Ktr = Aq((e) => $tr(e), "getDefaultClientConfiguration"),
    Wtr = Aq((e) => ztr(e), "resolveDefaultRuntimeConfig"),
    $Le = ((e) => (
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER"), e
    ))($Le || {}),
    Qtr = "__smithy_context",
    zLe = ((e) => (
      (e.PROFILE = "profile"),
      (e.SSO_SESSION = "sso-session"),
      (e.SERVICES = "services"),
      e
    ))(zLe || {}),
    KLe = ((e) => (
      (e.HTTP_0_9 = "http/0.9"),
      (e.HTTP_1_0 = "http/1.0"),
      (e.TDS_8_0 = "tds/8.0"),
      e
    ))(KLe || {});
});
var ts = g(($Nn, ZLe) => {
  c();
  var Pq = Object.defineProperty,
    Ytr = Object.getOwnPropertyDescriptor,
    Xtr = Object.getOwnPropertyNames,
    Jtr = Object.prototype.hasOwnProperty,
    Gf = (e, t) => Pq(e, "name", { value: t, configurable: !0 }),
    Ztr = (e, t) => {
      for (var r in t) Pq(e, r, { get: t[r], enumerable: !0 });
    },
    err = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Xtr(t))
          !Jtr.call(e, i) &&
            i !== r &&
            Pq(e, i, {
              get: () => t[i],
              enumerable: !(n = Ytr(t, i)) || n.enumerable,
            });
      return e;
    },
    trr = (e) => err(Pq({}, "__esModule", { value: !0 }), e),
    QLe = {};
  Ztr(QLe, {
    Field: () => irr,
    Fields: () => orr,
    HttpRequest: () => arr,
    HttpResponse: () => srr,
    IHttpRequest: () => YLe.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => rrr,
    isValidHostname: () => JLe,
    resolveHttpHandlerRuntimeConfig: () => nrr,
  });
  ZLe.exports = trr(QLe);
  var rrr = Gf(
      (e) => ({
        setHttpHandler(t) {
          e.httpHandler = t;
        },
        httpHandler() {
          return e.httpHandler;
        },
        updateHttpClientConfig(t, r) {
          e.httpHandler?.updateHttpClientConfig(t, r);
        },
        httpHandlerConfigs() {
          return e.httpHandler.httpHandlerConfigs();
        },
      }),
      "getHttpHandlerExtensionConfiguration",
    ),
    nrr = Gf(
      (e) => ({ httpHandler: e.httpHandler() }),
      "resolveHttpHandlerRuntimeConfig",
    ),
    YLe = Hf(),
    irr = class {
      static {
        Gf(this, "Field");
      }
      constructor({
        name: e,
        kind: t = YLe.FieldPosition.HEADER,
        values: r = [],
      }) {
        (this.name = e), (this.kind = t), (this.values = r);
      }
      add(e) {
        this.values.push(e);
      }
      set(e) {
        this.values = e;
      }
      remove(e) {
        this.values = this.values.filter((t) => t !== e);
      }
      toString() {
        return this.values
          .map((e) => (e.includes(",") || e.includes(" ") ? `"${e}"` : e))
          .join(", ");
      }
      get() {
        return this.values;
      }
    },
    orr = class {
      constructor({ fields: e = [], encoding: t = "utf-8" }) {
        (this.entries = {}),
          e.forEach(this.setField.bind(this)),
          (this.encoding = t);
      }
      static {
        Gf(this, "Fields");
      }
      setField(e) {
        this.entries[e.name.toLowerCase()] = e;
      }
      getField(e) {
        return this.entries[e.toLowerCase()];
      }
      removeField(e) {
        delete this.entries[e.toLowerCase()];
      }
      getByType(e) {
        return Object.values(this.entries).filter((t) => t.kind === e);
      }
    },
    arr = class FQ {
      static {
        Gf(this, "HttpRequest");
      }
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new FQ({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = XLe(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return FQ.clone(this);
      }
    };
  function XLe(e) {
    return Object.keys(e).reduce((t, r) => {
      let n = e[r];
      return { ...t, [r]: Array.isArray(n) ? [...n] : n };
    }, {});
  }
  Gf(XLe, "cloneQuery");
  var srr = class {
    static {
      Gf(this, "HttpResponse");
    }
    constructor(e) {
      (this.statusCode = e.statusCode),
        (this.reason = e.reason),
        (this.headers = e.headers || {}),
        (this.body = e.body);
    }
    static isInstance(e) {
      if (!e) return !1;
      let t = e;
      return typeof t.statusCode == "number" && typeof t.headers == "object";
    }
  };
  function JLe(e) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e);
  }
  Gf(JLe, "isValidHostname");
});
var eMe,
  BQ,
  tMe = w(() => {
    c();
    (eMe = A(ts())),
      (BQ = (e) =>
        eMe.HttpResponse.isInstance(e)
          ? (e.headers?.date ?? e.headers?.Date)
          : void 0);
  });
var W_,
  UQ = w(() => {
    c();
    W_ = (e) => new Date(Date.now() + e);
  });
var rMe,
  nMe = w(() => {
    c();
    UQ();
    rMe = (e, t) => Math.abs(W_(t).getTime() - e) >= 3e5;
  });
var HQ,
  iMe = w(() => {
    c();
    nMe();
    HQ = (e, t) => {
      let r = Date.parse(e);
      return rMe(r, t) ? r - Date.now() : t;
    };
  });
var GQ = w(() => {
  c();
  tMe();
  UQ();
  iMe();
});
var oMe,
  Zw,
  eO,
  Th,
  aMe,
  VQ = w(() => {
    c();
    oMe = A(ts());
    GQ();
    (Zw = (e, t) => {
      if (!t)
        throw new Error(
          `Property \`${e}\` is not resolved for AWS SDK SigV4Auth`,
        );
      return t;
    }),
      (eO = async (e) => {
        let t = Zw("context", e.context),
          r = Zw("config", e.config),
          n = t.endpointV2?.properties?.authSchemes?.[0],
          o = await Zw("signer", r.signer)(n),
          a = e?.signingRegion,
          s = e?.signingRegionSet,
          u = e?.signingName;
        return {
          config: r,
          signer: o,
          signingRegion: a,
          signingRegionSet: s,
          signingName: u,
        };
      }),
      (Th = class {
        async sign(t, r, n) {
          if (!oMe.HttpRequest.isInstance(t))
            throw new Error(
              "The request is not an instance of `HttpRequest` and cannot be signed",
            );
          let i = await eO(n),
            { config: o, signer: a } = i,
            { signingRegion: s, signingName: u } = i,
            l = n.context;
          if (l?.authSchemes?.length ?? !1) {
            let [f, m] = l.authSchemes;
            f?.name === "sigv4a" &&
              m?.name === "sigv4" &&
              ((s = m?.signingRegion ?? s), (u = m?.signingName ?? u));
          }
          return await a.sign(t, {
            signingDate: W_(o.systemClockOffset),
            signingRegion: s,
            signingService: u,
          });
        }
        errorHandler(t) {
          return (r) => {
            let n = r.ServerTime ?? BQ(r.$response);
            if (n) {
              let i = Zw("config", t.config),
                o = i.systemClockOffset;
              (i.systemClockOffset = HQ(n, i.systemClockOffset)),
                i.systemClockOffset !== o &&
                  r.$metadata &&
                  (r.$metadata.clockSkewCorrected = !0);
            }
            throw r;
          };
        }
        successHandler(t, r) {
          let n = BQ(t);
          if (n) {
            let i = Zw("config", r.config);
            i.systemClockOffset = HQ(n, i.systemClockOffset);
          }
        }
      }),
      (aMe = Th);
  });
var sMe,
  Rq,
  cMe = w(() => {
    c();
    sMe = A(ts());
    GQ();
    VQ();
    Rq = class extends Th {
      async sign(t, r, n) {
        if (!sMe.HttpRequest.isInstance(t))
          throw new Error(
            "The request is not an instance of `HttpRequest` and cannot be signed",
          );
        let {
            config: i,
            signer: o,
            signingRegion: a,
            signingRegionSet: s,
            signingName: u,
          } = await eO(n),
          d = ((await i.sigv4aSigningRegionSet?.()) ?? s ?? [a]).join(",");
        return await o.sign(t, {
          signingDate: W_(i.systemClockOffset),
          signingRegion: d,
          signingService: u,
        });
      }
    };
  });
var $Q,
  uMe = w(() => {
    c();
    $Q = (e) =>
      typeof e == "string" && e.length > 0
        ? e.split(",").map((t) => t.trim())
        : [];
  });
var lMe,
  dMe,
  crr,
  fMe = w(() => {
    c();
    uMe();
    (lMe = "AWS_AUTH_SCHEME_PREFERENCE"),
      (dMe = "auth_scheme_preference"),
      (crr = {
        environmentVariableSelector: (e) => {
          if (lMe in e) return $Q(e[lMe]);
        },
        configFileSelector: (e) => {
          if (dMe in e) return $Q(e[dMe]);
        },
        default: [],
      });
  });
var urr,
  pMe = w(() => {
    c();
    urr = A(Hf());
  });
var tO = g((Okn, vMe) => {
  c();
  var Iq = Object.defineProperty,
    lrr = Object.getOwnPropertyDescriptor,
    drr = Object.getOwnPropertyNames,
    frr = Object.prototype.hasOwnProperty,
    hMe = (e, t) => Iq(e, "name", { value: t, configurable: !0 }),
    prr = (e, t) => {
      for (var r in t) Iq(e, r, { get: t[r], enumerable: !0 });
    },
    mrr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of drr(t))
          !frr.call(e, i) &&
            i !== r &&
            Iq(e, i, {
              get: () => t[i],
              enumerable: !(n = lrr(t, i)) || n.enumerable,
            });
      return e;
    },
    hrr = (e) => mrr(Iq({}, "__esModule", { value: !0 }), e),
    gMe = {};
  prr(gMe, { getSmithyContext: () => grr, normalizeProvider: () => vrr });
  vMe.exports = hrr(gMe);
  var mMe = Hf(),
    grr = hMe(
      (e) => e[mMe.SMITHY_CONTEXT_KEY] || (e[mMe.SMITHY_CONTEXT_KEY] = {}),
      "getSmithyContext",
    ),
    vrr = hMe((e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    }, "normalizeProvider");
});
var yMe = w(() => {
  c();
});
var Ikn,
  yrr,
  xq = w(() => {
    c();
    (Ikn = A(Hf())), (yrr = A(tO()));
    yMe();
  });
var _Me = w(() => {
  c();
  xq();
});
var AMe = g((jkn, TMe) => {
  c();
  var Nq = Object.defineProperty,
    Err = Object.getOwnPropertyDescriptor,
    brr = Object.getOwnPropertyNames,
    Srr = Object.prototype.hasOwnProperty,
    zQ = (e, t) => Nq(e, "name", { value: t, configurable: !0 }),
    Crr = (e, t) => {
      for (var r in t) Nq(e, r, { get: t[r], enumerable: !0 });
    },
    wrr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of brr(t))
          !Srr.call(e, i) &&
            i !== r &&
            Nq(e, i, {
              get: () => t[i],
              enumerable: !(n = Err(t, i)) || n.enumerable,
            });
      return e;
    },
    Orr = (e) => wrr(Nq({}, "__esModule", { value: !0 }), e),
    EMe = {};
  Crr(EMe, {
    deserializerMiddleware: () => bMe,
    deserializerMiddlewareOption: () => CMe,
    getSerdePlugin: () => OMe,
    serializerMiddleware: () => SMe,
    serializerMiddlewareOption: () => wMe,
  });
  TMe.exports = Orr(EMe);
  var bMe = zQ(
      (e, t) => (r, n) => async (i) => {
        let { response: o } = await r(i);
        try {
          let a = await t(o, e);
          return { response: o, output: a };
        } catch (a) {
          if (
            (Object.defineProperty(a, "$response", { value: o }),
            !("$metadata" in a))
          ) {
            let s =
              "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
            try {
              a.message +=
                `
  ` + s;
            } catch {
              !n.logger || n.logger?.constructor?.name === "NoOpLogger"
                ? console.warn(s)
                : n.logger?.warn?.(s);
            }
            typeof a.$responseBodyText < "u" &&
              a.$response &&
              (a.$response.body = a.$responseBodyText);
          }
          throw a;
        }
      },
      "deserializerMiddleware",
    ),
    SMe = zQ(
      (e, t) => (r, n) => async (i) => {
        let o =
          n.endpointV2?.url && e.urlParser
            ? async () => e.urlParser(n.endpointV2.url)
            : e.endpoint;
        if (!o) throw new Error("No valid endpoint provider available.");
        let a = await t(i.input, { ...e, endpoint: o });
        return r({ ...i, request: a });
      },
      "serializerMiddleware",
    ),
    CMe = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: !0,
    },
    wMe = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: !0,
    };
  function OMe(e, t, r) {
    return {
      applyToStack: (n) => {
        n.add(bMe(e, r), CMe), n.add(SMe(e, t), wMe);
      },
    };
  }
  zQ(OMe, "getSerdePlugin");
});
var PMe,
  Ukn,
  RMe = w(() => {
    c();
    PMe = A(AMe());
    xq();
    Ukn = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: PMe.serializerMiddlewareOption.name,
    };
  });
var IMe = w(() => {
  c();
  xq();
  _Me();
  RMe();
});
var Trr,
  Qkn,
  Arr,
  KQ = w(() => {
    c();
    (Trr = A(ts())), (Qkn = A(Hf())), (Arr = A(tO()));
  });
var xMe = w(() => {
  c();
  KQ();
});
var NMe = w(() => {
  c();
  KQ();
  xMe();
});
var Ah,
  kMe = w(() => {
    c();
    Ah = (e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    };
  });
var DMe = w(() => {
  c();
});
var LMe = g((kq) => {
  "use strict";
  c();
  Object.defineProperty(kq, "__esModule", { value: !0 });
  kq.fromBase64 = void 0;
  var Prr = Hi(),
    Rrr = /^[A-Za-z0-9+/]*={0,2}$/,
    Irr = (e) => {
      if ((e.length * 3) % 4 !== 0)
        throw new TypeError("Incorrect padding on base64 string.");
      if (!Rrr.exec(e)) throw new TypeError("Invalid base64 string.");
      let t = (0, Prr.fromString)(e, "base64");
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    };
  kq.fromBase64 = Irr;
});
var MMe = g((Dq) => {
  "use strict";
  c();
  Object.defineProperty(Dq, "__esModule", { value: !0 });
  Dq.toBase64 = void 0;
  var xrr = Hi(),
    Nrr = Fe(),
    krr = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = (0, Nrr.fromUtf8)(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.",
        );
      return (0, xrr.fromArrayBuffer)(
        t.buffer,
        t.byteOffset,
        t.byteLength,
      ).toString("base64");
    };
  Dq.toBase64 = krr;
});
var Q_ = g((hDn, Lq) => {
  c();
  var qMe = Object.defineProperty,
    Drr = Object.getOwnPropertyDescriptor,
    Lrr = Object.getOwnPropertyNames,
    Mrr = Object.prototype.hasOwnProperty,
    WQ = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Lrr(t))
          !Mrr.call(e, i) &&
            i !== r &&
            qMe(e, i, {
              get: () => t[i],
              enumerable: !(n = Drr(t, i)) || n.enumerable,
            });
      return e;
    },
    jMe = (e, t, r) => (WQ(e, t, "default"), r && WQ(r, t, "default")),
    qrr = (e) => WQ(qMe({}, "__esModule", { value: !0 }), e),
    QQ = {};
  Lq.exports = qrr(QQ);
  jMe(QQ, LMe(), Lq.exports);
  jMe(QQ, MMe(), Lq.exports);
});
var XQ = g((Mq) => {
  "use strict";
  c();
  Object.defineProperty(Mq, "__esModule", { value: !0 });
  Mq.ChecksumStream = void 0;
  var jrr = Q_(),
    Frr = G("stream"),
    YQ = class extends Frr.Duplex {
      constructor({
        expectedChecksum: t,
        checksum: r,
        source: n,
        checksumSourceLocation: i,
        base64Encoder: o,
      }) {
        var a, s;
        if ((super(), typeof n.pipe == "function")) this.source = n;
        else
          throw new Error(
            `@smithy/util-stream: unsupported source type ${(s = (a = n?.constructor) === null || a === void 0 ? void 0 : a.name) !== null && s !== void 0 ? s : n} in ChecksumStream.`,
          );
        (this.base64Encoder = o ?? jrr.toBase64),
          (this.expectedChecksum = t),
          (this.checksum = r),
          (this.checksumSourceLocation = i),
          this.source.pipe(this);
      }
      _read(t) {}
      _write(t, r, n) {
        try {
          this.checksum.update(t), this.push(t);
        } catch (i) {
          return n(i);
        }
        return n();
      }
      async _final(t) {
        try {
          let r = await this.checksum.digest(),
            n = this.base64Encoder(r);
          if (this.expectedChecksum !== n)
            return t(
              new Error(
                `Checksum mismatch: expected "${this.expectedChecksum}" but received "${n}" in response header "${this.checksumSourceLocation}".`,
              ),
            );
        } catch (r) {
          return t(r);
        }
        return this.push(null), t();
      }
    };
  Mq.ChecksumStream = YQ;
});
var Vf = g((Y_) => {
  "use strict";
  c();
  Object.defineProperty(Y_, "__esModule", { value: !0 });
  Y_.isBlob = Y_.isReadableStream = void 0;
  var Brr = (e) => {
    var t;
    return (
      typeof ReadableStream == "function" &&
      (((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) ===
        ReadableStream.name ||
        e instanceof ReadableStream)
    );
  };
  Y_.isReadableStream = Brr;
  var Urr = (e) => {
    var t;
    return (
      typeof Blob == "function" &&
      (((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) ===
        Blob.name ||
        e instanceof Blob)
    );
  };
  Y_.isBlob = Urr;
});
var FMe = g((qq) => {
  "use strict";
  c();
  Object.defineProperty(qq, "__esModule", { value: !0 });
  qq.ChecksumStream = void 0;
  var Hrr =
      typeof ReadableStream == "function" ? ReadableStream : function () {},
    JQ = class extends Hrr {};
  qq.ChecksumStream = JQ;
});
var BMe = g((jq) => {
  "use strict";
  c();
  Object.defineProperty(jq, "__esModule", { value: !0 });
  jq.createChecksumStream = void 0;
  var Grr = Q_(),
    Vrr = Vf(),
    $rr = FMe(),
    zrr = ({
      expectedChecksum: e,
      checksum: t,
      source: r,
      checksumSourceLocation: n,
      base64Encoder: i,
    }) => {
      var o, a;
      if (!(0, Vrr.isReadableStream)(r))
        throw new Error(
          `@smithy/util-stream: unsupported source type ${(a = (o = r?.constructor) === null || o === void 0 ? void 0 : o.name) !== null && a !== void 0 ? a : r} in ChecksumStream.`,
        );
      let s = i ?? Grr.toBase64;
      if (typeof TransformStream != "function")
        throw new Error(
          "@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.",
        );
      let u = new TransformStream({
        start() {},
        async transform(d, f) {
          t.update(d), f.enqueue(d);
        },
        async flush(d) {
          let f = await t.digest(),
            m = s(f);
          if (e !== m) {
            let h = new Error(
              `Checksum mismatch: expected "${e}" but received "${m}" in response header "${n}".`,
            );
            d.error(h);
          } else d.terminate();
        },
      });
      r.pipeThrough(u);
      let l = u.readable;
      return Object.setPrototypeOf(l, $rr.ChecksumStream.prototype), l;
    };
  jq.createChecksumStream = zrr;
});
var UMe = g((Fq) => {
  "use strict";
  c();
  Object.defineProperty(Fq, "__esModule", { value: !0 });
  Fq.createChecksumStream = void 0;
  var Krr = Vf(),
    Wrr = XQ(),
    Qrr = BMe();
  function Yrr(e) {
    return typeof ReadableStream == "function" &&
      (0, Krr.isReadableStream)(e.source)
      ? (0, Qrr.createChecksumStream)(e)
      : new Wrr.ChecksumStream(e);
  }
  Fq.createChecksumStream = Yrr;
});
var e9 = g((Bq) => {
  "use strict";
  c();
  Object.defineProperty(Bq, "__esModule", { value: !0 });
  Bq.ByteArrayCollector = void 0;
  var ZQ = class {
    constructor(t) {
      (this.allocByteArray = t), (this.byteLength = 0), (this.byteArrays = []);
    }
    push(t) {
      this.byteArrays.push(t), (this.byteLength += t.byteLength);
    }
    flush() {
      if (this.byteArrays.length === 1) {
        let n = this.byteArrays[0];
        return this.reset(), n;
      }
      let t = this.allocByteArray(this.byteLength),
        r = 0;
      for (let n = 0; n < this.byteArrays.length; ++n) {
        let i = this.byteArrays[n];
        t.set(i, r), (r += i.byteLength);
      }
      return this.reset(), t;
    }
    reset() {
      (this.byteArrays = []), (this.byteLength = 0);
    }
  };
  Bq.ByteArrayCollector = ZQ;
});
var $Me = g((Lo) => {
  "use strict";
  c();
  Object.defineProperty(Lo, "__esModule", { value: !0 });
  Lo.modeOf =
    Lo.sizeOf =
    Lo.flush =
    Lo.merge =
    Lo.createBufferedReadable =
    Lo.createBufferedReadableStream =
      void 0;
  var Xrr = e9();
  function HMe(e, t, r) {
    let n = e.getReader(),
      i = !1,
      o = 0,
      a = ["", new Xrr.ByteArrayCollector((l) => new Uint8Array(l))],
      s = -1,
      u = async (l) => {
        let { value: d, done: f } = await n.read(),
          m = d;
        if (f) {
          if (s !== -1) {
            let h = Uq(a, s);
            X_(h) > 0 && l.enqueue(h);
          }
          l.close();
        } else {
          let h = VMe(m, !1);
          if ((s !== h && (s >= 0 && l.enqueue(Uq(a, s)), (s = h)), s === -1)) {
            l.enqueue(m);
            return;
          }
          let y = X_(m);
          o += y;
          let _ = X_(a[s]);
          if (y >= t && _ === 0) l.enqueue(m);
          else {
            let E = GMe(a, s, m);
            !i &&
              o > t * 2 &&
              ((i = !0),
              r?.warn(
                `@smithy/util-stream - stream chunk size ${y} is below threshold of ${t}, automatically buffering.`,
              )),
              E >= t ? l.enqueue(Uq(a, s)) : await u(l);
          }
        }
      };
    return new ReadableStream({ pull: u });
  }
  Lo.createBufferedReadableStream = HMe;
  Lo.createBufferedReadable = HMe;
  function GMe(e, t, r) {
    switch (t) {
      case 0:
        return (e[0] += r), X_(e[0]);
      case 1:
      case 2:
        return e[t].push(r), X_(e[t]);
    }
  }
  Lo.merge = GMe;
  function Uq(e, t) {
    switch (t) {
      case 0:
        let r = e[0];
        return (e[0] = ""), r;
      case 1:
      case 2:
        return e[t].flush();
    }
    throw new Error(
      `@smithy/util-stream - invalid index ${t} given to flush()`,
    );
  }
  Lo.flush = Uq;
  function X_(e) {
    var t, r;
    return (r =
      (t = e?.byteLength) !== null && t !== void 0 ? t : e?.length) !== null &&
      r !== void 0
      ? r
      : 0;
  }
  Lo.sizeOf = X_;
  function VMe(e, t = !0) {
    return t && typeof Buffer < "u" && e instanceof Buffer
      ? 2
      : e instanceof Uint8Array
        ? 1
        : typeof e == "string"
          ? 0
          : -1;
  }
  Lo.modeOf = VMe;
});
var KMe = g((Hq) => {
  "use strict";
  c();
  Object.defineProperty(Hq, "__esModule", { value: !0 });
  Hq.createBufferedReadable = void 0;
  var Jrr = G("node:stream"),
    zMe = e9(),
    jl = $Me(),
    Zrr = Vf();
  function enr(e, t, r) {
    if ((0, Zrr.isReadableStream)(e))
      return (0, jl.createBufferedReadableStream)(e, t, r);
    let n = new Jrr.Readable({ read() {} }),
      i = !1,
      o = 0,
      a = [
        "",
        new zMe.ByteArrayCollector((u) => new Uint8Array(u)),
        new zMe.ByteArrayCollector((u) => Buffer.from(new Uint8Array(u))),
      ],
      s = -1;
    return (
      e.on("data", (u) => {
        let l = (0, jl.modeOf)(u, !0);
        if (
          (s !== l && (s >= 0 && n.push((0, jl.flush)(a, s)), (s = l)),
          s === -1)
        ) {
          n.push(u);
          return;
        }
        let d = (0, jl.sizeOf)(u);
        o += d;
        let f = (0, jl.sizeOf)(a[s]);
        if (d >= t && f === 0) n.push(u);
        else {
          let m = (0, jl.merge)(a, s, u);
          !i &&
            o > t * 2 &&
            ((i = !0),
            r?.warn(
              `@smithy/util-stream - stream chunk size ${d} is below threshold of ${t}, automatically buffering.`,
            )),
            m >= t && n.push((0, jl.flush)(a, s));
        }
      }),
      e.on("end", () => {
        if (s !== -1) {
          let u = (0, jl.flush)(a, s);
          (0, jl.sizeOf)(u) > 0 && n.push(u);
        }
        n.push(null);
      }),
      n
    );
  }
  Hq.createBufferedReadable = enr;
});
var WMe = g((Gq) => {
  "use strict";
  c();
  Object.defineProperty(Gq, "__esModule", { value: !0 });
  Gq.getAwsChunkedEncodingStream = void 0;
  var tnr = G("stream"),
    rnr = (e, t) => {
      let {
          base64Encoder: r,
          bodyLengthChecker: n,
          checksumAlgorithmFn: i,
          checksumLocationName: o,
          streamHasher: a,
        } = t,
        s = r !== void 0 && i !== void 0 && o !== void 0 && a !== void 0,
        u = s ? a(i, e) : void 0,
        l = new tnr.Readable({ read: () => {} });
      return (
        e.on("data", (d) => {
          let f = n(d) || 0;
          l.push(`${f.toString(16)}\r
`),
            l.push(d),
            l.push(`\r
`);
        }),
        e.on("end", async () => {
          if (
            (l.push(`0\r
`),
            s)
          ) {
            let d = r(await u);
            l.push(`${o}:${d}\r
`),
              l.push(`\r
`);
          }
          l.push(null);
        }),
        l
      );
    };
  Gq.getAwsChunkedEncodingStream = rnr;
});
var QMe = g((Vq) => {
  "use strict";
  c();
  Object.defineProperty(Vq, "__esModule", { value: !0 });
  Vq.headStream = void 0;
  async function nnr(e, t) {
    var r;
    let n = 0,
      i = [],
      o = e.getReader(),
      a = !1;
    for (; !a; ) {
      let { done: l, value: d } = await o.read();
      if (
        (d &&
          (i.push(d),
          (n += (r = d?.byteLength) !== null && r !== void 0 ? r : 0)),
        n >= t)
      )
        break;
      a = l;
    }
    o.releaseLock();
    let s = new Uint8Array(Math.min(t, n)),
      u = 0;
    for (let l of i) {
      if (l.byteLength > s.byteLength - u) {
        s.set(l.subarray(0, s.byteLength - u), u);
        break;
      } else s.set(l, u);
      u += l.length;
    }
    return s;
  }
  Vq.headStream = nnr;
});
var YMe = g(($q) => {
  "use strict";
  c();
  Object.defineProperty($q, "__esModule", { value: !0 });
  $q.headStream = void 0;
  var inr = G("stream"),
    onr = QMe(),
    anr = Vf(),
    snr = (e, t) =>
      (0, anr.isReadableStream)(e)
        ? (0, onr.headStream)(e, t)
        : new Promise((r, n) => {
            let i = new t9();
            (i.limit = t),
              e.pipe(i),
              e.on("error", (o) => {
                i.end(), n(o);
              }),
              i.on("error", n),
              i.on("finish", function () {
                let o = new Uint8Array(Buffer.concat(this.buffers));
                r(o);
              });
          });
  $q.headStream = snr;
  var t9 = class extends inr.Writable {
    constructor() {
      super(...arguments),
        (this.buffers = []),
        (this.limit = 1 / 0),
        (this.bytesBuffered = 0);
    }
    _write(t, r, n) {
      var i;
      if (
        (this.buffers.push(t),
        (this.bytesBuffered +=
          (i = t.byteLength) !== null && i !== void 0 ? i : 0),
        this.bytesBuffered >= this.limit)
      ) {
        let o = this.bytesBuffered - this.limit,
          a = this.buffers[this.buffers.length - 1];
        (this.buffers[this.buffers.length - 1] = a.subarray(
          0,
          a.byteLength - o,
        )),
          this.emit("finish");
      }
      n();
    }
  };
});
var n9 = g((FDn, ZMe) => {
  c();
  var zq = Object.defineProperty,
    cnr = Object.getOwnPropertyDescriptor,
    unr = Object.getOwnPropertyNames,
    lnr = Object.prototype.hasOwnProperty,
    r9 = (e, t) => zq(e, "name", { value: t, configurable: !0 }),
    dnr = (e, t) => {
      for (var r in t) zq(e, r, { get: t[r], enumerable: !0 });
    },
    fnr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of unr(t))
          !lnr.call(e, i) &&
            i !== r &&
            zq(e, i, {
              get: () => t[i],
              enumerable: !(n = cnr(t, i)) || n.enumerable,
            });
      return e;
    },
    pnr = (e) => fnr(zq({}, "__esModule", { value: !0 }), e),
    XMe = {};
  dnr(XMe, { escapeUri: () => JMe, escapeUriPath: () => hnr });
  ZMe.exports = pnr(XMe);
  var JMe = r9(
      (e) => encodeURIComponent(e).replace(/[!'()*]/g, mnr),
      "escapeUri",
    ),
    mnr = r9(
      (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`,
      "hexEncode",
    ),
    hnr = r9((e) => e.split("/").map(JMe).join("/"), "escapeUriPath");
});
var o9 = g((UDn, rqe) => {
  c();
  var Kq = Object.defineProperty,
    gnr = Object.getOwnPropertyDescriptor,
    vnr = Object.getOwnPropertyNames,
    ynr = Object.prototype.hasOwnProperty,
    _nr = (e, t) => Kq(e, "name", { value: t, configurable: !0 }),
    Enr = (e, t) => {
      for (var r in t) Kq(e, r, { get: t[r], enumerable: !0 });
    },
    bnr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of vnr(t))
          !ynr.call(e, i) &&
            i !== r &&
            Kq(e, i, {
              get: () => t[i],
              enumerable: !(n = gnr(t, i)) || n.enumerable,
            });
      return e;
    },
    Snr = (e) => bnr(Kq({}, "__esModule", { value: !0 }), e),
    eqe = {};
  Enr(eqe, { buildQueryString: () => tqe });
  rqe.exports = Snr(eqe);
  var i9 = n9();
  function tqe(e) {
    let t = [];
    for (let r of Object.keys(e).sort()) {
      let n = e[r];
      if (((r = (0, i9.escapeUri)(r)), Array.isArray(n)))
        for (let i = 0, o = n.length; i < o; i++)
          t.push(`${r}=${(0, i9.escapeUri)(n[i])}`);
      else {
        let i = r;
        (n || typeof n == "string") && (i += `=${(0, i9.escapeUri)(n)}`),
          t.push(i);
      }
    }
    return t.join("&");
  }
  _nr(tqe, "buildQueryString");
});
var yqe = g((GDn, vqe) => {
  c();
  var Cnr = Object.create,
    rO = Object.defineProperty,
    wnr = Object.getOwnPropertyDescriptor,
    Onr = Object.getOwnPropertyNames,
    Tnr = Object.getPrototypeOf,
    Anr = Object.prototype.hasOwnProperty,
    mr = (e, t) => rO(e, "name", { value: t, configurable: !0 }),
    Pnr = (e, t) => {
      for (var r in t) rO(e, r, { get: t[r], enumerable: !0 });
    },
    sqe = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Onr(t))
          !Anr.call(e, i) &&
            i !== r &&
            rO(e, i, {
              get: () => t[i],
              enumerable: !(n = wnr(t, i)) || n.enumerable,
            });
      return e;
    },
    Rnr = (e, t, r) => (
      (r = e != null ? Cnr(Tnr(e)) : {}),
      sqe(
        t || !e || !e.__esModule
          ? rO(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    Inr = (e) => sqe(rO({}, "__esModule", { value: !0 }), e),
    cqe = {};
  Pnr(cqe, {
    DEFAULT_REQUEST_TIMEOUT: () => mqe,
    NodeHttp2Handler: () => Bnr,
    NodeHttpHandler: () => Mnr,
    streamCollector: () => Hnr,
  });
  vqe.exports = Inr(cqe);
  var uqe = ts(),
    lqe = o9(),
    a9 = G("http"),
    s9 = G("https"),
    xnr = ["ECONNRESET", "EPIPE", "ETIMEDOUT"],
    dqe = mr((e) => {
      let t = {};
      for (let r of Object.keys(e)) {
        let n = e[r];
        t[r] = Array.isArray(n) ? n.join(",") : n;
      }
      return t;
    }, "getTransformedHeaders"),
    Mo = {
      setTimeout: (e, t) => setTimeout(e, t),
      clearTimeout: (e) => clearTimeout(e),
    },
    nqe = 1e3,
    Nnr = mr((e, t, r = 0) => {
      if (!r) return -1;
      let n = mr((i) => {
        let o = Mo.setTimeout(() => {
            e.destroy(),
              t(
                Object.assign(
                  new Error(
                    `Socket timed out without establishing a connection within ${r} ms`,
                  ),
                  { name: "TimeoutError" },
                ),
              );
          }, r - i),
          a = mr((s) => {
            s?.connecting
              ? s.on("connect", () => {
                  Mo.clearTimeout(o);
                })
              : Mo.clearTimeout(o);
          }, "doWithSocket");
        e.socket ? a(e.socket) : e.on("socket", a);
      }, "registerTimeout");
      return r < 2e3 ? (n(0), 0) : Mo.setTimeout(n.bind(null, nqe), nqe);
    }, "setConnectionTimeout"),
    knr = 3e3,
    Dnr = mr((e, { keepAlive: t, keepAliveMsecs: r }, n = knr) => {
      if (t !== !0) return -1;
      let i = mr(() => {
        e.socket
          ? e.socket.setKeepAlive(t, r || 0)
          : e.on("socket", (o) => {
              o.setKeepAlive(t, r || 0);
            });
      }, "registerListener");
      return n === 0 ? (i(), 0) : Mo.setTimeout(i, n);
    }, "setSocketKeepAlive"),
    iqe = 3e3,
    Lnr = mr((e, t, r = mqe) => {
      let n = mr((i) => {
        let o = r - i,
          a = mr(() => {
            e.destroy(),
              t(
                Object.assign(new Error(`Connection timed out after ${r} ms`), {
                  name: "TimeoutError",
                }),
              );
          }, "onTimeout");
        e.socket
          ? (e.socket.setTimeout(o, a),
            e.on("close", () => e.socket?.removeListener("timeout", a)))
          : e.setTimeout(o, a);
      }, "registerTimeout");
      return 0 < r && r < 6e3
        ? (n(0), 0)
        : Mo.setTimeout(n.bind(null, r === 0 ? 0 : iqe), iqe);
    }, "setSocketTimeout"),
    fqe = G("stream"),
    oqe = 6e3;
  async function u9(e, t, r = oqe) {
    let n = t.headers ?? {},
      i = n.Expect || n.expect,
      o = -1,
      a = !0;
    i === "100-continue" &&
      (a = await Promise.race([
        new Promise((s) => {
          o = Number(Mo.setTimeout(() => s(!0), Math.max(oqe, r)));
        }),
        new Promise((s) => {
          e.on("continue", () => {
            Mo.clearTimeout(o), s(!0);
          }),
            e.on("response", () => {
              Mo.clearTimeout(o), s(!1);
            }),
            e.on("error", () => {
              Mo.clearTimeout(o), s(!1);
            });
        }),
      ])),
      a && pqe(e, t.body);
  }
  mr(u9, "writeRequestBody");
  function pqe(e, t) {
    if (t instanceof fqe.Readable) {
      t.pipe(e);
      return;
    }
    if (t) {
      if (Buffer.isBuffer(t) || typeof t == "string") {
        e.end(t);
        return;
      }
      let r = t;
      if (
        typeof r == "object" &&
        r.buffer &&
        typeof r.byteOffset == "number" &&
        typeof r.byteLength == "number"
      ) {
        e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength));
        return;
      }
      e.end(Buffer.from(t));
      return;
    }
    e.end();
  }
  mr(pqe, "writeBody");
  var mqe = 0,
    Mnr = class c9 {
      constructor(t) {
        (this.socketWarningTimestamp = 0),
          (this.metadata = { handlerProtocol: "http/1.1" }),
          (this.configProvider = new Promise((r, n) => {
            typeof t == "function"
              ? t()
                  .then((i) => {
                    r(this.resolveDefaultConfig(i));
                  })
                  .catch(n)
              : r(this.resolveDefaultConfig(t));
          }));
      }
      static {
        mr(this, "NodeHttpHandler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new c9(t);
      }
      static checkSocketUsage(t, r, n = console) {
        let { sockets: i, requests: o, maxSockets: a } = t;
        if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r)
          return r;
        if (i && o)
          for (let u in i) {
            let l = i[u]?.length ?? 0,
              d = o[u]?.length ?? 0;
            if (l >= a && d >= 2 * a)
              return (
                n?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${l} and ${d} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`),
                Date.now()
              );
          }
        return r;
      }
      resolveDefaultConfig(t) {
        let {
            requestTimeout: r,
            connectionTimeout: n,
            socketTimeout: i,
            socketAcquisitionWarningTimeout: o,
            httpAgent: a,
            httpsAgent: s,
          } = t || {},
          u = !0,
          l = 50;
        return {
          connectionTimeout: n,
          requestTimeout: r ?? i,
          socketAcquisitionWarningTimeout: o,
          httpAgent:
            a instanceof a9.Agent || typeof a?.destroy == "function"
              ? a
              : new a9.Agent({ keepAlive: u, maxSockets: l, ...a }),
          httpsAgent:
            s instanceof s9.Agent || typeof s?.destroy == "function"
              ? s
              : new s9.Agent({ keepAlive: u, maxSockets: l, ...s }),
          logger: console,
        };
      }
      destroy() {
        this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy();
      }
      async handle(t, { abortSignal: r } = {}) {
        return (
          this.config || (this.config = await this.configProvider),
          new Promise((n, i) => {
            let o,
              a = [],
              s = mr(async (C) => {
                await o, a.forEach(Mo.clearTimeout), n(C);
              }, "resolve"),
              u = mr(async (C) => {
                await o, a.forEach(Mo.clearTimeout), i(C);
              }, "reject");
            if (!this.config)
              throw new Error(
                "Node HTTP request handler config is not resolved",
              );
            if (r?.aborted) {
              let C = new Error("Request aborted");
              (C.name = "AbortError"), u(C);
              return;
            }
            let l = t.protocol === "https:",
              d = l ? this.config.httpsAgent : this.config.httpAgent;
            a.push(
              Mo.setTimeout(
                () => {
                  this.socketWarningTimestamp = c9.checkSocketUsage(
                    d,
                    this.socketWarningTimestamp,
                    this.config.logger,
                  );
                },
                this.config.socketAcquisitionWarningTimeout ??
                  (this.config.requestTimeout ?? 2e3) +
                    (this.config.connectionTimeout ?? 1e3),
              ),
            );
            let f = (0, lqe.buildQueryString)(t.query || {}),
              m;
            if (t.username != null || t.password != null) {
              let C = t.username ?? "",
                P = t.password ?? "";
              m = `${C}:${P}`;
            }
            let h = t.path;
            f && (h += `?${f}`), t.fragment && (h += `#${t.fragment}`);
            let y = t.hostname ?? "";
            y[0] === "[" && y.endsWith("]")
              ? (y = t.hostname.slice(1, -1))
              : (y = t.hostname);
            let _ = {
                headers: t.headers,
                host: y,
                method: t.method,
                path: h,
                port: t.port,
                agent: d,
                auth: m,
              },
              b = (l ? s9.request : a9.request)(_, (C) => {
                let P = new uqe.HttpResponse({
                  statusCode: C.statusCode || -1,
                  reason: C.statusMessage,
                  headers: dqe(C.headers),
                  body: C,
                });
                s({ response: P });
              });
            if (
              (b.on("error", (C) => {
                xnr.includes(C.code)
                  ? u(Object.assign(C, { name: "TimeoutError" }))
                  : u(C);
              }),
              r)
            ) {
              let C = mr(() => {
                b.destroy();
                let P = new Error("Request aborted");
                (P.name = "AbortError"), u(P);
              }, "onAbort");
              if (typeof r.addEventListener == "function") {
                let P = r;
                P.addEventListener("abort", C, { once: !0 }),
                  b.once("close", () => P.removeEventListener("abort", C));
              } else r.onabort = C;
            }
            a.push(Nnr(b, u, this.config.connectionTimeout)),
              a.push(Lnr(b, u, this.config.requestTimeout));
            let O = _.agent;
            typeof O == "object" &&
              "keepAlive" in O &&
              a.push(
                Dnr(b, {
                  keepAlive: O.keepAlive,
                  keepAliveMsecs: O.keepAliveMsecs,
                }),
              ),
              (o = u9(b, t, this.config.requestTimeout).catch(
                (C) => (a.forEach(Mo.clearTimeout), i(C)),
              ));
          })
        );
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then((n) => ({
            ...n,
            [t]: r,
          })));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    },
    aqe = G("http2"),
    qnr = Rnr(G("http2")),
    jnr = class {
      constructor(e) {
        (this.sessions = []), (this.sessions = e ?? []);
      }
      static {
        mr(this, "NodeHttp2ConnectionPool");
      }
      poll() {
        if (this.sessions.length > 0) return this.sessions.shift();
      }
      offerLast(e) {
        this.sessions.push(e);
      }
      contains(e) {
        return this.sessions.includes(e);
      }
      remove(e) {
        this.sessions = this.sessions.filter((t) => t !== e);
      }
      [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
      }
      destroy(e) {
        for (let t of this.sessions) t === e && (t.destroyed || t.destroy());
      }
    },
    Fnr = class {
      constructor(e) {
        if (
          ((this.sessionCache = new Map()),
          (this.config = e),
          this.config.maxConcurrency && this.config.maxConcurrency <= 0)
        )
          throw new RangeError("maxConcurrency must be greater than zero.");
      }
      static {
        mr(this, "NodeHttp2ConnectionManager");
      }
      lease(e, t) {
        let r = this.getUrlString(e),
          n = this.sessionCache.get(r);
        if (n) {
          let s = n.poll();
          if (s && !this.config.disableConcurrency) return s;
        }
        let i = qnr.default.connect(r);
        this.config.maxConcurrency &&
          i.settings(
            { maxConcurrentStreams: this.config.maxConcurrency },
            (s) => {
              if (s)
                throw new Error(
                  "Fail to set maxConcurrentStreams to " +
                    this.config.maxConcurrency +
                    "when creating new session for " +
                    e.destination.toString(),
                );
            },
          ),
          i.unref();
        let o = mr(() => {
          i.destroy(), this.deleteSession(r, i);
        }, "destroySessionCb");
        i.on("goaway", o),
          i.on("error", o),
          i.on("frameError", o),
          i.on("close", () => this.deleteSession(r, i)),
          t.requestTimeout && i.setTimeout(t.requestTimeout, o);
        let a = this.sessionCache.get(r) || new jnr();
        return a.offerLast(i), this.sessionCache.set(r, a), i;
      }
      deleteSession(e, t) {
        let r = this.sessionCache.get(e);
        r && r.contains(t) && (r.remove(t), this.sessionCache.set(e, r));
      }
      release(e, t) {
        let r = this.getUrlString(e);
        this.sessionCache.get(r)?.offerLast(t);
      }
      destroy() {
        for (let [e, t] of this.sessionCache) {
          for (let r of t) r.destroyed || r.destroy(), t.remove(r);
          this.sessionCache.delete(e);
        }
      }
      setMaxConcurrentStreams(e) {
        if (e && e <= 0)
          throw new RangeError(
            "maxConcurrentStreams must be greater than zero.",
          );
        this.config.maxConcurrency = e;
      }
      setDisableConcurrentStreams(e) {
        this.config.disableConcurrency = e;
      }
      getUrlString(e) {
        return e.destination.toString();
      }
    },
    Bnr = class hqe {
      constructor(t) {
        (this.metadata = { handlerProtocol: "h2" }),
          (this.connectionManager = new Fnr({})),
          (this.configProvider = new Promise((r, n) => {
            typeof t == "function"
              ? t()
                  .then((i) => {
                    r(i || {});
                  })
                  .catch(n)
              : r(t || {});
          }));
      }
      static {
        mr(this, "NodeHttp2Handler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new hqe(t);
      }
      destroy() {
        this.connectionManager.destroy();
      }
      async handle(t, { abortSignal: r } = {}) {
        this.config ||
          ((this.config = await this.configProvider),
          this.connectionManager.setDisableConcurrentStreams(
            this.config.disableConcurrentStreams || !1,
          ),
          this.config.maxConcurrentStreams &&
            this.connectionManager.setMaxConcurrentStreams(
              this.config.maxConcurrentStreams,
            ));
        let { requestTimeout: n, disableConcurrentStreams: i } = this.config;
        return new Promise((o, a) => {
          let s = !1,
            u,
            l = mr(async (L) => {
              await u, o(L);
            }, "resolve"),
            d = mr(async (L) => {
              await u, a(L);
            }, "reject");
          if (r?.aborted) {
            s = !0;
            let L = new Error("Request aborted");
            (L.name = "AbortError"), d(L);
            return;
          }
          let { hostname: f, method: m, port: h, protocol: y, query: _ } = t,
            E = "";
          if (t.username != null || t.password != null) {
            let L = t.username ?? "",
              Z = t.password ?? "";
            E = `${L}:${Z}@`;
          }
          let b = `${y}//${E}${f}${h ? `:${h}` : ""}`,
            O = { destination: new URL(b) },
            C = this.connectionManager.lease(O, {
              requestTimeout: this.config?.sessionTimeout,
              disableConcurrentStreams: i || !1,
            }),
            P = mr((L) => {
              i && this.destroySession(C), (s = !0), d(L);
            }, "rejectWithDestroy"),
            k = (0, lqe.buildQueryString)(_ || {}),
            H = t.path;
          k && (H += `?${k}`), t.fragment && (H += `#${t.fragment}`);
          let B = C.request({
            ...t.headers,
            [aqe.constants.HTTP2_HEADER_PATH]: H,
            [aqe.constants.HTTP2_HEADER_METHOD]: m,
          });
          if (
            (C.ref(),
            B.on("response", (L) => {
              let Z = new uqe.HttpResponse({
                statusCode: L[":status"] || -1,
                headers: dqe(L),
                body: B,
              });
              (s = !0),
                l({ response: Z }),
                i && (C.close(), this.connectionManager.deleteSession(b, C));
            }),
            n &&
              B.setTimeout(n, () => {
                B.close();
                let L = new Error(
                  `Stream timed out because of no activity for ${n} ms`,
                );
                (L.name = "TimeoutError"), P(L);
              }),
            r)
          ) {
            let L = mr(() => {
              B.close();
              let Z = new Error("Request aborted");
              (Z.name = "AbortError"), P(Z);
            }, "onAbort");
            if (typeof r.addEventListener == "function") {
              let Z = r;
              Z.addEventListener("abort", L, { once: !0 }),
                B.once("close", () => Z.removeEventListener("abort", L));
            } else r.onabort = L;
          }
          B.on("frameError", (L, Z, ft) => {
            P(
              new Error(
                `Frame type id ${L} in stream id ${ft} has failed with code ${Z}.`,
              ),
            );
          }),
            B.on("error", P),
            B.on("aborted", () => {
              P(
                new Error(
                  `HTTP/2 stream is abnormally aborted in mid-communication with result code ${B.rstCode}.`,
                ),
              );
            }),
            B.on("close", () => {
              C.unref(),
                i && C.destroy(),
                s ||
                  P(
                    new Error(
                      "Unexpected error: http2 request did not get a response",
                    ),
                  );
            }),
            (u = u9(B, t, n));
        });
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then((n) => ({
            ...n,
            [t]: r,
          })));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
      destroySession(t) {
        t.destroyed || t.destroy();
      }
    },
    Unr = class extends fqe.Writable {
      constructor() {
        super(...arguments), (this.bufferedBytes = []);
      }
      static {
        mr(this, "Collector");
      }
      _write(e, t, r) {
        this.bufferedBytes.push(e), r();
      }
    },
    Hnr = mr(
      (e) =>
        Gnr(e)
          ? gqe(e)
          : new Promise((t, r) => {
              let n = new Unr();
              e.pipe(n),
                e.on("error", (i) => {
                  n.end(), r(i);
                }),
                n.on("error", r),
                n.on("finish", function () {
                  let i = new Uint8Array(Buffer.concat(this.bufferedBytes));
                  t(i);
                });
            }),
      "streamCollector",
    ),
    Gnr = mr(
      (e) => typeof ReadableStream == "function" && e instanceof ReadableStream,
      "isReadableStreamInstance",
    );
  async function gqe(e) {
    let t = [],
      r = e.getReader(),
      n = !1,
      i = 0;
    for (; !n; ) {
      let { done: s, value: u } = await r.read();
      u && (t.push(u), (i += u.length)), (n = s);
    }
    let o = new Uint8Array(i),
      a = 0;
    for (let s of t) o.set(s, a), (a += s.length);
    return o;
  }
  mr(gqe, "collectReadableStream");
});
var Aqe = g((WDn, Tqe) => {
  c();
  var Qq = Object.defineProperty,
    Vnr = Object.getOwnPropertyDescriptor,
    $nr = Object.getOwnPropertyNames,
    znr = Object.prototype.hasOwnProperty,
    iu = (e, t) => Qq(e, "name", { value: t, configurable: !0 }),
    Knr = (e, t) => {
      for (var r in t) Qq(e, r, { get: t[r], enumerable: !0 });
    },
    Wnr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of $nr(t))
          !znr.call(e, i) &&
            i !== r &&
            Qq(e, i, {
              get: () => t[i],
              enumerable: !(n = Vnr(t, i)) || n.enumerable,
            });
      return e;
    },
    Qnr = (e) => Wnr(Qq({}, "__esModule", { value: !0 }), e),
    Eqe = {};
  Knr(Eqe, {
    FetchHttpHandler: () => Xnr,
    keepAliveSupport: () => Wq,
    streamCollector: () => Znr,
  });
  Tqe.exports = Qnr(Eqe);
  var _qe = ts(),
    Ynr = o9();
  function l9(e, t) {
    return new Request(e, t);
  }
  iu(l9, "createRequest");
  function bqe(e = 0) {
    return new Promise((t, r) => {
      e &&
        setTimeout(() => {
          let n = new Error(`Request did not complete within ${e} ms`);
          (n.name = "TimeoutError"), r(n);
        }, e);
    });
  }
  iu(bqe, "requestTimeout");
  var Wq = { supported: void 0 },
    Xnr = class Sqe {
      static {
        iu(this, "FetchHttpHandler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new Sqe(t);
      }
      constructor(t) {
        typeof t == "function"
          ? (this.configProvider = t().then((r) => r || {}))
          : ((this.config = t ?? {}),
            (this.configProvider = Promise.resolve(this.config))),
          Wq.supported === void 0 &&
            (Wq.supported =
              typeof Request < "u" && "keepalive" in l9("https://[::1]"));
      }
      destroy() {}
      async handle(t, { abortSignal: r } = {}) {
        this.config || (this.config = await this.configProvider);
        let n = this.config.requestTimeout,
          i = this.config.keepAlive === !0,
          o = this.config.credentials;
        if (r?.aborted) {
          let b = new Error("Request aborted");
          return (b.name = "AbortError"), Promise.reject(b);
        }
        let a = t.path,
          s = (0, Ynr.buildQueryString)(t.query || {});
        s && (a += `?${s}`), t.fragment && (a += `#${t.fragment}`);
        let u = "";
        if (t.username != null || t.password != null) {
          let b = t.username ?? "",
            O = t.password ?? "";
          u = `${b}:${O}@`;
        }
        let { port: l, method: d } = t,
          f = `${t.protocol}//${u}${t.hostname}${l ? `:${l}` : ""}${a}`,
          m = d === "GET" || d === "HEAD" ? void 0 : t.body,
          h = {
            body: m,
            headers: new Headers(t.headers),
            method: d,
            credentials: o,
          };
        this.config?.cache && (h.cache = this.config.cache),
          m && (h.duplex = "half"),
          typeof AbortController < "u" && (h.signal = r),
          Wq.supported && (h.keepalive = i),
          typeof this.config.requestInit == "function" &&
            Object.assign(h, this.config.requestInit(t));
        let y = iu(() => {}, "removeSignalEventListener"),
          _ = l9(f, h),
          E = [
            fetch(_).then((b) => {
              let O = b.headers,
                C = {};
              for (let k of O.entries()) C[k[0]] = k[1];
              return b.body != null
                ? {
                    response: new _qe.HttpResponse({
                      headers: C,
                      reason: b.statusText,
                      statusCode: b.status,
                      body: b.body,
                    }),
                  }
                : b.blob().then((k) => ({
                    response: new _qe.HttpResponse({
                      headers: C,
                      reason: b.statusText,
                      statusCode: b.status,
                      body: k,
                    }),
                  }));
            }),
            bqe(n),
          ];
        return (
          r &&
            E.push(
              new Promise((b, O) => {
                let C = iu(() => {
                  let P = new Error("Request aborted");
                  (P.name = "AbortError"), O(P);
                }, "onAbort");
                if (typeof r.addEventListener == "function") {
                  let P = r;
                  P.addEventListener("abort", C, { once: !0 }),
                    (y = iu(
                      () => P.removeEventListener("abort", C),
                      "removeSignalEventListener",
                    ));
                } else r.onabort = C;
              }),
            ),
          Promise.race(E).finally(y)
        );
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then(
            (n) => ((n[t] = r), n),
          ));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    },
    Jnr = Q_(),
    Znr = iu(
      async (e) =>
        (typeof Blob == "function" && e instanceof Blob) ||
        e.constructor?.name === "Blob"
          ? Blob.prototype.arrayBuffer !== void 0
            ? new Uint8Array(await e.arrayBuffer())
            : Cqe(e)
          : wqe(e),
      "streamCollector",
    );
  async function Cqe(e) {
    let t = await Oqe(e),
      r = (0, Jnr.fromBase64)(t);
    return new Uint8Array(r);
  }
  iu(Cqe, "collectBlob");
  async function wqe(e) {
    let t = [],
      r = e.getReader(),
      n = !1,
      i = 0;
    for (; !n; ) {
      let { done: s, value: u } = await r.read();
      u && (t.push(u), (i += u.length)), (n = s);
    }
    let o = new Uint8Array(i),
      a = 0;
    for (let s of t) o.set(s, a), (a += s.length);
    return o;
  }
  iu(wqe, "collectStream");
  function Oqe(e) {
    return new Promise((t, r) => {
      let n = new FileReader();
      (n.onloadend = () => {
        if (n.readyState !== 2) return r(new Error("Reader aborted too early"));
        let i = n.result ?? "",
          o = i.indexOf(","),
          a = o > -1 ? o + 1 : i.length;
        t(i.substring(a));
      }),
        (n.onabort = () => r(new Error("Read aborted"))),
        (n.onerror = () => r(n.error)),
        n.readAsDataURL(e);
    });
  }
  iu(Oqe, "readToBase64");
});
var xqe = g((Yq) => {
  "use strict";
  c();
  Object.defineProperty(Yq, "__esModule", { value: !0 });
  Yq.sdkStreamMixin = void 0;
  var eir = Aqe(),
    tir = Q_(),
    rir = zs(),
    nir = Fe(),
    Pqe = Vf(),
    Rqe = "The stream has already been transformed.",
    iir = (e) => {
      var t, r;
      if (!Iqe(e) && !(0, Pqe.isReadableStream)(e)) {
        let a =
          ((r =
            (t = e?.__proto__) === null || t === void 0
              ? void 0
              : t.constructor) === null || r === void 0
            ? void 0
            : r.name) || e;
        throw new Error(
          `Unexpected stream implementation, expect Blob or ReadableStream, got ${a}`,
        );
      }
      let n = !1,
        i = async () => {
          if (n) throw new Error(Rqe);
          return (n = !0), await (0, eir.streamCollector)(e);
        },
        o = (a) => {
          if (typeof a.stream != "function")
            throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
          return a.stream();
        };
      return Object.assign(e, {
        transformToByteArray: i,
        transformToString: async (a) => {
          let s = await i();
          if (a === "base64") return (0, tir.toBase64)(s);
          if (a === "hex") return (0, rir.toHex)(s);
          if (a === void 0 || a === "utf8" || a === "utf-8")
            return (0, nir.toUtf8)(s);
          if (typeof TextDecoder == "function")
            return new TextDecoder(a).decode(s);
          throw new Error(
            "TextDecoder is not available, please make sure polyfill is provided.",
          );
        },
        transformToWebStream: () => {
          if (n) throw new Error(Rqe);
          if (((n = !0), Iqe(e))) return o(e);
          if ((0, Pqe.isReadableStream)(e)) return e;
          throw new Error(`Cannot transform payload to web stream, got ${e}`);
        },
      });
    };
  Yq.sdkStreamMixin = iir;
  var Iqe = (e) => typeof Blob == "function" && e instanceof Blob;
});
var kqe = g((Xq) => {
  "use strict";
  c();
  Object.defineProperty(Xq, "__esModule", { value: !0 });
  Xq.sdkStreamMixin = void 0;
  var oir = yqe(),
    air = Hi(),
    d9 = G("stream"),
    sir = xqe(),
    Nqe = "The stream has already been transformed.",
    cir = (e) => {
      var t, r;
      if (!(e instanceof d9.Readable))
        try {
          return (0, sir.sdkStreamMixin)(e);
        } catch {
          let a =
            ((r =
              (t = e?.__proto__) === null || t === void 0
                ? void 0
                : t.constructor) === null || r === void 0
              ? void 0
              : r.name) || e;
          throw new Error(
            `Unexpected stream implementation, expect Stream.Readable instance, got ${a}`,
          );
        }
      let n = !1,
        i = async () => {
          if (n) throw new Error(Nqe);
          return (n = !0), await (0, oir.streamCollector)(e);
        };
      return Object.assign(e, {
        transformToByteArray: i,
        transformToString: async (o) => {
          let a = await i();
          return o === void 0 || Buffer.isEncoding(o)
            ? (0, air.fromArrayBuffer)(
                a.buffer,
                a.byteOffset,
                a.byteLength,
              ).toString(o)
            : new TextDecoder(o).decode(a);
        },
        transformToWebStream: () => {
          if (n) throw new Error(Nqe);
          if (e.readableFlowing !== null)
            throw new Error("The stream has been consumed by other callbacks.");
          if (typeof d9.Readable.toWeb != "function")
            throw new Error(
              "Readable.toWeb() is not supported. Please ensure a polyfill is available.",
            );
          return (n = !0), d9.Readable.toWeb(e);
        },
      });
    };
  Xq.sdkStreamMixin = cir;
});
var Dqe = g((Jq) => {
  "use strict";
  c();
  Object.defineProperty(Jq, "__esModule", { value: !0 });
  Jq.splitStream = void 0;
  async function uir(e) {
    return typeof e.stream == "function" && (e = e.stream()), e.tee();
  }
  Jq.splitStream = uir;
});
var qqe = g((Zq) => {
  "use strict";
  c();
  Object.defineProperty(Zq, "__esModule", { value: !0 });
  Zq.splitStream = void 0;
  var Lqe = G("stream"),
    lir = Dqe(),
    Mqe = Vf();
  async function dir(e) {
    if ((0, Mqe.isReadableStream)(e) || (0, Mqe.isBlob)(e))
      return (0, lir.splitStream)(e);
    let t = new Lqe.PassThrough(),
      r = new Lqe.PassThrough();
    return e.pipe(t), e.pipe(r), [t, r];
  }
  Zq.splitStream = dir;
});
var h9 = g((iLn, au) => {
  c();
  var ej = Object.defineProperty,
    fir = Object.getOwnPropertyDescriptor,
    pir = Object.getOwnPropertyNames,
    mir = Object.prototype.hasOwnProperty,
    m9 = (e, t) => ej(e, "name", { value: t, configurable: !0 }),
    hir = (e, t) => {
      for (var r in t) ej(e, r, { get: t[r], enumerable: !0 });
    },
    f9 = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of pir(t))
          !mir.call(e, i) &&
            i !== r &&
            ej(e, i, {
              get: () => t[i],
              enumerable: !(n = fir(t, i)) || n.enumerable,
            });
      return e;
    },
    $f = (e, t, r) => (f9(e, t, "default"), r && f9(r, t, "default")),
    gir = (e) => f9(ej({}, "__esModule", { value: !0 }), e),
    ou = {};
  hir(ou, { Uint8ArrayBlobAdapter: () => p9 });
  au.exports = gir(ou);
  var jqe = Q_(),
    Fqe = Fe();
  function Bqe(e, t = "utf-8") {
    return t === "base64" ? (0, jqe.toBase64)(e) : (0, Fqe.toUtf8)(e);
  }
  m9(Bqe, "transformToString");
  function Uqe(e, t) {
    return t === "base64"
      ? p9.mutate((0, jqe.fromBase64)(e))
      : p9.mutate((0, Fqe.fromUtf8)(e));
  }
  m9(Uqe, "transformFromString");
  var p9 = class Hqe extends Uint8Array {
    static {
      m9(this, "Uint8ArrayBlobAdapter");
    }
    static fromString(t, r = "utf-8") {
      switch (typeof t) {
        case "string":
          return Uqe(t, r);
        default:
          throw new Error(
            `Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`,
          );
      }
    }
    static mutate(t) {
      return Object.setPrototypeOf(t, Hqe.prototype), t;
    }
    transformToString(t = "utf-8") {
      return Bqe(this, t);
    }
  };
  $f(ou, XQ(), au.exports);
  $f(ou, UMe(), au.exports);
  $f(ou, KMe(), au.exports);
  $f(ou, WMe(), au.exports);
  $f(ou, YMe(), au.exports);
  $f(ou, kqe(), au.exports);
  $f(ou, qqe(), au.exports);
  $f(ou, Vf(), au.exports);
});
var tj,
  vir,
  Gqe = w(() => {
    c();
    (tj = A(h9())),
      (vir = async (e = new Uint8Array(), t) => {
        if (e instanceof Uint8Array) return tj.Uint8ArrayBlobAdapter.mutate(e);
        if (!e) return tj.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
        let r = t.streamCollector(e);
        return tj.Uint8ArrayBlobAdapter.mutate(await r);
      });
  });
function rj(e) {
  return encodeURIComponent(e).replace(/[!'()*]/g, function (t) {
    return "%" + t.charCodeAt(0).toString(16).toUpperCase();
  });
}
var g9 = w(() => {
  c();
});
var v9,
  y9 = w(() => {
    c();
    g9();
    v9 = (e, t, r, n, i, o) => {
      if (t != null && t[r] !== void 0) {
        let a = n();
        if (a.length <= 0)
          throw new Error(
            "Empty value provided for input HTTP label: " + r + ".",
          );
        e = e.replace(
          i,
          o
            ? a
                .split("/")
                .map((s) => rj(s))
                .join("/")
            : rj(a),
        );
      } else
        throw new Error("No value provided for input HTTP label: " + r + ".");
      return e;
    };
  });
function $qe(e, t) {
  return new nj(e, t);
}
var Vqe,
  nj,
  zqe = w(() => {
    c();
    Vqe = A(ts());
    y9();
    nj = class {
      constructor(t, r) {
        (this.input = t),
          (this.context = r),
          (this.query = {}),
          (this.method = ""),
          (this.headers = {}),
          (this.path = ""),
          (this.body = null),
          (this.hostname = ""),
          (this.resolvePathStack = []);
      }
      async build() {
        let {
          hostname: t,
          protocol: r = "https",
          port: n,
          path: i,
        } = await this.context.endpoint();
        this.path = i;
        for (let o of this.resolvePathStack) o(this.path);
        return new Vqe.HttpRequest({
          protocol: r,
          hostname: this.hostname || t,
          port: n,
          method: this.method,
          path: this.path,
          query: this.query,
          body: this.body,
          headers: this.headers,
        });
      }
      hn(t) {
        return (this.hostname = t), this;
      }
      bp(t) {
        return (
          this.resolvePathStack.push((r) => {
            this.path = `${r?.endsWith("/") ? r.slice(0, -1) : r || ""}` + t;
          }),
          this
        );
      }
      p(t, r, n, i) {
        return (
          this.resolvePathStack.push((o) => {
            this.path = v9(o, this.input, t, r, n, i);
          }),
          this
        );
      }
      h(t) {
        return (this.headers = t), this;
      }
      q(t) {
        return (this.query = t), this;
      }
      b(t) {
        return (this.body = t), this;
      }
      m(t) {
        return (this.method = t), this;
      }
    };
  });
var Kqe = {};
bn(Kqe, {
  RequestBuilder: () => nj,
  collectBody: () => vir,
  extendedEncodeURIComponent: () => rj,
  requestBuilder: () => $qe,
  resolvedPath: () => v9,
});
var _9 = w(() => {
  c();
  Gqe();
  g9();
  zqe();
  y9();
});
var Wqe = w(() => {
  c();
  _9();
});
var Qqe = w(() => {
  c();
});
var Yqe = w(() => {
  c();
});
var yir,
  _ir,
  Xqe = w(() => {
    c();
    (yir = A(ts())), (_ir = A(Hf()));
  });
var Eir,
  Jqe = w(() => {
    c();
    Eir = A(ts());
  });
var Zqe = w(() => {
  c();
});
var eje = w(() => {
  c();
  Xqe();
  Jqe();
  Zqe();
});
var bir,
  tje,
  E9,
  rje,
  nje = w(() => {
    c();
    (bir = (e) => (t) => E9(t) && t.expiration.getTime() - Date.now() < e),
      (tje = bir(3e5)),
      (E9 = (e) => e.expiration !== void 0),
      (rje = (e, t, r) => {
        if (e === void 0) return;
        let n = typeof e != "function" ? async () => Promise.resolve(e) : e,
          i,
          o,
          a,
          s = !1,
          u = async (l) => {
            o || (o = n(l));
            try {
              (i = await o), (a = !0), (s = !1);
            } finally {
              o = void 0;
            }
            return i;
          };
        return t === void 0
          ? async (l) => ((!a || l?.forceRefresh) && (i = await u(l)), i)
          : async (l) => (
              (!a || l?.forceRefresh) && (i = await u(l)),
              s ? i : r(i) ? (t(i) && (await u(l)), i) : ((s = !0), i)
            );
      });
  });
var ije = w(() => {
  c();
  Yqe();
  eje();
  nje();
});
var b9 = w(() => {
  c();
  pMe();
  IMe();
  NMe();
  kMe();
  DMe();
  Wqe();
  Qqe();
  ije();
});
var lje = g((nMn, uje) => {
  c();
  var ij = Object.defineProperty,
    Sir = Object.getOwnPropertyDescriptor,
    Cir = Object.getOwnPropertyNames,
    wir = Object.prototype.hasOwnProperty,
    Ph = (e, t) => ij(e, "name", { value: t, configurable: !0 }),
    Oir = (e, t) => {
      for (var r in t) ij(e, r, { get: t[r], enumerable: !0 });
    },
    Tir = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Cir(t))
          !wir.call(e, i) &&
            i !== r &&
            ij(e, i, {
              get: () => t[i],
              enumerable: !(n = Sir(t, i)) || n.enumerable,
            });
      return e;
    },
    Air = (e) => Tir(ij({}, "__esModule", { value: !0 }), e),
    oje = {};
  Oir(oje, {
    CredentialsProviderError: () => Pir,
    ProviderError: () => oj,
    TokenProviderError: () => Rir,
    chain: () => Iir,
    fromStatic: () => xir,
    memoize: () => Nir,
  });
  uje.exports = Air(oje);
  var oj = class aje extends Error {
      constructor(t, r = !0) {
        let n,
          i = !0;
        typeof r == "boolean"
          ? ((n = void 0), (i = r))
          : r != null &&
            typeof r == "object" &&
            ((n = r.logger), (i = r.tryNextLink ?? !0)),
          super(t),
          (this.name = "ProviderError"),
          (this.tryNextLink = i),
          Object.setPrototypeOf(this, aje.prototype),
          n?.debug?.(`@smithy/property-provider ${i ? "->" : "(!)"} ${t}`);
      }
      static {
        Ph(this, "ProviderError");
      }
      static from(t, r = !0) {
        return Object.assign(new this(t.message, r), t);
      }
    },
    Pir = class sje extends oj {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "CredentialsProviderError"),
          Object.setPrototypeOf(this, sje.prototype);
      }
      static {
        Ph(this, "CredentialsProviderError");
      }
    },
    Rir = class cje extends oj {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "TokenProviderError"),
          Object.setPrototypeOf(this, cje.prototype);
      }
      static {
        Ph(this, "TokenProviderError");
      }
    },
    Iir = Ph(
      (...e) =>
        async () => {
          if (e.length === 0) throw new oj("No providers in chain");
          let t;
          for (let r of e)
            try {
              return await r();
            } catch (n) {
              if (((t = n), n?.tryNextLink)) continue;
              throw n;
            }
          throw t;
        },
      "chain",
    ),
    xir = Ph((e) => () => Promise.resolve(e), "fromStatic"),
    Nir = Ph((e, t, r) => {
      let n,
        i,
        o,
        a = !1,
        s = Ph(async () => {
          i || (i = e());
          try {
            (n = await i), (o = !0), (a = !1);
          } finally {
            i = void 0;
          }
          return n;
        }, "coalesceProvider");
      return t === void 0
        ? async (u) => ((!o || u?.forceRefresh) && (n = await s()), n)
        : async (u) => (
            (!o || u?.forceRefresh) && (n = await s()),
            a ? n : r && !r(n) ? ((a = !0), n) : (t(n) && (await s()), n)
          );
    }, "memoize");
});
var S9,
  kir,
  Dir,
  dje = w(() => {
    c();
    b9();
    (S9 = A(lje())),
      (kir = (e) => (
        (e.sigv4aSigningRegionSet = Ah(e.sigv4aSigningRegionSet)), e
      )),
      (Dir = {
        environmentVariableSelector(e) {
          if (e.AWS_SIGV4A_SIGNING_REGION_SET)
            return e.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((t) =>
              t.trim(),
            );
          throw new S9.ProviderError(
            "AWS_SIGV4A_SIGNING_REGION_SET not set in env.",
            { tryNextLink: !0 },
          );
        },
        configFileSelector(e) {
          if (e.sigv4a_signing_region_set)
            return (e.sigv4a_signing_region_set ?? "")
              .split(",")
              .map((t) => t.trim());
          throw new S9.ProviderError(
            "sigv4a_signing_region_set not set in profile.",
            { tryNextLink: !0 },
          );
        },
        default: void 0,
      });
  });
var Bje = g((cMn, Fje) => {
  c();
  var fj = Object.defineProperty,
    Lir = Object.getOwnPropertyDescriptor,
    Mir = Object.getOwnPropertyNames,
    qir = Object.prototype.hasOwnProperty,
    Ai = (e, t) => fj(e, "name", { value: t, configurable: !0 }),
    jir = (e, t) => {
      for (var r in t) fj(e, r, { get: t[r], enumerable: !0 });
    },
    Fir = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Mir(t))
          !qir.call(e, i) &&
            i !== r &&
            fj(e, i, {
              get: () => t[i],
              enumerable: !(n = Lir(t, i)) || n.enumerable,
            });
      return e;
    },
    Bir = (e) => Fir(fj({}, "__esModule", { value: !0 }), e),
    gje = {};
  jir(gje, {
    ALGORITHM_IDENTIFIER: () => aj,
    ALGORITHM_IDENTIFIER_V4A: () => Vir,
    ALGORITHM_QUERY_PARAM: () => vje,
    ALWAYS_UNSIGNABLE_HEADERS: () => Oje,
    AMZ_DATE_HEADER: () => I9,
    AMZ_DATE_QUERY_PARAM: () => T9,
    AUTH_HEADER: () => R9,
    CREDENTIAL_QUERY_PARAM: () => yje,
    DATE_HEADER: () => bje,
    EVENT_ALGORITHM_IDENTIFIER: () => Pje,
    EXPIRES_QUERY_PARAM: () => Eje,
    GENERATED_HEADERS: () => Sje,
    HOST_HEADER: () => Hir,
    KEY_TYPE_IDENTIFIER: () => x9,
    MAX_CACHE_SIZE: () => Ije,
    MAX_PRESIGNED_TTL: () => xje,
    PROXY_HEADER_PATTERN: () => Tje,
    REGION_SET_PARAM: () => Uir,
    SEC_HEADER_PATTERN: () => Aje,
    SHA256_HEADER: () => dj,
    SIGNATURE_HEADER: () => Cje,
    SIGNATURE_QUERY_PARAM: () => A9,
    SIGNED_HEADERS_QUERY_PARAM: () => _je,
    SignatureV4: () => tor,
    SignatureV4Base: () => jje,
    TOKEN_HEADER: () => wje,
    TOKEN_QUERY_PARAM: () => P9,
    UNSIGNABLE_PATTERNS: () => Gir,
    UNSIGNED_PAYLOAD: () => Rje,
    clearCredentialCache: () => zir,
    createScope: () => cj,
    getCanonicalHeaders: () => C9,
    getCanonicalQuery: () => qje,
    getPayloadHash: () => uj,
    getSigningKey: () => Nje,
    hasHeader: () => Dje,
    moveHeadersToQuery: () => Mje,
    prepareRequest: () => O9,
    signatureV4aContainer: () => ror,
  });
  Fje.exports = Bir(gje);
  var fje = Fe(),
    vje = "X-Amz-Algorithm",
    yje = "X-Amz-Credential",
    T9 = "X-Amz-Date",
    _je = "X-Amz-SignedHeaders",
    Eje = "X-Amz-Expires",
    A9 = "X-Amz-Signature",
    P9 = "X-Amz-Security-Token",
    Uir = "X-Amz-Region-Set",
    R9 = "authorization",
    I9 = T9.toLowerCase(),
    bje = "date",
    Sje = [R9, I9, bje],
    Cje = A9.toLowerCase(),
    dj = "x-amz-content-sha256",
    wje = P9.toLowerCase(),
    Hir = "host",
    Oje = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0,
    },
    Tje = /^proxy-/,
    Aje = /^sec-/,
    Gir = [/^proxy-/i, /^sec-/i],
    aj = "AWS4-HMAC-SHA256",
    Vir = "AWS4-ECDSA-P256-SHA256",
    Pje = "AWS4-HMAC-SHA256-PAYLOAD",
    Rje = "UNSIGNED-PAYLOAD",
    Ije = 50,
    x9 = "aws4_request",
    xje = 60 * 60 * 24 * 7,
    zf = zs(),
    $ir = Fe(),
    J_ = {},
    sj = [],
    cj = Ai((e, t, r) => `${e}/${t}/${r}/${x9}`, "createScope"),
    Nje = Ai(async (e, t, r, n, i) => {
      let o = await pje(e, t.secretAccessKey, t.accessKeyId),
        a = `${r}:${n}:${i}:${(0, zf.toHex)(o)}:${t.sessionToken}`;
      if (a in J_) return J_[a];
      for (sj.push(a); sj.length > Ije; ) delete J_[sj.shift()];
      let s = `AWS4${t.secretAccessKey}`;
      for (let u of [r, n, i, x9]) s = await pje(e, s, u);
      return (J_[a] = s);
    }, "getSigningKey"),
    zir = Ai(() => {
      (sj.length = 0),
        Object.keys(J_).forEach((e) => {
          delete J_[e];
        });
    }, "clearCredentialCache"),
    pje = Ai((e, t, r) => {
      let n = new e(t);
      return n.update((0, $ir.toUint8Array)(r)), n.digest();
    }, "hmac"),
    C9 = Ai(({ headers: e }, t, r) => {
      let n = {};
      for (let i of Object.keys(e).sort()) {
        if (e[i] == null) continue;
        let o = i.toLowerCase();
        ((o in Oje || t?.has(o) || Tje.test(o) || Aje.test(o)) &&
          (!r || (r && !r.has(o)))) ||
          (n[o] = e[i].trim().replace(/\s+/g, " "));
      }
      return n;
    }, "getCanonicalHeaders"),
    Kir = hf(),
    Wir = Fe(),
    uj = Ai(async ({ headers: e, body: t }, r) => {
      for (let n of Object.keys(e)) if (n.toLowerCase() === dj) return e[n];
      if (t == null)
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      if (
        typeof t == "string" ||
        ArrayBuffer.isView(t) ||
        (0, Kir.isArrayBuffer)(t)
      ) {
        let n = new r();
        return (
          n.update((0, Wir.toUint8Array)(t)), (0, zf.toHex)(await n.digest())
        );
      }
      return Rje;
    }, "getPayloadHash"),
    mje = Fe(),
    Qir = class {
      static {
        Ai(this, "HeaderFormatter");
      }
      format(e) {
        let t = [];
        for (let i of Object.keys(e)) {
          let o = (0, mje.fromUtf8)(i);
          t.push(
            Uint8Array.from([o.byteLength]),
            o,
            this.formatHeaderValue(e[i]),
          );
        }
        let r = new Uint8Array(t.reduce((i, o) => i + o.byteLength, 0)),
          n = 0;
        for (let i of t) r.set(i, n), (n += i.byteLength);
        return r;
      }
      formatHeaderValue(e) {
        switch (e.type) {
          case "boolean":
            return Uint8Array.from([e.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, e.value]);
          case "short":
            let t = new DataView(new ArrayBuffer(3));
            return (
              t.setUint8(0, 3),
              t.setInt16(1, e.value, !1),
              new Uint8Array(t.buffer)
            );
          case "integer":
            let r = new DataView(new ArrayBuffer(5));
            return (
              r.setUint8(0, 4),
              r.setInt32(1, e.value, !1),
              new Uint8Array(r.buffer)
            );
          case "long":
            let n = new Uint8Array(9);
            return (n[0] = 5), n.set(e.value.bytes, 1), n;
          case "binary":
            let i = new DataView(new ArrayBuffer(3 + e.value.byteLength));
            i.setUint8(0, 6), i.setUint16(1, e.value.byteLength, !1);
            let o = new Uint8Array(i.buffer);
            return o.set(e.value, 3), o;
          case "string":
            let a = (0, mje.fromUtf8)(e.value),
              s = new DataView(new ArrayBuffer(3 + a.byteLength));
            s.setUint8(0, 7), s.setUint16(1, a.byteLength, !1);
            let u = new Uint8Array(s.buffer);
            return u.set(a, 3), u;
          case "timestamp":
            let l = new Uint8Array(9);
            return (
              (l[0] = 8), l.set(Xir.fromNumber(e.value.valueOf()).bytes, 1), l
            );
          case "uuid":
            if (!Yir.test(e.value))
              throw new Error(`Invalid UUID received: ${e.value}`);
            let d = new Uint8Array(17);
            return (
              (d[0] = 9),
              d.set((0, zf.fromHex)(e.value.replace(/\-/g, "")), 1),
              d
            );
        }
      }
    },
    Yir = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    Xir = class kje {
      constructor(t) {
        if (((this.bytes = t), t.byteLength !== 8))
          throw new Error("Int64 buffers must be exactly 8 bytes");
      }
      static {
        Ai(this, "Int64");
      }
      static fromNumber(t) {
        if (t > 9223372036854776e3 || t < -9223372036854776e3)
          throw new Error(
            `${t} is too large (or, if negative, too small) to represent as an Int64`,
          );
        let r = new Uint8Array(8);
        for (
          let n = 7, i = Math.abs(Math.round(t));
          n > -1 && i > 0;
          n--, i /= 256
        )
          r[n] = i;
        return t < 0 && w9(r), new kje(r);
      }
      valueOf() {
        let t = this.bytes.slice(0),
          r = t[0] & 128;
        return r && w9(t), parseInt((0, zf.toHex)(t), 16) * (r ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  function w9(e) {
    for (let t = 0; t < 8; t++) e[t] ^= 255;
    for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
  }
  Ai(w9, "negate");
  var Dje = Ai((e, t) => {
      e = e.toLowerCase();
      for (let r of Object.keys(t)) if (e === r.toLowerCase()) return !0;
      return !1;
    }, "hasHeader"),
    Lje = ts(),
    Mje = Ai((e, t = {}) => {
      let { headers: r, query: n = {} } = Lje.HttpRequest.clone(e);
      for (let i of Object.keys(r)) {
        let o = i.toLowerCase();
        ((o.slice(0, 6) === "x-amz-" && !t.unhoistableHeaders?.has(o)) ||
          t.hoistableHeaders?.has(o)) &&
          ((n[i] = r[i]), delete r[i]);
      }
      return { ...e, headers: r, query: n };
    }, "moveHeadersToQuery"),
    O9 = Ai((e) => {
      e = Lje.HttpRequest.clone(e);
      for (let t of Object.keys(e.headers))
        Sje.indexOf(t.toLowerCase()) > -1 && delete e.headers[t];
      return e;
    }, "prepareRequest"),
    hje = tO(),
    Jir = Fe(),
    lj = n9(),
    qje = Ai(({ query: e = {} }) => {
      let t = [],
        r = {};
      for (let n of Object.keys(e)) {
        if (n.toLowerCase() === Cje) continue;
        let i = (0, lj.escapeUri)(n);
        t.push(i);
        let o = e[n];
        typeof o == "string"
          ? (r[i] = `${i}=${(0, lj.escapeUri)(o)}`)
          : Array.isArray(o) &&
            (r[i] = o
              .slice(0)
              .reduce((a, s) => a.concat([`${i}=${(0, lj.escapeUri)(s)}`]), [])
              .sort()
              .join("&"));
      }
      return t
        .sort()
        .map((n) => r[n])
        .filter((n) => n)
        .join("&");
    }, "getCanonicalQuery"),
    Zir = Ai(
      (e) =>
        eor(e)
          .toISOString()
          .replace(/\.\d{3}Z$/, "Z"),
      "iso8601",
    ),
    eor = Ai(
      (e) =>
        typeof e == "number"
          ? new Date(e * 1e3)
          : typeof e == "string"
            ? Number(e)
              ? new Date(Number(e) * 1e3)
              : new Date(e)
            : e,
      "toDate",
    ),
    jje = class {
      static {
        Ai(this, "SignatureV4Base");
      }
      constructor({
        applyChecksum: e,
        credentials: t,
        region: r,
        service: n,
        sha256: i,
        uriEscapePath: o = !0,
      }) {
        (this.service = n),
          (this.sha256 = i),
          (this.uriEscapePath = o),
          (this.applyChecksum = typeof e == "boolean" ? e : !0),
          (this.regionProvider = (0, hje.normalizeProvider)(r)),
          (this.credentialProvider = (0, hje.normalizeProvider)(t));
      }
      createCanonicalRequest(e, t, r) {
        let n = Object.keys(t).sort();
        return `${e.method}
${this.getCanonicalPath(e)}
${qje(e)}
${n.map((i) => `${i}:${t[i]}`).join(`
`)}

${n.join(";")}
${r}`;
      }
      async createStringToSign(e, t, r, n) {
        let i = new this.sha256();
        i.update((0, Jir.toUint8Array)(r));
        let o = await i.digest();
        return `${n}
${e}
${t}
${(0, zf.toHex)(o)}`;
      }
      getCanonicalPath({ path: e }) {
        if (this.uriEscapePath) {
          let t = [];
          for (let i of e.split("/"))
            i?.length !== 0 && i !== "." && (i === ".." ? t.pop() : t.push(i));
          let r = `${e?.startsWith("/") ? "/" : ""}${t.join("/")}${t.length > 0 && e?.endsWith("/") ? "/" : ""}`;
          return (0, lj.escapeUri)(r).replace(/%2F/g, "/");
        }
        return e;
      }
      validateResolvedCredentials(e) {
        if (
          typeof e != "object" ||
          typeof e.accessKeyId != "string" ||
          typeof e.secretAccessKey != "string"
        )
          throw new Error("Resolved credential object is not valid");
      }
      formatDate(e) {
        let t = Zir(e).replace(/[\-:]/g, "");
        return { longDate: t, shortDate: t.slice(0, 8) };
      }
      getCanonicalHeaderList(e) {
        return Object.keys(e).sort().join(";");
      }
    },
    tor = class extends jje {
      constructor({
        applyChecksum: e,
        credentials: t,
        region: r,
        service: n,
        sha256: i,
        uriEscapePath: o = !0,
      }) {
        super({
          applyChecksum: e,
          credentials: t,
          region: r,
          service: n,
          sha256: i,
          uriEscapePath: o,
        }),
          (this.headerFormatter = new Qir());
      }
      static {
        Ai(this, "SignatureV4");
      }
      async presign(e, t = {}) {
        let {
            signingDate: r = new Date(),
            expiresIn: n = 3600,
            unsignableHeaders: i,
            unhoistableHeaders: o,
            signableHeaders: a,
            hoistableHeaders: s,
            signingRegion: u,
            signingService: l,
          } = t,
          d = await this.credentialProvider();
        this.validateResolvedCredentials(d);
        let f = u ?? (await this.regionProvider()),
          { longDate: m, shortDate: h } = this.formatDate(r);
        if (n > xje)
          return Promise.reject(
            "Signature version 4 presigned URLs must have an expiration date less than one week in the future",
          );
        let y = cj(h, f, l ?? this.service),
          _ = Mje(O9(e), { unhoistableHeaders: o, hoistableHeaders: s });
        d.sessionToken && (_.query[P9] = d.sessionToken),
          (_.query[vje] = aj),
          (_.query[yje] = `${d.accessKeyId}/${y}`),
          (_.query[T9] = m),
          (_.query[Eje] = n.toString(10));
        let E = C9(_, i, a);
        return (
          (_.query[_je] = this.getCanonicalHeaderList(E)),
          (_.query[A9] = await this.getSignature(
            m,
            y,
            this.getSigningKey(d, f, h, l),
            this.createCanonicalRequest(_, E, await uj(e, this.sha256)),
          )),
          _
        );
      }
      async sign(e, t) {
        return typeof e == "string"
          ? this.signString(e, t)
          : e.headers && e.payload
            ? this.signEvent(e, t)
            : e.message
              ? this.signMessage(e, t)
              : this.signRequest(e, t);
      }
      async signEvent(
        { headers: e, payload: t },
        {
          signingDate: r = new Date(),
          priorSignature: n,
          signingRegion: i,
          signingService: o,
        },
      ) {
        let a = i ?? (await this.regionProvider()),
          { shortDate: s, longDate: u } = this.formatDate(r),
          l = cj(s, a, o ?? this.service),
          d = await uj({ headers: {}, body: t }, this.sha256),
          f = new this.sha256();
        f.update(e);
        let m = (0, zf.toHex)(await f.digest()),
          h = [Pje, u, l, n, m, d].join(`
`);
        return this.signString(h, {
          signingDate: r,
          signingRegion: a,
          signingService: o,
        });
      }
      async signMessage(
        e,
        { signingDate: t = new Date(), signingRegion: r, signingService: n },
      ) {
        return this.signEvent(
          {
            headers: this.headerFormatter.format(e.message.headers),
            payload: e.message.body,
          },
          {
            signingDate: t,
            signingRegion: r,
            signingService: n,
            priorSignature: e.priorSignature,
          },
        ).then((o) => ({ message: e.message, signature: o }));
      }
      async signString(
        e,
        {
          signingDate: t = new Date(),
          signingRegion: r,
          signingService: n,
        } = {},
      ) {
        let i = await this.credentialProvider();
        this.validateResolvedCredentials(i);
        let o = r ?? (await this.regionProvider()),
          { shortDate: a } = this.formatDate(t),
          s = new this.sha256(await this.getSigningKey(i, o, a, n));
        return (
          s.update((0, fje.toUint8Array)(e)), (0, zf.toHex)(await s.digest())
        );
      }
      async signRequest(
        e,
        {
          signingDate: t = new Date(),
          signableHeaders: r,
          unsignableHeaders: n,
          signingRegion: i,
          signingService: o,
        } = {},
      ) {
        let a = await this.credentialProvider();
        this.validateResolvedCredentials(a);
        let s = i ?? (await this.regionProvider()),
          u = O9(e),
          { longDate: l, shortDate: d } = this.formatDate(t),
          f = cj(d, s, o ?? this.service);
        (u.headers[I9] = l),
          a.sessionToken && (u.headers[wje] = a.sessionToken);
        let m = await uj(u, this.sha256);
        !Dje(dj, u.headers) && this.applyChecksum && (u.headers[dj] = m);
        let h = C9(u, n, r),
          y = await this.getSignature(
            l,
            f,
            this.getSigningKey(a, s, d, o),
            this.createCanonicalRequest(u, h, m),
          );
        return (
          (u.headers[R9] =
            `${aj} Credential=${a.accessKeyId}/${f}, SignedHeaders=${this.getCanonicalHeaderList(h)}, Signature=${y}`),
          u
        );
      }
      async getSignature(e, t, r, n) {
        let i = await this.createStringToSign(e, t, n, aj),
          o = new this.sha256(await r);
        return (
          o.update((0, fje.toUint8Array)(i)), (0, zf.toHex)(await o.digest())
        );
      }
      getSigningKey(e, t, r, n) {
        return Nje(this.sha256, e, r, t, n || this.service);
      }
    },
    ror = { SignatureV4a: null };
});
function ior(e, { credentials: t, credentialDefaultProvider: r }) {
  let n;
  return (
    t
      ? t?.memoized
        ? (n = t)
        : (n = rje(t, tje, E9))
      : r
        ? (n = Ah(r(Object.assign({}, e, { parentClientConfig: e }))))
        : (n = async () => {
            throw new Error(
              "@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.",
            );
          }),
    (n.memoized = !0),
    n
  );
}
function oor(e, t) {
  if (t.configBound) return t;
  let r = async (n) => t({ ...n, callerClientConfig: e });
  return (r.memoized = t.memoized), (r.configBound = !0), r;
}
var N9,
  Uje,
  nor,
  Hje = w(() => {
    c();
    jQ();
    b9();
    (N9 = A(Bje())),
      (Uje = (e) => {
        let t = e.credentials,
          r = !!e.credentials,
          n;
        Object.defineProperty(e, "credentials", {
          set(l) {
            l && l !== t && l !== n && (r = !0), (t = l);
            let d = ior(e, {
                credentials: t,
                credentialDefaultProvider: e.credentialDefaultProvider,
              }),
              f = oor(e, d);
            r && !f.attributed
              ? ((n = async (m) =>
                  f(m).then((h) => qQ(h, "CREDENTIALS_CODE", "e"))),
                (n.memoized = f.memoized),
                (n.configBound = f.configBound),
                (n.attributed = !0))
              : (n = f);
          },
          get() {
            return n;
          },
          enumerable: !0,
          configurable: !0,
        }),
          (e.credentials = t);
        let {
            signingEscapePath: i = !0,
            systemClockOffset: o = e.systemClockOffset || 0,
            sha256: a,
          } = e,
          s;
        return (
          e.signer
            ? (s = Ah(e.signer))
            : e.regionInfoProvider
              ? (s = () =>
                  Ah(e.region)()
                    .then(async (l) => [
                      (await e.regionInfoProvider(l, {
                        useFipsEndpoint: await e.useFipsEndpoint(),
                        useDualstackEndpoint: await e.useDualstackEndpoint(),
                      })) || {},
                      l,
                    ])
                    .then(([l, d]) => {
                      let { signingRegion: f, signingService: m } = l;
                      (e.signingRegion = e.signingRegion || f || d),
                        (e.signingName = e.signingName || m || e.serviceId);
                      let h = {
                          ...e,
                          credentials: e.credentials,
                          region: e.signingRegion,
                          service: e.signingName,
                          sha256: a,
                          uriEscapePath: i,
                        },
                        y = e.signerConstructor || N9.SignatureV4;
                      return new y(h);
                    }))
              : (s = async (l) => {
                  l = Object.assign(
                    {},
                    {
                      name: "sigv4",
                      signingName: e.signingName || e.defaultSigningName,
                      signingRegion: await Ah(e.region)(),
                      properties: {},
                    },
                    l,
                  );
                  let d = l.signingRegion,
                    f = l.signingName;
                  (e.signingRegion = e.signingRegion || d),
                    (e.signingName = e.signingName || f || e.serviceId);
                  let m = {
                      ...e,
                      credentials: e.credentials,
                      region: e.signingRegion,
                      service: e.signingName,
                      sha256: a,
                      uriEscapePath: i,
                    },
                    h = e.signerConstructor || N9.SignatureV4;
                  return new h(m);
                }),
          Object.assign(e, {
            systemClockOffset: o,
            signingEscapePath: i,
            signer: s,
          })
        );
      }),
      (nor = Uje);
  });
var Gje = w(() => {
  c();
  VQ();
  cMe();
  fMe();
  dje();
  Hje();
});
var Vje = w(() => {
  c();
  Gje();
});
var aor,
  sor,
  cor,
  $je = w(() => {
    c();
    (aor = (e) => {
      if (e == null) return e;
      if (typeof e == "number" || typeof e == "bigint") {
        let t = new Error(`Received number ${e} where a string was expected.`);
        return (t.name = "Warning"), console.warn(t), String(e);
      }
      if (typeof e == "boolean") {
        let t = new Error(`Received boolean ${e} where a string was expected.`);
        return (t.name = "Warning"), console.warn(t), String(e);
      }
      return e;
    }),
      (sor = (e) => {
        if (e == null) return e;
        if (typeof e == "string") {
          let t = e.toLowerCase();
          if (e !== "" && t !== "false" && t !== "true") {
            let r = new Error(
              `Received string "${e}" where a boolean was expected.`,
            );
            (r.name = "Warning"), console.warn(r);
          }
          return e !== "" && t !== "false";
        }
        return e;
      }),
      (cor = (e) => {
        if (e == null) return e;
        if (typeof e == "string") {
          let t = Number(e);
          if (t.toString() !== e) {
            let r = new Error(
              `Received string "${e}" where a number was expected.`,
            );
            return (r.name = "Warning"), console.warn(r), e;
          }
          return t;
        }
        return e;
      });
  });
var Yje = g((RMn, Qje) => {
  c();
  var pj = Object.defineProperty,
    uor = Object.getOwnPropertyDescriptor,
    lor = Object.getOwnPropertyNames,
    dor = Object.prototype.hasOwnProperty,
    rs = (e, t) => pj(e, "name", { value: t, configurable: !0 }),
    por = (e, t) => {
      for (var r in t) pj(e, r, { get: t[r], enumerable: !0 });
    },
    mor = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of lor(t))
          !dor.call(e, i) &&
            i !== r &&
            pj(e, i, {
              get: () => t[i],
              enumerable: !(n = uor(t, i)) || n.enumerable,
            });
      return e;
    },
    hor = (e) => mor(pj({}, "__esModule", { value: !0 }), e),
    Wje = {};
  por(Wje, { constructStack: () => k9 });
  Qje.exports = hor(Wje);
  var Rh = rs((e, t) => {
      let r = [];
      if ((e && r.push(e), t)) for (let n of t) r.push(n);
      return r;
    }, "getAllAliases"),
    Kf = rs(
      (e, t) =>
        `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`,
      "getMiddlewareNameWithAliases",
    ),
    k9 = rs(() => {
      let e = [],
        t = [],
        r = !1,
        n = new Set(),
        i = rs(
          (f) =>
            f.sort(
              (m, h) =>
                zje[h.step] - zje[m.step] ||
                Kje[h.priority || "normal"] - Kje[m.priority || "normal"],
            ),
          "sort",
        ),
        o = rs((f) => {
          let m = !1,
            h = rs((y) => {
              let _ = Rh(y.name, y.aliases);
              if (_.includes(f)) {
                m = !0;
                for (let E of _) n.delete(E);
                return !1;
              }
              return !0;
            }, "filterCb");
          return (e = e.filter(h)), (t = t.filter(h)), m;
        }, "removeByName"),
        a = rs((f) => {
          let m = !1,
            h = rs((y) => {
              if (y.middleware === f) {
                m = !0;
                for (let _ of Rh(y.name, y.aliases)) n.delete(_);
                return !1;
              }
              return !0;
            }, "filterCb");
          return (e = e.filter(h)), (t = t.filter(h)), m;
        }, "removeByReference"),
        s = rs(
          (f) => (
            e.forEach((m) => {
              f.add(m.middleware, { ...m });
            }),
            t.forEach((m) => {
              f.addRelativeTo(m.middleware, { ...m });
            }),
            f.identifyOnResolve?.(d.identifyOnResolve()),
            f
          ),
          "cloneTo",
        ),
        u = rs((f) => {
          let m = [];
          return (
            f.before.forEach((h) => {
              h.before.length === 0 && h.after.length === 0
                ? m.push(h)
                : m.push(...u(h));
            }),
            m.push(f),
            f.after.reverse().forEach((h) => {
              h.before.length === 0 && h.after.length === 0
                ? m.push(h)
                : m.push(...u(h));
            }),
            m
          );
        }, "expandRelativeMiddlewareList"),
        l = rs((f = !1) => {
          let m = [],
            h = [],
            y = {};
          return (
            e.forEach((E) => {
              let b = { ...E, before: [], after: [] };
              for (let O of Rh(b.name, b.aliases)) y[O] = b;
              m.push(b);
            }),
            t.forEach((E) => {
              let b = { ...E, before: [], after: [] };
              for (let O of Rh(b.name, b.aliases)) y[O] = b;
              h.push(b);
            }),
            h.forEach((E) => {
              if (E.toMiddleware) {
                let b = y[E.toMiddleware];
                if (b === void 0) {
                  if (f) return;
                  throw new Error(
                    `${E.toMiddleware} is not found when adding ${Kf(E.name, E.aliases)} middleware ${E.relation} ${E.toMiddleware}`,
                  );
                }
                E.relation === "after" && b.after.push(E),
                  E.relation === "before" && b.before.push(E);
              }
            }),
            i(m)
              .map(u)
              .reduce((E, b) => (E.push(...b), E), [])
          );
        }, "getMiddlewareList"),
        d = {
          add: (f, m = {}) => {
            let { name: h, override: y, aliases: _ } = m,
              E = {
                step: "initialize",
                priority: "normal",
                middleware: f,
                ...m,
              },
              b = Rh(h, _);
            if (b.length > 0) {
              if (b.some((O) => n.has(O))) {
                if (!y)
                  throw new Error(`Duplicate middleware name '${Kf(h, _)}'`);
                for (let O of b) {
                  let C = e.findIndex(
                    (k) => k.name === O || k.aliases?.some((H) => H === O),
                  );
                  if (C === -1) continue;
                  let P = e[C];
                  if (P.step !== E.step || E.priority !== P.priority)
                    throw new Error(
                      `"${Kf(P.name, P.aliases)}" middleware with ${P.priority} priority in ${P.step} step cannot be overridden by "${Kf(h, _)}" middleware with ${E.priority} priority in ${E.step} step.`,
                    );
                  e.splice(C, 1);
                }
              }
              for (let O of b) n.add(O);
            }
            e.push(E);
          },
          addRelativeTo: (f, m) => {
            let { name: h, override: y, aliases: _ } = m,
              E = { middleware: f, ...m },
              b = Rh(h, _);
            if (b.length > 0) {
              if (b.some((O) => n.has(O))) {
                if (!y)
                  throw new Error(`Duplicate middleware name '${Kf(h, _)}'`);
                for (let O of b) {
                  let C = t.findIndex(
                    (k) => k.name === O || k.aliases?.some((H) => H === O),
                  );
                  if (C === -1) continue;
                  let P = t[C];
                  if (
                    P.toMiddleware !== E.toMiddleware ||
                    P.relation !== E.relation
                  )
                    throw new Error(
                      `"${Kf(P.name, P.aliases)}" middleware ${P.relation} "${P.toMiddleware}" middleware cannot be overridden by "${Kf(h, _)}" middleware ${E.relation} "${E.toMiddleware}" middleware.`,
                    );
                  t.splice(C, 1);
                }
              }
              for (let O of b) n.add(O);
            }
            t.push(E);
          },
          clone: () => s(k9()),
          use: (f) => {
            f.applyToStack(d);
          },
          remove: (f) => (typeof f == "string" ? o(f) : a(f)),
          removeByTag: (f) => {
            let m = !1,
              h = rs((y) => {
                let { tags: _, name: E, aliases: b } = y;
                if (_ && _.includes(f)) {
                  let O = Rh(E, b);
                  for (let C of O) n.delete(C);
                  return (m = !0), !1;
                }
                return !0;
              }, "filterCb");
            return (e = e.filter(h)), (t = t.filter(h)), m;
          },
          concat: (f) => {
            let m = s(k9());
            return (
              m.use(f),
              m.identifyOnResolve(
                r || m.identifyOnResolve() || (f.identifyOnResolve?.() ?? !1),
              ),
              m
            );
          },
          applyToStack: s,
          identify: () =>
            l(!0).map((f) => {
              let m = f.step ?? f.relation + " " + f.toMiddleware;
              return Kf(f.name, f.aliases) + " - " + m;
            }),
          identifyOnResolve(f) {
            return typeof f == "boolean" && (r = f), r;
          },
          resolve: (f, m) => {
            for (let h of l()
              .map((y) => y.middleware)
              .reverse())
              f = h(f, m);
            return r && console.log(d.identify()), f;
          },
        };
      return d;
    }, "constructStack"),
    zje = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1,
    },
    Kje = { high: 3, normal: 2, low: 1 };
});
var vj = g((xMn, mFe) => {
  c();
  var gj = Object.defineProperty,
    gor = Object.getOwnPropertyDescriptor,
    vor = Object.getOwnPropertyNames,
    yor = Object.prototype.hasOwnProperty,
    fe = (e, t) => gj(e, "name", { value: t, configurable: !0 }),
    _or = (e, t) => {
      for (var r in t) gj(e, r, { get: t[r], enumerable: !0 });
    },
    Eor = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of vor(t))
          !yor.call(e, i) &&
            i !== r &&
            gj(e, i, {
              get: () => t[i],
              enumerable: !(n = gor(t, i)) || n.enumerable,
            });
      return e;
    },
    bor = (e) => Eor(gj({}, "__esModule", { value: !0 }), e),
    Jje = {};
  _or(Jje, {
    Client: () => Sor,
    Command: () => eFe,
    LazyJsonString: () => Ih,
    NoOpLogger: () => _ar,
    SENSITIVE_STRING: () => wor,
    ServiceException: () => oar,
    _json: () => B9,
    collectBody: () => D9.collectBody,
    convertMap: () => Ear,
    createAggregatedClient: () => Oor,
    dateToUtcString: () => aFe,
    decorateServiceException: () => sFe,
    emitWarningIfUnsupportedVersion: () => uar,
    expectBoolean: () => Aor,
    expectByte: () => F9,
    expectFloat32: () => mj,
    expectInt: () => Ror,
    expectInt32: () => q9,
    expectLong: () => aO,
    expectNonNull: () => xor,
    expectNumber: () => oO,
    expectObject: () => tFe,
    expectShort: () => j9,
    expectString: () => Nor,
    expectUnion: () => kor,
    extendedEncodeURIComponent: () => D9.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => gar,
    getDefaultClientConfiguration: () => mar,
    getDefaultExtensionConfiguration: () => uFe,
    getValueFromTextNode: () => lFe,
    handleFloat: () => Mor,
    isSerializableHeaderValue: () => yar,
    limitedParseDouble: () => G9,
    limitedParseFloat: () => qor,
    limitedParseFloat32: () => jor,
    loadConfigsForDefaultMode: () => car,
    logger: () => sO,
    map: () => $9,
    parseBoolean: () => Tor,
    parseEpochTimestamp: () => Yor,
    parseRfc3339DateTime: () => Gor,
    parseRfc3339DateTimeWithOffset: () => $or,
    parseRfc7231DateTime: () => Qor,
    quoteHeader: () => fFe,
    resolveDefaultRuntimeConfig: () => har,
    resolvedPath: () => D9.resolvedPath,
    serializeDateTime: () => Tar,
    serializeFloat: () => Oar,
    splitEvery: () => pFe,
    splitHeader: () => Aar,
    strictParseByte: () => oFe,
    strictParseDouble: () => H9,
    strictParseFloat: () => Dor,
    strictParseFloat32: () => rFe,
    strictParseInt: () => For,
    strictParseInt32: () => Bor,
    strictParseLong: () => iFe,
    strictParseShort: () => Z_,
    take: () => bar,
    throwDefaultError: () => cFe,
    withBaseException: () => aar,
  });
  mFe.exports = bor(Jje);
  var Zje = Yje(),
    Sor = class {
      constructor(e) {
        (this.config = e), (this.middlewareStack = (0, Zje.constructStack)());
      }
      static {
        fe(this, "Client");
      }
      send(e, t, r) {
        let n = typeof t != "function" ? t : void 0,
          i = typeof t == "function" ? t : r,
          o = n === void 0 && this.config.cacheMiddleware === !0,
          a;
        if (o) {
          this.handlers || (this.handlers = new WeakMap());
          let s = this.handlers;
          s.has(e.constructor)
            ? (a = s.get(e.constructor))
            : ((a = e.resolveMiddleware(this.middlewareStack, this.config, n)),
              s.set(e.constructor, a));
        } else
          delete this.handlers,
            (a = e.resolveMiddleware(this.middlewareStack, this.config, n));
        if (i)
          a(e)
            .then(
              (s) => i(null, s.output),
              (s) => i(s),
            )
            .catch(() => {});
        else return a(e).then((s) => s.output);
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers;
      }
    },
    D9 = (_9(), ue(Kqe)),
    M9 = Hf(),
    eFe = class {
      constructor() {
        this.middlewareStack = (0, Zje.constructStack)();
      }
      static {
        fe(this, "Command");
      }
      static classBuilder() {
        return new Cor();
      }
      resolveMiddlewareWithContext(
        e,
        t,
        r,
        {
          middlewareFn: n,
          clientName: i,
          commandName: o,
          inputFilterSensitiveLog: a,
          outputFilterSensitiveLog: s,
          smithyContext: u,
          additionalContext: l,
          CommandCtor: d,
        },
      ) {
        for (let _ of n.bind(this)(d, e, t, r)) this.middlewareStack.use(_);
        let f = e.concat(this.middlewareStack),
          { logger: m } = t,
          h = {
            logger: m,
            clientName: i,
            commandName: o,
            inputFilterSensitiveLog: a,
            outputFilterSensitiveLog: s,
            [M9.SMITHY_CONTEXT_KEY]: { commandInstance: this, ...u },
            ...l,
          },
          { requestHandler: y } = t;
        return f.resolve((_) => y.handle(_.request, r || {}), h);
      }
    },
    Cor = class {
      constructor() {
        (this._init = () => {}),
          (this._ep = {}),
          (this._middlewareFn = () => []),
          (this._commandName = ""),
          (this._clientName = ""),
          (this._additionalContext = {}),
          (this._smithyContext = {}),
          (this._inputFilterSensitiveLog = (e) => e),
          (this._outputFilterSensitiveLog = (e) => e),
          (this._serializer = null),
          (this._deserializer = null);
      }
      static {
        fe(this, "ClassBuilder");
      }
      init(e) {
        this._init = e;
      }
      ep(e) {
        return (this._ep = e), this;
      }
      m(e) {
        return (this._middlewareFn = e), this;
      }
      s(e, t, r = {}) {
        return (this._smithyContext = { service: e, operation: t, ...r }), this;
      }
      c(e = {}) {
        return (this._additionalContext = e), this;
      }
      n(e, t) {
        return (this._clientName = e), (this._commandName = t), this;
      }
      f(e = (r) => r, t = (r) => r) {
        return (
          (this._inputFilterSensitiveLog = e),
          (this._outputFilterSensitiveLog = t),
          this
        );
      }
      ser(e) {
        return (this._serializer = e), this;
      }
      de(e) {
        return (this._deserializer = e), this;
      }
      build() {
        let e = this,
          t;
        return (t = class extends eFe {
          constructor(...[r]) {
            super(),
              (this.serialize = e._serializer),
              (this.deserialize = e._deserializer),
              (this.input = r ?? {}),
              e._init(this);
          }
          static {
            fe(this, "CommandRef");
          }
          static getEndpointParameterInstructions() {
            return e._ep;
          }
          resolveMiddleware(r, n, i) {
            return this.resolveMiddlewareWithContext(r, n, i, {
              CommandCtor: t,
              middlewareFn: e._middlewareFn,
              clientName: e._clientName,
              commandName: e._commandName,
              inputFilterSensitiveLog: e._inputFilterSensitiveLog,
              outputFilterSensitiveLog: e._outputFilterSensitiveLog,
              smithyContext: e._smithyContext,
              additionalContext: e._additionalContext,
            });
          }
        });
      }
    },
    wor = "***SensitiveInformation***",
    Oor = fe((e, t) => {
      for (let r of Object.keys(e)) {
        let n = e[r],
          i = fe(async function (a, s, u) {
            let l = new n(a);
            if (typeof s == "function") this.send(l, s);
            else if (typeof u == "function") {
              if (typeof s != "object")
                throw new Error(`Expected http options but got ${typeof s}`);
              this.send(l, s || {}, u);
            } else return this.send(l, s);
          }, "methodImpl"),
          o = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, "");
        t.prototype[o] = i;
      }
    }, "createAggregatedClient"),
    Tor = fe((e) => {
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw new Error(`Unable to parse boolean value "${e}"`);
      }
    }, "parseBoolean"),
    Aor = fe((e) => {
      if (e != null) {
        if (typeof e == "number") {
          if (
            ((e === 0 || e === 1) &&
              sO.warn(hj(`Expected boolean, got ${typeof e}: ${e}`)),
            e === 0)
          )
            return !1;
          if (e === 1) return !0;
        }
        if (typeof e == "string") {
          let t = e.toLowerCase();
          if (
            ((t === "false" || t === "true") &&
              sO.warn(hj(`Expected boolean, got ${typeof e}: ${e}`)),
            t === "false")
          )
            return !1;
          if (t === "true") return !0;
        }
        if (typeof e == "boolean") return e;
        throw new TypeError(`Expected boolean, got ${typeof e}: ${e}`);
      }
    }, "expectBoolean"),
    oO = fe((e) => {
      if (e != null) {
        if (typeof e == "string") {
          let t = parseFloat(e);
          if (!Number.isNaN(t))
            return (
              String(t) !== String(e) &&
                sO.warn(hj(`Expected number but observed string: ${e}`)),
              t
            );
        }
        if (typeof e == "number") return e;
        throw new TypeError(`Expected number, got ${typeof e}: ${e}`);
      }
    }, "expectNumber"),
    Por = Math.ceil(2 ** 127 * (2 - 2 ** -23)),
    mj = fe((e) => {
      let t = oO(e);
      if (
        t !== void 0 &&
        !Number.isNaN(t) &&
        t !== 1 / 0 &&
        t !== -1 / 0 &&
        Math.abs(t) > Por
      )
        throw new TypeError(`Expected 32-bit float, got ${e}`);
      return t;
    }, "expectFloat32"),
    aO = fe((e) => {
      if (e != null) {
        if (Number.isInteger(e) && !Number.isNaN(e)) return e;
        throw new TypeError(`Expected integer, got ${typeof e}: ${e}`);
      }
    }, "expectLong"),
    Ror = aO,
    q9 = fe((e) => U9(e, 32), "expectInt32"),
    j9 = fe((e) => U9(e, 16), "expectShort"),
    F9 = fe((e) => U9(e, 8), "expectByte"),
    U9 = fe((e, t) => {
      let r = aO(e);
      if (r !== void 0 && Ior(r, t) !== r)
        throw new TypeError(`Expected ${t}-bit integer, got ${e}`);
      return r;
    }, "expectSizedInt"),
    Ior = fe((e, t) => {
      switch (t) {
        case 32:
          return Int32Array.of(e)[0];
        case 16:
          return Int16Array.of(e)[0];
        case 8:
          return Int8Array.of(e)[0];
      }
    }, "castInt"),
    xor = fe((e, t) => {
      if (e == null)
        throw t
          ? new TypeError(`Expected a non-null value for ${t}`)
          : new TypeError("Expected a non-null value");
      return e;
    }, "expectNonNull"),
    tFe = fe((e) => {
      if (e == null) return;
      if (typeof e == "object" && !Array.isArray(e)) return e;
      let t = Array.isArray(e) ? "array" : typeof e;
      throw new TypeError(`Expected object, got ${t}: ${e}`);
    }, "expectObject"),
    Nor = fe((e) => {
      if (e != null) {
        if (typeof e == "string") return e;
        if (["boolean", "number", "bigint"].includes(typeof e))
          return (
            sO.warn(hj(`Expected string, got ${typeof e}: ${e}`)), String(e)
          );
        throw new TypeError(`Expected string, got ${typeof e}: ${e}`);
      }
    }, "expectString"),
    kor = fe((e) => {
      if (e == null) return;
      let t = tFe(e),
        r = Object.entries(t)
          .filter(([, n]) => n != null)
          .map(([n]) => n);
      if (r.length === 0)
        throw new TypeError(
          "Unions must have exactly one non-null member. None were found.",
        );
      if (r.length > 1)
        throw new TypeError(
          `Unions must have exactly one non-null member. Keys ${r} were not null.`,
        );
      return t;
    }, "expectUnion"),
    H9 = fe((e) => oO(typeof e == "string" ? tE(e) : e), "strictParseDouble"),
    Dor = H9,
    rFe = fe((e) => mj(typeof e == "string" ? tE(e) : e), "strictParseFloat32"),
    Lor = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    tE = fe((e) => {
      let t = e.match(Lor);
      if (t === null || t[0].length !== e.length)
        throw new TypeError("Expected real number, got implicit NaN");
      return parseFloat(e);
    }, "parseNumber"),
    G9 = fe(
      (e) => (typeof e == "string" ? nFe(e) : oO(e)),
      "limitedParseDouble",
    ),
    Mor = G9,
    qor = G9,
    jor = fe(
      (e) => (typeof e == "string" ? nFe(e) : mj(e)),
      "limitedParseFloat32",
    ),
    nFe = fe((e) => {
      switch (e) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw new Error(`Unable to parse float value: ${e}`);
      }
    }, "parseFloatString"),
    iFe = fe((e) => aO(typeof e == "string" ? tE(e) : e), "strictParseLong"),
    For = iFe,
    Bor = fe((e) => q9(typeof e == "string" ? tE(e) : e), "strictParseInt32"),
    Z_ = fe((e) => j9(typeof e == "string" ? tE(e) : e), "strictParseShort"),
    oFe = fe((e) => F9(typeof e == "string" ? tE(e) : e), "strictParseByte"),
    hj = fe(
      (e) =>
        String(new TypeError(e).stack || e)
          .split(
            `
`,
          )
          .slice(0, 5)
          .filter((t) => !t.includes("stackTraceWarning")).join(`
`),
      "stackTraceWarning",
    ),
    sO = { warn: console.warn },
    Uor = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    V9 = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
  function aFe(e) {
    let t = e.getUTCFullYear(),
      r = e.getUTCMonth(),
      n = e.getUTCDay(),
      i = e.getUTCDate(),
      o = e.getUTCHours(),
      a = e.getUTCMinutes(),
      s = e.getUTCSeconds(),
      u = i < 10 ? `0${i}` : `${i}`,
      l = o < 10 ? `0${o}` : `${o}`,
      d = a < 10 ? `0${a}` : `${a}`,
      f = s < 10 ? `0${s}` : `${s}`;
    return `${Uor[n]}, ${u} ${V9[r]} ${t} ${l}:${d}:${f} GMT`;
  }
  fe(aFe, "dateToUtcString");
  var Hor = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/,
    ),
    Gor = fe((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      let t = Hor.exec(e);
      if (!t) throw new TypeError("Invalid RFC-3339 date-time value");
      let [r, n, i, o, a, s, u, l] = t,
        d = Z_(eE(n)),
        f = su(i, "month", 1, 12),
        m = su(o, "day", 1, 31);
      return iO(d, f, m, {
        hours: a,
        minutes: s,
        seconds: u,
        fractionalMilliseconds: l,
      });
    }, "parseRfc3339DateTime"),
    Vor = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/,
    ),
    $or = fe((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      let t = Vor.exec(e);
      if (!t) throw new TypeError("Invalid RFC-3339 date-time value");
      let [r, n, i, o, a, s, u, l, d] = t,
        f = Z_(eE(n)),
        m = su(i, "month", 1, 12),
        h = su(o, "day", 1, 31),
        y = iO(f, m, h, {
          hours: a,
          minutes: s,
          seconds: u,
          fractionalMilliseconds: l,
        });
      return d.toUpperCase() != "Z" && y.setTime(y.getTime() - iar(d)), y;
    }, "parseRfc3339DateTimeWithOffset"),
    zor = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    Kor = new RegExp(
      /^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    Wor = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/,
    ),
    Qor = fe((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
      let t = zor.exec(e);
      if (t) {
        let [r, n, i, o, a, s, u, l] = t;
        return iO(Z_(eE(o)), L9(i), su(n, "day", 1, 31), {
          hours: a,
          minutes: s,
          seconds: u,
          fractionalMilliseconds: l,
        });
      }
      if (((t = Kor.exec(e)), t)) {
        let [r, n, i, o, a, s, u, l] = t;
        return Zor(
          iO(Xor(o), L9(i), su(n, "day", 1, 31), {
            hours: a,
            minutes: s,
            seconds: u,
            fractionalMilliseconds: l,
          }),
        );
      }
      if (((t = Wor.exec(e)), t)) {
        let [r, n, i, o, a, s, u, l] = t;
        return iO(Z_(eE(l)), L9(n), su(i.trimLeft(), "day", 1, 31), {
          hours: o,
          minutes: a,
          seconds: s,
          fractionalMilliseconds: u,
        });
      }
      throw new TypeError("Invalid RFC-7231 date-time value");
    }, "parseRfc7231DateTime"),
    Yor = fe((e) => {
      if (e == null) return;
      let t;
      if (typeof e == "number") t = e;
      else if (typeof e == "string") t = H9(e);
      else if (typeof e == "object" && e.tag === 1) t = e.value;
      else
        throw new TypeError(
          "Epoch timestamps must be expressed as floating point numbers or their string representation",
        );
      if (Number.isNaN(t) || t === 1 / 0 || t === -1 / 0)
        throw new TypeError(
          "Epoch timestamps must be valid, non-Infinite, non-NaN numerics",
        );
      return new Date(Math.round(t * 1e3));
    }, "parseEpochTimestamp"),
    iO = fe((e, t, r, n) => {
      let i = t - 1;
      return (
        tar(e, i, r),
        new Date(
          Date.UTC(
            e,
            i,
            r,
            su(n.hours, "hour", 0, 23),
            su(n.minutes, "minute", 0, 59),
            su(n.seconds, "seconds", 0, 60),
            nar(n.fractionalMilliseconds),
          ),
        )
      );
    }, "buildDate"),
    Xor = fe((e) => {
      let t = new Date().getUTCFullYear(),
        r = Math.floor(t / 100) * 100 + Z_(eE(e));
      return r < t ? r + 100 : r;
    }, "parseTwoDigitYear"),
    Jor = 50 * 365 * 24 * 60 * 60 * 1e3,
    Zor = fe(
      (e) =>
        e.getTime() - new Date().getTime() > Jor
          ? new Date(
              Date.UTC(
                e.getUTCFullYear() - 100,
                e.getUTCMonth(),
                e.getUTCDate(),
                e.getUTCHours(),
                e.getUTCMinutes(),
                e.getUTCSeconds(),
                e.getUTCMilliseconds(),
              ),
            )
          : e,
      "adjustRfc850Year",
    ),
    L9 = fe((e) => {
      let t = V9.indexOf(e);
      if (t < 0) throw new TypeError(`Invalid month: ${e}`);
      return t + 1;
    }, "parseMonthByShortName"),
    ear = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    tar = fe((e, t, r) => {
      let n = ear[t];
      if ((t === 1 && rar(e) && (n = 29), r > n))
        throw new TypeError(`Invalid day for ${V9[t]} in ${e}: ${r}`);
    }, "validateDayOfMonth"),
    rar = fe(
      (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0),
      "isLeapYear",
    ),
    su = fe((e, t, r, n) => {
      let i = oFe(eE(e));
      if (i < r || i > n)
        throw new TypeError(`${t} must be between ${r} and ${n}, inclusive`);
      return i;
    }, "parseDateValue"),
    nar = fe((e) => (e == null ? 0 : rFe("0." + e) * 1e3), "parseMilliseconds"),
    iar = fe((e) => {
      let t = e[0],
        r = 1;
      if (t == "+") r = 1;
      else if (t == "-") r = -1;
      else throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`);
      let n = Number(e.substring(1, 3)),
        i = Number(e.substring(4, 6));
      return r * (n * 60 + i) * 60 * 1e3;
    }, "parseOffsetToMilliseconds"),
    eE = fe((e) => {
      let t = 0;
      for (; t < e.length - 1 && e.charAt(t) === "0"; ) t++;
      return t === 0 ? e : e.slice(t);
    }, "stripLeadingZeroes"),
    oar = class nO extends Error {
      static {
        fe(this, "ServiceException");
      }
      constructor(t) {
        super(t.message),
          Object.setPrototypeOf(
            this,
            Object.getPrototypeOf(this).constructor.prototype,
          ),
          (this.name = t.name),
          (this.$fault = t.$fault),
          (this.$metadata = t.$metadata);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          nO.prototype.isPrototypeOf(r) ||
          (!!r.$fault &&
            !!r.$metadata &&
            (r.$fault === "client" || r.$fault === "server"))
        );
      }
      static [Symbol.hasInstance](t) {
        if (!t) return !1;
        let r = t;
        return this === nO
          ? nO.isInstance(t)
          : nO.isInstance(t)
            ? r.name && this.name
              ? this.prototype.isPrototypeOf(t) || r.name === this.name
              : this.prototype.isPrototypeOf(t)
            : !1;
      }
    },
    sFe = fe((e, t = {}) => {
      Object.entries(t)
        .filter(([, n]) => n !== void 0)
        .forEach(([n, i]) => {
          (e[n] == null || e[n] === "") && (e[n] = i);
        });
      let r = e.message || e.Message || "UnknownError";
      return (e.message = r), delete e.Message, e;
    }, "decorateServiceException"),
    cFe = fe(({ output: e, parsedBody: t, exceptionCtor: r, errorCode: n }) => {
      let i = sar(e),
        o = i.httpStatusCode ? i.httpStatusCode + "" : void 0,
        a = new r({
          name: t?.code || t?.Code || n || o || "UnknownError",
          $fault: "client",
          $metadata: i,
        });
      throw sFe(a, t);
    }, "throwDefaultError"),
    aar = fe(
      (e) =>
        ({ output: t, parsedBody: r, errorCode: n }) => {
          cFe({ output: t, parsedBody: r, exceptionCtor: e, errorCode: n });
        },
      "withBaseException",
    ),
    sar = fe(
      (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }),
      "deserializeMetadata",
    ),
    car = fe((e) => {
      switch (e) {
        case "standard":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "in-region":
          return { retryMode: "standard", connectionTimeout: 1100 };
        case "cross-region":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "mobile":
          return { retryMode: "standard", connectionTimeout: 3e4 };
        default:
          return {};
      }
    }, "loadConfigsForDefaultMode"),
    Xje = !1,
    uar = fe((e) => {
      e && !Xje && parseInt(e.substring(1, e.indexOf("."))) < 16 && (Xje = !0);
    }, "emitWarningIfUnsupportedVersion"),
    lar = fe((e) => {
      let t = [];
      for (let r in M9.AlgorithmId) {
        let n = M9.AlgorithmId[r];
        e[n] !== void 0 &&
          t.push({ algorithmId: () => n, checksumConstructor: () => e[n] });
      }
      return {
        addChecksumAlgorithm(r) {
          t.push(r);
        },
        checksumAlgorithms() {
          return t;
        },
      };
    }, "getChecksumConfiguration"),
    dar = fe((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    far = fe(
      (e) => ({
        setRetryStrategy(t) {
          e.retryStrategy = t;
        },
        retryStrategy() {
          return e.retryStrategy;
        },
      }),
      "getRetryConfiguration",
    ),
    par = fe((e) => {
      let t = {};
      return (t.retryStrategy = e.retryStrategy()), t;
    }, "resolveRetryRuntimeConfig"),
    uFe = fe(
      (e) => Object.assign(lar(e), far(e)),
      "getDefaultExtensionConfiguration",
    ),
    mar = uFe,
    har = fe(
      (e) => Object.assign(dar(e), par(e)),
      "resolveDefaultRuntimeConfig",
    ),
    gar = fe((e) => (Array.isArray(e) ? e : [e]), "getArrayIfSingleItem"),
    lFe = fe((e) => {
      let t = "#text";
      for (let r in e)
        e.hasOwnProperty(r) && e[r][t] !== void 0
          ? (e[r] = e[r][t])
          : typeof e[r] == "object" && e[r] !== null && (e[r] = lFe(e[r]));
      return e;
    }, "getValueFromTextNode"),
    yar = fe((e) => e != null, "isSerializableHeaderValue"),
    Ih = fe(function (t) {
      return Object.assign(new String(t), {
        deserializeJSON() {
          return JSON.parse(String(t));
        },
        toString() {
          return String(t);
        },
        toJSON() {
          return String(t);
        },
      });
    }, "LazyJsonString");
  Ih.from = (e) =>
    e && typeof e == "object" && (e instanceof Ih || "deserializeJSON" in e)
      ? e
      : typeof e == "string" || Object.getPrototypeOf(e) === String.prototype
        ? Ih(String(e))
        : Ih(JSON.stringify(e));
  Ih.fromObject = Ih.from;
  var _ar = class {
    static {
      fe(this, "NoOpLogger");
    }
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  };
  function $9(e, t, r) {
    let n, i, o;
    if (typeof t > "u" && typeof r > "u") (n = {}), (o = e);
    else {
      if (((n = e), typeof t == "function"))
        return (i = t), (o = r), Sar(n, i, o);
      o = t;
    }
    for (let a of Object.keys(o)) {
      if (!Array.isArray(o[a])) {
        n[a] = o[a];
        continue;
      }
      dFe(n, null, o, a);
    }
    return n;
  }
  fe($9, "map");
  var Ear = fe((e) => {
      let t = {};
      for (let [r, n] of Object.entries(e || {})) t[r] = [, n];
      return t;
    }, "convertMap"),
    bar = fe((e, t) => {
      let r = {};
      for (let n in t) dFe(r, e, t, n);
      return r;
    }, "take"),
    Sar = fe(
      (e, t, r) =>
        $9(
          e,
          Object.entries(r).reduce(
            (n, [i, o]) => (
              Array.isArray(o)
                ? (n[i] = o)
                : typeof o == "function"
                  ? (n[i] = [t, o()])
                  : (n[i] = [t, o]),
              n
            ),
            {},
          ),
        ),
      "mapWithFilter",
    ),
    dFe = fe((e, t, r, n) => {
      if (t !== null) {
        let a = r[n];
        typeof a == "function" && (a = [, a]);
        let [s = Car, u = war, l = n] = a;
        ((typeof s == "function" && s(t[l])) ||
          (typeof s != "function" && s)) &&
          (e[n] = u(t[l]));
        return;
      }
      let [i, o] = r[n];
      if (typeof o == "function") {
        let a,
          s = i === void 0 && (a = o()) != null,
          u =
            (typeof i == "function" && !!i(void 0)) ||
            (typeof i != "function" && !!i);
        s ? (e[n] = a) : u && (e[n] = o());
      } else {
        let a = i === void 0 && o != null,
          s =
            (typeof i == "function" && !!i(o)) ||
            (typeof i != "function" && !!i);
        (a || s) && (e[n] = o);
      }
    }, "applyInstruction"),
    Car = fe((e) => e != null, "nonNullish"),
    war = fe((e) => e, "pass");
  function fFe(e) {
    return (
      (e.includes(",") || e.includes('"')) &&
        (e = `"${e.replace(/"/g, '\\"')}"`),
      e
    );
  }
  fe(fFe, "quoteHeader");
  var Oar = fe((e) => {
      if (e !== e) return "NaN";
      switch (e) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return e;
      }
    }, "serializeFloat"),
    Tar = fe((e) => e.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    B9 = fe((e) => {
      if (e == null) return {};
      if (Array.isArray(e)) return e.filter((t) => t != null).map(B9);
      if (typeof e == "object") {
        let t = {};
        for (let r of Object.keys(e)) e[r] != null && (t[r] = B9(e[r]));
        return t;
      }
      return e;
    }, "_json");
  function pFe(e, t, r) {
    if (r <= 0 || !Number.isInteger(r))
      throw new Error(
        "Invalid number of delimiters (" + r + ") for splitEvery.",
      );
    let n = e.split(t);
    if (r === 1) return n;
    let i = [],
      o = "";
    for (let a = 0; a < n.length; a++)
      o === "" ? (o = n[a]) : (o += t + n[a]),
        (a + 1) % r === 0 && (i.push(o), (o = ""));
    return o !== "" && i.push(o), i;
  }
  fe(pFe, "splitEvery");
  var Aar = fe((e) => {
    let t = e.length,
      r = [],
      n = !1,
      i,
      o = 0;
    for (let a = 0; a < t; ++a) {
      let s = e[a];
      switch (s) {
        case '"':
          i !== "\\" && (n = !n);
          break;
        case ",":
          n || (r.push(e.slice(o, a)), (o = a + 1));
          break;
        default:
      }
      i = s;
    }
    return (
      r.push(e.slice(o)),
      r.map((a) => {
        a = a.trim();
        let s = a.length;
        return s < 2
          ? a
          : (a[0] === '"' && a[s - 1] === '"' && (a = a.slice(1, s - 1)),
            a.replace(/\\"/g, '"'));
      })
    );
  }, "splitHeader");
});
var hFe,
  Par,
  gFe = w(() => {
    c();
    (hFe = A(vj())),
      (Par = (e) => {
        if (e != null)
          return (
            typeof e == "object" && "__type" in e && delete e.__type,
            (0, hFe.expectUnion)(e)
          );
      });
  });
var vFe,
  yj,
  z9 = w(() => {
    c();
    (vFe = A(vj())),
      (yj = (e, t) => (0, vFe.collectBody)(e, t).then((r) => t.utf8Encoder(r)));
  });
var yFe,
  Rar,
  Iar,
  _Fe = w(() => {
    c();
    z9();
    (yFe = (e, t) =>
      yj(e, t).then((r) => {
        if (r.length)
          try {
            return JSON.parse(r);
          } catch (n) {
            throw (
              (n?.name === "SyntaxError" &&
                Object.defineProperty(n, "$responseBodyText", { value: r }),
              n)
            );
          }
        return {};
      })),
      (Rar = async (e, t) => {
        let r = await yFe(e, t);
        return (r.message = r.message ?? r.Message), r;
      }),
      (Iar = (e, t) => {
        let r = (o, a) =>
            Object.keys(o).find((s) => s.toLowerCase() === a.toLowerCase()),
          n = (o) => {
            let a = o;
            return (
              typeof a == "number" && (a = a.toString()),
              a.indexOf(",") >= 0 && (a = a.split(",")[0]),
              a.indexOf(":") >= 0 && (a = a.split(":")[0]),
              a.indexOf("#") >= 0 && (a = a.split("#")[1]),
              a
            );
          },
          i = r(e.headers, "x-amzn-errortype");
        if (i !== void 0) return n(e.headers[i]);
        if (t.code !== void 0) return n(t.code);
        if (t.__type !== void 0) return n(t.__type);
      });
  });
var EFe,
  bFe,
  SFe,
  xar,
  Nar,
  CFe = w(() => {
    c();
    (EFe = A(vj())), (bFe = A(UC()));
    z9();
    (SFe = (e, t) =>
      yj(e, t).then((r) => {
        if (r.length) {
          let n = new bFe.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: (u, l) =>
              l.trim() === "" &&
              l.includes(`
`)
                ? ""
                : void 0,
          });
          n.addEntity("#xD", "\r"),
            n.addEntity(
              "#10",
              `
`,
            );
          let i;
          try {
            i = n.parse(r, !0);
          } catch (u) {
            throw (
              (u &&
                typeof u == "object" &&
                Object.defineProperty(u, "$responseBodyText", { value: r }),
              u)
            );
          }
          let o = "#text",
            a = Object.keys(i)[0],
            s = i[a];
          return (
            s[o] && ((s[a] = s[o]), delete s[o]),
            (0, EFe.getValueFromTextNode)(s)
          );
        }
        return {};
      })),
      (xar = async (e, t) => {
        let r = await SFe(e, t);
        return (
          r.Error && (r.Error.message = r.Error.message ?? r.Error.Message), r
        );
      }),
      (Nar = (e, t) => {
        if (t?.Error?.Code !== void 0) return t.Error.Code;
        if (t?.Code !== void 0) return t.Code;
        if (e.statusCode == 404) return "NotFound";
      });
  });
var wFe = w(() => {
  c();
  $je();
  gFe();
  _Fe();
  CFe();
});
var OFe = {};
bn(OFe, {
  AWSSDKSigV4Signer: () => aMe,
  AwsSdkSigV4ASigner: () => Rq,
  AwsSdkSigV4Signer: () => Th,
  NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => crr,
  NODE_SIGV4A_CONFIG_OPTIONS: () => Dir,
  _toBool: () => sor,
  _toNum: () => cor,
  _toStr: () => aor,
  awsExpectUnion: () => Par,
  emitWarningIfUnsupportedVersion: () => qtr,
  loadRestJsonErrorCode: () => Iar,
  loadRestXmlErrorCode: () => Nar,
  parseJsonBody: () => yFe,
  parseJsonErrorBody: () => Rar,
  parseXmlBody: () => SFe,
  parseXmlErrorBody: () => xar,
  resolveAWSSDKSigV4Config: () => nor,
  resolveAwsSdkSigV4AConfig: () => kir,
  resolveAwsSdkSigV4Config: () => Uje,
  setCredentialFeature: () => qQ,
  setFeature: () => jtr,
  state: () => MQ,
  validateSigningProperties: () => eO,
});
var TFe = w(() => {
  c();
  jQ();
  Vje();
  wFe();
});
var RFe = g((_j) => {
  "use strict";
  c();
  Object.defineProperty(_j, "__esModule", { value: !0 });
  _j.AwsCrc32c = void 0;
  var AFe = (go(), ue(ho)),
    K9 = Vp(),
    PFe = W9(),
    kar = (function () {
      function e() {
        this.crc32c = new PFe.Crc32c();
      }
      return (
        (e.prototype.update = function (t) {
          (0, K9.isEmptyData)(t) ||
            this.crc32c.update((0, K9.convertToBuffer)(t));
        }),
        (e.prototype.digest = function () {
          return AFe.__awaiter(this, void 0, void 0, function () {
            return AFe.__generator(this, function (t) {
              return [2, (0, K9.numToUint8)(this.crc32c.digest())];
            });
          });
        }),
        (e.prototype.reset = function () {
          this.crc32c = new PFe.Crc32c();
        }),
        e
      );
    })();
  _j.AwsCrc32c = kar;
});
var W9 = g((Wf) => {
  "use strict";
  c();
  Object.defineProperty(Wf, "__esModule", { value: !0 });
  Wf.AwsCrc32c = Wf.Crc32c = Wf.crc32c = void 0;
  var Dar = (go(), ue(ho)),
    Lar = Vp();
  function Mar(e) {
    return new IFe().update(e).digest();
  }
  Wf.crc32c = Mar;
  var IFe = (function () {
    function e() {
      this.checksum = 4294967295;
    }
    return (
      (e.prototype.update = function (t) {
        var r, n;
        try {
          for (var i = Dar.__values(t), o = i.next(); !o.done; o = i.next()) {
            var a = o.value;
            this.checksum =
              (this.checksum >>> 8) ^ jar[(this.checksum ^ a) & 255];
          }
        } catch (s) {
          r = { error: s };
        } finally {
          try {
            o && !o.done && (n = i.return) && n.call(i);
          } finally {
            if (r) throw r.error;
          }
        }
        return this;
      }),
      (e.prototype.digest = function () {
        return (this.checksum ^ 4294967295) >>> 0;
      }),
      e
    );
  })();
  Wf.Crc32c = IFe;
  var qar = [
      0, 4067132163, 3778769143, 324072436, 3348797215, 904991772, 648144872,
      3570033899, 2329499855, 2024987596, 1809983544, 2575936315, 1296289744,
      3207089363, 2893594407, 1578318884, 274646895, 3795141740, 4049975192,
      51262619, 3619967088, 632279923, 922689671, 3298075524, 2592579488,
      1760304291, 2075979607, 2312596564, 1562183871, 2943781820, 3156637768,
      1313733451, 549293790, 3537243613, 3246849577, 871202090, 3878099393,
      357341890, 102525238, 4101499445, 2858735121, 1477399826, 1264559846,
      3107202533, 1845379342, 2677391885, 2361733625, 2125378298, 820201905,
      3263744690, 3520608582, 598981189, 4151959214, 85089709, 373468761,
      3827903834, 3124367742, 1213305469, 1526817161, 2842354314, 2107672161,
      2412447074, 2627466902, 1861252501, 1098587580, 3004210879, 2688576843,
      1378610760, 2262928035, 1955203488, 1742404180, 2511436119, 3416409459,
      969524848, 714683780, 3639785095, 205050476, 4266873199, 3976438427,
      526918040, 1361435347, 2739821008, 2954799652, 1114974503, 2529119692,
      1691668175, 2005155131, 2247081528, 3690758684, 697762079, 986182379,
      3366744552, 476452099, 3993867776, 4250756596, 255256311, 1640403810,
      2477592673, 2164122517, 1922457750, 2791048317, 1412925310, 1197962378,
      3037525897, 3944729517, 427051182, 170179418, 4165941337, 746937522,
      3740196785, 3451792453, 1070968646, 1905808397, 2213795598, 2426610938,
      1657317369, 3053634322, 1147748369, 1463399397, 2773627110, 4215344322,
      153784257, 444234805, 3893493558, 1021025245, 3467647198, 3722505002,
      797665321, 2197175160, 1889384571, 1674398607, 2443626636, 1164749927,
      3070701412, 2757221520, 1446797203, 137323447, 4198817972, 3910406976,
      461344835, 3484808360, 1037989803, 781091935, 3705997148, 2460548119,
      1623424788, 1939049696, 2180517859, 1429367560, 2807687179, 3020495871,
      1180866812, 410100952, 3927582683, 4182430767, 186734380, 3756733383,
      763408580, 1053836080, 3434856499, 2722870694, 1344288421, 1131464017,
      2971354706, 1708204729, 2545590714, 2229949006, 1988219213, 680717673,
      3673779818, 3383336350, 1002577565, 4010310262, 493091189, 238226049,
      4233660802, 2987750089, 1082061258, 1395524158, 2705686845, 1972364758,
      2279892693, 2494862625, 1725896226, 952904198, 3399985413, 3656866545,
      731699698, 4283874585, 222117402, 510512622, 3959836397, 3280807620,
      837199303, 582374963, 3504198960, 68661723, 4135334616, 3844915500,
      390545967, 1230274059, 3141532936, 2825850620, 1510247935, 2395924756,
      2091215383, 1878366691, 2644384480, 3553878443, 565732008, 854102364,
      3229815391, 340358836, 3861050807, 4117890627, 119113024, 1493875044,
      2875275879, 3090270611, 1247431312, 2660249211, 1828433272, 2141937292,
      2378227087, 3811616794, 291187481, 34330861, 4032846830, 615137029,
      3603020806, 3314634738, 939183345, 1776939221, 2609017814, 2295496738,
      2058945313, 2926798794, 1545135305, 1330124605, 3173225534, 4084100981,
      17165430, 307568514, 3762199681, 888469610, 3332340585, 3587147933,
      665062302, 2042050490, 2346497209, 2559330125, 1793573966, 3190661285,
      1279665062, 1595330642, 2910671697,
    ],
    jar = (0, Lar.uint32ArrayFrom)(qar),
    Far = RFe();
  Object.defineProperty(Wf, "AwsCrc32c", {
    enumerable: !0,
    get: function () {
      return Far.AwsCrc32c;
    },
  });
});
var kFe = g((Ej) => {
  "use strict";
  c();
  Object.defineProperty(Ej, "__esModule", { value: !0 });
  Ej.AwsCrc32 = void 0;
  var xFe = (go(), ue(ho)),
    Q9 = Vp(),
    NFe = cO(),
    Bar = (function () {
      function e() {
        this.crc32 = new NFe.Crc32();
      }
      return (
        (e.prototype.update = function (t) {
          (0, Q9.isEmptyData)(t) ||
            this.crc32.update((0, Q9.convertToBuffer)(t));
        }),
        (e.prototype.digest = function () {
          return xFe.__awaiter(this, void 0, void 0, function () {
            return xFe.__generator(this, function (t) {
              return [2, (0, Q9.numToUint8)(this.crc32.digest())];
            });
          });
        }),
        (e.prototype.reset = function () {
          this.crc32 = new NFe.Crc32();
        }),
        e
      );
    })();
  Ej.AwsCrc32 = Bar;
});
var cO = g((Qf) => {
  "use strict";
  c();
  Object.defineProperty(Qf, "__esModule", { value: !0 });
  Qf.AwsCrc32 = Qf.Crc32 = Qf.crc32 = void 0;
  var Uar = (go(), ue(ho)),
    Har = Vp();
  function Gar(e) {
    return new DFe().update(e).digest();
  }
  Qf.crc32 = Gar;
  var DFe = (function () {
    function e() {
      this.checksum = 4294967295;
    }
    return (
      (e.prototype.update = function (t) {
        var r, n;
        try {
          for (var i = Uar.__values(t), o = i.next(); !o.done; o = i.next()) {
            var a = o.value;
            this.checksum =
              (this.checksum >>> 8) ^ $ar[(this.checksum ^ a) & 255];
          }
        } catch (s) {
          r = { error: s };
        } finally {
          try {
            o && !o.done && (n = i.return) && n.call(i);
          } finally {
            if (r) throw r.error;
          }
        }
        return this;
      }),
      (e.prototype.digest = function () {
        return (this.checksum ^ 4294967295) >>> 0;
      }),
      e
    );
  })();
  Qf.Crc32 = DFe;
  var Var = [
      0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685,
      2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995,
      2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648,
      2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990,
      1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755,
      2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145,
      1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206,
      2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980,
      1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705,
      3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527,
      1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772,
      4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290,
      251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719,
      3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925,
      453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202,
      4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960,
      984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733,
      3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467,
      855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048,
      3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054,
      702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443,
      3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945,
      2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430,
      2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580,
      2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225,
      1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143,
      2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732,
      1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850,
      2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135,
      1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109,
      3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954,
      1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920,
      3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877,
      83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603,
      3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992,
      534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934,
      4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795,
      376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105,
      3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270,
      936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108,
      3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449,
      601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471,
      3272380065, 1510334235, 755167117,
    ],
    $ar = (0, Har.uint32ArrayFrom)(Var),
    zar = kFe();
  Object.defineProperty(Qf, "AwsCrc32", {
    enumerable: !0,
    get: function () {
      return zar.AwsCrc32;
    },
  });
});
var MFe = g((bj) => {
  "use strict";
  c();
  Object.defineProperty(bj, "__esModule", { value: !0 });
  bj.getCrc32ChecksumAlgorithmFunction = void 0;
  var Kar = (go(), ue(ho)),
    War = cO(),
    Qar = Vp(),
    LFe = Kar.__importStar(G("zlib")),
    Y9 = class {
      checksum = 0;
      update(t) {
        this.checksum = LFe.crc32(t, this.checksum);
      }
      async digest() {
        return (0, Qar.numToUint8)(this.checksum);
      }
      reset() {
        this.checksum = 0;
      }
    },
    Yar = () => (typeof LFe.crc32 > "u" ? War.AwsCrc32 : Y9);
  bj.getCrc32ChecksumAlgorithmFunction = Yar;
});
var rY = g((mqn, ZFe) => {
  "use strict";
  c();
  var wj = Object.defineProperty,
    Xar = Object.getOwnPropertyDescriptor,
    Jar = Object.getOwnPropertyNames,
    Zar = Object.prototype.hasOwnProperty,
    un = (e, t) => wj(e, "name", { value: t, configurable: !0 }),
    esr = (e, t) => {
      for (var r in t) wj(e, r, { get: t[r], enumerable: !0 });
    },
    tsr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Jar(t))
          !Zar.call(e, i) &&
            i !== r &&
            wj(e, i, {
              get: () => t[i],
              enumerable: !(n = Xar(t, i)) || n.enumerable,
            });
      return e;
    },
    rsr = (e) => tsr(wj({}, "__esModule", { value: !0 }), e),
    jFe = {};
  esr(jFe, {
    CONFIG_REQUEST_CHECKSUM_CALCULATION: () => HFe,
    CONFIG_RESPONSE_CHECKSUM_VALIDATION: () => VFe,
    ChecksumAlgorithm: () => FFe,
    ChecksumLocation: () => BFe,
    DEFAULT_CHECKSUM_ALGORITHM: () => Sj,
    DEFAULT_REQUEST_CHECKSUM_CALCULATION: () => Z9,
    DEFAULT_RESPONSE_CHECKSUM_VALIDATION: () => eY,
    ENV_REQUEST_CHECKSUM_CALCULATION: () => UFe,
    ENV_RESPONSE_CHECKSUM_VALIDATION: () => GFe,
    NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS: () => nsr,
    NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS: () => isr,
    RequestChecksumCalculation: () => Bl,
    ResponseChecksumValidation: () => rE,
    crc64NvmeCrtContainer: () => X9,
    flexibleChecksumsMiddleware: () => XFe,
    flexibleChecksumsMiddlewareOptions: () => YFe,
    getFlexibleChecksumsPlugin: () => Esr,
    resolveFlexibleChecksumsConfig: () => bsr,
  });
  ZFe.exports = rsr(jFe);
  var Bl = { WHEN_SUPPORTED: "WHEN_SUPPORTED", WHEN_REQUIRED: "WHEN_REQUIRED" },
    Z9 = Bl.WHEN_SUPPORTED,
    rE = { WHEN_SUPPORTED: "WHEN_SUPPORTED", WHEN_REQUIRED: "WHEN_REQUIRED" },
    eY = Bl.WHEN_SUPPORTED,
    FFe = ((e) => (
      (e.MD5 = "MD5"),
      (e.CRC32 = "CRC32"),
      (e.CRC32C = "CRC32C"),
      (e.CRC64NVME = "CRC64NVME"),
      (e.SHA1 = "SHA1"),
      (e.SHA256 = "SHA256"),
      e
    ))(FFe || {}),
    BFe = ((e) => ((e.HEADER = "header"), (e.TRAILER = "trailer"), e))(
      BFe || {},
    ),
    Sj = "CRC32",
    Cj = un((e, t, r, n) => {
      if (!(t in e)) return;
      let i = e[t].toUpperCase();
      if (!Object.values(r).includes(i))
        throw new TypeError(
          `Cannot load ${n} '${t}'. Expected one of ${Object.values(r)}, got '${e[t]}'.`,
        );
      return i;
    }, "stringUnionSelector"),
    UFe = "AWS_REQUEST_CHECKSUM_CALCULATION",
    HFe = "request_checksum_calculation",
    nsr = {
      environmentVariableSelector: un(
        (e) => Cj(e, UFe, Bl, "env"),
        "environmentVariableSelector",
      ),
      configFileSelector: un(
        (e) => Cj(e, HFe, Bl, "shared config entry"),
        "configFileSelector",
      ),
      default: Z9,
    },
    GFe = "AWS_RESPONSE_CHECKSUM_VALIDATION",
    VFe = "response_checksum_validation",
    isr = {
      environmentVariableSelector: un(
        (e) => Cj(e, GFe, rE, "env"),
        "environmentVariableSelector",
      ),
      configFileSelector: un(
        (e) => Cj(e, VFe, rE, "shared config entry"),
        "configFileSelector",
      ),
      default: eY,
    },
    X9 = { CrtCrc64Nvme: null },
    Fl = (TFe(), ue(OFe)),
    $Fe = ts(),
    zFe = h9(),
    J9 = ["CRC32", "CRC32C", "CRC64NVME", "SHA1", "SHA256"],
    osr = ["SHA256", "SHA1", "CRC32", "CRC32C", "CRC64NVME"],
    asr = un(
      (
        e,
        {
          requestChecksumRequired: t,
          requestAlgorithmMember: r,
          requestChecksumCalculation: n,
        },
      ) => {
        if (!r) return n === Bl.WHEN_SUPPORTED || t ? Sj : void 0;
        if (!e[r]) return;
        let i = e[r];
        if (!J9.includes(i))
          throw new Error(
            `The checksum algorithm "${i}" is not supported by the client. Select one of ${J9}.`,
          );
        return i;
      },
      "getChecksumAlgorithmForRequest",
    ),
    tY = un(
      (e) =>
        e === "MD5" ? "content-md5" : `x-amz-checksum-${e.toLowerCase()}`,
      "getChecksumLocationName",
    ),
    ssr = un((e, t) => {
      let r = e.toLowerCase();
      for (let n of Object.keys(t)) if (r === n.toLowerCase()) return !0;
      return !1;
    }, "hasHeader"),
    csr = un((e, t) => {
      let r = e.toLowerCase();
      for (let n of Object.keys(t))
        if (n.toLowerCase().startsWith(r)) return !0;
      return !1;
    }, "hasHeaderWithPrefix"),
    usr = hf(),
    KFe = un(
      (e) =>
        e !== void 0 &&
        typeof e != "string" &&
        !ArrayBuffer.isView(e) &&
        !(0, usr.isArrayBuffer)(e),
      "isStreaming",
    ),
    lsr = W9(),
    dsr = MFe(),
    WFe = un((e, t) => {
      switch (e) {
        case "MD5":
          return t.md5;
        case "CRC32":
          return (0, dsr.getCrc32ChecksumAlgorithmFunction)();
        case "CRC32C":
          return lsr.AwsCrc32c;
        case "CRC64NVME":
          if (typeof X9.CrtCrc64Nvme != "function")
            throw new Error(`Please check whether you have installed the "@aws-sdk/crc64-nvme-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/crc64-nvme-crt");] or an ESM equivalent such as [import "@aws-sdk/crc64-nvme-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
          return X9.CrtCrc64Nvme;
        case "SHA1":
          return t.sha1;
        case "SHA256":
          return t.sha256;
        default:
          throw new Error(`Unsupported checksum algorithm: ${e}`);
      }
    }, "selectChecksumAlgorithmFunction"),
    fsr = Fe(),
    QFe = un((e, t) => {
      let r = new e();
      return r.update((0, fsr.toUint8Array)(t || "")), r.digest();
    }, "stringHasher"),
    YFe = {
      name: "flexibleChecksumsMiddleware",
      step: "build",
      tags: ["BODY_CHECKSUM"],
      override: !0,
    },
    XFe = un(
      (e, t) => (r, n) => async (i) => {
        if (
          !$Fe.HttpRequest.isInstance(i.request) ||
          csr("x-amz-checksum-", i.request.headers)
        )
          return r(i);
        let { request: o, input: a } = i,
          { body: s, headers: u } = o,
          { base64Encoder: l, streamHasher: d } = e,
          { requestChecksumRequired: f, requestAlgorithmMember: m } = t,
          h = await e.requestChecksumCalculation(),
          y = m?.name,
          _ = m?.httpHeader;
        y &&
          !a[y] &&
          (h === Bl.WHEN_SUPPORTED || f) &&
          ((a[y] = Sj), _ && (u[_] = Sj));
        let E = asr(a, {
            requestChecksumRequired: f,
            requestAlgorithmMember: m?.name,
            requestChecksumCalculation: h,
          }),
          b = s,
          O = u;
        if (E) {
          switch (E) {
            case "CRC32":
              (0, Fl.setFeature)(n, "FLEXIBLE_CHECKSUMS_REQ_CRC32", "U");
              break;
            case "CRC32C":
              (0, Fl.setFeature)(n, "FLEXIBLE_CHECKSUMS_REQ_CRC32C", "V");
              break;
            case "CRC64NVME":
              (0, Fl.setFeature)(n, "FLEXIBLE_CHECKSUMS_REQ_CRC64", "W");
              break;
            case "SHA1":
              (0, Fl.setFeature)(n, "FLEXIBLE_CHECKSUMS_REQ_SHA1", "X");
              break;
            case "SHA256":
              (0, Fl.setFeature)(n, "FLEXIBLE_CHECKSUMS_REQ_SHA256", "Y");
              break;
          }
          let P = tY(E),
            k = WFe(E, e);
          if (KFe(s)) {
            let { getAwsChunkedEncodingStream: H, bodyLengthChecker: B } = e;
            (b = H(
              typeof e.requestStreamBufferSize == "number" &&
                e.requestStreamBufferSize >= 8 * 1024
                ? (0, zFe.createBufferedReadable)(
                    s,
                    e.requestStreamBufferSize,
                    n.logger,
                  )
                : s,
              {
                base64Encoder: l,
                bodyLengthChecker: B,
                checksumLocationName: P,
                checksumAlgorithmFn: k,
                streamHasher: d,
              },
            )),
              (O = {
                ...u,
                "content-encoding": u["content-encoding"]
                  ? `${u["content-encoding"]},aws-chunked`
                  : "aws-chunked",
                "transfer-encoding": "chunked",
                "x-amz-decoded-content-length": u["content-length"],
                "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
                "x-amz-trailer": P,
              }),
              delete O["content-length"];
          } else if (!ssr(P, u)) {
            let H = await QFe(k, s);
            O = { ...u, [P]: l(H) };
          }
        }
        return await r({ ...i, request: { ...o, headers: O, body: b } });
      },
      "flexibleChecksumsMiddleware",
    ),
    psr = {
      name: "flexibleChecksumsInputMiddleware",
      toMiddleware: "serializerMiddleware",
      relation: "before",
      tags: ["BODY_CHECKSUM"],
      override: !0,
    },
    msr = un(
      (e, t) => (r, n) => async (i) => {
        let o = i.input,
          { requestValidationModeMember: a } = t,
          s = await e.requestChecksumCalculation(),
          u = await e.responseChecksumValidation();
        switch (s) {
          case Bl.WHEN_REQUIRED:
            (0, Fl.setFeature)(n, "FLEXIBLE_CHECKSUMS_REQ_WHEN_REQUIRED", "a");
            break;
          case Bl.WHEN_SUPPORTED:
            (0, Fl.setFeature)(n, "FLEXIBLE_CHECKSUMS_REQ_WHEN_SUPPORTED", "Z");
            break;
        }
        switch (u) {
          case rE.WHEN_REQUIRED:
            (0, Fl.setFeature)(n, "FLEXIBLE_CHECKSUMS_RES_WHEN_REQUIRED", "c");
            break;
          case rE.WHEN_SUPPORTED:
            (0, Fl.setFeature)(n, "FLEXIBLE_CHECKSUMS_RES_WHEN_SUPPORTED", "b");
            break;
        }
        return (
          a && !o[a] && u === rE.WHEN_SUPPORTED && (o[a] = "ENABLED"), r(i)
        );
      },
      "flexibleChecksumsInputMiddleware",
    ),
    JFe = un((e = []) => {
      let t = [];
      for (let r of osr) !e.includes(r) || !J9.includes(r) || t.push(r);
      return t;
    }, "getChecksumAlgorithmListForResponse"),
    hsr = un((e) => {
      let t = e.lastIndexOf("-");
      if (t !== -1) {
        let r = e.slice(t + 1);
        if (!r.startsWith("0")) {
          let n = parseInt(r, 10);
          if (!isNaN(n) && n >= 1 && n <= 1e4) return !0;
        }
      }
      return !1;
    }, "isChecksumWithPartNumber"),
    gsr = un(
      async (e, { checksumAlgorithmFn: t, base64Encoder: r }) =>
        r(await QFe(t, e)),
      "getChecksum",
    ),
    vsr = un(async (e, { config: t, responseAlgorithms: r, logger: n }) => {
      let i = JFe(r),
        { body: o, headers: a } = e;
      for (let s of i) {
        let u = tY(s),
          l = a[u];
        if (l) {
          let d;
          try {
            d = WFe(s, t);
          } catch (h) {
            if (s === "CRC64NVME") {
              n?.warn(`Skipping CRC64NVME checksum validation: ${h.message}`);
              continue;
            }
            throw h;
          }
          let { base64Encoder: f } = t;
          if (KFe(o)) {
            e.body = (0, zFe.createChecksumStream)({
              expectedChecksum: l,
              checksumSourceLocation: u,
              checksum: new d(),
              source: o,
              base64Encoder: f,
            });
            return;
          }
          let m = await gsr(o, { checksumAlgorithmFn: d, base64Encoder: f });
          if (m === l) break;
          throw new Error(
            `Checksum mismatch: expected "${m}" but received "${l}" in response header "${u}".`,
          );
        }
      }
    }, "validateChecksumFromResponse"),
    ysr = {
      name: "flexibleChecksumsResponseMiddleware",
      toMiddleware: "deserializerMiddleware",
      relation: "after",
      tags: ["BODY_CHECKSUM"],
      override: !0,
    },
    _sr = un(
      (e, t) => (r, n) => async (i) => {
        if (!$Fe.HttpRequest.isInstance(i.request)) return r(i);
        let o = i.input,
          a = await r(i),
          s = a.response,
          { requestValidationModeMember: u, responseAlgorithms: l } = t;
        if (u && o[u] === "ENABLED") {
          let { clientName: d, commandName: f } = n;
          if (
            d === "S3Client" &&
            f === "GetObjectCommand" &&
            JFe(l).every((h) => {
              let y = tY(h),
                _ = s.headers[y];
              return !_ || hsr(_);
            })
          )
            return a;
          await vsr(s, { config: e, responseAlgorithms: l, logger: n.logger });
        }
        return a;
      },
      "flexibleChecksumsResponseMiddleware",
    ),
    Esr = un(
      (e, t) => ({
        applyToStack: un((r) => {
          r.add(XFe(e, t), YFe),
            r.addRelativeTo(msr(e, t), psr),
            r.addRelativeTo(_sr(e, t), ysr);
        }, "applyToStack"),
      }),
      "getFlexibleChecksumsPlugin",
    ),
    qFe = tO(),
    bsr = un((e) => {
      let {
        requestChecksumCalculation: t,
        responseChecksumValidation: r,
        requestStreamBufferSize: n,
      } = e;
      return Object.assign(e, {
        requestChecksumCalculation: (0, qFe.normalizeProvider)(t ?? Z9),
        responseChecksumValidation: (0, qFe.normalizeProvider)(r ?? eY),
        requestStreamBufferSize: Number(n ?? 0),
      });
    }, "resolveFlexibleChecksumsConfig");
});
var Ul = g((gqn, c1e) => {
  c();
  var Oj = Object.defineProperty,
    Ssr = Object.getOwnPropertyDescriptor,
    Csr = Object.getOwnPropertyNames,
    wsr = Object.prototype.hasOwnProperty,
    Tj = (e, t) => Oj(e, "name", { value: t, configurable: !0 }),
    Osr = (e, t) => {
      for (var r in t) Oj(e, r, { get: t[r], enumerable: !0 });
    },
    Tsr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Csr(t))
          !wsr.call(e, i) &&
            i !== r &&
            Oj(e, i, {
              get: () => t[i],
              enumerable: !(n = Ssr(t, i)) || n.enumerable,
            });
      return e;
    },
    Asr = (e) => Tsr(Oj({}, "__esModule", { value: !0 }), e),
    e1e = {};
  Osr(e1e, {
    AlgorithmId: () => i1e,
    EndpointURLScheme: () => n1e,
    FieldPosition: () => o1e,
    HttpApiKeyAuthLocation: () => r1e,
    HttpAuthLocation: () => t1e,
    IniSectionType: () => a1e,
    RequestHandlerProtocol: () => s1e,
    SMITHY_CONTEXT_KEY: () => Nsr,
    getDefaultClientConfiguration: () => Isr,
    resolveDefaultRuntimeConfig: () => xsr,
  });
  c1e.exports = Asr(e1e);
  var t1e = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(t1e || {}),
    r1e = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(r1e || {}),
    n1e = ((e) => ((e.HTTP = "http"), (e.HTTPS = "https"), e))(n1e || {}),
    i1e = ((e) => (
      (e.MD5 = "md5"),
      (e.CRC32 = "crc32"),
      (e.CRC32C = "crc32c"),
      (e.SHA1 = "sha1"),
      (e.SHA256 = "sha256"),
      e
    ))(i1e || {}),
    Psr = Tj((e) => {
      let t = [];
      return (
        e.sha256 !== void 0 &&
          t.push({
            algorithmId: () => "sha256",
            checksumConstructor: () => e.sha256,
          }),
        e.md5 != null &&
          t.push({
            algorithmId: () => "md5",
            checksumConstructor: () => e.md5,
          }),
        {
          addChecksumAlgorithm(r) {
            t.push(r);
          },
          checksumAlgorithms() {
            return t;
          },
        }
      );
    }, "getChecksumConfiguration"),
    Rsr = Tj((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    Isr = Tj((e) => Psr(e), "getDefaultClientConfiguration"),
    xsr = Tj((e) => Rsr(e), "resolveDefaultRuntimeConfig"),
    o1e = ((e) => (
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER"), e
    ))(o1e || {}),
    Nsr = "__smithy_context",
    a1e = ((e) => (
      (e.PROFILE = "profile"),
      (e.SSO_SESSION = "sso-session"),
      (e.SERVICES = "services"),
      e
    ))(a1e || {}),
    s1e = ((e) => (
      (e.HTTP_0_9 = "http/0.9"),
      (e.HTTP_1_0 = "http/1.0"),
      (e.TDS_8_0 = "tds/8.0"),
      e
    ))(s1e || {});
});
var ln = g((yqn, p1e) => {
  c();
  var Aj = Object.defineProperty,
    ksr = Object.getOwnPropertyDescriptor,
    Dsr = Object.getOwnPropertyNames,
    Lsr = Object.prototype.hasOwnProperty,
    Yf = (e, t) => Aj(e, "name", { value: t, configurable: !0 }),
    Msr = (e, t) => {
      for (var r in t) Aj(e, r, { get: t[r], enumerable: !0 });
    },
    qsr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Dsr(t))
          !Lsr.call(e, i) &&
            i !== r &&
            Aj(e, i, {
              get: () => t[i],
              enumerable: !(n = ksr(t, i)) || n.enumerable,
            });
      return e;
    },
    jsr = (e) => qsr(Aj({}, "__esModule", { value: !0 }), e),
    u1e = {};
  Msr(u1e, {
    Field: () => Usr,
    Fields: () => Hsr,
    HttpRequest: () => Gsr,
    HttpResponse: () => Vsr,
    IHttpRequest: () => l1e.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => Fsr,
    isValidHostname: () => f1e,
    resolveHttpHandlerRuntimeConfig: () => Bsr,
  });
  p1e.exports = jsr(u1e);
  var Fsr = Yf(
      (e) => ({
        setHttpHandler(t) {
          e.httpHandler = t;
        },
        httpHandler() {
          return e.httpHandler;
        },
        updateHttpClientConfig(t, r) {
          e.httpHandler?.updateHttpClientConfig(t, r);
        },
        httpHandlerConfigs() {
          return e.httpHandler.httpHandlerConfigs();
        },
      }),
      "getHttpHandlerExtensionConfiguration",
    ),
    Bsr = Yf(
      (e) => ({ httpHandler: e.httpHandler() }),
      "resolveHttpHandlerRuntimeConfig",
    ),
    l1e = Ul(),
    Usr = class {
      static {
        Yf(this, "Field");
      }
      constructor({
        name: e,
        kind: t = l1e.FieldPosition.HEADER,
        values: r = [],
      }) {
        (this.name = e), (this.kind = t), (this.values = r);
      }
      add(e) {
        this.values.push(e);
      }
      set(e) {
        this.values = e;
      }
      remove(e) {
        this.values = this.values.filter((t) => t !== e);
      }
      toString() {
        return this.values
          .map((e) => (e.includes(",") || e.includes(" ") ? `"${e}"` : e))
          .join(", ");
      }
      get() {
        return this.values;
      }
    },
    Hsr = class {
      constructor({ fields: e = [], encoding: t = "utf-8" }) {
        (this.entries = {}),
          e.forEach(this.setField.bind(this)),
          (this.encoding = t);
      }
      static {
        Yf(this, "Fields");
      }
      setField(e) {
        this.entries[e.name.toLowerCase()] = e;
      }
      getField(e) {
        return this.entries[e.toLowerCase()];
      }
      removeField(e) {
        delete this.entries[e.toLowerCase()];
      }
      getByType(e) {
        return Object.values(this.entries).filter((t) => t.kind === e);
      }
    },
    Gsr = class nY {
      static {
        Yf(this, "HttpRequest");
      }
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new nY({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = d1e(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return nY.clone(this);
      }
    };
  function d1e(e) {
    return Object.keys(e).reduce((t, r) => {
      let n = e[r];
      return { ...t, [r]: Array.isArray(n) ? [...n] : n };
    }, {});
  }
  Yf(d1e, "cloneQuery");
  var Vsr = class {
    static {
      Yf(this, "HttpResponse");
    }
    constructor(e) {
      (this.statusCode = e.statusCode),
        (this.reason = e.reason),
        (this.headers = e.headers || {}),
        (this.body = e.body);
    }
    static isInstance(e) {
      if (!e) return !1;
      let t = e;
      return typeof t.statusCode == "number" && typeof t.headers == "object";
    }
  };
  function f1e(e) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e);
  }
  Yf(f1e, "isValidHostname");
});
var uO = g((Cqn, y1e) => {
  "use strict";
  c();
  var Rj = Object.defineProperty,
    $sr = Object.getOwnPropertyDescriptor,
    zsr = Object.getOwnPropertyNames,
    Ksr = Object.prototype.hasOwnProperty,
    Pj = (e, t) => Rj(e, "name", { value: t, configurable: !0 }),
    Wsr = (e, t) => {
      for (var r in t) Rj(e, r, { get: t[r], enumerable: !0 });
    },
    Qsr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of zsr(t))
          !Ksr.call(e, i) &&
            i !== r &&
            Rj(e, i, {
              get: () => t[i],
              enumerable: !(n = $sr(t, i)) || n.enumerable,
            });
      return e;
    },
    Ysr = (e) => Qsr(Rj({}, "__esModule", { value: !0 }), e),
    m1e = {};
  Wsr(m1e, {
    getHostHeaderPlugin: () => Jsr,
    hostHeaderMiddleware: () => g1e,
    hostHeaderMiddlewareOptions: () => v1e,
    resolveHostHeaderConfig: () => h1e,
  });
  y1e.exports = Ysr(m1e);
  var Xsr = ln();
  function h1e(e) {
    return e;
  }
  Pj(h1e, "resolveHostHeaderConfig");
  var g1e = Pj(
      (e) => (t) => async (r) => {
        if (!Xsr.HttpRequest.isInstance(r.request)) return t(r);
        let { request: n } = r,
          { handlerProtocol: i = "" } = e.requestHandler.metadata || {};
        if (i.indexOf("h2") >= 0 && !n.headers[":authority"])
          delete n.headers.host,
            (n.headers[":authority"] =
              n.hostname + (n.port ? ":" + n.port : ""));
        else if (!n.headers.host) {
          let o = n.hostname;
          n.port != null && (o += `:${n.port}`), (n.headers.host = o);
        }
        return t(r);
      },
      "hostHeaderMiddleware",
    ),
    v1e = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: !0,
    },
    Jsr = Pj(
      (e) => ({
        applyToStack: Pj((t) => {
          t.add(g1e(e), v1e);
        }, "applyToStack"),
      }),
      "getHostHeaderPlugin",
    );
});
var lO = g((Oqn, S1e) => {
  "use strict";
  c();
  var Ij = Object.defineProperty,
    Zsr = Object.getOwnPropertyDescriptor,
    ecr = Object.getOwnPropertyNames,
    tcr = Object.prototype.hasOwnProperty,
    iY = (e, t) => Ij(e, "name", { value: t, configurable: !0 }),
    rcr = (e, t) => {
      for (var r in t) Ij(e, r, { get: t[r], enumerable: !0 });
    },
    ncr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of ecr(t))
          !tcr.call(e, i) &&
            i !== r &&
            Ij(e, i, {
              get: () => t[i],
              enumerable: !(n = Zsr(t, i)) || n.enumerable,
            });
      return e;
    },
    icr = (e) => ncr(Ij({}, "__esModule", { value: !0 }), e),
    _1e = {};
  rcr(_1e, {
    getLoggerPlugin: () => ocr,
    loggerMiddleware: () => E1e,
    loggerMiddlewareOptions: () => b1e,
  });
  S1e.exports = icr(_1e);
  var E1e = iY(
      () => (e, t) => async (r) => {
        try {
          let n = await e(r),
            {
              clientName: i,
              commandName: o,
              logger: a,
              dynamoDbDocumentClientOptions: s = {},
            } = t,
            {
              overrideInputFilterSensitiveLog: u,
              overrideOutputFilterSensitiveLog: l,
            } = s,
            d = u ?? t.inputFilterSensitiveLog,
            f = l ?? t.outputFilterSensitiveLog,
            { $metadata: m, ...h } = n.output;
          return (
            a?.info?.({
              clientName: i,
              commandName: o,
              input: d(r.input),
              output: f(h),
              metadata: m,
            }),
            n
          );
        } catch (n) {
          let {
              clientName: i,
              commandName: o,
              logger: a,
              dynamoDbDocumentClientOptions: s = {},
            } = t,
            { overrideInputFilterSensitiveLog: u } = s,
            l = u ?? t.inputFilterSensitiveLog;
          throw (
            (a?.error?.({
              clientName: i,
              commandName: o,
              input: l(r.input),
              error: n,
              metadata: n.$metadata,
            }),
            n)
          );
        }
      },
      "loggerMiddleware",
    ),
    b1e = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: !0,
    },
    ocr = iY(
      (e) => ({
        applyToStack: iY((t) => {
          t.add(E1e(), b1e);
        }, "applyToStack"),
      }),
      "getLoggerPlugin",
    );
});
var dO = g((Aqn, T1e) => {
  "use strict";
  c();
  var Nj = Object.defineProperty,
    acr = Object.getOwnPropertyDescriptor,
    scr = Object.getOwnPropertyNames,
    ccr = Object.prototype.hasOwnProperty,
    xj = (e, t) => Nj(e, "name", { value: t, configurable: !0 }),
    ucr = (e, t) => {
      for (var r in t) Nj(e, r, { get: t[r], enumerable: !0 });
    },
    lcr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of scr(t))
          !ccr.call(e, i) &&
            i !== r &&
            Nj(e, i, {
              get: () => t[i],
              enumerable: !(n = acr(t, i)) || n.enumerable,
            });
      return e;
    },
    dcr = (e) => lcr(Nj({}, "__esModule", { value: !0 }), e),
    C1e = {};
  ucr(C1e, {
    addRecursionDetectionMiddlewareOptions: () => O1e,
    getRecursionDetectionPlugin: () => hcr,
    recursionDetectionMiddleware: () => w1e,
  });
  T1e.exports = dcr(C1e);
  var fcr = ln(),
    oY = "X-Amzn-Trace-Id",
    pcr = "AWS_LAMBDA_FUNCTION_NAME",
    mcr = "_X_AMZN_TRACE_ID",
    w1e = xj(
      (e) => (t) => async (r) => {
        let { request: n } = r;
        if (!fcr.HttpRequest.isInstance(n) || e.runtime !== "node") return t(r);
        let i =
          Object.keys(n.headers ?? {}).find(
            (u) => u.toLowerCase() === oY.toLowerCase(),
          ) ?? oY;
        if (n.headers.hasOwnProperty(i)) return t(r);
        let o = process.env[pcr],
          a = process.env[mcr],
          s = xj((u) => typeof u == "string" && u.length > 0, "nonEmptyString");
        return s(o) && s(a) && (n.headers[oY] = a), t({ ...r, request: n });
      },
      "recursionDetectionMiddleware",
    ),
    O1e = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: !0,
      priority: "low",
    },
    hcr = xj(
      (e) => ({
        applyToStack: xj((t) => {
          t.add(w1e(e), O1e);
        }, "applyToStack"),
      }),
      "getRecursionDetectionPlugin",
    );
});
var Xf = g((Rqn, L1e) => {
  c();
  var kj = Object.defineProperty,
    gcr = Object.getOwnPropertyDescriptor,
    vcr = Object.getOwnPropertyNames,
    ycr = Object.prototype.hasOwnProperty,
    Dj = (e, t) => kj(e, "name", { value: t, configurable: !0 }),
    _cr = (e, t) => {
      for (var r in t) kj(e, r, { get: t[r], enumerable: !0 });
    },
    Ecr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of vcr(t))
          !ycr.call(e, i) &&
            i !== r &&
            kj(e, i, {
              get: () => t[i],
              enumerable: !(n = gcr(t, i)) || n.enumerable,
            });
      return e;
    },
    bcr = (e) => Ecr(kj({}, "__esModule", { value: !0 }), e),
    A1e = {};
  _cr(A1e, {
    AlgorithmId: () => x1e,
    EndpointURLScheme: () => I1e,
    FieldPosition: () => N1e,
    HttpApiKeyAuthLocation: () => R1e,
    HttpAuthLocation: () => P1e,
    IniSectionType: () => k1e,
    RequestHandlerProtocol: () => D1e,
    SMITHY_CONTEXT_KEY: () => Tcr,
    getDefaultClientConfiguration: () => wcr,
    resolveDefaultRuntimeConfig: () => Ocr,
  });
  L1e.exports = bcr(A1e);
  var P1e = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(P1e || {}),
    R1e = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(R1e || {}),
    I1e = ((e) => ((e.HTTP = "http"), (e.HTTPS = "https"), e))(I1e || {}),
    x1e = ((e) => (
      (e.MD5 = "md5"),
      (e.CRC32 = "crc32"),
      (e.CRC32C = "crc32c"),
      (e.SHA1 = "sha1"),
      (e.SHA256 = "sha256"),
      e
    ))(x1e || {}),
    Scr = Dj((e) => {
      let t = [];
      return (
        e.sha256 !== void 0 &&
          t.push({
            algorithmId: () => "sha256",
            checksumConstructor: () => e.sha256,
          }),
        e.md5 != null &&
          t.push({
            algorithmId: () => "md5",
            checksumConstructor: () => e.md5,
          }),
        {
          addChecksumAlgorithm(r) {
            t.push(r);
          },
          checksumAlgorithms() {
            return t;
          },
        }
      );
    }, "getChecksumConfiguration"),
    Ccr = Dj((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    wcr = Dj((e) => Scr(e), "getDefaultClientConfiguration"),
    Ocr = Dj((e) => Ccr(e), "resolveDefaultRuntimeConfig"),
    N1e = ((e) => (
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER"), e
    ))(N1e || {}),
    Tcr = "__smithy_context",
    k1e = ((e) => (
      (e.PROFILE = "profile"),
      (e.SSO_SESSION = "sso-session"),
      (e.SERVICES = "services"),
      e
    ))(k1e || {}),
    D1e = ((e) => (
      (e.HTTP_0_9 = "http/0.9"),
      (e.HTTP_1_0 = "http/1.0"),
      (e.TDS_8_0 = "tds/8.0"),
      e
    ))(D1e || {});
});
var ns = g((xqn, B1e) => {
  c();
  var Lj = Object.defineProperty,
    Acr = Object.getOwnPropertyDescriptor,
    Pcr = Object.getOwnPropertyNames,
    Rcr = Object.prototype.hasOwnProperty,
    Jf = (e, t) => Lj(e, "name", { value: t, configurable: !0 }),
    Icr = (e, t) => {
      for (var r in t) Lj(e, r, { get: t[r], enumerable: !0 });
    },
    xcr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Pcr(t))
          !Rcr.call(e, i) &&
            i !== r &&
            Lj(e, i, {
              get: () => t[i],
              enumerable: !(n = Acr(t, i)) || n.enumerable,
            });
      return e;
    },
    Ncr = (e) => xcr(Lj({}, "__esModule", { value: !0 }), e),
    M1e = {};
  Icr(M1e, {
    Field: () => Lcr,
    Fields: () => Mcr,
    HttpRequest: () => qcr,
    HttpResponse: () => jcr,
    IHttpRequest: () => q1e.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => kcr,
    isValidHostname: () => F1e,
    resolveHttpHandlerRuntimeConfig: () => Dcr,
  });
  B1e.exports = Ncr(M1e);
  var kcr = Jf(
      (e) => ({
        setHttpHandler(t) {
          e.httpHandler = t;
        },
        httpHandler() {
          return e.httpHandler;
        },
        updateHttpClientConfig(t, r) {
          e.httpHandler?.updateHttpClientConfig(t, r);
        },
        httpHandlerConfigs() {
          return e.httpHandler.httpHandlerConfigs();
        },
      }),
      "getHttpHandlerExtensionConfiguration",
    ),
    Dcr = Jf(
      (e) => ({ httpHandler: e.httpHandler() }),
      "resolveHttpHandlerRuntimeConfig",
    ),
    q1e = Xf(),
    Lcr = class {
      static {
        Jf(this, "Field");
      }
      constructor({
        name: e,
        kind: t = q1e.FieldPosition.HEADER,
        values: r = [],
      }) {
        (this.name = e), (this.kind = t), (this.values = r);
      }
      add(e) {
        this.values.push(e);
      }
      set(e) {
        this.values = e;
      }
      remove(e) {
        this.values = this.values.filter((t) => t !== e);
      }
      toString() {
        return this.values
          .map((e) => (e.includes(",") || e.includes(" ") ? `"${e}"` : e))
          .join(", ");
      }
      get() {
        return this.values;
      }
    },
    Mcr = class {
      constructor({ fields: e = [], encoding: t = "utf-8" }) {
        (this.entries = {}),
          e.forEach(this.setField.bind(this)),
          (this.encoding = t);
      }
      static {
        Jf(this, "Fields");
      }
      setField(e) {
        this.entries[e.name.toLowerCase()] = e;
      }
      getField(e) {
        return this.entries[e.toLowerCase()];
      }
      removeField(e) {
        delete this.entries[e.toLowerCase()];
      }
      getByType(e) {
        return Object.values(this.entries).filter((t) => t.kind === e);
      }
    },
    qcr = class aY {
      static {
        Jf(this, "HttpRequest");
      }
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new aY({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = j1e(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return aY.clone(this);
      }
    };
  function j1e(e) {
    return Object.keys(e).reduce((t, r) => {
      let n = e[r];
      return { ...t, [r]: Array.isArray(n) ? [...n] : n };
    }, {});
  }
  Jf(j1e, "cloneQuery");
  var jcr = class {
    static {
      Jf(this, "HttpResponse");
    }
    constructor(e) {
      (this.statusCode = e.statusCode),
        (this.reason = e.reason),
        (this.headers = e.headers || {}),
        (this.body = e.body);
    }
    static isInstance(e) {
      if (!e) return !1;
      let t = e;
      return typeof t.statusCode == "number" && typeof t.headers == "object";
    }
  };
  function F1e(e) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e);
  }
  Jf(F1e, "isValidHostname");
});
var $1e = g((Mqn, V1e) => {
  c();
  var Mj = Object.defineProperty,
    Fcr = Object.getOwnPropertyDescriptor,
    Bcr = Object.getOwnPropertyNames,
    Ucr = Object.prototype.hasOwnProperty,
    is = (e, t) => Mj(e, "name", { value: t, configurable: !0 }),
    Hcr = (e, t) => {
      for (var r in t) Mj(e, r, { get: t[r], enumerable: !0 });
    },
    Gcr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Bcr(t))
          !Ucr.call(e, i) &&
            i !== r &&
            Mj(e, i, {
              get: () => t[i],
              enumerable: !(n = Fcr(t, i)) || n.enumerable,
            });
      return e;
    },
    Vcr = (e) => Gcr(Mj({}, "__esModule", { value: !0 }), e),
    G1e = {};
  Hcr(G1e, { constructStack: () => sY });
  V1e.exports = Vcr(G1e);
  var xh = is((e, t) => {
      let r = [];
      if ((e && r.push(e), t)) for (let n of t) r.push(n);
      return r;
    }, "getAllAliases"),
    Zf = is(
      (e, t) =>
        `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`,
      "getMiddlewareNameWithAliases",
    ),
    sY = is(() => {
      let e = [],
        t = [],
        r = !1,
        n = new Set(),
        i = is(
          (f) =>
            f.sort(
              (m, h) =>
                U1e[h.step] - U1e[m.step] ||
                H1e[h.priority || "normal"] - H1e[m.priority || "normal"],
            ),
          "sort",
        ),
        o = is((f) => {
          let m = !1,
            h = is((y) => {
              let _ = xh(y.name, y.aliases);
              if (_.includes(f)) {
                m = !0;
                for (let E of _) n.delete(E);
                return !1;
              }
              return !0;
            }, "filterCb");
          return (e = e.filter(h)), (t = t.filter(h)), m;
        }, "removeByName"),
        a = is((f) => {
          let m = !1,
            h = is((y) => {
              if (y.middleware === f) {
                m = !0;
                for (let _ of xh(y.name, y.aliases)) n.delete(_);
                return !1;
              }
              return !0;
            }, "filterCb");
          return (e = e.filter(h)), (t = t.filter(h)), m;
        }, "removeByReference"),
        s = is(
          (f) => (
            e.forEach((m) => {
              f.add(m.middleware, { ...m });
            }),
            t.forEach((m) => {
              f.addRelativeTo(m.middleware, { ...m });
            }),
            f.identifyOnResolve?.(d.identifyOnResolve()),
            f
          ),
          "cloneTo",
        ),
        u = is((f) => {
          let m = [];
          return (
            f.before.forEach((h) => {
              h.before.length === 0 && h.after.length === 0
                ? m.push(h)
                : m.push(...u(h));
            }),
            m.push(f),
            f.after.reverse().forEach((h) => {
              h.before.length === 0 && h.after.length === 0
                ? m.push(h)
                : m.push(...u(h));
            }),
            m
          );
        }, "expandRelativeMiddlewareList"),
        l = is((f = !1) => {
          let m = [],
            h = [],
            y = {};
          return (
            e.forEach((E) => {
              let b = { ...E, before: [], after: [] };
              for (let O of xh(b.name, b.aliases)) y[O] = b;
              m.push(b);
            }),
            t.forEach((E) => {
              let b = { ...E, before: [], after: [] };
              for (let O of xh(b.name, b.aliases)) y[O] = b;
              h.push(b);
            }),
            h.forEach((E) => {
              if (E.toMiddleware) {
                let b = y[E.toMiddleware];
                if (b === void 0) {
                  if (f) return;
                  throw new Error(
                    `${E.toMiddleware} is not found when adding ${Zf(E.name, E.aliases)} middleware ${E.relation} ${E.toMiddleware}`,
                  );
                }
                E.relation === "after" && b.after.push(E),
                  E.relation === "before" && b.before.push(E);
              }
            }),
            i(m)
              .map(u)
              .reduce((E, b) => (E.push(...b), E), [])
          );
        }, "getMiddlewareList"),
        d = {
          add: (f, m = {}) => {
            let { name: h, override: y, aliases: _ } = m,
              E = {
                step: "initialize",
                priority: "normal",
                middleware: f,
                ...m,
              },
              b = xh(h, _);
            if (b.length > 0) {
              if (b.some((O) => n.has(O))) {
                if (!y)
                  throw new Error(`Duplicate middleware name '${Zf(h, _)}'`);
                for (let O of b) {
                  let C = e.findIndex(
                    (k) => k.name === O || k.aliases?.some((H) => H === O),
                  );
                  if (C === -1) continue;
                  let P = e[C];
                  if (P.step !== E.step || E.priority !== P.priority)
                    throw new Error(
                      `"${Zf(P.name, P.aliases)}" middleware with ${P.priority} priority in ${P.step} step cannot be overridden by "${Zf(h, _)}" middleware with ${E.priority} priority in ${E.step} step.`,
                    );
                  e.splice(C, 1);
                }
              }
              for (let O of b) n.add(O);
            }
            e.push(E);
          },
          addRelativeTo: (f, m) => {
            let { name: h, override: y, aliases: _ } = m,
              E = { middleware: f, ...m },
              b = xh(h, _);
            if (b.length > 0) {
              if (b.some((O) => n.has(O))) {
                if (!y)
                  throw new Error(`Duplicate middleware name '${Zf(h, _)}'`);
                for (let O of b) {
                  let C = t.findIndex(
                    (k) => k.name === O || k.aliases?.some((H) => H === O),
                  );
                  if (C === -1) continue;
                  let P = t[C];
                  if (
                    P.toMiddleware !== E.toMiddleware ||
                    P.relation !== E.relation
                  )
                    throw new Error(
                      `"${Zf(P.name, P.aliases)}" middleware ${P.relation} "${P.toMiddleware}" middleware cannot be overridden by "${Zf(h, _)}" middleware ${E.relation} "${E.toMiddleware}" middleware.`,
                    );
                  t.splice(C, 1);
                }
              }
              for (let O of b) n.add(O);
            }
            t.push(E);
          },
          clone: () => s(sY()),
          use: (f) => {
            f.applyToStack(d);
          },
          remove: (f) => (typeof f == "string" ? o(f) : a(f)),
          removeByTag: (f) => {
            let m = !1,
              h = is((y) => {
                let { tags: _, name: E, aliases: b } = y;
                if (_ && _.includes(f)) {
                  let O = xh(E, b);
                  for (let C of O) n.delete(C);
                  return (m = !0), !1;
                }
                return !0;
              }, "filterCb");
            return (e = e.filter(h)), (t = t.filter(h)), m;
          },
          concat: (f) => {
            let m = s(sY());
            return (
              m.use(f),
              m.identifyOnResolve(
                r || m.identifyOnResolve() || (f.identifyOnResolve?.() ?? !1),
              ),
              m
            );
          },
          applyToStack: s,
          identify: () =>
            l(!0).map((f) => {
              let m = f.step ?? f.relation + " " + f.toMiddleware;
              return Zf(f.name, f.aliases) + " - " + m;
            }),
          identifyOnResolve(f) {
            return typeof f == "boolean" && (r = f), r;
          },
          resolve: (f, m) => {
            for (let h of l()
              .map((y) => y.middleware)
              .reverse())
              f = h(f, m);
            return r && console.log(d.identify()), f;
          },
        };
      return d;
    }, "constructStack"),
    U1e = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1,
    },
    H1e = { high: 3, normal: 2, low: 1 };
});
var z1e = g((qj) => {
  "use strict";
  c();
  Object.defineProperty(qj, "__esModule", { value: !0 });
  qj.fromBase64 = void 0;
  var $cr = Hi(),
    zcr = /^[A-Za-z0-9+/]*={0,2}$/,
    Kcr = (e) => {
      if ((e.length * 3) % 4 !== 0)
        throw new TypeError("Incorrect padding on base64 string.");
      if (!zcr.exec(e)) throw new TypeError("Invalid base64 string.");
      let t = (0, $cr.fromString)(e, "base64");
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    };
  qj.fromBase64 = Kcr;
});
var K1e = g((jj) => {
  "use strict";
  c();
  Object.defineProperty(jj, "__esModule", { value: !0 });
  jj.toBase64 = void 0;
  var Wcr = Hi(),
    Qcr = Fe(),
    Ycr = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = (0, Qcr.fromUtf8)(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.",
        );
      return (0, Wcr.fromArrayBuffer)(
        t.buffer,
        t.byteOffset,
        t.byteLength,
      ).toString("base64");
    };
  jj.toBase64 = Ycr;
});
var nE = g((Hqn, Fj) => {
  c();
  var W1e = Object.defineProperty,
    Xcr = Object.getOwnPropertyDescriptor,
    Jcr = Object.getOwnPropertyNames,
    Zcr = Object.prototype.hasOwnProperty,
    cY = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Jcr(t))
          !Zcr.call(e, i) &&
            i !== r &&
            W1e(e, i, {
              get: () => t[i],
              enumerable: !(n = Xcr(t, i)) || n.enumerable,
            });
      return e;
    },
    Q1e = (e, t, r) => (cY(e, t, "default"), r && cY(r, t, "default")),
    eur = (e) => cY(W1e({}, "__esModule", { value: !0 }), e),
    uY = {};
  Fj.exports = eur(uY);
  Q1e(uY, z1e(), Fj.exports);
  Q1e(uY, K1e(), Fj.exports);
});
var dY = g((Bj) => {
  "use strict";
  c();
  Object.defineProperty(Bj, "__esModule", { value: !0 });
  Bj.ChecksumStream = void 0;
  var tur = nE(),
    rur = G("stream"),
    lY = class extends rur.Duplex {
      constructor({
        expectedChecksum: t,
        checksum: r,
        source: n,
        checksumSourceLocation: i,
        base64Encoder: o,
      }) {
        var a, s;
        if ((super(), typeof n.pipe == "function")) this.source = n;
        else
          throw new Error(
            `@smithy/util-stream: unsupported source type ${(s = (a = n?.constructor) === null || a === void 0 ? void 0 : a.name) !== null && s !== void 0 ? s : n} in ChecksumStream.`,
          );
        (this.base64Encoder = o ?? tur.toBase64),
          (this.expectedChecksum = t),
          (this.checksum = r),
          (this.checksumSourceLocation = i),
          this.source.pipe(this);
      }
      _read(t) {}
      _write(t, r, n) {
        try {
          this.checksum.update(t), this.push(t);
        } catch (i) {
          return n(i);
        }
        return n();
      }
      async _final(t) {
        try {
          let r = await this.checksum.digest(),
            n = this.base64Encoder(r);
          if (this.expectedChecksum !== n)
            return t(
              new Error(
                `Checksum mismatch: expected "${this.expectedChecksum}" but received "${n}" in response header "${this.checksumSourceLocation}".`,
              ),
            );
        } catch (r) {
          return t(r);
        }
        return this.push(null), t();
      }
    };
  Bj.ChecksumStream = lY;
});
var ep = g((iE) => {
  "use strict";
  c();
  Object.defineProperty(iE, "__esModule", { value: !0 });
  iE.isBlob = iE.isReadableStream = void 0;
  var nur = (e) => {
    var t;
    return (
      typeof ReadableStream == "function" &&
      (((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) ===
        ReadableStream.name ||
        e instanceof ReadableStream)
    );
  };
  iE.isReadableStream = nur;
  var iur = (e) => {
    var t;
    return (
      typeof Blob == "function" &&
      (((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) ===
        Blob.name ||
        e instanceof Blob)
    );
  };
  iE.isBlob = iur;
});
var Y1e = g((Uj) => {
  "use strict";
  c();
  Object.defineProperty(Uj, "__esModule", { value: !0 });
  Uj.ChecksumStream = void 0;
  var our =
      typeof ReadableStream == "function" ? ReadableStream : function () {},
    fY = class extends our {};
  Uj.ChecksumStream = fY;
});
var X1e = g((Hj) => {
  "use strict";
  c();
  Object.defineProperty(Hj, "__esModule", { value: !0 });
  Hj.createChecksumStream = void 0;
  var aur = nE(),
    sur = ep(),
    cur = Y1e(),
    uur = ({
      expectedChecksum: e,
      checksum: t,
      source: r,
      checksumSourceLocation: n,
      base64Encoder: i,
    }) => {
      var o, a;
      if (!(0, sur.isReadableStream)(r))
        throw new Error(
          `@smithy/util-stream: unsupported source type ${(a = (o = r?.constructor) === null || o === void 0 ? void 0 : o.name) !== null && a !== void 0 ? a : r} in ChecksumStream.`,
        );
      let s = i ?? aur.toBase64;
      if (typeof TransformStream != "function")
        throw new Error(
          "@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.",
        );
      let u = new TransformStream({
        start() {},
        async transform(d, f) {
          t.update(d), f.enqueue(d);
        },
        async flush(d) {
          let f = await t.digest(),
            m = s(f);
          if (e !== m) {
            let h = new Error(
              `Checksum mismatch: expected "${e}" but received "${m}" in response header "${n}".`,
            );
            d.error(h);
          } else d.terminate();
        },
      });
      r.pipeThrough(u);
      let l = u.readable;
      return Object.setPrototypeOf(l, cur.ChecksumStream.prototype), l;
    };
  Hj.createChecksumStream = uur;
});
var J1e = g((Gj) => {
  "use strict";
  c();
  Object.defineProperty(Gj, "__esModule", { value: !0 });
  Gj.createChecksumStream = void 0;
  var lur = ep(),
    dur = dY(),
    fur = X1e();
  function pur(e) {
    return typeof ReadableStream == "function" &&
      (0, lur.isReadableStream)(e.source)
      ? (0, fur.createChecksumStream)(e)
      : new dur.ChecksumStream(e);
  }
  Gj.createChecksumStream = pur;
});
var mY = g((Vj) => {
  "use strict";
  c();
  Object.defineProperty(Vj, "__esModule", { value: !0 });
  Vj.ByteArrayCollector = void 0;
  var pY = class {
    constructor(t) {
      (this.allocByteArray = t), (this.byteLength = 0), (this.byteArrays = []);
    }
    push(t) {
      this.byteArrays.push(t), (this.byteLength += t.byteLength);
    }
    flush() {
      if (this.byteArrays.length === 1) {
        let n = this.byteArrays[0];
        return this.reset(), n;
      }
      let t = this.allocByteArray(this.byteLength),
        r = 0;
      for (let n = 0; n < this.byteArrays.length; ++n) {
        let i = this.byteArrays[n];
        t.set(i, r), (r += i.byteLength);
      }
      return this.reset(), t;
    }
    reset() {
      (this.byteArrays = []), (this.byteLength = 0);
    }
  };
  Vj.ByteArrayCollector = pY;
});
var rBe = g((qo) => {
  "use strict";
  c();
  Object.defineProperty(qo, "__esModule", { value: !0 });
  qo.modeOf =
    qo.sizeOf =
    qo.flush =
    qo.merge =
    qo.createBufferedReadable =
    qo.createBufferedReadableStream =
      void 0;
  var mur = mY();
  function Z1e(e, t, r) {
    let n = e.getReader(),
      i = !1,
      o = 0,
      a = ["", new mur.ByteArrayCollector((l) => new Uint8Array(l))],
      s = -1,
      u = async (l) => {
        let { value: d, done: f } = await n.read(),
          m = d;
        if (f) {
          if (s !== -1) {
            let h = $j(a, s);
            oE(h) > 0 && l.enqueue(h);
          }
          l.close();
        } else {
          let h = tBe(m, !1);
          if ((s !== h && (s >= 0 && l.enqueue($j(a, s)), (s = h)), s === -1)) {
            l.enqueue(m);
            return;
          }
          let y = oE(m);
          o += y;
          let _ = oE(a[s]);
          if (y >= t && _ === 0) l.enqueue(m);
          else {
            let E = eBe(a, s, m);
            !i &&
              o > t * 2 &&
              ((i = !0),
              r?.warn(
                `@smithy/util-stream - stream chunk size ${y} is below threshold of ${t}, automatically buffering.`,
              )),
              E >= t ? l.enqueue($j(a, s)) : await u(l);
          }
        }
      };
    return new ReadableStream({ pull: u });
  }
  qo.createBufferedReadableStream = Z1e;
  qo.createBufferedReadable = Z1e;
  function eBe(e, t, r) {
    switch (t) {
      case 0:
        return (e[0] += r), oE(e[0]);
      case 1:
      case 2:
        return e[t].push(r), oE(e[t]);
    }
  }
  qo.merge = eBe;
  function $j(e, t) {
    switch (t) {
      case 0:
        let r = e[0];
        return (e[0] = ""), r;
      case 1:
      case 2:
        return e[t].flush();
    }
    throw new Error(
      `@smithy/util-stream - invalid index ${t} given to flush()`,
    );
  }
  qo.flush = $j;
  function oE(e) {
    var t, r;
    return (r =
      (t = e?.byteLength) !== null && t !== void 0 ? t : e?.length) !== null &&
      r !== void 0
      ? r
      : 0;
  }
  qo.sizeOf = oE;
  function tBe(e, t = !0) {
    return t && typeof Buffer < "u" && e instanceof Buffer
      ? 2
      : e instanceof Uint8Array
        ? 1
        : typeof e == "string"
          ? 0
          : -1;
  }
  qo.modeOf = tBe;
});
var iBe = g((zj) => {
  "use strict";
  c();
  Object.defineProperty(zj, "__esModule", { value: !0 });
  zj.createBufferedReadable = void 0;
  var hur = G("node:stream"),
    nBe = mY(),
    Hl = rBe(),
    gur = ep();
  function vur(e, t, r) {
    if ((0, gur.isReadableStream)(e))
      return (0, Hl.createBufferedReadableStream)(e, t, r);
    let n = new hur.Readable({ read() {} }),
      i = !1,
      o = 0,
      a = [
        "",
        new nBe.ByteArrayCollector((u) => new Uint8Array(u)),
        new nBe.ByteArrayCollector((u) => Buffer.from(new Uint8Array(u))),
      ],
      s = -1;
    return (
      e.on("data", (u) => {
        let l = (0, Hl.modeOf)(u, !0);
        if (
          (s !== l && (s >= 0 && n.push((0, Hl.flush)(a, s)), (s = l)),
          s === -1)
        ) {
          n.push(u);
          return;
        }
        let d = (0, Hl.sizeOf)(u);
        o += d;
        let f = (0, Hl.sizeOf)(a[s]);
        if (d >= t && f === 0) n.push(u);
        else {
          let m = (0, Hl.merge)(a, s, u);
          !i &&
            o > t * 2 &&
            ((i = !0),
            r?.warn(
              `@smithy/util-stream - stream chunk size ${d} is below threshold of ${t}, automatically buffering.`,
            )),
            m >= t && n.push((0, Hl.flush)(a, s));
        }
      }),
      e.on("end", () => {
        if (s !== -1) {
          let u = (0, Hl.flush)(a, s);
          (0, Hl.sizeOf)(u) > 0 && n.push(u);
        }
        n.push(null);
      }),
      n
    );
  }
  zj.createBufferedReadable = vur;
});
var oBe = g((Kj) => {
  "use strict";
  c();
  Object.defineProperty(Kj, "__esModule", { value: !0 });
  Kj.getAwsChunkedEncodingStream = void 0;
  var yur = G("stream"),
    _ur = (e, t) => {
      let {
          base64Encoder: r,
          bodyLengthChecker: n,
          checksumAlgorithmFn: i,
          checksumLocationName: o,
          streamHasher: a,
        } = t,
        s = r !== void 0 && i !== void 0 && o !== void 0 && a !== void 0,
        u = s ? a(i, e) : void 0,
        l = new yur.Readable({ read: () => {} });
      return (
        e.on("data", (d) => {
          let f = n(d) || 0;
          l.push(`${f.toString(16)}\r
`),
            l.push(d),
            l.push(`\r
`);
        }),
        e.on("end", async () => {
          if (
            (l.push(`0\r
`),
            s)
          ) {
            let d = r(await u);
            l.push(`${o}:${d}\r
`),
              l.push(`\r
`);
          }
          l.push(null);
        }),
        l
      );
    };
  Kj.getAwsChunkedEncodingStream = _ur;
});
var aBe = g((Wj) => {
  "use strict";
  c();
  Object.defineProperty(Wj, "__esModule", { value: !0 });
  Wj.headStream = void 0;
  async function Eur(e, t) {
    var r;
    let n = 0,
      i = [],
      o = e.getReader(),
      a = !1;
    for (; !a; ) {
      let { done: l, value: d } = await o.read();
      if (
        (d &&
          (i.push(d),
          (n += (r = d?.byteLength) !== null && r !== void 0 ? r : 0)),
        n >= t)
      )
        break;
      a = l;
    }
    o.releaseLock();
    let s = new Uint8Array(Math.min(t, n)),
      u = 0;
    for (let l of i) {
      if (l.byteLength > s.byteLength - u) {
        s.set(l.subarray(0, s.byteLength - u), u);
        break;
      } else s.set(l, u);
      u += l.length;
    }
    return s;
  }
  Wj.headStream = Eur;
});
var sBe = g((Qj) => {
  "use strict";
  c();
  Object.defineProperty(Qj, "__esModule", { value: !0 });
  Qj.headStream = void 0;
  var bur = G("stream"),
    Sur = aBe(),
    Cur = ep(),
    wur = (e, t) =>
      (0, Cur.isReadableStream)(e)
        ? (0, Sur.headStream)(e, t)
        : new Promise((r, n) => {
            let i = new hY();
            (i.limit = t),
              e.pipe(i),
              e.on("error", (o) => {
                i.end(), n(o);
              }),
              i.on("error", n),
              i.on("finish", function () {
                let o = new Uint8Array(Buffer.concat(this.buffers));
                r(o);
              });
          });
  Qj.headStream = wur;
  var hY = class extends bur.Writable {
    constructor() {
      super(...arguments),
        (this.buffers = []),
        (this.limit = 1 / 0),
        (this.bytesBuffered = 0);
    }
    _write(t, r, n) {
      var i;
      if (
        (this.buffers.push(t),
        (this.bytesBuffered +=
          (i = t.byteLength) !== null && i !== void 0 ? i : 0),
        this.bytesBuffered >= this.limit)
      ) {
        let o = this.bytesBuffered - this.limit,
          a = this.buffers[this.buffers.length - 1];
        (this.buffers[this.buffers.length - 1] = a.subarray(
          0,
          a.byteLength - o,
        )),
          this.emit("finish");
      }
      n();
    }
  };
});
var vY = g((fjn, lBe) => {
  c();
  var Yj = Object.defineProperty,
    Our = Object.getOwnPropertyDescriptor,
    Tur = Object.getOwnPropertyNames,
    Aur = Object.prototype.hasOwnProperty,
    gY = (e, t) => Yj(e, "name", { value: t, configurable: !0 }),
    Pur = (e, t) => {
      for (var r in t) Yj(e, r, { get: t[r], enumerable: !0 });
    },
    Rur = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Tur(t))
          !Aur.call(e, i) &&
            i !== r &&
            Yj(e, i, {
              get: () => t[i],
              enumerable: !(n = Our(t, i)) || n.enumerable,
            });
      return e;
    },
    Iur = (e) => Rur(Yj({}, "__esModule", { value: !0 }), e),
    cBe = {};
  Pur(cBe, { escapeUri: () => uBe, escapeUriPath: () => Nur });
  lBe.exports = Iur(cBe);
  var uBe = gY(
      (e) => encodeURIComponent(e).replace(/[!'()*]/g, xur),
      "escapeUri",
    ),
    xur = gY(
      (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`,
      "hexEncode",
    ),
    Nur = gY((e) => e.split("/").map(uBe).join("/"), "escapeUriPath");
});
var _Y = g((mjn, pBe) => {
  c();
  var Xj = Object.defineProperty,
    kur = Object.getOwnPropertyDescriptor,
    Dur = Object.getOwnPropertyNames,
    Lur = Object.prototype.hasOwnProperty,
    Mur = (e, t) => Xj(e, "name", { value: t, configurable: !0 }),
    qur = (e, t) => {
      for (var r in t) Xj(e, r, { get: t[r], enumerable: !0 });
    },
    jur = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Dur(t))
          !Lur.call(e, i) &&
            i !== r &&
            Xj(e, i, {
              get: () => t[i],
              enumerable: !(n = kur(t, i)) || n.enumerable,
            });
      return e;
    },
    Fur = (e) => jur(Xj({}, "__esModule", { value: !0 }), e),
    dBe = {};
  qur(dBe, { buildQueryString: () => fBe });
  pBe.exports = Fur(dBe);
  var yY = vY();
  function fBe(e) {
    let t = [];
    for (let r of Object.keys(e).sort()) {
      let n = e[r];
      if (((r = (0, yY.escapeUri)(r)), Array.isArray(n)))
        for (let i = 0, o = n.length; i < o; i++)
          t.push(`${r}=${(0, yY.escapeUri)(n[i])}`);
      else {
        let i = r;
        (n || typeof n == "string") && (i += `=${(0, yY.escapeUri)(n)}`),
          t.push(i);
      }
    }
    return t.join("&");
  }
  Mur(fBe, "buildQueryString");
});
var RBe = g((gjn, PBe) => {
  c();
  var Bur = Object.create,
    fO = Object.defineProperty,
    Uur = Object.getOwnPropertyDescriptor,
    Hur = Object.getOwnPropertyNames,
    Gur = Object.getPrototypeOf,
    Vur = Object.prototype.hasOwnProperty,
    hr = (e, t) => fO(e, "name", { value: t, configurable: !0 }),
    $ur = (e, t) => {
      for (var r in t) fO(e, r, { get: t[r], enumerable: !0 });
    },
    yBe = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Hur(t))
          !Vur.call(e, i) &&
            i !== r &&
            fO(e, i, {
              get: () => t[i],
              enumerable: !(n = Uur(t, i)) || n.enumerable,
            });
      return e;
    },
    zur = (e, t, r) => (
      (r = e != null ? Bur(Gur(e)) : {}),
      yBe(
        t || !e || !e.__esModule
          ? fO(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    Kur = (e) => yBe(fO({}, "__esModule", { value: !0 }), e),
    _Be = {};
  $ur(_Be, {
    DEFAULT_REQUEST_TIMEOUT: () => OBe,
    NodeHttp2Handler: () => nlr,
    NodeHttpHandler: () => Zur,
    streamCollector: () => olr,
  });
  PBe.exports = Kur(_Be);
  var EBe = ns(),
    bBe = _Y(),
    EY = G("http"),
    bY = G("https"),
    Wur = ["ECONNRESET", "EPIPE", "ETIMEDOUT"],
    SBe = hr((e) => {
      let t = {};
      for (let r of Object.keys(e)) {
        let n = e[r];
        t[r] = Array.isArray(n) ? n.join(",") : n;
      }
      return t;
    }, "getTransformedHeaders"),
    jo = {
      setTimeout: (e, t) => setTimeout(e, t),
      clearTimeout: (e) => clearTimeout(e),
    },
    mBe = 1e3,
    Qur = hr((e, t, r = 0) => {
      if (!r) return -1;
      let n = hr((i) => {
        let o = jo.setTimeout(() => {
            e.destroy(),
              t(
                Object.assign(
                  new Error(
                    `Socket timed out without establishing a connection within ${r} ms`,
                  ),
                  { name: "TimeoutError" },
                ),
              );
          }, r - i),
          a = hr((s) => {
            s?.connecting
              ? s.on("connect", () => {
                  jo.clearTimeout(o);
                })
              : jo.clearTimeout(o);
          }, "doWithSocket");
        e.socket ? a(e.socket) : e.on("socket", a);
      }, "registerTimeout");
      return r < 2e3 ? (n(0), 0) : jo.setTimeout(n.bind(null, mBe), mBe);
    }, "setConnectionTimeout"),
    Yur = 3e3,
    Xur = hr((e, { keepAlive: t, keepAliveMsecs: r }, n = Yur) => {
      if (t !== !0) return -1;
      let i = hr(() => {
        e.socket
          ? e.socket.setKeepAlive(t, r || 0)
          : e.on("socket", (o) => {
              o.setKeepAlive(t, r || 0);
            });
      }, "registerListener");
      return n === 0 ? (i(), 0) : jo.setTimeout(i, n);
    }, "setSocketKeepAlive"),
    hBe = 3e3,
    Jur = hr((e, t, r = OBe) => {
      let n = hr((i) => {
        let o = r - i,
          a = hr(() => {
            e.destroy(),
              t(
                Object.assign(new Error(`Connection timed out after ${r} ms`), {
                  name: "TimeoutError",
                }),
              );
          }, "onTimeout");
        e.socket
          ? (e.socket.setTimeout(o, a),
            e.on("close", () => e.socket?.removeListener("timeout", a)))
          : e.setTimeout(o, a);
      }, "registerTimeout");
      return 0 < r && r < 6e3
        ? (n(0), 0)
        : jo.setTimeout(n.bind(null, r === 0 ? 0 : hBe), hBe);
    }, "setSocketTimeout"),
    CBe = G("stream"),
    gBe = 6e3;
  async function CY(e, t, r = gBe) {
    let n = t.headers ?? {},
      i = n.Expect || n.expect,
      o = -1,
      a = !0;
    i === "100-continue" &&
      (a = await Promise.race([
        new Promise((s) => {
          o = Number(jo.setTimeout(() => s(!0), Math.max(gBe, r)));
        }),
        new Promise((s) => {
          e.on("continue", () => {
            jo.clearTimeout(o), s(!0);
          }),
            e.on("response", () => {
              jo.clearTimeout(o), s(!1);
            }),
            e.on("error", () => {
              jo.clearTimeout(o), s(!1);
            });
        }),
      ])),
      a && wBe(e, t.body);
  }
  hr(CY, "writeRequestBody");
  function wBe(e, t) {
    if (t instanceof CBe.Readable) {
      t.pipe(e);
      return;
    }
    if (t) {
      if (Buffer.isBuffer(t) || typeof t == "string") {
        e.end(t);
        return;
      }
      let r = t;
      if (
        typeof r == "object" &&
        r.buffer &&
        typeof r.byteOffset == "number" &&
        typeof r.byteLength == "number"
      ) {
        e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength));
        return;
      }
      e.end(Buffer.from(t));
      return;
    }
    e.end();
  }
  hr(wBe, "writeBody");
  var OBe = 0,
    Zur = class SY {
      constructor(t) {
        (this.socketWarningTimestamp = 0),
          (this.metadata = { handlerProtocol: "http/1.1" }),
          (this.configProvider = new Promise((r, n) => {
            typeof t == "function"
              ? t()
                  .then((i) => {
                    r(this.resolveDefaultConfig(i));
                  })
                  .catch(n)
              : r(this.resolveDefaultConfig(t));
          }));
      }
      static {
        hr(this, "NodeHttpHandler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new SY(t);
      }
      static checkSocketUsage(t, r, n = console) {
        let { sockets: i, requests: o, maxSockets: a } = t;
        if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r)
          return r;
        if (i && o)
          for (let u in i) {
            let l = i[u]?.length ?? 0,
              d = o[u]?.length ?? 0;
            if (l >= a && d >= 2 * a)
              return (
                n?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${l} and ${d} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`),
                Date.now()
              );
          }
        return r;
      }
      resolveDefaultConfig(t) {
        let {
            requestTimeout: r,
            connectionTimeout: n,
            socketTimeout: i,
            socketAcquisitionWarningTimeout: o,
            httpAgent: a,
            httpsAgent: s,
          } = t || {},
          u = !0,
          l = 50;
        return {
          connectionTimeout: n,
          requestTimeout: r ?? i,
          socketAcquisitionWarningTimeout: o,
          httpAgent:
            a instanceof EY.Agent || typeof a?.destroy == "function"
              ? a
              : new EY.Agent({ keepAlive: u, maxSockets: l, ...a }),
          httpsAgent:
            s instanceof bY.Agent || typeof s?.destroy == "function"
              ? s
              : new bY.Agent({ keepAlive: u, maxSockets: l, ...s }),
          logger: console,
        };
      }
      destroy() {
        this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy();
      }
      async handle(t, { abortSignal: r } = {}) {
        return (
          this.config || (this.config = await this.configProvider),
          new Promise((n, i) => {
            let o,
              a = [],
              s = hr(async (C) => {
                await o, a.forEach(jo.clearTimeout), n(C);
              }, "resolve"),
              u = hr(async (C) => {
                await o, a.forEach(jo.clearTimeout), i(C);
              }, "reject");
            if (!this.config)
              throw new Error(
                "Node HTTP request handler config is not resolved",
              );
            if (r?.aborted) {
              let C = new Error("Request aborted");
              (C.name = "AbortError"), u(C);
              return;
            }
            let l = t.protocol === "https:",
              d = l ? this.config.httpsAgent : this.config.httpAgent;
            a.push(
              jo.setTimeout(
                () => {
                  this.socketWarningTimestamp = SY.checkSocketUsage(
                    d,
                    this.socketWarningTimestamp,
                    this.config.logger,
                  );
                },
                this.config.socketAcquisitionWarningTimeout ??
                  (this.config.requestTimeout ?? 2e3) +
                    (this.config.connectionTimeout ?? 1e3),
              ),
            );
            let f = (0, bBe.buildQueryString)(t.query || {}),
              m;
            if (t.username != null || t.password != null) {
              let C = t.username ?? "",
                P = t.password ?? "";
              m = `${C}:${P}`;
            }
            let h = t.path;
            f && (h += `?${f}`), t.fragment && (h += `#${t.fragment}`);
            let y = t.hostname ?? "";
            y[0] === "[" && y.endsWith("]")
              ? (y = t.hostname.slice(1, -1))
              : (y = t.hostname);
            let _ = {
                headers: t.headers,
                host: y,
                method: t.method,
                path: h,
                port: t.port,
                agent: d,
                auth: m,
              },
              b = (l ? bY.request : EY.request)(_, (C) => {
                let P = new EBe.HttpResponse({
                  statusCode: C.statusCode || -1,
                  reason: C.statusMessage,
                  headers: SBe(C.headers),
                  body: C,
                });
                s({ response: P });
              });
            if (
              (b.on("error", (C) => {
                Wur.includes(C.code)
                  ? u(Object.assign(C, { name: "TimeoutError" }))
                  : u(C);
              }),
              r)
            ) {
              let C = hr(() => {
                b.destroy();
                let P = new Error("Request aborted");
                (P.name = "AbortError"), u(P);
              }, "onAbort");
              if (typeof r.addEventListener == "function") {
                let P = r;
                P.addEventListener("abort", C, { once: !0 }),
                  b.once("close", () => P.removeEventListener("abort", C));
              } else r.onabort = C;
            }
            a.push(Qur(b, u, this.config.connectionTimeout)),
              a.push(Jur(b, u, this.config.requestTimeout));
            let O = _.agent;
            typeof O == "object" &&
              "keepAlive" in O &&
              a.push(
                Xur(b, {
                  keepAlive: O.keepAlive,
                  keepAliveMsecs: O.keepAliveMsecs,
                }),
              ),
              (o = CY(b, t, this.config.requestTimeout).catch(
                (C) => (a.forEach(jo.clearTimeout), i(C)),
              ));
          })
        );
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then((n) => ({
            ...n,
            [t]: r,
          })));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    },
    vBe = G("http2"),
    elr = zur(G("http2")),
    tlr = class {
      constructor(e) {
        (this.sessions = []), (this.sessions = e ?? []);
      }
      static {
        hr(this, "NodeHttp2ConnectionPool");
      }
      poll() {
        if (this.sessions.length > 0) return this.sessions.shift();
      }
      offerLast(e) {
        this.sessions.push(e);
      }
      contains(e) {
        return this.sessions.includes(e);
      }
      remove(e) {
        this.sessions = this.sessions.filter((t) => t !== e);
      }
      [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
      }
      destroy(e) {
        for (let t of this.sessions) t === e && (t.destroyed || t.destroy());
      }
    },
    rlr = class {
      constructor(e) {
        if (
          ((this.sessionCache = new Map()),
          (this.config = e),
          this.config.maxConcurrency && this.config.maxConcurrency <= 0)
        )
          throw new RangeError("maxConcurrency must be greater than zero.");
      }
      static {
        hr(this, "NodeHttp2ConnectionManager");
      }
      lease(e, t) {
        let r = this.getUrlString(e),
          n = this.sessionCache.get(r);
        if (n) {
          let s = n.poll();
          if (s && !this.config.disableConcurrency) return s;
        }
        let i = elr.default.connect(r);
        this.config.maxConcurrency &&
          i.settings(
            { maxConcurrentStreams: this.config.maxConcurrency },
            (s) => {
              if (s)
                throw new Error(
                  "Fail to set maxConcurrentStreams to " +
                    this.config.maxConcurrency +
                    "when creating new session for " +
                    e.destination.toString(),
                );
            },
          ),
          i.unref();
        let o = hr(() => {
          i.destroy(), this.deleteSession(r, i);
        }, "destroySessionCb");
        i.on("goaway", o),
          i.on("error", o),
          i.on("frameError", o),
          i.on("close", () => this.deleteSession(r, i)),
          t.requestTimeout && i.setTimeout(t.requestTimeout, o);
        let a = this.sessionCache.get(r) || new tlr();
        return a.offerLast(i), this.sessionCache.set(r, a), i;
      }
      deleteSession(e, t) {
        let r = this.sessionCache.get(e);
        r && r.contains(t) && (r.remove(t), this.sessionCache.set(e, r));
      }
      release(e, t) {
        let r = this.getUrlString(e);
        this.sessionCache.get(r)?.offerLast(t);
      }
      destroy() {
        for (let [e, t] of this.sessionCache) {
          for (let r of t) r.destroyed || r.destroy(), t.remove(r);
          this.sessionCache.delete(e);
        }
      }
      setMaxConcurrentStreams(e) {
        if (e && e <= 0)
          throw new RangeError(
            "maxConcurrentStreams must be greater than zero.",
          );
        this.config.maxConcurrency = e;
      }
      setDisableConcurrentStreams(e) {
        this.config.disableConcurrency = e;
      }
      getUrlString(e) {
        return e.destination.toString();
      }
    },
    nlr = class TBe {
      constructor(t) {
        (this.metadata = { handlerProtocol: "h2" }),
          (this.connectionManager = new rlr({})),
          (this.configProvider = new Promise((r, n) => {
            typeof t == "function"
              ? t()
                  .then((i) => {
                    r(i || {});
                  })
                  .catch(n)
              : r(t || {});
          }));
      }
      static {
        hr(this, "NodeHttp2Handler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new TBe(t);
      }
      destroy() {
        this.connectionManager.destroy();
      }
      async handle(t, { abortSignal: r } = {}) {
        this.config ||
          ((this.config = await this.configProvider),
          this.connectionManager.setDisableConcurrentStreams(
            this.config.disableConcurrentStreams || !1,
          ),
          this.config.maxConcurrentStreams &&
            this.connectionManager.setMaxConcurrentStreams(
              this.config.maxConcurrentStreams,
            ));
        let { requestTimeout: n, disableConcurrentStreams: i } = this.config;
        return new Promise((o, a) => {
          let s = !1,
            u,
            l = hr(async (L) => {
              await u, o(L);
            }, "resolve"),
            d = hr(async (L) => {
              await u, a(L);
            }, "reject");
          if (r?.aborted) {
            s = !0;
            let L = new Error("Request aborted");
            (L.name = "AbortError"), d(L);
            return;
          }
          let { hostname: f, method: m, port: h, protocol: y, query: _ } = t,
            E = "";
          if (t.username != null || t.password != null) {
            let L = t.username ?? "",
              Z = t.password ?? "";
            E = `${L}:${Z}@`;
          }
          let b = `${y}//${E}${f}${h ? `:${h}` : ""}`,
            O = { destination: new URL(b) },
            C = this.connectionManager.lease(O, {
              requestTimeout: this.config?.sessionTimeout,
              disableConcurrentStreams: i || !1,
            }),
            P = hr((L) => {
              i && this.destroySession(C), (s = !0), d(L);
            }, "rejectWithDestroy"),
            k = (0, bBe.buildQueryString)(_ || {}),
            H = t.path;
          k && (H += `?${k}`), t.fragment && (H += `#${t.fragment}`);
          let B = C.request({
            ...t.headers,
            [vBe.constants.HTTP2_HEADER_PATH]: H,
            [vBe.constants.HTTP2_HEADER_METHOD]: m,
          });
          if (
            (C.ref(),
            B.on("response", (L) => {
              let Z = new EBe.HttpResponse({
                statusCode: L[":status"] || -1,
                headers: SBe(L),
                body: B,
              });
              (s = !0),
                l({ response: Z }),
                i && (C.close(), this.connectionManager.deleteSession(b, C));
            }),
            n &&
              B.setTimeout(n, () => {
                B.close();
                let L = new Error(
                  `Stream timed out because of no activity for ${n} ms`,
                );
                (L.name = "TimeoutError"), P(L);
              }),
            r)
          ) {
            let L = hr(() => {
              B.close();
              let Z = new Error("Request aborted");
              (Z.name = "AbortError"), P(Z);
            }, "onAbort");
            if (typeof r.addEventListener == "function") {
              let Z = r;
              Z.addEventListener("abort", L, { once: !0 }),
                B.once("close", () => Z.removeEventListener("abort", L));
            } else r.onabort = L;
          }
          B.on("frameError", (L, Z, ft) => {
            P(
              new Error(
                `Frame type id ${L} in stream id ${ft} has failed with code ${Z}.`,
              ),
            );
          }),
            B.on("error", P),
            B.on("aborted", () => {
              P(
                new Error(
                  `HTTP/2 stream is abnormally aborted in mid-communication with result code ${B.rstCode}.`,
                ),
              );
            }),
            B.on("close", () => {
              C.unref(),
                i && C.destroy(),
                s ||
                  P(
                    new Error(
                      "Unexpected error: http2 request did not get a response",
                    ),
                  );
            }),
            (u = CY(B, t, n));
        });
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then((n) => ({
            ...n,
            [t]: r,
          })));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
      destroySession(t) {
        t.destroyed || t.destroy();
      }
    },
    ilr = class extends CBe.Writable {
      constructor() {
        super(...arguments), (this.bufferedBytes = []);
      }
      static {
        hr(this, "Collector");
      }
      _write(e, t, r) {
        this.bufferedBytes.push(e), r();
      }
    },
    olr = hr(
      (e) =>
        alr(e)
          ? ABe(e)
          : new Promise((t, r) => {
              let n = new ilr();
              e.pipe(n),
                e.on("error", (i) => {
                  n.end(), r(i);
                }),
                n.on("error", r),
                n.on("finish", function () {
                  let i = new Uint8Array(Buffer.concat(this.bufferedBytes));
                  t(i);
                });
            }),
      "streamCollector",
    ),
    alr = hr(
      (e) => typeof ReadableStream == "function" && e instanceof ReadableStream,
      "isReadableStreamInstance",
    );
  async function ABe(e) {
    let t = [],
      r = e.getReader(),
      n = !1,
      i = 0;
    for (; !n; ) {
      let { done: s, value: u } = await r.read();
      u && (t.push(u), (i += u.length)), (n = s);
    }
    let o = new Uint8Array(i),
      a = 0;
    for (let s of t) o.set(s, a), (a += s.length);
    return o;
  }
  hr(ABe, "collectReadableStream");
});
var jBe = g((bjn, qBe) => {
  c();
  var Zj = Object.defineProperty,
    slr = Object.getOwnPropertyDescriptor,
    clr = Object.getOwnPropertyNames,
    ulr = Object.prototype.hasOwnProperty,
    cu = (e, t) => Zj(e, "name", { value: t, configurable: !0 }),
    llr = (e, t) => {
      for (var r in t) Zj(e, r, { get: t[r], enumerable: !0 });
    },
    dlr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of clr(t))
          !ulr.call(e, i) &&
            i !== r &&
            Zj(e, i, {
              get: () => t[i],
              enumerable: !(n = slr(t, i)) || n.enumerable,
            });
      return e;
    },
    flr = (e) => dlr(Zj({}, "__esModule", { value: !0 }), e),
    xBe = {};
  llr(xBe, {
    FetchHttpHandler: () => mlr,
    keepAliveSupport: () => Jj,
    streamCollector: () => glr,
  });
  qBe.exports = flr(xBe);
  var IBe = ns(),
    plr = _Y();
  function wY(e, t) {
    return new Request(e, t);
  }
  cu(wY, "createRequest");
  function NBe(e = 0) {
    return new Promise((t, r) => {
      e &&
        setTimeout(() => {
          let n = new Error(`Request did not complete within ${e} ms`);
          (n.name = "TimeoutError"), r(n);
        }, e);
    });
  }
  cu(NBe, "requestTimeout");
  var Jj = { supported: void 0 },
    mlr = class kBe {
      static {
        cu(this, "FetchHttpHandler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new kBe(t);
      }
      constructor(t) {
        typeof t == "function"
          ? (this.configProvider = t().then((r) => r || {}))
          : ((this.config = t ?? {}),
            (this.configProvider = Promise.resolve(this.config))),
          Jj.supported === void 0 &&
            (Jj.supported =
              typeof Request < "u" && "keepalive" in wY("https://[::1]"));
      }
      destroy() {}
      async handle(t, { abortSignal: r } = {}) {
        this.config || (this.config = await this.configProvider);
        let n = this.config.requestTimeout,
          i = this.config.keepAlive === !0,
          o = this.config.credentials;
        if (r?.aborted) {
          let b = new Error("Request aborted");
          return (b.name = "AbortError"), Promise.reject(b);
        }
        let a = t.path,
          s = (0, plr.buildQueryString)(t.query || {});
        s && (a += `?${s}`), t.fragment && (a += `#${t.fragment}`);
        let u = "";
        if (t.username != null || t.password != null) {
          let b = t.username ?? "",
            O = t.password ?? "";
          u = `${b}:${O}@`;
        }
        let { port: l, method: d } = t,
          f = `${t.protocol}//${u}${t.hostname}${l ? `:${l}` : ""}${a}`,
          m = d === "GET" || d === "HEAD" ? void 0 : t.body,
          h = {
            body: m,
            headers: new Headers(t.headers),
            method: d,
            credentials: o,
          };
        this.config?.cache && (h.cache = this.config.cache),
          m && (h.duplex = "half"),
          typeof AbortController < "u" && (h.signal = r),
          Jj.supported && (h.keepalive = i),
          typeof this.config.requestInit == "function" &&
            Object.assign(h, this.config.requestInit(t));
        let y = cu(() => {}, "removeSignalEventListener"),
          _ = wY(f, h),
          E = [
            fetch(_).then((b) => {
              let O = b.headers,
                C = {};
              for (let k of O.entries()) C[k[0]] = k[1];
              return b.body != null
                ? {
                    response: new IBe.HttpResponse({
                      headers: C,
                      reason: b.statusText,
                      statusCode: b.status,
                      body: b.body,
                    }),
                  }
                : b.blob().then((k) => ({
                    response: new IBe.HttpResponse({
                      headers: C,
                      reason: b.statusText,
                      statusCode: b.status,
                      body: k,
                    }),
                  }));
            }),
            NBe(n),
          ];
        return (
          r &&
            E.push(
              new Promise((b, O) => {
                let C = cu(() => {
                  let P = new Error("Request aborted");
                  (P.name = "AbortError"), O(P);
                }, "onAbort");
                if (typeof r.addEventListener == "function") {
                  let P = r;
                  P.addEventListener("abort", C, { once: !0 }),
                    (y = cu(
                      () => P.removeEventListener("abort", C),
                      "removeSignalEventListener",
                    ));
                } else r.onabort = C;
              }),
            ),
          Promise.race(E).finally(y)
        );
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then(
            (n) => ((n[t] = r), n),
          ));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    },
    hlr = nE(),
    glr = cu(
      async (e) =>
        (typeof Blob == "function" && e instanceof Blob) ||
        e.constructor?.name === "Blob"
          ? Blob.prototype.arrayBuffer !== void 0
            ? new Uint8Array(await e.arrayBuffer())
            : DBe(e)
          : LBe(e),
      "streamCollector",
    );
  async function DBe(e) {
    let t = await MBe(e),
      r = (0, hlr.fromBase64)(t);
    return new Uint8Array(r);
  }
  cu(DBe, "collectBlob");
  async function LBe(e) {
    let t = [],
      r = e.getReader(),
      n = !1,
      i = 0;
    for (; !n; ) {
      let { done: s, value: u } = await r.read();
      u && (t.push(u), (i += u.length)), (n = s);
    }
    let o = new Uint8Array(i),
      a = 0;
    for (let s of t) o.set(s, a), (a += s.length);
    return o;
  }
  cu(LBe, "collectStream");
  function MBe(e) {
    return new Promise((t, r) => {
      let n = new FileReader();
      (n.onloadend = () => {
        if (n.readyState !== 2) return r(new Error("Reader aborted too early"));
        let i = n.result ?? "",
          o = i.indexOf(","),
          a = o > -1 ? o + 1 : i.length;
        t(i.substring(a));
      }),
        (n.onabort = () => r(new Error("Read aborted"))),
        (n.onerror = () => r(n.error)),
        n.readAsDataURL(e);
    });
  }
  cu(MBe, "readToBase64");
});
var HBe = g((eF) => {
  "use strict";
  c();
  Object.defineProperty(eF, "__esModule", { value: !0 });
  eF.sdkStreamMixin = void 0;
  var vlr = jBe(),
    ylr = nE(),
    _lr = zs(),
    Elr = Fe(),
    FBe = ep(),
    BBe = "The stream has already been transformed.",
    blr = (e) => {
      var t, r;
      if (!UBe(e) && !(0, FBe.isReadableStream)(e)) {
        let a =
          ((r =
            (t = e?.__proto__) === null || t === void 0
              ? void 0
              : t.constructor) === null || r === void 0
            ? void 0
            : r.name) || e;
        throw new Error(
          `Unexpected stream implementation, expect Blob or ReadableStream, got ${a}`,
        );
      }
      let n = !1,
        i = async () => {
          if (n) throw new Error(BBe);
          return (n = !0), await (0, vlr.streamCollector)(e);
        },
        o = (a) => {
          if (typeof a.stream != "function")
            throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
          return a.stream();
        };
      return Object.assign(e, {
        transformToByteArray: i,
        transformToString: async (a) => {
          let s = await i();
          if (a === "base64") return (0, ylr.toBase64)(s);
          if (a === "hex") return (0, _lr.toHex)(s);
          if (a === void 0 || a === "utf8" || a === "utf-8")
            return (0, Elr.toUtf8)(s);
          if (typeof TextDecoder == "function")
            return new TextDecoder(a).decode(s);
          throw new Error(
            "TextDecoder is not available, please make sure polyfill is provided.",
          );
        },
        transformToWebStream: () => {
          if (n) throw new Error(BBe);
          if (((n = !0), UBe(e))) return o(e);
          if ((0, FBe.isReadableStream)(e)) return e;
          throw new Error(`Cannot transform payload to web stream, got ${e}`);
        },
      });
    };
  eF.sdkStreamMixin = blr;
  var UBe = (e) => typeof Blob == "function" && e instanceof Blob;
});
var VBe = g((tF) => {
  "use strict";
  c();
  Object.defineProperty(tF, "__esModule", { value: !0 });
  tF.sdkStreamMixin = void 0;
  var Slr = RBe(),
    Clr = Hi(),
    OY = G("stream"),
    wlr = HBe(),
    GBe = "The stream has already been transformed.",
    Olr = (e) => {
      var t, r;
      if (!(e instanceof OY.Readable))
        try {
          return (0, wlr.sdkStreamMixin)(e);
        } catch {
          let a =
            ((r =
              (t = e?.__proto__) === null || t === void 0
                ? void 0
                : t.constructor) === null || r === void 0
              ? void 0
              : r.name) || e;
          throw new Error(
            `Unexpected stream implementation, expect Stream.Readable instance, got ${a}`,
          );
        }
      let n = !1,
        i = async () => {
          if (n) throw new Error(GBe);
          return (n = !0), await (0, Slr.streamCollector)(e);
        };
      return Object.assign(e, {
        transformToByteArray: i,
        transformToString: async (o) => {
          let a = await i();
          return o === void 0 || Buffer.isEncoding(o)
            ? (0, Clr.fromArrayBuffer)(
                a.buffer,
                a.byteOffset,
                a.byteLength,
              ).toString(o)
            : new TextDecoder(o).decode(a);
        },
        transformToWebStream: () => {
          if (n) throw new Error(GBe);
          if (e.readableFlowing !== null)
            throw new Error("The stream has been consumed by other callbacks.");
          if (typeof OY.Readable.toWeb != "function")
            throw new Error(
              "Readable.toWeb() is not supported. Please ensure a polyfill is available.",
            );
          return (n = !0), OY.Readable.toWeb(e);
        },
      });
    };
  tF.sdkStreamMixin = Olr;
});
var $Be = g((rF) => {
  "use strict";
  c();
  Object.defineProperty(rF, "__esModule", { value: !0 });
  rF.splitStream = void 0;
  async function Tlr(e) {
    return typeof e.stream == "function" && (e = e.stream()), e.tee();
  }
  rF.splitStream = Tlr;
});
var WBe = g((nF) => {
  "use strict";
  c();
  Object.defineProperty(nF, "__esModule", { value: !0 });
  nF.splitStream = void 0;
  var zBe = G("stream"),
    Alr = $Be(),
    KBe = ep();
  async function Plr(e) {
    if ((0, KBe.isReadableStream)(e) || (0, KBe.isBlob)(e))
      return (0, Alr.splitStream)(e);
    let t = new zBe.PassThrough(),
      r = new zBe.PassThrough();
    return e.pipe(t), e.pipe(r), [t, r];
  }
  nF.splitStream = Plr;
});
var RY = g((xjn, lu) => {
  c();
  var iF = Object.defineProperty,
    Rlr = Object.getOwnPropertyDescriptor,
    Ilr = Object.getOwnPropertyNames,
    xlr = Object.prototype.hasOwnProperty,
    PY = (e, t) => iF(e, "name", { value: t, configurable: !0 }),
    Nlr = (e, t) => {
      for (var r in t) iF(e, r, { get: t[r], enumerable: !0 });
    },
    TY = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Ilr(t))
          !xlr.call(e, i) &&
            i !== r &&
            iF(e, i, {
              get: () => t[i],
              enumerable: !(n = Rlr(t, i)) || n.enumerable,
            });
      return e;
    },
    tp = (e, t, r) => (TY(e, t, "default"), r && TY(r, t, "default")),
    klr = (e) => TY(iF({}, "__esModule", { value: !0 }), e),
    uu = {};
  Nlr(uu, { Uint8ArrayBlobAdapter: () => AY });
  lu.exports = klr(uu);
  var QBe = nE(),
    YBe = Fe();
  function XBe(e, t = "utf-8") {
    return t === "base64" ? (0, QBe.toBase64)(e) : (0, YBe.toUtf8)(e);
  }
  PY(XBe, "transformToString");
  function JBe(e, t) {
    return t === "base64"
      ? AY.mutate((0, QBe.fromBase64)(e))
      : AY.mutate((0, YBe.fromUtf8)(e));
  }
  PY(JBe, "transformFromString");
  var AY = class ZBe extends Uint8Array {
    static {
      PY(this, "Uint8ArrayBlobAdapter");
    }
    static fromString(t, r = "utf-8") {
      switch (typeof t) {
        case "string":
          return JBe(t, r);
        default:
          throw new Error(
            `Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`,
          );
      }
    }
    static mutate(t) {
      return Object.setPrototypeOf(t, ZBe.prototype), t;
    }
    transformToString(t = "utf-8") {
      return XBe(this, t);
    }
  };
  tp(uu, dY(), lu.exports);
  tp(uu, J1e(), lu.exports);
  tp(uu, iBe(), lu.exports);
  tp(uu, oBe(), lu.exports);
  tp(uu, sBe(), lu.exports);
  tp(uu, VBe(), lu.exports);
  tp(uu, WBe(), lu.exports);
  tp(uu, ep(), lu.exports);
});
var oF,
  Dlr,
  eUe = w(() => {
    c();
    (oF = A(RY())),
      (Dlr = async (e = new Uint8Array(), t) => {
        if (e instanceof Uint8Array) return oF.Uint8ArrayBlobAdapter.mutate(e);
        if (!e) return oF.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
        let r = t.streamCollector(e);
        return oF.Uint8ArrayBlobAdapter.mutate(await r);
      });
  });
function aF(e) {
  return encodeURIComponent(e).replace(/[!'()*]/g, function (t) {
    return "%" + t.charCodeAt(0).toString(16).toUpperCase();
  });
}
var IY = w(() => {
  c();
});
var xY,
  NY = w(() => {
    c();
    IY();
    xY = (e, t, r, n, i, o) => {
      if (t != null && t[r] !== void 0) {
        let a = n();
        if (a.length <= 0)
          throw new Error(
            "Empty value provided for input HTTP label: " + r + ".",
          );
        e = e.replace(
          i,
          o
            ? a
                .split("/")
                .map((s) => aF(s))
                .join("/")
            : aF(a),
        );
      } else
        throw new Error("No value provided for input HTTP label: " + r + ".");
      return e;
    };
  });
function kY(e, t) {
  return new sF(e, t);
}
var tUe,
  sF,
  rUe = w(() => {
    c();
    tUe = A(ns());
    NY();
    sF = class {
      constructor(t, r) {
        (this.input = t),
          (this.context = r),
          (this.query = {}),
          (this.method = ""),
          (this.headers = {}),
          (this.path = ""),
          (this.body = null),
          (this.hostname = ""),
          (this.resolvePathStack = []);
      }
      async build() {
        let {
          hostname: t,
          protocol: r = "https",
          port: n,
          path: i,
        } = await this.context.endpoint();
        this.path = i;
        for (let o of this.resolvePathStack) o(this.path);
        return new tUe.HttpRequest({
          protocol: r,
          hostname: this.hostname || t,
          port: n,
          method: this.method,
          path: this.path,
          query: this.query,
          body: this.body,
          headers: this.headers,
        });
      }
      hn(t) {
        return (this.hostname = t), this;
      }
      bp(t) {
        return (
          this.resolvePathStack.push((r) => {
            this.path = `${r?.endsWith("/") ? r.slice(0, -1) : r || ""}` + t;
          }),
          this
        );
      }
      p(t, r, n, i) {
        return (
          this.resolvePathStack.push((o) => {
            this.path = xY(o, this.input, t, r, n, i);
          }),
          this
        );
      }
      h(t) {
        return (this.headers = t), this;
      }
      q(t) {
        return (this.query = t), this;
      }
      b(t) {
        return (this.body = t), this;
      }
      m(t) {
        return (this.method = t), this;
      }
    };
  });
var nUe = {};
bn(nUe, {
  RequestBuilder: () => sF,
  collectBody: () => Dlr,
  extendedEncodeURIComponent: () => aF,
  requestBuilder: () => kY,
  resolvedPath: () => xY,
});
var DY = w(() => {
  c();
  eUe();
  IY();
  rUe();
  NY();
});
var yO = g((Wjn, bUe) => {
  c();
  var lF = Object.defineProperty,
    Llr = Object.getOwnPropertyDescriptor,
    Mlr = Object.getOwnPropertyNames,
    qlr = Object.prototype.hasOwnProperty,
    pe = (e, t) => lF(e, "name", { value: t, configurable: !0 }),
    jlr = (e, t) => {
      for (var r in t) lF(e, r, { get: t[r], enumerable: !0 });
    },
    Flr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Mlr(t))
          !qlr.call(e, i) &&
            i !== r &&
            lF(e, i, {
              get: () => t[i],
              enumerable: !(n = Llr(t, i)) || n.enumerable,
            });
      return e;
    },
    Blr = (e) => Flr(lF({}, "__esModule", { value: !0 }), e),
    oUe = {};
  jlr(oUe, {
    Client: () => Ulr,
    Command: () => sUe,
    LazyJsonString: () => Nh,
    NoOpLogger: () => qdr,
    SENSITIVE_STRING: () => Glr,
    ServiceException: () => wdr,
    _json: () => UY,
    collectBody: () => LY.collectBody,
    convertMap: () => jdr,
    createAggregatedClient: () => Vlr,
    dateToUtcString: () => pUe,
    decorateServiceException: () => mUe,
    emitWarningIfUnsupportedVersion: () => Pdr,
    expectBoolean: () => zlr,
    expectByte: () => BY,
    expectFloat32: () => cF,
    expectInt: () => Wlr,
    expectInt32: () => jY,
    expectLong: () => gO,
    expectNonNull: () => Ylr,
    expectNumber: () => hO,
    expectObject: () => cUe,
    expectShort: () => FY,
    expectString: () => Xlr,
    expectUnion: () => Jlr,
    extendedEncodeURIComponent: () => LY.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => Ldr,
    getDefaultClientConfiguration: () => kdr,
    getDefaultExtensionConfiguration: () => gUe,
    getValueFromTextNode: () => vUe,
    handleFloat: () => tdr,
    isSerializableHeaderValue: () => Mdr,
    limitedParseDouble: () => VY,
    limitedParseFloat: () => rdr,
    limitedParseFloat32: () => ndr,
    loadConfigsForDefaultMode: () => Adr,
    logger: () => vO,
    map: () => zY,
    parseBoolean: () => $lr,
    parseEpochTimestamp: () => hdr,
    parseRfc3339DateTime: () => cdr,
    parseRfc3339DateTimeWithOffset: () => ldr,
    parseRfc7231DateTime: () => mdr,
    quoteHeader: () => _Ue,
    resolveDefaultRuntimeConfig: () => Ddr,
    resolvedPath: () => LY.resolvedPath,
    serializeDateTime: () => Vdr,
    serializeFloat: () => Gdr,
    splitEvery: () => EUe,
    splitHeader: () => $dr,
    strictParseByte: () => fUe,
    strictParseDouble: () => GY,
    strictParseFloat: () => Zlr,
    strictParseFloat32: () => uUe,
    strictParseInt: () => idr,
    strictParseInt32: () => odr,
    strictParseLong: () => dUe,
    strictParseShort: () => aE,
    take: () => Fdr,
    throwDefaultError: () => hUe,
    withBaseException: () => Odr,
  });
  bUe.exports = Blr(oUe);
  var aUe = $1e(),
    Ulr = class {
      constructor(e) {
        (this.config = e), (this.middlewareStack = (0, aUe.constructStack)());
      }
      static {
        pe(this, "Client");
      }
      send(e, t, r) {
        let n = typeof t != "function" ? t : void 0,
          i = typeof t == "function" ? t : r,
          o = n === void 0 && this.config.cacheMiddleware === !0,
          a;
        if (o) {
          this.handlers || (this.handlers = new WeakMap());
          let s = this.handlers;
          s.has(e.constructor)
            ? (a = s.get(e.constructor))
            : ((a = e.resolveMiddleware(this.middlewareStack, this.config, n)),
              s.set(e.constructor, a));
        } else
          delete this.handlers,
            (a = e.resolveMiddleware(this.middlewareStack, this.config, n));
        if (i)
          a(e)
            .then(
              (s) => i(null, s.output),
              (s) => i(s),
            )
            .catch(() => {});
        else return a(e).then((s) => s.output);
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers;
      }
    },
    LY = (DY(), ue(nUe)),
    qY = Xf(),
    sUe = class {
      constructor() {
        this.middlewareStack = (0, aUe.constructStack)();
      }
      static {
        pe(this, "Command");
      }
      static classBuilder() {
        return new Hlr();
      }
      resolveMiddlewareWithContext(
        e,
        t,
        r,
        {
          middlewareFn: n,
          clientName: i,
          commandName: o,
          inputFilterSensitiveLog: a,
          outputFilterSensitiveLog: s,
          smithyContext: u,
          additionalContext: l,
          CommandCtor: d,
        },
      ) {
        for (let _ of n.bind(this)(d, e, t, r)) this.middlewareStack.use(_);
        let f = e.concat(this.middlewareStack),
          { logger: m } = t,
          h = {
            logger: m,
            clientName: i,
            commandName: o,
            inputFilterSensitiveLog: a,
            outputFilterSensitiveLog: s,
            [qY.SMITHY_CONTEXT_KEY]: { commandInstance: this, ...u },
            ...l,
          },
          { requestHandler: y } = t;
        return f.resolve((_) => y.handle(_.request, r || {}), h);
      }
    },
    Hlr = class {
      constructor() {
        (this._init = () => {}),
          (this._ep = {}),
          (this._middlewareFn = () => []),
          (this._commandName = ""),
          (this._clientName = ""),
          (this._additionalContext = {}),
          (this._smithyContext = {}),
          (this._inputFilterSensitiveLog = (e) => e),
          (this._outputFilterSensitiveLog = (e) => e),
          (this._serializer = null),
          (this._deserializer = null);
      }
      static {
        pe(this, "ClassBuilder");
      }
      init(e) {
        this._init = e;
      }
      ep(e) {
        return (this._ep = e), this;
      }
      m(e) {
        return (this._middlewareFn = e), this;
      }
      s(e, t, r = {}) {
        return (this._smithyContext = { service: e, operation: t, ...r }), this;
      }
      c(e = {}) {
        return (this._additionalContext = e), this;
      }
      n(e, t) {
        return (this._clientName = e), (this._commandName = t), this;
      }
      f(e = (r) => r, t = (r) => r) {
        return (
          (this._inputFilterSensitiveLog = e),
          (this._outputFilterSensitiveLog = t),
          this
        );
      }
      ser(e) {
        return (this._serializer = e), this;
      }
      de(e) {
        return (this._deserializer = e), this;
      }
      build() {
        let e = this,
          t;
        return (t = class extends sUe {
          constructor(...[r]) {
            super(),
              (this.serialize = e._serializer),
              (this.deserialize = e._deserializer),
              (this.input = r ?? {}),
              e._init(this);
          }
          static {
            pe(this, "CommandRef");
          }
          static getEndpointParameterInstructions() {
            return e._ep;
          }
          resolveMiddleware(r, n, i) {
            return this.resolveMiddlewareWithContext(r, n, i, {
              CommandCtor: t,
              middlewareFn: e._middlewareFn,
              clientName: e._clientName,
              commandName: e._commandName,
              inputFilterSensitiveLog: e._inputFilterSensitiveLog,
              outputFilterSensitiveLog: e._outputFilterSensitiveLog,
              smithyContext: e._smithyContext,
              additionalContext: e._additionalContext,
            });
          }
        });
      }
    },
    Glr = "***SensitiveInformation***",
    Vlr = pe((e, t) => {
      for (let r of Object.keys(e)) {
        let n = e[r],
          i = pe(async function (a, s, u) {
            let l = new n(a);
            if (typeof s == "function") this.send(l, s);
            else if (typeof u == "function") {
              if (typeof s != "object")
                throw new Error(`Expected http options but got ${typeof s}`);
              this.send(l, s || {}, u);
            } else return this.send(l, s);
          }, "methodImpl"),
          o = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, "");
        t.prototype[o] = i;
      }
    }, "createAggregatedClient"),
    $lr = pe((e) => {
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw new Error(`Unable to parse boolean value "${e}"`);
      }
    }, "parseBoolean"),
    zlr = pe((e) => {
      if (e != null) {
        if (typeof e == "number") {
          if (
            ((e === 0 || e === 1) &&
              vO.warn(uF(`Expected boolean, got ${typeof e}: ${e}`)),
            e === 0)
          )
            return !1;
          if (e === 1) return !0;
        }
        if (typeof e == "string") {
          let t = e.toLowerCase();
          if (
            ((t === "false" || t === "true") &&
              vO.warn(uF(`Expected boolean, got ${typeof e}: ${e}`)),
            t === "false")
          )
            return !1;
          if (t === "true") return !0;
        }
        if (typeof e == "boolean") return e;
        throw new TypeError(`Expected boolean, got ${typeof e}: ${e}`);
      }
    }, "expectBoolean"),
    hO = pe((e) => {
      if (e != null) {
        if (typeof e == "string") {
          let t = parseFloat(e);
          if (!Number.isNaN(t))
            return (
              String(t) !== String(e) &&
                vO.warn(uF(`Expected number but observed string: ${e}`)),
              t
            );
        }
        if (typeof e == "number") return e;
        throw new TypeError(`Expected number, got ${typeof e}: ${e}`);
      }
    }, "expectNumber"),
    Klr = Math.ceil(2 ** 127 * (2 - 2 ** -23)),
    cF = pe((e) => {
      let t = hO(e);
      if (
        t !== void 0 &&
        !Number.isNaN(t) &&
        t !== 1 / 0 &&
        t !== -1 / 0 &&
        Math.abs(t) > Klr
      )
        throw new TypeError(`Expected 32-bit float, got ${e}`);
      return t;
    }, "expectFloat32"),
    gO = pe((e) => {
      if (e != null) {
        if (Number.isInteger(e) && !Number.isNaN(e)) return e;
        throw new TypeError(`Expected integer, got ${typeof e}: ${e}`);
      }
    }, "expectLong"),
    Wlr = gO,
    jY = pe((e) => HY(e, 32), "expectInt32"),
    FY = pe((e) => HY(e, 16), "expectShort"),
    BY = pe((e) => HY(e, 8), "expectByte"),
    HY = pe((e, t) => {
      let r = gO(e);
      if (r !== void 0 && Qlr(r, t) !== r)
        throw new TypeError(`Expected ${t}-bit integer, got ${e}`);
      return r;
    }, "expectSizedInt"),
    Qlr = pe((e, t) => {
      switch (t) {
        case 32:
          return Int32Array.of(e)[0];
        case 16:
          return Int16Array.of(e)[0];
        case 8:
          return Int8Array.of(e)[0];
      }
    }, "castInt"),
    Ylr = pe((e, t) => {
      if (e == null)
        throw t
          ? new TypeError(`Expected a non-null value for ${t}`)
          : new TypeError("Expected a non-null value");
      return e;
    }, "expectNonNull"),
    cUe = pe((e) => {
      if (e == null) return;
      if (typeof e == "object" && !Array.isArray(e)) return e;
      let t = Array.isArray(e) ? "array" : typeof e;
      throw new TypeError(`Expected object, got ${t}: ${e}`);
    }, "expectObject"),
    Xlr = pe((e) => {
      if (e != null) {
        if (typeof e == "string") return e;
        if (["boolean", "number", "bigint"].includes(typeof e))
          return (
            vO.warn(uF(`Expected string, got ${typeof e}: ${e}`)), String(e)
          );
        throw new TypeError(`Expected string, got ${typeof e}: ${e}`);
      }
    }, "expectString"),
    Jlr = pe((e) => {
      if (e == null) return;
      let t = cUe(e),
        r = Object.entries(t)
          .filter(([, n]) => n != null)
          .map(([n]) => n);
      if (r.length === 0)
        throw new TypeError(
          "Unions must have exactly one non-null member. None were found.",
        );
      if (r.length > 1)
        throw new TypeError(
          `Unions must have exactly one non-null member. Keys ${r} were not null.`,
        );
      return t;
    }, "expectUnion"),
    GY = pe((e) => hO(typeof e == "string" ? cE(e) : e), "strictParseDouble"),
    Zlr = GY,
    uUe = pe((e) => cF(typeof e == "string" ? cE(e) : e), "strictParseFloat32"),
    edr = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    cE = pe((e) => {
      let t = e.match(edr);
      if (t === null || t[0].length !== e.length)
        throw new TypeError("Expected real number, got implicit NaN");
      return parseFloat(e);
    }, "parseNumber"),
    VY = pe(
      (e) => (typeof e == "string" ? lUe(e) : hO(e)),
      "limitedParseDouble",
    ),
    tdr = VY,
    rdr = VY,
    ndr = pe(
      (e) => (typeof e == "string" ? lUe(e) : cF(e)),
      "limitedParseFloat32",
    ),
    lUe = pe((e) => {
      switch (e) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw new Error(`Unable to parse float value: ${e}`);
      }
    }, "parseFloatString"),
    dUe = pe((e) => gO(typeof e == "string" ? cE(e) : e), "strictParseLong"),
    idr = dUe,
    odr = pe((e) => jY(typeof e == "string" ? cE(e) : e), "strictParseInt32"),
    aE = pe((e) => FY(typeof e == "string" ? cE(e) : e), "strictParseShort"),
    fUe = pe((e) => BY(typeof e == "string" ? cE(e) : e), "strictParseByte"),
    uF = pe(
      (e) =>
        String(new TypeError(e).stack || e)
          .split(
            `
`,
          )
          .slice(0, 5)
          .filter((t) => !t.includes("stackTraceWarning")).join(`
`),
      "stackTraceWarning",
    ),
    vO = { warn: console.warn },
    adr = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    $Y = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
  function pUe(e) {
    let t = e.getUTCFullYear(),
      r = e.getUTCMonth(),
      n = e.getUTCDay(),
      i = e.getUTCDate(),
      o = e.getUTCHours(),
      a = e.getUTCMinutes(),
      s = e.getUTCSeconds(),
      u = i < 10 ? `0${i}` : `${i}`,
      l = o < 10 ? `0${o}` : `${o}`,
      d = a < 10 ? `0${a}` : `${a}`,
      f = s < 10 ? `0${s}` : `${s}`;
    return `${adr[n]}, ${u} ${$Y[r]} ${t} ${l}:${d}:${f} GMT`;
  }
  pe(pUe, "dateToUtcString");
  var sdr = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/,
    ),
    cdr = pe((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      let t = sdr.exec(e);
      if (!t) throw new TypeError("Invalid RFC-3339 date-time value");
      let [r, n, i, o, a, s, u, l] = t,
        d = aE(sE(n)),
        f = du(i, "month", 1, 12),
        m = du(o, "day", 1, 31);
      return mO(d, f, m, {
        hours: a,
        minutes: s,
        seconds: u,
        fractionalMilliseconds: l,
      });
    }, "parseRfc3339DateTime"),
    udr = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/,
    ),
    ldr = pe((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      let t = udr.exec(e);
      if (!t) throw new TypeError("Invalid RFC-3339 date-time value");
      let [r, n, i, o, a, s, u, l, d] = t,
        f = aE(sE(n)),
        m = du(i, "month", 1, 12),
        h = du(o, "day", 1, 31),
        y = mO(f, m, h, {
          hours: a,
          minutes: s,
          seconds: u,
          fractionalMilliseconds: l,
        });
      return d.toUpperCase() != "Z" && y.setTime(y.getTime() - Cdr(d)), y;
    }, "parseRfc3339DateTimeWithOffset"),
    ddr = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    fdr = new RegExp(
      /^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    pdr = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/,
    ),
    mdr = pe((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
      let t = ddr.exec(e);
      if (t) {
        let [r, n, i, o, a, s, u, l] = t;
        return mO(aE(sE(o)), MY(i), du(n, "day", 1, 31), {
          hours: a,
          minutes: s,
          seconds: u,
          fractionalMilliseconds: l,
        });
      }
      if (((t = fdr.exec(e)), t)) {
        let [r, n, i, o, a, s, u, l] = t;
        return ydr(
          mO(gdr(o), MY(i), du(n, "day", 1, 31), {
            hours: a,
            minutes: s,
            seconds: u,
            fractionalMilliseconds: l,
          }),
        );
      }
      if (((t = pdr.exec(e)), t)) {
        let [r, n, i, o, a, s, u, l] = t;
        return mO(aE(sE(l)), MY(n), du(i.trimLeft(), "day", 1, 31), {
          hours: o,
          minutes: a,
          seconds: s,
          fractionalMilliseconds: u,
        });
      }
      throw new TypeError("Invalid RFC-7231 date-time value");
    }, "parseRfc7231DateTime"),
    hdr = pe((e) => {
      if (e == null) return;
      let t;
      if (typeof e == "number") t = e;
      else if (typeof e == "string") t = GY(e);
      else if (typeof e == "object" && e.tag === 1) t = e.value;
      else
        throw new TypeError(
          "Epoch timestamps must be expressed as floating point numbers or their string representation",
        );
      if (Number.isNaN(t) || t === 1 / 0 || t === -1 / 0)
        throw new TypeError(
          "Epoch timestamps must be valid, non-Infinite, non-NaN numerics",
        );
      return new Date(Math.round(t * 1e3));
    }, "parseEpochTimestamp"),
    mO = pe((e, t, r, n) => {
      let i = t - 1;
      return (
        Edr(e, i, r),
        new Date(
          Date.UTC(
            e,
            i,
            r,
            du(n.hours, "hour", 0, 23),
            du(n.minutes, "minute", 0, 59),
            du(n.seconds, "seconds", 0, 60),
            Sdr(n.fractionalMilliseconds),
          ),
        )
      );
    }, "buildDate"),
    gdr = pe((e) => {
      let t = new Date().getUTCFullYear(),
        r = Math.floor(t / 100) * 100 + aE(sE(e));
      return r < t ? r + 100 : r;
    }, "parseTwoDigitYear"),
    vdr = 50 * 365 * 24 * 60 * 60 * 1e3,
    ydr = pe(
      (e) =>
        e.getTime() - new Date().getTime() > vdr
          ? new Date(
              Date.UTC(
                e.getUTCFullYear() - 100,
                e.getUTCMonth(),
                e.getUTCDate(),
                e.getUTCHours(),
                e.getUTCMinutes(),
                e.getUTCSeconds(),
                e.getUTCMilliseconds(),
              ),
            )
          : e,
      "adjustRfc850Year",
    ),
    MY = pe((e) => {
      let t = $Y.indexOf(e);
      if (t < 0) throw new TypeError(`Invalid month: ${e}`);
      return t + 1;
    }, "parseMonthByShortName"),
    _dr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    Edr = pe((e, t, r) => {
      let n = _dr[t];
      if ((t === 1 && bdr(e) && (n = 29), r > n))
        throw new TypeError(`Invalid day for ${$Y[t]} in ${e}: ${r}`);
    }, "validateDayOfMonth"),
    bdr = pe(
      (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0),
      "isLeapYear",
    ),
    du = pe((e, t, r, n) => {
      let i = fUe(sE(e));
      if (i < r || i > n)
        throw new TypeError(`${t} must be between ${r} and ${n}, inclusive`);
      return i;
    }, "parseDateValue"),
    Sdr = pe((e) => (e == null ? 0 : uUe("0." + e) * 1e3), "parseMilliseconds"),
    Cdr = pe((e) => {
      let t = e[0],
        r = 1;
      if (t == "+") r = 1;
      else if (t == "-") r = -1;
      else throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`);
      let n = Number(e.substring(1, 3)),
        i = Number(e.substring(4, 6));
      return r * (n * 60 + i) * 60 * 1e3;
    }, "parseOffsetToMilliseconds"),
    sE = pe((e) => {
      let t = 0;
      for (; t < e.length - 1 && e.charAt(t) === "0"; ) t++;
      return t === 0 ? e : e.slice(t);
    }, "stripLeadingZeroes"),
    wdr = class pO extends Error {
      static {
        pe(this, "ServiceException");
      }
      constructor(t) {
        super(t.message),
          Object.setPrototypeOf(
            this,
            Object.getPrototypeOf(this).constructor.prototype,
          ),
          (this.name = t.name),
          (this.$fault = t.$fault),
          (this.$metadata = t.$metadata);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          pO.prototype.isPrototypeOf(r) ||
          (!!r.$fault &&
            !!r.$metadata &&
            (r.$fault === "client" || r.$fault === "server"))
        );
      }
      static [Symbol.hasInstance](t) {
        if (!t) return !1;
        let r = t;
        return this === pO
          ? pO.isInstance(t)
          : pO.isInstance(t)
            ? r.name && this.name
              ? this.prototype.isPrototypeOf(t) || r.name === this.name
              : this.prototype.isPrototypeOf(t)
            : !1;
      }
    },
    mUe = pe((e, t = {}) => {
      Object.entries(t)
        .filter(([, n]) => n !== void 0)
        .forEach(([n, i]) => {
          (e[n] == null || e[n] === "") && (e[n] = i);
        });
      let r = e.message || e.Message || "UnknownError";
      return (e.message = r), delete e.Message, e;
    }, "decorateServiceException"),
    hUe = pe(({ output: e, parsedBody: t, exceptionCtor: r, errorCode: n }) => {
      let i = Tdr(e),
        o = i.httpStatusCode ? i.httpStatusCode + "" : void 0,
        a = new r({
          name: t?.code || t?.Code || n || o || "UnknownError",
          $fault: "client",
          $metadata: i,
        });
      throw mUe(a, t);
    }, "throwDefaultError"),
    Odr = pe(
      (e) =>
        ({ output: t, parsedBody: r, errorCode: n }) => {
          hUe({ output: t, parsedBody: r, exceptionCtor: e, errorCode: n });
        },
      "withBaseException",
    ),
    Tdr = pe(
      (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }),
      "deserializeMetadata",
    ),
    Adr = pe((e) => {
      switch (e) {
        case "standard":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "in-region":
          return { retryMode: "standard", connectionTimeout: 1100 };
        case "cross-region":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "mobile":
          return { retryMode: "standard", connectionTimeout: 3e4 };
        default:
          return {};
      }
    }, "loadConfigsForDefaultMode"),
    iUe = !1,
    Pdr = pe((e) => {
      e && !iUe && parseInt(e.substring(1, e.indexOf("."))) < 16 && (iUe = !0);
    }, "emitWarningIfUnsupportedVersion"),
    Rdr = pe((e) => {
      let t = [];
      for (let r in qY.AlgorithmId) {
        let n = qY.AlgorithmId[r];
        e[n] !== void 0 &&
          t.push({ algorithmId: () => n, checksumConstructor: () => e[n] });
      }
      return {
        addChecksumAlgorithm(r) {
          t.push(r);
        },
        checksumAlgorithms() {
          return t;
        },
      };
    }, "getChecksumConfiguration"),
    Idr = pe((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    xdr = pe(
      (e) => ({
        setRetryStrategy(t) {
          e.retryStrategy = t;
        },
        retryStrategy() {
          return e.retryStrategy;
        },
      }),
      "getRetryConfiguration",
    ),
    Ndr = pe((e) => {
      let t = {};
      return (t.retryStrategy = e.retryStrategy()), t;
    }, "resolveRetryRuntimeConfig"),
    gUe = pe(
      (e) => Object.assign(Rdr(e), xdr(e)),
      "getDefaultExtensionConfiguration",
    ),
    kdr = gUe,
    Ddr = pe(
      (e) => Object.assign(Idr(e), Ndr(e)),
      "resolveDefaultRuntimeConfig",
    ),
    Ldr = pe((e) => (Array.isArray(e) ? e : [e]), "getArrayIfSingleItem"),
    vUe = pe((e) => {
      let t = "#text";
      for (let r in e)
        e.hasOwnProperty(r) && e[r][t] !== void 0
          ? (e[r] = e[r][t])
          : typeof e[r] == "object" && e[r] !== null && (e[r] = vUe(e[r]));
      return e;
    }, "getValueFromTextNode"),
    Mdr = pe((e) => e != null, "isSerializableHeaderValue"),
    Nh = pe(function (t) {
      return Object.assign(new String(t), {
        deserializeJSON() {
          return JSON.parse(String(t));
        },
        toString() {
          return String(t);
        },
        toJSON() {
          return String(t);
        },
      });
    }, "LazyJsonString");
  Nh.from = (e) =>
    e && typeof e == "object" && (e instanceof Nh || "deserializeJSON" in e)
      ? e
      : typeof e == "string" || Object.getPrototypeOf(e) === String.prototype
        ? Nh(String(e))
        : Nh(JSON.stringify(e));
  Nh.fromObject = Nh.from;
  var qdr = class {
    static {
      pe(this, "NoOpLogger");
    }
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  };
  function zY(e, t, r) {
    let n, i, o;
    if (typeof t > "u" && typeof r > "u") (n = {}), (o = e);
    else {
      if (((n = e), typeof t == "function"))
        return (i = t), (o = r), Bdr(n, i, o);
      o = t;
    }
    for (let a of Object.keys(o)) {
      if (!Array.isArray(o[a])) {
        n[a] = o[a];
        continue;
      }
      yUe(n, null, o, a);
    }
    return n;
  }
  pe(zY, "map");
  var jdr = pe((e) => {
      let t = {};
      for (let [r, n] of Object.entries(e || {})) t[r] = [, n];
      return t;
    }, "convertMap"),
    Fdr = pe((e, t) => {
      let r = {};
      for (let n in t) yUe(r, e, t, n);
      return r;
    }, "take"),
    Bdr = pe(
      (e, t, r) =>
        zY(
          e,
          Object.entries(r).reduce(
            (n, [i, o]) => (
              Array.isArray(o)
                ? (n[i] = o)
                : typeof o == "function"
                  ? (n[i] = [t, o()])
                  : (n[i] = [t, o]),
              n
            ),
            {},
          ),
        ),
      "mapWithFilter",
    ),
    yUe = pe((e, t, r, n) => {
      if (t !== null) {
        let a = r[n];
        typeof a == "function" && (a = [, a]);
        let [s = Udr, u = Hdr, l = n] = a;
        ((typeof s == "function" && s(t[l])) ||
          (typeof s != "function" && s)) &&
          (e[n] = u(t[l]));
        return;
      }
      let [i, o] = r[n];
      if (typeof o == "function") {
        let a,
          s = i === void 0 && (a = o()) != null,
          u =
            (typeof i == "function" && !!i(void 0)) ||
            (typeof i != "function" && !!i);
        s ? (e[n] = a) : u && (e[n] = o());
      } else {
        let a = i === void 0 && o != null,
          s =
            (typeof i == "function" && !!i(o)) ||
            (typeof i != "function" && !!i);
        (a || s) && (e[n] = o);
      }
    }, "applyInstruction"),
    Udr = pe((e) => e != null, "nonNullish"),
    Hdr = pe((e) => e, "pass");
  function _Ue(e) {
    return (
      (e.includes(",") || e.includes('"')) &&
        (e = `"${e.replace(/"/g, '\\"')}"`),
      e
    );
  }
  pe(_Ue, "quoteHeader");
  var Gdr = pe((e) => {
      if (e !== e) return "NaN";
      switch (e) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return e;
      }
    }, "serializeFloat"),
    Vdr = pe((e) => e.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    UY = pe((e) => {
      if (e == null) return {};
      if (Array.isArray(e)) return e.filter((t) => t != null).map(UY);
      if (typeof e == "object") {
        let t = {};
        for (let r of Object.keys(e)) e[r] != null && (t[r] = UY(e[r]));
        return t;
      }
      return e;
    }, "_json");
  function EUe(e, t, r) {
    if (r <= 0 || !Number.isInteger(r))
      throw new Error(
        "Invalid number of delimiters (" + r + ") for splitEvery.",
      );
    let n = e.split(t);
    if (r === 1) return n;
    let i = [],
      o = "";
    for (let a = 0; a < n.length; a++)
      o === "" ? (o = n[a]) : (o += t + n[a]),
        (a + 1) % r === 0 && (i.push(o), (o = ""));
    return o !== "" && i.push(o), i;
  }
  pe(EUe, "splitEvery");
  var $dr = pe((e) => {
    let t = e.length,
      r = [],
      n = !1,
      i,
      o = 0;
    for (let a = 0; a < t; ++a) {
      let s = e[a];
      switch (s) {
        case '"':
          i !== "\\" && (n = !n);
          break;
        case ",":
          n || (r.push(e.slice(o, a)), (o = a + 1));
          break;
        default:
      }
      i = s;
    }
    return (
      r.push(e.slice(o)),
      r.map((a) => {
        a = a.trim();
        let s = a.length;
        return s < 2
          ? a
          : (a[0] === '"' && a[s - 1] === '"' && (a = a.slice(1, s - 1)),
            a.replace(/\\"/g, '"'));
      })
    );
  }, "splitHeader");
});
var _O = g((tFn, OUe) => {
  c();
  var dF = Object.defineProperty,
    zdr = Object.getOwnPropertyDescriptor,
    Kdr = Object.getOwnPropertyNames,
    Wdr = Object.prototype.hasOwnProperty,
    CUe = (e, t) => dF(e, "name", { value: t, configurable: !0 }),
    Qdr = (e, t) => {
      for (var r in t) dF(e, r, { get: t[r], enumerable: !0 });
    },
    Ydr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Kdr(t))
          !Wdr.call(e, i) &&
            i !== r &&
            dF(e, i, {
              get: () => t[i],
              enumerable: !(n = zdr(t, i)) || n.enumerable,
            });
      return e;
    },
    Xdr = (e) => Ydr(dF({}, "__esModule", { value: !0 }), e),
    wUe = {};
  Qdr(wUe, { getSmithyContext: () => Jdr, normalizeProvider: () => Zdr });
  OUe.exports = Xdr(wUe);
  var SUe = Xf(),
    Jdr = CUe(
      (e) => e[SUe.SMITHY_CONTEXT_KEY] || (e[SUe.SMITHY_CONTEXT_KEY] = {}),
      "getSmithyContext",
    ),
    Zdr = CUe((e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    }, "normalizeProvider");
});
var rX = g((nFn, ZUe) => {
  c();
  var yF = Object.defineProperty,
    efr = Object.getOwnPropertyDescriptor,
    tfr = Object.getOwnPropertyNames,
    rfr = Object.prototype.hasOwnProperty,
    Pi = (e, t) => yF(e, "name", { value: t, configurable: !0 }),
    nfr = (e, t) => {
      for (var r in t) yF(e, r, { get: t[r], enumerable: !0 });
    },
    ifr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of tfr(t))
          !rfr.call(e, i) &&
            i !== r &&
            yF(e, i, {
              get: () => t[i],
              enumerable: !(n = efr(t, i)) || n.enumerable,
            });
      return e;
    },
    ofr = (e) => ifr(yF({}, "__esModule", { value: !0 }), e),
    IUe = {};
  nfr(IUe, {
    ALGORITHM_IDENTIFIER: () => fF,
    ALGORITHM_IDENTIFIER_V4A: () => ufr,
    ALGORITHM_QUERY_PARAM: () => xUe,
    ALWAYS_UNSIGNABLE_HEADERS: () => FUe,
    AMZ_DATE_HEADER: () => eX,
    AMZ_DATE_QUERY_PARAM: () => YY,
    AUTH_HEADER: () => ZY,
    CREDENTIAL_QUERY_PARAM: () => NUe,
    DATE_HEADER: () => LUe,
    EVENT_ALGORITHM_IDENTIFIER: () => HUe,
    EXPIRES_QUERY_PARAM: () => DUe,
    GENERATED_HEADERS: () => MUe,
    HOST_HEADER: () => sfr,
    KEY_TYPE_IDENTIFIER: () => tX,
    MAX_CACHE_SIZE: () => VUe,
    MAX_PRESIGNED_TTL: () => $Ue,
    PROXY_HEADER_PATTERN: () => BUe,
    REGION_SET_PARAM: () => afr,
    SEC_HEADER_PATTERN: () => UUe,
    SHA256_HEADER: () => vF,
    SIGNATURE_HEADER: () => qUe,
    SIGNATURE_QUERY_PARAM: () => XY,
    SIGNED_HEADERS_QUERY_PARAM: () => kUe,
    SignatureV4: () => Efr,
    SignatureV4Base: () => JUe,
    TOKEN_HEADER: () => jUe,
    TOKEN_QUERY_PARAM: () => JY,
    UNSIGNABLE_PATTERNS: () => cfr,
    UNSIGNED_PAYLOAD: () => GUe,
    clearCredentialCache: () => dfr,
    createScope: () => mF,
    getCanonicalHeaders: () => KY,
    getCanonicalQuery: () => XUe,
    getPayloadHash: () => hF,
    getSigningKey: () => zUe,
    hasHeader: () => WUe,
    moveHeadersToQuery: () => YUe,
    prepareRequest: () => QY,
    signatureV4aContainer: () => bfr,
  });
  ZUe.exports = ofr(IUe);
  var TUe = Fe(),
    xUe = "X-Amz-Algorithm",
    NUe = "X-Amz-Credential",
    YY = "X-Amz-Date",
    kUe = "X-Amz-SignedHeaders",
    DUe = "X-Amz-Expires",
    XY = "X-Amz-Signature",
    JY = "X-Amz-Security-Token",
    afr = "X-Amz-Region-Set",
    ZY = "authorization",
    eX = YY.toLowerCase(),
    LUe = "date",
    MUe = [ZY, eX, LUe],
    qUe = XY.toLowerCase(),
    vF = "x-amz-content-sha256",
    jUe = JY.toLowerCase(),
    sfr = "host",
    FUe = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0,
    },
    BUe = /^proxy-/,
    UUe = /^sec-/,
    cfr = [/^proxy-/i, /^sec-/i],
    fF = "AWS4-HMAC-SHA256",
    ufr = "AWS4-ECDSA-P256-SHA256",
    HUe = "AWS4-HMAC-SHA256-PAYLOAD",
    GUe = "UNSIGNED-PAYLOAD",
    VUe = 50,
    tX = "aws4_request",
    $Ue = 60 * 60 * 24 * 7,
    rp = zs(),
    lfr = Fe(),
    uE = {},
    pF = [],
    mF = Pi((e, t, r) => `${e}/${t}/${r}/${tX}`, "createScope"),
    zUe = Pi(async (e, t, r, n, i) => {
      let o = await AUe(e, t.secretAccessKey, t.accessKeyId),
        a = `${r}:${n}:${i}:${(0, rp.toHex)(o)}:${t.sessionToken}`;
      if (a in uE) return uE[a];
      for (pF.push(a); pF.length > VUe; ) delete uE[pF.shift()];
      let s = `AWS4${t.secretAccessKey}`;
      for (let u of [r, n, i, tX]) s = await AUe(e, s, u);
      return (uE[a] = s);
    }, "getSigningKey"),
    dfr = Pi(() => {
      (pF.length = 0),
        Object.keys(uE).forEach((e) => {
          delete uE[e];
        });
    }, "clearCredentialCache"),
    AUe = Pi((e, t, r) => {
      let n = new e(t);
      return n.update((0, lfr.toUint8Array)(r)), n.digest();
    }, "hmac"),
    KY = Pi(({ headers: e }, t, r) => {
      let n = {};
      for (let i of Object.keys(e).sort()) {
        if (e[i] == null) continue;
        let o = i.toLowerCase();
        ((o in FUe || t?.has(o) || BUe.test(o) || UUe.test(o)) &&
          (!r || (r && !r.has(o)))) ||
          (n[o] = e[i].trim().replace(/\s+/g, " "));
      }
      return n;
    }, "getCanonicalHeaders"),
    ffr = hf(),
    pfr = Fe(),
    hF = Pi(async ({ headers: e, body: t }, r) => {
      for (let n of Object.keys(e)) if (n.toLowerCase() === vF) return e[n];
      if (t == null)
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      if (
        typeof t == "string" ||
        ArrayBuffer.isView(t) ||
        (0, ffr.isArrayBuffer)(t)
      ) {
        let n = new r();
        return (
          n.update((0, pfr.toUint8Array)(t)), (0, rp.toHex)(await n.digest())
        );
      }
      return GUe;
    }, "getPayloadHash"),
    PUe = Fe(),
    mfr = class {
      static {
        Pi(this, "HeaderFormatter");
      }
      format(e) {
        let t = [];
        for (let i of Object.keys(e)) {
          let o = (0, PUe.fromUtf8)(i);
          t.push(
            Uint8Array.from([o.byteLength]),
            o,
            this.formatHeaderValue(e[i]),
          );
        }
        let r = new Uint8Array(t.reduce((i, o) => i + o.byteLength, 0)),
          n = 0;
        for (let i of t) r.set(i, n), (n += i.byteLength);
        return r;
      }
      formatHeaderValue(e) {
        switch (e.type) {
          case "boolean":
            return Uint8Array.from([e.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, e.value]);
          case "short":
            let t = new DataView(new ArrayBuffer(3));
            return (
              t.setUint8(0, 3),
              t.setInt16(1, e.value, !1),
              new Uint8Array(t.buffer)
            );
          case "integer":
            let r = new DataView(new ArrayBuffer(5));
            return (
              r.setUint8(0, 4),
              r.setInt32(1, e.value, !1),
              new Uint8Array(r.buffer)
            );
          case "long":
            let n = new Uint8Array(9);
            return (n[0] = 5), n.set(e.value.bytes, 1), n;
          case "binary":
            let i = new DataView(new ArrayBuffer(3 + e.value.byteLength));
            i.setUint8(0, 6), i.setUint16(1, e.value.byteLength, !1);
            let o = new Uint8Array(i.buffer);
            return o.set(e.value, 3), o;
          case "string":
            let a = (0, PUe.fromUtf8)(e.value),
              s = new DataView(new ArrayBuffer(3 + a.byteLength));
            s.setUint8(0, 7), s.setUint16(1, a.byteLength, !1);
            let u = new Uint8Array(s.buffer);
            return u.set(a, 3), u;
          case "timestamp":
            let l = new Uint8Array(9);
            return (
              (l[0] = 8), l.set(gfr.fromNumber(e.value.valueOf()).bytes, 1), l
            );
          case "uuid":
            if (!hfr.test(e.value))
              throw new Error(`Invalid UUID received: ${e.value}`);
            let d = new Uint8Array(17);
            return (
              (d[0] = 9),
              d.set((0, rp.fromHex)(e.value.replace(/\-/g, "")), 1),
              d
            );
        }
      }
    },
    hfr = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    gfr = class KUe {
      constructor(t) {
        if (((this.bytes = t), t.byteLength !== 8))
          throw new Error("Int64 buffers must be exactly 8 bytes");
      }
      static {
        Pi(this, "Int64");
      }
      static fromNumber(t) {
        if (t > 9223372036854776e3 || t < -9223372036854776e3)
          throw new Error(
            `${t} is too large (or, if negative, too small) to represent as an Int64`,
          );
        let r = new Uint8Array(8);
        for (
          let n = 7, i = Math.abs(Math.round(t));
          n > -1 && i > 0;
          n--, i /= 256
        )
          r[n] = i;
        return t < 0 && WY(r), new KUe(r);
      }
      valueOf() {
        let t = this.bytes.slice(0),
          r = t[0] & 128;
        return r && WY(t), parseInt((0, rp.toHex)(t), 16) * (r ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  function WY(e) {
    for (let t = 0; t < 8; t++) e[t] ^= 255;
    for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
  }
  Pi(WY, "negate");
  var WUe = Pi((e, t) => {
      e = e.toLowerCase();
      for (let r of Object.keys(t)) if (e === r.toLowerCase()) return !0;
      return !1;
    }, "hasHeader"),
    QUe = ns(),
    YUe = Pi((e, t = {}) => {
      let { headers: r, query: n = {} } = QUe.HttpRequest.clone(e);
      for (let i of Object.keys(r)) {
        let o = i.toLowerCase();
        ((o.slice(0, 6) === "x-amz-" && !t.unhoistableHeaders?.has(o)) ||
          t.hoistableHeaders?.has(o)) &&
          ((n[i] = r[i]), delete r[i]);
      }
      return { ...e, headers: r, query: n };
    }, "moveHeadersToQuery"),
    QY = Pi((e) => {
      e = QUe.HttpRequest.clone(e);
      for (let t of Object.keys(e.headers))
        MUe.indexOf(t.toLowerCase()) > -1 && delete e.headers[t];
      return e;
    }, "prepareRequest"),
    RUe = _O(),
    vfr = Fe(),
    gF = vY(),
    XUe = Pi(({ query: e = {} }) => {
      let t = [],
        r = {};
      for (let n of Object.keys(e)) {
        if (n.toLowerCase() === qUe) continue;
        let i = (0, gF.escapeUri)(n);
        t.push(i);
        let o = e[n];
        typeof o == "string"
          ? (r[i] = `${i}=${(0, gF.escapeUri)(o)}`)
          : Array.isArray(o) &&
            (r[i] = o
              .slice(0)
              .reduce((a, s) => a.concat([`${i}=${(0, gF.escapeUri)(s)}`]), [])
              .sort()
              .join("&"));
      }
      return t
        .sort()
        .map((n) => r[n])
        .filter((n) => n)
        .join("&");
    }, "getCanonicalQuery"),
    yfr = Pi(
      (e) =>
        _fr(e)
          .toISOString()
          .replace(/\.\d{3}Z$/, "Z"),
      "iso8601",
    ),
    _fr = Pi(
      (e) =>
        typeof e == "number"
          ? new Date(e * 1e3)
          : typeof e == "string"
            ? Number(e)
              ? new Date(Number(e) * 1e3)
              : new Date(e)
            : e,
      "toDate",
    ),
    JUe = class {
      static {
        Pi(this, "SignatureV4Base");
      }
      constructor({
        applyChecksum: e,
        credentials: t,
        region: r,
        service: n,
        sha256: i,
        uriEscapePath: o = !0,
      }) {
        (this.service = n),
          (this.sha256 = i),
          (this.uriEscapePath = o),
          (this.applyChecksum = typeof e == "boolean" ? e : !0),
          (this.regionProvider = (0, RUe.normalizeProvider)(r)),
          (this.credentialProvider = (0, RUe.normalizeProvider)(t));
      }
      createCanonicalRequest(e, t, r) {
        let n = Object.keys(t).sort();
        return `${e.method}
${this.getCanonicalPath(e)}
${XUe(e)}
${n.map((i) => `${i}:${t[i]}`).join(`
`)}

${n.join(";")}
${r}`;
      }
      async createStringToSign(e, t, r, n) {
        let i = new this.sha256();
        i.update((0, vfr.toUint8Array)(r));
        let o = await i.digest();
        return `${n}
${e}
${t}
${(0, rp.toHex)(o)}`;
      }
      getCanonicalPath({ path: e }) {
        if (this.uriEscapePath) {
          let t = [];
          for (let i of e.split("/"))
            i?.length !== 0 && i !== "." && (i === ".." ? t.pop() : t.push(i));
          let r = `${e?.startsWith("/") ? "/" : ""}${t.join("/")}${t.length > 0 && e?.endsWith("/") ? "/" : ""}`;
          return (0, gF.escapeUri)(r).replace(/%2F/g, "/");
        }
        return e;
      }
      validateResolvedCredentials(e) {
        if (
          typeof e != "object" ||
          typeof e.accessKeyId != "string" ||
          typeof e.secretAccessKey != "string"
        )
          throw new Error("Resolved credential object is not valid");
      }
      formatDate(e) {
        let t = yfr(e).replace(/[\-:]/g, "");
        return { longDate: t, shortDate: t.slice(0, 8) };
      }
      getCanonicalHeaderList(e) {
        return Object.keys(e).sort().join(";");
      }
    },
    Efr = class extends JUe {
      constructor({
        applyChecksum: e,
        credentials: t,
        region: r,
        service: n,
        sha256: i,
        uriEscapePath: o = !0,
      }) {
        super({
          applyChecksum: e,
          credentials: t,
          region: r,
          service: n,
          sha256: i,
          uriEscapePath: o,
        }),
          (this.headerFormatter = new mfr());
      }
      static {
        Pi(this, "SignatureV4");
      }
      async presign(e, t = {}) {
        let {
            signingDate: r = new Date(),
            expiresIn: n = 3600,
            unsignableHeaders: i,
            unhoistableHeaders: o,
            signableHeaders: a,
            hoistableHeaders: s,
            signingRegion: u,
            signingService: l,
          } = t,
          d = await this.credentialProvider();
        this.validateResolvedCredentials(d);
        let f = u ?? (await this.regionProvider()),
          { longDate: m, shortDate: h } = this.formatDate(r);
        if (n > $Ue)
          return Promise.reject(
            "Signature version 4 presigned URLs must have an expiration date less than one week in the future",
          );
        let y = mF(h, f, l ?? this.service),
          _ = YUe(QY(e), { unhoistableHeaders: o, hoistableHeaders: s });
        d.sessionToken && (_.query[JY] = d.sessionToken),
          (_.query[xUe] = fF),
          (_.query[NUe] = `${d.accessKeyId}/${y}`),
          (_.query[YY] = m),
          (_.query[DUe] = n.toString(10));
        let E = KY(_, i, a);
        return (
          (_.query[kUe] = this.getCanonicalHeaderList(E)),
          (_.query[XY] = await this.getSignature(
            m,
            y,
            this.getSigningKey(d, f, h, l),
            this.createCanonicalRequest(_, E, await hF(e, this.sha256)),
          )),
          _
        );
      }
      async sign(e, t) {
        return typeof e == "string"
          ? this.signString(e, t)
          : e.headers && e.payload
            ? this.signEvent(e, t)
            : e.message
              ? this.signMessage(e, t)
              : this.signRequest(e, t);
      }
      async signEvent(
        { headers: e, payload: t },
        {
          signingDate: r = new Date(),
          priorSignature: n,
          signingRegion: i,
          signingService: o,
        },
      ) {
        let a = i ?? (await this.regionProvider()),
          { shortDate: s, longDate: u } = this.formatDate(r),
          l = mF(s, a, o ?? this.service),
          d = await hF({ headers: {}, body: t }, this.sha256),
          f = new this.sha256();
        f.update(e);
        let m = (0, rp.toHex)(await f.digest()),
          h = [HUe, u, l, n, m, d].join(`
`);
        return this.signString(h, {
          signingDate: r,
          signingRegion: a,
          signingService: o,
        });
      }
      async signMessage(
        e,
        { signingDate: t = new Date(), signingRegion: r, signingService: n },
      ) {
        return this.signEvent(
          {
            headers: this.headerFormatter.format(e.message.headers),
            payload: e.message.body,
          },
          {
            signingDate: t,
            signingRegion: r,
            signingService: n,
            priorSignature: e.priorSignature,
          },
        ).then((o) => ({ message: e.message, signature: o }));
      }
      async signString(
        e,
        {
          signingDate: t = new Date(),
          signingRegion: r,
          signingService: n,
        } = {},
      ) {
        let i = await this.credentialProvider();
        this.validateResolvedCredentials(i);
        let o = r ?? (await this.regionProvider()),
          { shortDate: a } = this.formatDate(t),
          s = new this.sha256(await this.getSigningKey(i, o, a, n));
        return (
          s.update((0, TUe.toUint8Array)(e)), (0, rp.toHex)(await s.digest())
        );
      }
      async signRequest(
        e,
        {
          signingDate: t = new Date(),
          signableHeaders: r,
          unsignableHeaders: n,
          signingRegion: i,
          signingService: o,
        } = {},
      ) {
        let a = await this.credentialProvider();
        this.validateResolvedCredentials(a);
        let s = i ?? (await this.regionProvider()),
          u = QY(e),
          { longDate: l, shortDate: d } = this.formatDate(t),
          f = mF(d, s, o ?? this.service);
        (u.headers[eX] = l),
          a.sessionToken && (u.headers[jUe] = a.sessionToken);
        let m = await hF(u, this.sha256);
        !WUe(vF, u.headers) && this.applyChecksum && (u.headers[vF] = m);
        let h = KY(u, n, r),
          y = await this.getSignature(
            l,
            f,
            this.getSigningKey(a, s, d, o),
            this.createCanonicalRequest(u, h, m),
          );
        return (
          (u.headers[ZY] =
            `${fF} Credential=${a.accessKeyId}/${f}, SignedHeaders=${this.getCanonicalHeaderList(h)}, Signature=${y}`),
          u
        );
      }
      async getSignature(e, t, r, n) {
        let i = await this.createStringToSign(e, t, n, fF),
          o = new this.sha256(await r);
        return (
          o.update((0, TUe.toUint8Array)(i)), (0, rp.toHex)(await o.digest())
        );
      }
      getSigningKey(e, t, r, n) {
        return zUe(this.sha256, e, r, t, n || this.service);
      }
    },
    bfr = { SignatureV4a: null };
});
var nX,
  Sfr,
  eHe = w(() => {
    c();
    (nX = { warningEmitted: !1 }),
      (Sfr = (e) => {
        e &&
          !nX.warningEmitted &&
          parseInt(e.substring(1, e.indexOf("."))) < 18 &&
          ((nX.warningEmitted = !0),
          process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`));
      });
  });
function iX(e, t, r) {
  return e.$source || (e.$source = {}), (e.$source[t] = r), e;
}
var tHe = w(() => {
  c();
});
function Cfr(e, t, r) {
  e.__aws_sdk_context
    ? e.__aws_sdk_context.features || (e.__aws_sdk_context.features = {})
    : (e.__aws_sdk_context = { features: {} }),
    (e.__aws_sdk_context.features[t] = r);
}
var rHe = w(() => {
  c();
});
var oX = w(() => {
  c();
  eHe();
  tHe();
  rHe();
});
var nHe,
  aX,
  iHe = w(() => {
    c();
    (nHe = A(ns())),
      (aX = (e) =>
        nHe.HttpResponse.isInstance(e)
          ? (e.headers?.date ?? e.headers?.Date)
          : void 0);
  });
var lE,
  sX = w(() => {
    c();
    lE = (e) => new Date(Date.now() + e);
  });
var oHe,
  aHe = w(() => {
    c();
    sX();
    oHe = (e, t) => Math.abs(lE(t).getTime() - e) >= 3e5;
  });
var cX,
  sHe = w(() => {
    c();
    aHe();
    cX = (e, t) => {
      let r = Date.parse(e);
      return oHe(r, t) ? r - Date.now() : t;
    };
  });
var uX = w(() => {
  c();
  iHe();
  sX();
  sHe();
});
var cHe,
  EO,
  bO,
  kh,
  uHe,
  lX = w(() => {
    c();
    cHe = A(ns());
    uX();
    (EO = (e, t) => {
      if (!t)
        throw new Error(
          `Property \`${e}\` is not resolved for AWS SDK SigV4Auth`,
        );
      return t;
    }),
      (bO = async (e) => {
        let t = EO("context", e.context),
          r = EO("config", e.config),
          n = t.endpointV2?.properties?.authSchemes?.[0],
          o = await EO("signer", r.signer)(n),
          a = e?.signingRegion,
          s = e?.signingRegionSet,
          u = e?.signingName;
        return {
          config: r,
          signer: o,
          signingRegion: a,
          signingRegionSet: s,
          signingName: u,
        };
      }),
      (kh = class {
        async sign(t, r, n) {
          if (!cHe.HttpRequest.isInstance(t))
            throw new Error(
              "The request is not an instance of `HttpRequest` and cannot be signed",
            );
          let i = await bO(n),
            { config: o, signer: a } = i,
            { signingRegion: s, signingName: u } = i,
            l = n.context;
          if (l?.authSchemes?.length ?? !1) {
            let [f, m] = l.authSchemes;
            f?.name === "sigv4a" &&
              m?.name === "sigv4" &&
              ((s = m?.signingRegion ?? s), (u = m?.signingName ?? u));
          }
          return await a.sign(t, {
            signingDate: lE(o.systemClockOffset),
            signingRegion: s,
            signingService: u,
          });
        }
        errorHandler(t) {
          return (r) => {
            let n = r.ServerTime ?? aX(r.$response);
            if (n) {
              let i = EO("config", t.config),
                o = i.systemClockOffset;
              (i.systemClockOffset = cX(n, i.systemClockOffset)),
                i.systemClockOffset !== o &&
                  r.$metadata &&
                  (r.$metadata.clockSkewCorrected = !0);
            }
            throw r;
          };
        }
        successHandler(t, r) {
          let n = aX(t);
          if (n) {
            let i = EO("config", r.config);
            i.systemClockOffset = cX(n, i.systemClockOffset);
          }
        }
      }),
      (uHe = kh);
  });
var lHe,
  _F,
  dHe = w(() => {
    c();
    lHe = A(ns());
    uX();
    lX();
    _F = class extends kh {
      async sign(t, r, n) {
        if (!lHe.HttpRequest.isInstance(t))
          throw new Error(
            "The request is not an instance of `HttpRequest` and cannot be signed",
          );
        let {
            config: i,
            signer: o,
            signingRegion: a,
            signingRegionSet: s,
            signingName: u,
          } = await bO(n),
          d = ((await i.sigv4aSigningRegionSet?.()) ?? s ?? [a]).join(",");
        return await o.sign(t, {
          signingDate: lE(i.systemClockOffset),
          signingRegion: d,
          signingService: u,
        });
      }
    };
  });
var dX,
  fHe = w(() => {
    c();
    dX = (e) =>
      typeof e == "string" && e.length > 0
        ? e.split(",").map((t) => t.trim())
        : [];
  });
var pHe,
  mHe,
  wfr,
  hHe = w(() => {
    c();
    fHe();
    (pHe = "AWS_AUTH_SCHEME_PREFERENCE"),
      (mHe = "auth_scheme_preference"),
      (wfr = {
        environmentVariableSelector: (e) => {
          if (pHe in e) return dX(e[pHe]);
        },
        configFileSelector: (e) => {
          if (mHe in e) return dX(e[mHe]);
        },
        default: [],
      });
  });
var fX,
  Ofr,
  gHe = w(() => {
    c();
    (fX = A(Xf())),
      (Ofr = (e) =>
        e[fX.SMITHY_CONTEXT_KEY] || (e[fX.SMITHY_CONTEXT_KEY] = {}));
  });
var vHe,
  yHe = w(() => {
    c();
    vHe = (e, t) => {
      if (!t || t.length === 0) return e;
      let r = [];
      for (let n of t)
        for (let i of e) i.schemeId.split("#")[1] === n && r.push(i);
      for (let n of e)
        r.find(({ schemeId: i }) => i === n.schemeId) || r.push(n);
      return r;
    };
  });
function Tfr(e) {
  let t = new Map();
  for (let r of e) t.set(r.schemeId, r);
  return t;
}
var YFn,
  _He,
  SO,
  EF = w(() => {
    c();
    (YFn = A(Xf())), (_He = A(_O()));
    yHe();
    SO = (e, t) => (r, n) => async (i) => {
      let o = e.httpAuthSchemeProvider(
          await t.httpAuthSchemeParametersProvider(e, n, i.input),
        ),
        a = e.authSchemePreference ? await e.authSchemePreference() : [],
        s = vHe(o, a),
        u = Tfr(e.httpAuthSchemes),
        l = (0, _He.getSmithyContext)(n),
        d = [];
      for (let f of s) {
        let m = u.get(f.schemeId);
        if (!m) {
          d.push(
            `HttpAuthScheme \`${f.schemeId}\` was not enabled for this service.`,
          );
          continue;
        }
        let h = m.identityProvider(await t.identityProviderConfigProvider(e));
        if (!h) {
          d.push(
            `HttpAuthScheme \`${f.schemeId}\` did not have an IdentityProvider configured.`,
          );
          continue;
        }
        let { identityProperties: y = {}, signingProperties: _ = {} } =
          f.propertiesExtractor?.(e, n) || {};
        (f.identityProperties = Object.assign(f.identityProperties || {}, y)),
          (f.signingProperties = Object.assign(f.signingProperties || {}, _)),
          (l.selectedHttpAuthScheme = {
            httpAuthOption: f,
            identity: await h(f.identityProperties),
            signer: m.signer,
          });
        break;
      }
      if (!l.selectedHttpAuthScheme)
        throw new Error(
          d.join(`
`),
        );
      return r(i);
    };
  });
var EHe,
  Afr,
  bHe = w(() => {
    c();
    EF();
    (EHe = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: "endpointV2Middleware",
    }),
      (Afr = (
        e,
        {
          httpAuthSchemeParametersProvider: t,
          identityProviderConfigProvider: r,
        },
      ) => ({
        applyToStack: (n) => {
          n.addRelativeTo(
            SO(e, {
              httpAuthSchemeParametersProvider: t,
              identityProviderConfigProvider: r,
            }),
            EHe,
          );
        },
      }));
  });
var RHe = g((i1n, PHe) => {
  c();
  var bF = Object.defineProperty,
    Pfr = Object.getOwnPropertyDescriptor,
    Rfr = Object.getOwnPropertyNames,
    Ifr = Object.prototype.hasOwnProperty,
    pX = (e, t) => bF(e, "name", { value: t, configurable: !0 }),
    xfr = (e, t) => {
      for (var r in t) bF(e, r, { get: t[r], enumerable: !0 });
    },
    Nfr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Rfr(t))
          !Ifr.call(e, i) &&
            i !== r &&
            bF(e, i, {
              get: () => t[i],
              enumerable: !(n = Pfr(t, i)) || n.enumerable,
            });
      return e;
    },
    kfr = (e) => Nfr(bF({}, "__esModule", { value: !0 }), e),
    SHe = {};
  xfr(SHe, {
    deserializerMiddleware: () => CHe,
    deserializerMiddlewareOption: () => OHe,
    getSerdePlugin: () => AHe,
    serializerMiddleware: () => wHe,
    serializerMiddlewareOption: () => THe,
  });
  PHe.exports = kfr(SHe);
  var CHe = pX(
      (e, t) => (r, n) => async (i) => {
        let { response: o } = await r(i);
        try {
          let a = await t(o, e);
          return { response: o, output: a };
        } catch (a) {
          if (
            (Object.defineProperty(a, "$response", { value: o }),
            !("$metadata" in a))
          ) {
            let s =
              "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
            try {
              a.message +=
                `
  ` + s;
            } catch {
              !n.logger || n.logger?.constructor?.name === "NoOpLogger"
                ? console.warn(s)
                : n.logger?.warn?.(s);
            }
            typeof a.$responseBodyText < "u" &&
              a.$response &&
              (a.$response.body = a.$responseBodyText);
          }
          throw a;
        }
      },
      "deserializerMiddleware",
    ),
    wHe = pX(
      (e, t) => (r, n) => async (i) => {
        let o =
          n.endpointV2?.url && e.urlParser
            ? async () => e.urlParser(n.endpointV2.url)
            : e.endpoint;
        if (!o) throw new Error("No valid endpoint provider available.");
        let a = await t(i.input, { ...e, endpoint: o });
        return r({ ...i, request: a });
      },
      "serializerMiddleware",
    ),
    OHe = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: !0,
    },
    THe = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: !0,
    };
  function AHe(e, t, r) {
    return {
      applyToStack: (n) => {
        n.add(CHe(e, r), OHe), n.add(wHe(e, t), THe);
      },
    };
  }
  pX(AHe, "getSerdePlugin");
});
var IHe,
  xHe,
  Dfr,
  NHe = w(() => {
    c();
    IHe = A(RHe());
    EF();
    (xHe = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: IHe.serializerMiddlewareOption.name,
    }),
      (Dfr = (
        e,
        {
          httpAuthSchemeParametersProvider: t,
          identityProviderConfigProvider: r,
        },
      ) => ({
        applyToStack: (n) => {
          n.addRelativeTo(
            SO(e, {
              httpAuthSchemeParametersProvider: t,
              identityProviderConfigProvider: r,
            }),
            xHe,
          );
        },
      }));
  });
var kHe = w(() => {
  c();
  EF();
  bHe();
  NHe();
});
var DHe,
  m1n,
  LHe,
  Lfr,
  Mfr,
  mX,
  hX = w(() => {
    c();
    (DHe = A(ns())),
      (m1n = A(Xf())),
      (LHe = A(_O())),
      (Lfr = (e) => (t) => {
        throw t;
      }),
      (Mfr = (e, t) => {}),
      (mX = (e) => (t, r) => async (n) => {
        if (!DHe.HttpRequest.isInstance(n.request)) return t(n);
        let o = (0, LHe.getSmithyContext)(r).selectedHttpAuthScheme;
        if (!o)
          throw new Error(
            "No HttpAuthScheme was selected: unable to sign request",
          );
        let {
            httpAuthOption: { signingProperties: a = {} },
            identity: s,
            signer: u,
          } = o,
          l = await t({ ...n, request: await u.sign(n.request, s, a) }).catch(
            (u.errorHandler || Lfr)(a),
          );
        return (u.successHandler || Mfr)(l.response, a), l;
      });
  });
var MHe,
  qfr,
  qHe = w(() => {
    c();
    hX();
    (MHe = {
      step: "finalizeRequest",
      tags: ["HTTP_SIGNING"],
      name: "httpSigningMiddleware",
      aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
      override: !0,
      relation: "after",
      toMiddleware: "retryMiddleware",
    }),
      (qfr = (e) => ({
        applyToStack: (t) => {
          t.addRelativeTo(mX(e), MHe);
        },
      }));
  });
var jHe = w(() => {
  c();
  hX();
  qHe();
});
var np,
  FHe = w(() => {
    c();
    np = (e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    };
  });
function BHe(e, t, r, n, i) {
  return async function* (a, s, ...u) {
    let l = s,
      d = a.startingToken ?? l[r],
      f = !0,
      m;
    for (; f; ) {
      if (((l[r] = d), i && (l[i] = l[i] ?? a.pageSize), a.client instanceof e))
        m = await jfr(t, a.client, s, a.withCommand, ...u);
      else throw new Error(`Invalid client, expected instance of ${e.name}`);
      yield m;
      let h = d;
      (d = Ffr(m, n)), (f = !!(d && (!a.stopOnSameToken || d !== h)));
    }
    return void 0;
  };
}
var jfr,
  Ffr,
  UHe = w(() => {
    c();
    jfr = async (e, t, r, n = (o) => o, ...i) => {
      let o = new e(r);
      return (o = n(o) ?? o), await t.send(o, ...i);
    };
    Ffr = (e, t) => {
      let r = e,
        n = t.split(".");
      for (let i of n) {
        if (!r || typeof r != "object") return;
        r = r[i];
      }
      return r;
    };
  });
var HHe = w(() => {
  c();
  DY();
});
function Bfr(e, t, r) {
  e.__smithy_context
    ? e.__smithy_context.features || (e.__smithy_context.features = {})
    : (e.__smithy_context = { features: {} }),
    (e.__smithy_context.features[t] = r);
}
var GHe = w(() => {
  c();
});
var gX,
  VHe = w(() => {
    c();
    gX = class {
      constructor(t) {
        this.authSchemes = new Map();
        for (let [r, n] of Object.entries(t))
          n !== void 0 && this.authSchemes.set(r, n);
      }
      getIdentityProvider(t) {
        return this.authSchemes.get(t);
      }
    };
  });
var $He,
  vX,
  yX,
  zHe = w(() => {
    c();
    ($He = A(ns())),
      (vX = A(Xf())),
      (yX = class {
        async sign(t, r, n) {
          if (!n)
            throw new Error(
              "request could not be signed with `apiKey` since the `name` and `in` signer properties are missing",
            );
          if (!n.name)
            throw new Error(
              "request could not be signed with `apiKey` since the `name` signer property is missing",
            );
          if (!n.in)
            throw new Error(
              "request could not be signed with `apiKey` since the `in` signer property is missing",
            );
          if (!r.apiKey)
            throw new Error(
              "request could not be signed with `apiKey` since the `apiKey` is not defined",
            );
          let i = $He.HttpRequest.clone(t);
          if (n.in === vX.HttpApiKeyAuthLocation.QUERY)
            i.query[n.name] = r.apiKey;
          else if (n.in === vX.HttpApiKeyAuthLocation.HEADER)
            i.headers[n.name] = n.scheme ? `${n.scheme} ${r.apiKey}` : r.apiKey;
          else
            throw new Error(
              "request can only be signed with `apiKey` locations `query` or `header`, but found: `" +
                n.in +
                "`",
            );
          return i;
        }
      });
  });
var KHe,
  _X,
  WHe = w(() => {
    c();
    (KHe = A(ns())),
      (_X = class {
        async sign(t, r, n) {
          let i = KHe.HttpRequest.clone(t);
          if (!r.token)
            throw new Error(
              "request could not be signed with `token` since the `token` is not defined",
            );
          return (i.headers.Authorization = `Bearer ${r.token}`), i;
        }
      });
  });
var EX,
  QHe = w(() => {
    c();
    EX = class {
      async sign(t, r, n) {
        return t;
      }
    };
  });
var YHe = w(() => {
  c();
  zHe();
  WHe();
  QHe();
});
var XHe,
  Ufr,
  bX,
  SF,
  SX,
  JHe = w(() => {
    c();
    (XHe = (e) => (t) => SF(t) && t.expiration.getTime() - Date.now() < e),
      (Ufr = 3e5),
      (bX = XHe(3e5)),
      (SF = (e) => e.expiration !== void 0),
      (SX = (e, t, r) => {
        if (e === void 0) return;
        let n = typeof e != "function" ? async () => Promise.resolve(e) : e,
          i,
          o,
          a,
          s = !1,
          u = async (l) => {
            o || (o = n(l));
            try {
              (i = await o), (a = !0), (s = !1);
            } finally {
              o = void 0;
            }
            return i;
          };
        return t === void 0
          ? async (l) => ((!a || l?.forceRefresh) && (i = await u(l)), i)
          : async (l) => (
              (!a || l?.forceRefresh) && (i = await u(l)),
              s ? i : r(i) ? (t(i) && (await u(l)), i) : ((s = !0), i)
            );
      });
  });
var ZHe = w(() => {
  c();
  VHe();
  YHe();
  JHe();
});
var e3e = {};
bn(e3e, {
  DefaultIdentityProviderConfig: () => gX,
  EXPIRATION_MS: () => Ufr,
  HttpApiKeyAuthSigner: () => yX,
  HttpBearerAuthSigner: () => _X,
  NoAuthSigner: () => EX,
  createIsIdentityExpiredFunction: () => XHe,
  createPaginator: () => BHe,
  doesIdentityRequireRefresh: () => SF,
  getHttpAuthSchemeEndpointRuleSetPlugin: () => Afr,
  getHttpAuthSchemePlugin: () => Dfr,
  getHttpSigningPlugin: () => qfr,
  getSmithyContext: () => Ofr,
  httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => EHe,
  httpAuthSchemeMiddleware: () => SO,
  httpAuthSchemeMiddlewareOptions: () => xHe,
  httpSigningMiddleware: () => mX,
  httpSigningMiddlewareOptions: () => MHe,
  isIdentityExpired: () => bX,
  memoizeIdentityProvider: () => SX,
  normalizeProvider: () => np,
  requestBuilder: () => kY,
  setFeature: () => Bfr,
});
var CF = w(() => {
  c();
  gHe();
  kHe();
  jHe();
  FHe();
  UHe();
  HHe();
  GHe();
  ZHe();
});
var a3e = g((uBn, o3e) => {
  c();
  var wF = Object.defineProperty,
    Hfr = Object.getOwnPropertyDescriptor,
    Gfr = Object.getOwnPropertyNames,
    Vfr = Object.prototype.hasOwnProperty,
    Dh = (e, t) => wF(e, "name", { value: t, configurable: !0 }),
    $fr = (e, t) => {
      for (var r in t) wF(e, r, { get: t[r], enumerable: !0 });
    },
    zfr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Gfr(t))
          !Vfr.call(e, i) &&
            i !== r &&
            wF(e, i, {
              get: () => t[i],
              enumerable: !(n = Hfr(t, i)) || n.enumerable,
            });
      return e;
    },
    Kfr = (e) => zfr(wF({}, "__esModule", { value: !0 }), e),
    t3e = {};
  $fr(t3e, {
    CredentialsProviderError: () => Wfr,
    ProviderError: () => OF,
    TokenProviderError: () => Qfr,
    chain: () => Yfr,
    fromStatic: () => Xfr,
    memoize: () => Jfr,
  });
  o3e.exports = Kfr(t3e);
  var OF = class r3e extends Error {
      constructor(t, r = !0) {
        let n,
          i = !0;
        typeof r == "boolean"
          ? ((n = void 0), (i = r))
          : r != null &&
            typeof r == "object" &&
            ((n = r.logger), (i = r.tryNextLink ?? !0)),
          super(t),
          (this.name = "ProviderError"),
          (this.tryNextLink = i),
          Object.setPrototypeOf(this, r3e.prototype),
          n?.debug?.(`@smithy/property-provider ${i ? "->" : "(!)"} ${t}`);
      }
      static {
        Dh(this, "ProviderError");
      }
      static from(t, r = !0) {
        return Object.assign(new this(t.message, r), t);
      }
    },
    Wfr = class n3e extends OF {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "CredentialsProviderError"),
          Object.setPrototypeOf(this, n3e.prototype);
      }
      static {
        Dh(this, "CredentialsProviderError");
      }
    },
    Qfr = class i3e extends OF {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "TokenProviderError"),
          Object.setPrototypeOf(this, i3e.prototype);
      }
      static {
        Dh(this, "TokenProviderError");
      }
    },
    Yfr = Dh(
      (...e) =>
        async () => {
          if (e.length === 0) throw new OF("No providers in chain");
          let t;
          for (let r of e)
            try {
              return await r();
            } catch (n) {
              if (((t = n), n?.tryNextLink)) continue;
              throw n;
            }
          throw t;
        },
      "chain",
    ),
    Xfr = Dh((e) => () => Promise.resolve(e), "fromStatic"),
    Jfr = Dh((e, t, r) => {
      let n,
        i,
        o,
        a = !1,
        s = Dh(async () => {
          i || (i = e());
          try {
            (n = await i), (o = !0), (a = !1);
          } finally {
            i = void 0;
          }
          return n;
        }, "coalesceProvider");
      return t === void 0
        ? async (u) => ((!o || u?.forceRefresh) && (n = await s()), n)
        : async (u) => (
            (!o || u?.forceRefresh) && (n = await s()),
            a ? n : r && !r(n) ? ((a = !0), n) : (t(n) && (await s()), n)
          );
    }, "memoize");
});
var CX,
  Zfr,
  epr,
  s3e = w(() => {
    c();
    CF();
    (CX = A(a3e())),
      (Zfr = (e) => (
        (e.sigv4aSigningRegionSet = np(e.sigv4aSigningRegionSet)), e
      )),
      (epr = {
        environmentVariableSelector(e) {
          if (e.AWS_SIGV4A_SIGNING_REGION_SET)
            return e.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((t) =>
              t.trim(),
            );
          throw new CX.ProviderError(
            "AWS_SIGV4A_SIGNING_REGION_SET not set in env.",
            { tryNextLink: !0 },
          );
        },
        configFileSelector(e) {
          if (e.sigv4a_signing_region_set)
            return (e.sigv4a_signing_region_set ?? "")
              .split(",")
              .map((t) => t.trim());
          throw new CX.ProviderError(
            "sigv4a_signing_region_set not set in profile.",
            { tryNextLink: !0 },
          );
        },
        default: void 0,
      });
  });
function rpr(e, { credentials: t, credentialDefaultProvider: r }) {
  let n;
  return (
    t
      ? t?.memoized
        ? (n = t)
        : (n = SX(t, bX, SF))
      : r
        ? (n = np(r(Object.assign({}, e, { parentClientConfig: e }))))
        : (n = async () => {
            throw new Error(
              "@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.",
            );
          }),
    (n.memoized = !0),
    n
  );
}
function npr(e, t) {
  if (t.configBound) return t;
  let r = async (n) => t({ ...n, callerClientConfig: e });
  return (r.memoized = t.memoized), (r.configBound = !0), r;
}
var wX,
  c3e,
  tpr,
  u3e = w(() => {
    c();
    oX();
    CF();
    (wX = A(rX())),
      (c3e = (e) => {
        let t = e.credentials,
          r = !!e.credentials,
          n;
        Object.defineProperty(e, "credentials", {
          set(l) {
            l && l !== t && l !== n && (r = !0), (t = l);
            let d = rpr(e, {
                credentials: t,
                credentialDefaultProvider: e.credentialDefaultProvider,
              }),
              f = npr(e, d);
            r && !f.attributed
              ? ((n = async (m) =>
                  f(m).then((h) => iX(h, "CREDENTIALS_CODE", "e"))),
                (n.memoized = f.memoized),
                (n.configBound = f.configBound),
                (n.attributed = !0))
              : (n = f);
          },
          get() {
            return n;
          },
          enumerable: !0,
          configurable: !0,
        }),
          (e.credentials = t);
        let {
            signingEscapePath: i = !0,
            systemClockOffset: o = e.systemClockOffset || 0,
            sha256: a,
          } = e,
          s;
        return (
          e.signer
            ? (s = np(e.signer))
            : e.regionInfoProvider
              ? (s = () =>
                  np(e.region)()
                    .then(async (l) => [
                      (await e.regionInfoProvider(l, {
                        useFipsEndpoint: await e.useFipsEndpoint(),
                        useDualstackEndpoint: await e.useDualstackEndpoint(),
                      })) || {},
                      l,
                    ])
                    .then(([l, d]) => {
                      let { signingRegion: f, signingService: m } = l;
                      (e.signingRegion = e.signingRegion || f || d),
                        (e.signingName = e.signingName || m || e.serviceId);
                      let h = {
                          ...e,
                          credentials: e.credentials,
                          region: e.signingRegion,
                          service: e.signingName,
                          sha256: a,
                          uriEscapePath: i,
                        },
                        y = e.signerConstructor || wX.SignatureV4;
                      return new y(h);
                    }))
              : (s = async (l) => {
                  l = Object.assign(
                    {},
                    {
                      name: "sigv4",
                      signingName: e.signingName || e.defaultSigningName,
                      signingRegion: await np(e.region)(),
                      properties: {},
                    },
                    l,
                  );
                  let d = l.signingRegion,
                    f = l.signingName;
                  (e.signingRegion = e.signingRegion || d),
                    (e.signingName = e.signingName || f || e.serviceId);
                  let m = {
                      ...e,
                      credentials: e.credentials,
                      region: e.signingRegion,
                      service: e.signingName,
                      sha256: a,
                      uriEscapePath: i,
                    },
                    h = e.signerConstructor || wX.SignatureV4;
                  return new h(m);
                }),
          Object.assign(e, {
            systemClockOffset: o,
            signingEscapePath: i,
            signer: s,
          })
        );
      }),
      (tpr = c3e);
  });
var l3e = w(() => {
  c();
  lX();
  dHe();
  hHe();
  s3e();
  u3e();
});
var d3e = w(() => {
  c();
  l3e();
});
var ipr,
  opr,
  apr,
  f3e = w(() => {
    c();
    (ipr = (e) => {
      if (e == null) return e;
      if (typeof e == "number" || typeof e == "bigint") {
        let t = new Error(`Received number ${e} where a string was expected.`);
        return (t.name = "Warning"), console.warn(t), String(e);
      }
      if (typeof e == "boolean") {
        let t = new Error(`Received boolean ${e} where a string was expected.`);
        return (t.name = "Warning"), console.warn(t), String(e);
      }
      return e;
    }),
      (opr = (e) => {
        if (e == null) return e;
        if (typeof e == "string") {
          let t = e.toLowerCase();
          if (e !== "" && t !== "false" && t !== "true") {
            let r = new Error(
              `Received string "${e}" where a boolean was expected.`,
            );
            (r.name = "Warning"), console.warn(r);
          }
          return e !== "" && t !== "false";
        }
        return e;
      }),
      (apr = (e) => {
        if (e == null) return e;
        if (typeof e == "string") {
          let t = Number(e);
          if (t.toString() !== e) {
            let r = new Error(
              `Received string "${e}" where a number was expected.`,
            );
            return (r.name = "Warning"), console.warn(r), e;
          }
          return t;
        }
        return e;
      });
  });
var p3e,
  spr,
  m3e = w(() => {
    c();
    (p3e = A(yO())),
      (spr = (e) => {
        if (e != null)
          return (
            typeof e == "object" && "__type" in e && delete e.__type,
            (0, p3e.expectUnion)(e)
          );
      });
  });
var h3e,
  TF,
  OX = w(() => {
    c();
    (h3e = A(yO())),
      (TF = (e, t) => (0, h3e.collectBody)(e, t).then((r) => t.utf8Encoder(r)));
  });
var g3e,
  cpr,
  upr,
  v3e = w(() => {
    c();
    OX();
    (g3e = (e, t) =>
      TF(e, t).then((r) => {
        if (r.length)
          try {
            return JSON.parse(r);
          } catch (n) {
            throw (
              (n?.name === "SyntaxError" &&
                Object.defineProperty(n, "$responseBodyText", { value: r }),
              n)
            );
          }
        return {};
      })),
      (cpr = async (e, t) => {
        let r = await g3e(e, t);
        return (r.message = r.message ?? r.Message), r;
      }),
      (upr = (e, t) => {
        let r = (o, a) =>
            Object.keys(o).find((s) => s.toLowerCase() === a.toLowerCase()),
          n = (o) => {
            let a = o;
            return (
              typeof a == "number" && (a = a.toString()),
              a.indexOf(",") >= 0 && (a = a.split(",")[0]),
              a.indexOf(":") >= 0 && (a = a.split(":")[0]),
              a.indexOf("#") >= 0 && (a = a.split("#")[1]),
              a
            );
          },
          i = r(e.headers, "x-amzn-errortype");
        if (i !== void 0) return n(e.headers[i]);
        if (t.code !== void 0) return n(t.code);
        if (t.__type !== void 0) return n(t.__type);
      });
  });
var y3e,
  _3e,
  E3e,
  lpr,
  dpr,
  b3e = w(() => {
    c();
    (y3e = A(yO())), (_3e = A(UC()));
    OX();
    (E3e = (e, t) =>
      TF(e, t).then((r) => {
        if (r.length) {
          let n = new _3e.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: (u, l) =>
              l.trim() === "" &&
              l.includes(`
`)
                ? ""
                : void 0,
          });
          n.addEntity("#xD", "\r"),
            n.addEntity(
              "#10",
              `
`,
            );
          let i;
          try {
            i = n.parse(r, !0);
          } catch (u) {
            throw (
              (u &&
                typeof u == "object" &&
                Object.defineProperty(u, "$responseBodyText", { value: r }),
              u)
            );
          }
          let o = "#text",
            a = Object.keys(i)[0],
            s = i[a];
          return (
            s[o] && ((s[a] = s[o]), delete s[o]),
            (0, y3e.getValueFromTextNode)(s)
          );
        }
        return {};
      })),
      (lpr = async (e, t) => {
        let r = await E3e(e, t);
        return (
          r.Error && (r.Error.message = r.Error.message ?? r.Error.Message), r
        );
      }),
      (dpr = (e, t) => {
        if (t?.Error?.Code !== void 0) return t.Error.Code;
        if (t?.Code !== void 0) return t.Code;
        if (e.statusCode == 404) return "NotFound";
      });
  });
var S3e = w(() => {
  c();
  f3e();
  m3e();
  v3e();
  b3e();
});
var C3e = {};
bn(C3e, {
  AWSSDKSigV4Signer: () => uHe,
  AwsSdkSigV4ASigner: () => _F,
  AwsSdkSigV4Signer: () => kh,
  NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => wfr,
  NODE_SIGV4A_CONFIG_OPTIONS: () => epr,
  _toBool: () => opr,
  _toNum: () => apr,
  _toStr: () => ipr,
  awsExpectUnion: () => spr,
  emitWarningIfUnsupportedVersion: () => Sfr,
  loadRestJsonErrorCode: () => upr,
  loadRestXmlErrorCode: () => dpr,
  parseJsonBody: () => g3e,
  parseJsonErrorBody: () => cpr,
  parseXmlBody: () => E3e,
  parseXmlErrorBody: () => lpr,
  resolveAWSSDKSigV4Config: () => tpr,
  resolveAwsSdkSigV4AConfig: () => Zfr,
  resolveAwsSdkSigV4Config: () => c3e,
  setCredentialFeature: () => iX,
  setFeature: () => Cfr,
  state: () => nX,
  validateSigningProperties: () => bO,
});
var w3e = w(() => {
  c();
  oX();
  d3e();
  S3e();
});
var AX = g((YBn, T3e) => {
  "use strict";
  c();
  var AF = Object.defineProperty,
    fpr = Object.getOwnPropertyDescriptor,
    ppr = Object.getOwnPropertyNames,
    mpr = Object.prototype.hasOwnProperty,
    TX = (e, t) => AF(e, "name", { value: t, configurable: !0 }),
    hpr = (e, t) => {
      for (var r in t) AF(e, r, { get: t[r], enumerable: !0 });
    },
    gpr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of ppr(t))
          !mpr.call(e, i) &&
            i !== r &&
            AF(e, i, {
              get: () => t[i],
              enumerable: !(n = fpr(t, i)) || n.enumerable,
            });
      return e;
    },
    vpr = (e) => gpr(AF({}, "__esModule", { value: !0 }), e),
    O3e = {};
  hpr(O3e, { build: () => Epr, parse: () => _pr, validate: () => ypr });
  T3e.exports = vpr(O3e);
  var ypr = TX(
      (e) =>
        typeof e == "string" &&
        e.indexOf("arn:") === 0 &&
        e.split(":").length >= 6,
      "validate",
    ),
    _pr = TX((e) => {
      let t = e.split(":");
      if (t.length < 6 || t[0] !== "arn") throw new Error("Malformed ARN");
      let [, r, n, i, o, ...a] = t;
      return {
        partition: r,
        service: n,
        region: i,
        accountId: o,
        resource: a.join(":"),
      };
    }, "parse"),
    Epr = TX((e) => {
      let {
        partition: t = "aws",
        service: r,
        region: n,
        accountId: i,
        resource: o,
      } = e;
      if ([r, n, i, o].some((a) => typeof a != "string"))
        throw new Error("Input ARN object is invalid");
      return `arn:${t}:${r}:${n}:${i}:${o}`;
    }, "build");
});
var Te = g((JBn, W3e) => {
  "use strict";
  c();
  var IF = Object.defineProperty,
    bpr = Object.getOwnPropertyDescriptor,
    Spr = Object.getOwnPropertyNames,
    Cpr = Object.prototype.hasOwnProperty,
    ot = (e, t) => IF(e, "name", { value: t, configurable: !0 }),
    wpr = (e, t) => {
      for (var r in t) IF(e, r, { get: t[r], enumerable: !0 });
    },
    Opr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Spr(t))
          !Cpr.call(e, i) &&
            i !== r &&
            IF(e, i, {
              get: () => t[i],
              enumerable: !(n = bpr(t, i)) || n.enumerable,
            });
      return e;
    },
    Tpr = (e) => Opr(IF({}, "__esModule", { value: !0 }), e),
    P3e = {};
  wpr(P3e, {
    NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS: () => jpr,
    S3ExpressIdentityCache: () => M3e,
    S3ExpressIdentityCacheEntry: () => RF,
    S3ExpressIdentityProviderImpl: () => j3e,
    SignatureV4S3Express: () => Fpr,
    checkContentLengthHeader: () => NX,
    checkContentLengthHeaderMiddlewareOptions: () => I3e,
    getCheckContentLengthHeaderPlugin: () => Rpr,
    getRegionRedirectMiddlewarePlugin: () => Ipr,
    getS3ExpiresMiddlewarePlugin: () => xpr,
    getS3ExpressHttpSigningPlugin: () => Kpr,
    getS3ExpressPlugin: () => Upr,
    getThrow200ExceptionsPlugin: () => Jpr,
    getValidateBucketNamePlugin: () => tmr,
    regionRedirectEndpointMiddleware: () => x3e,
    regionRedirectEndpointMiddlewareOptions: () => N3e,
    regionRedirectMiddleware: () => kX,
    regionRedirectMiddlewareOptions: () => k3e,
    resolveS3Config: () => Wpr,
    s3ExpiresMiddleware: () => D3e,
    s3ExpiresMiddlewareOptions: () => L3e,
    s3ExpressHttpSigningMiddleware: () => G3e,
    s3ExpressHttpSigningMiddlewareOptions: () => zpr,
    s3ExpressMiddleware: () => B3e,
    s3ExpressMiddlewareOptions: () => U3e,
    throw200ExceptionsMiddleware: () => V3e,
    throw200ExceptionsMiddlewareOptions: () => $3e,
    validateBucketNameMiddleware: () => DX,
    validateBucketNameMiddlewareOptions: () => K3e,
  });
  W3e.exports = Tpr(P3e);
  var CO = ns(),
    R3e = yO(),
    Apr = "content-length",
    Ppr = "x-amz-decoded-content-length";
  function NX() {
    return (e, t) => async (r) => {
      let { request: n } = r;
      if (
        CO.HttpRequest.isInstance(n) &&
        !(Apr in n.headers) &&
        !(Ppr in n.headers)
      ) {
        let i =
          "Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.";
        typeof t?.logger?.warn == "function" &&
        !(t.logger instanceof R3e.NoOpLogger)
          ? t.logger.warn(i)
          : console.warn(i);
      }
      return e({ ...r });
    };
  }
  ot(NX, "checkContentLengthHeader");
  var I3e = {
      step: "finalizeRequest",
      tags: ["CHECK_CONTENT_LENGTH_HEADER"],
      name: "getCheckContentLengthHeaderPlugin",
      override: !0,
    },
    Rpr = ot(
      (e) => ({
        applyToStack: ot((t) => {
          t.add(NX(), I3e);
        }, "applyToStack"),
      }),
      "getCheckContentLengthHeaderPlugin",
    ),
    x3e = ot(
      (e) => (t, r) => async (n) => {
        let i = await e.region(),
          o = e.region,
          a = ot(() => {}, "unlock");
        r.__s3RegionRedirect &&
          (Object.defineProperty(e, "region", {
            writable: !1,
            value: ot(async () => r.__s3RegionRedirect, "value"),
          }),
          (a = ot(
            () =>
              Object.defineProperty(e, "region", { writable: !0, value: o }),
            "unlock",
          )));
        try {
          let s = await t(n);
          if (r.__s3RegionRedirect) {
            a();
            let u = await e.region();
            if (i !== u)
              throw new Error(
                "Region was not restored following S3 region redirect.",
              );
          }
          return s;
        } catch (s) {
          throw (a(), s);
        }
      },
      "regionRedirectEndpointMiddleware",
    ),
    N3e = {
      tags: ["REGION_REDIRECT", "S3"],
      name: "regionRedirectEndpointMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: "endpointV2Middleware",
    };
  function kX(e) {
    return (t, r) => async (n) => {
      try {
        return await t(n);
      } catch (i) {
        if (
          e.followRegionRedirects &&
          (i?.$metadata?.httpStatusCode === 301 ||
            (i?.$metadata?.httpStatusCode === 400 &&
              i?.name === "IllegalLocationConstraintException"))
        ) {
          try {
            let o = i.$response.headers["x-amz-bucket-region"];
            r.logger?.debug(`Redirecting from ${await e.region()} to ${o}`),
              (r.__s3RegionRedirect = o);
          } catch (o) {
            throw new Error("Region redirect failed: " + o);
          }
          return t(n);
        }
        throw i;
      }
    };
  }
  ot(kX, "regionRedirectMiddleware");
  var k3e = {
      step: "initialize",
      tags: ["REGION_REDIRECT", "S3"],
      name: "regionRedirectMiddleware",
      override: !0,
    },
    Ipr = ot(
      (e) => ({
        applyToStack: ot((t) => {
          t.add(kX(e), k3e), t.addRelativeTo(x3e(e), N3e);
        }, "applyToStack"),
      }),
      "getRegionRedirectMiddlewarePlugin",
    ),
    D3e = ot(
      (e) => (t, r) => async (n) => {
        let i = await t(n),
          { response: o } = i;
        if (CO.HttpResponse.isInstance(o) && o.headers.expires) {
          o.headers.expiresstring = o.headers.expires;
          try {
            (0, R3e.parseRfc7231DateTime)(o.headers.expires);
          } catch (a) {
            r.logger?.warn(
              `AWS SDK Warning for ${r.clientName}::${r.commandName} response parsing (${o.headers.expires}): ${a}`,
            ),
              delete o.headers.expires;
          }
        }
        return i;
      },
      "s3ExpiresMiddleware",
    ),
    L3e = {
      tags: ["S3"],
      name: "s3ExpiresMiddleware",
      override: !0,
      relation: "after",
      toMiddleware: "deserializerMiddleware",
    },
    xpr = ot(
      (e) => ({
        applyToStack: ot((t) => {
          t.addRelativeTo(D3e(e), L3e);
        }, "applyToStack"),
      }),
      "getS3ExpiresMiddlewarePlugin",
    ),
    M3e = class q3e {
      constructor(t = {}) {
        this.data = t;
      }
      static {
        ot(this, "S3ExpressIdentityCache");
      }
      lastPurgeTime = Date.now();
      static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
      get(t) {
        let r = this.data[t];
        if (r) return r;
      }
      set(t, r) {
        return (this.data[t] = r), r;
      }
      delete(t) {
        delete this.data[t];
      }
      async purgeExpired() {
        let t = Date.now();
        if (
          !(this.lastPurgeTime + q3e.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > t)
        )
          for (let r in this.data) {
            let n = this.data[r];
            if (!n.isRefreshing) {
              let i = await n.identity;
              i.expiration && i.expiration.getTime() < t && delete this.data[r];
            }
          }
      }
    },
    RF = class {
      constructor(e, t = !1, r = Date.now()) {
        (this._identity = e), (this.isRefreshing = t), (this.accessed = r);
      }
      static {
        ot(this, "S3ExpressIdentityCacheEntry");
      }
      get identity() {
        return (this.accessed = Date.now()), this._identity;
      }
    },
    j3e = class F3e {
      constructor(t, r = new M3e()) {
        (this.createSessionFn = t), (this.cache = r);
      }
      static {
        ot(this, "S3ExpressIdentityProviderImpl");
      }
      static REFRESH_WINDOW_MS = 6e4;
      async getS3ExpressIdentity(t, r) {
        let n = r.Bucket,
          { cache: i } = this,
          o = i.get(n);
        return o
          ? o.identity.then((a) =>
              (a.expiration?.getTime() ?? 0) < Date.now()
                ? i.set(n, new RF(this.getIdentity(n))).identity
                : ((a.expiration?.getTime() ?? 0) <
                    Date.now() + F3e.REFRESH_WINDOW_MS &&
                    !o.isRefreshing &&
                    ((o.isRefreshing = !0),
                    this.getIdentity(n).then((l) => {
                      i.set(n, new RF(Promise.resolve(l)));
                    })),
                  a),
            )
          : i.set(n, new RF(this.getIdentity(n))).identity;
      }
      async getIdentity(t) {
        await this.cache.purgeExpired().catch((i) => {
          console.warn(
            `Error while clearing expired entries in S3ExpressIdentityCache: 
` + i,
          );
        });
        let r = await this.createSessionFn(t);
        if (!r.Credentials?.AccessKeyId || !r.Credentials?.SecretAccessKey)
          throw new Error(
            "s3#createSession response credential missing AccessKeyId or SecretAccessKey.",
          );
        return {
          accessKeyId: r.Credentials.AccessKeyId,
          secretAccessKey: r.Credentials.SecretAccessKey,
          sessionToken: r.Credentials.SessionToken,
          expiration: r.Credentials.Expiration
            ? new Date(r.Credentials.Expiration)
            : void 0,
        };
      }
    },
    Npr = rX(),
    PF = GC(),
    kpr = "Directory",
    Dpr = "S3Express",
    Lpr = "sigv4-s3express",
    PX = "X-Amz-S3session-Token",
    RX = PX.toLowerCase(),
    Mpr = "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH",
    qpr = "s3_disable_express_session_auth",
    jpr = {
      environmentVariableSelector: ot(
        (e) => (0, PF.booleanSelector)(e, Mpr, PF.SelectorType.ENV),
        "environmentVariableSelector",
      ),
      configFileSelector: ot(
        (e) => (0, PF.booleanSelector)(e, qpr, PF.SelectorType.CONFIG),
        "configFileSelector",
      ),
      default: !1,
    },
    Fpr = class extends Npr.SignatureV4 {
      static {
        ot(this, "SignatureV4S3Express");
      }
      async signWithCredentials(e, t, r) {
        let n = IX(t);
        e.headers[RX] = t.sessionToken;
        let i = this;
        return xX(i, n), i.signRequest(e, r ?? {});
      }
      async presignWithCredentials(e, t, r) {
        let n = IX(t);
        return (
          delete e.headers[RX],
          (e.headers[PX] = t.sessionToken),
          (e.query = e.query ?? {}),
          (e.query[PX] = t.sessionToken),
          xX(this, n),
          this.presign(e, r)
        );
      }
    };
  function IX(e) {
    return {
      accessKeyId: e.accessKeyId,
      secretAccessKey: e.secretAccessKey,
      expiration: e.expiration,
    };
  }
  ot(IX, "getCredentialsWithoutSessionToken");
  function xX(e, t) {
    let r = setTimeout(() => {
        throw new Error(
          "SignatureV4S3Express credential override was created but not called.",
        );
      }, 10),
      n = e.credentialProvider,
      i = ot(
        () => (clearTimeout(r), (e.credentialProvider = n), Promise.resolve(t)),
        "overrideCredentialsProviderOnce",
      );
    e.credentialProvider = i;
  }
  ot(xX, "setSingleOverride");
  var Bpr = (w3e(), ue(C3e)),
    B3e = ot(
      (e) => (t, r) => async (n) => {
        if (r.endpointV2) {
          let i = r.endpointV2,
            o = i.properties?.authSchemes?.[0]?.name === Lpr;
          if (
            ((i.properties?.backend === Dpr ||
              i.properties?.bucketType === kpr) &&
              ((0, Bpr.setFeature)(r, "S3_EXPRESS_BUCKET", "J"),
              (r.isS3ExpressBucket = !0)),
            o)
          ) {
            let s = n.input.Bucket;
            if (s) {
              let u = await e.s3ExpressIdentityProvider.getS3ExpressIdentity(
                await e.credentials(),
                { Bucket: s },
              );
              (r.s3ExpressIdentity = u),
                CO.HttpRequest.isInstance(n.request) &&
                  u.sessionToken &&
                  (n.request.headers[RX] = u.sessionToken);
            }
          }
        }
        return t(n);
      },
      "s3ExpressMiddleware",
    ),
    U3e = {
      name: "s3ExpressMiddleware",
      step: "build",
      tags: ["S3", "S3_EXPRESS"],
      override: !0,
    },
    Upr = ot(
      (e) => ({
        applyToStack: ot((t) => {
          t.add(B3e(e), U3e);
        }, "applyToStack"),
      }),
      "getS3ExpressPlugin",
    ),
    H3e = (CF(), ue(e3e)),
    Hpr = _O(),
    Gpr = ot(async (e, t, r, n) => {
      let i = await n.signWithCredentials(r, e, {});
      if (
        i.headers["X-Amz-Security-Token"] ||
        i.headers["x-amz-security-token"]
      )
        throw new Error(
          "X-Amz-Security-Token must not be set for s3-express requests.",
        );
      return i;
    }, "signS3Express"),
    Vpr = ot(
      (e) => (t) => {
        throw t;
      },
      "defaultErrorHandler",
    ),
    $pr = ot((e, t) => {}, "defaultSuccessHandler"),
    zpr = H3e.httpSigningMiddlewareOptions,
    G3e = ot(
      (e) => (t, r) => async (n) => {
        if (!CO.HttpRequest.isInstance(n.request)) return t(n);
        let o = (0, Hpr.getSmithyContext)(r).selectedHttpAuthScheme;
        if (!o)
          throw new Error(
            "No HttpAuthScheme was selected: unable to sign request",
          );
        let {
            httpAuthOption: { signingProperties: a = {} },
            identity: s,
            signer: u,
          } = o,
          l;
        r.s3ExpressIdentity
          ? (l = await Gpr(r.s3ExpressIdentity, a, n.request, await e.signer()))
          : (l = await u.sign(n.request, s, a));
        let d = await t({ ...n, request: l }).catch((u.errorHandler || Vpr)(a));
        return (u.successHandler || $pr)(d.response, a), d;
      },
      "s3ExpressHttpSigningMiddleware",
    ),
    Kpr = ot(
      (e) => ({
        applyToStack: ot((t) => {
          t.addRelativeTo(G3e(e), H3e.httpSigningMiddlewareOptions);
        }, "applyToStack"),
      }),
      "getS3ExpressHttpSigningPlugin",
    ),
    Wpr = ot((e, { session: t }) => {
      let [r, n] = t,
        {
          forcePathStyle: i,
          useAccelerateEndpoint: o,
          disableMultiregionAccessPoints: a,
          followRegionRedirects: s,
          s3ExpressIdentityProvider: u,
          bucketEndpoint: l,
        } = e;
      return Object.assign(e, {
        forcePathStyle: i ?? !1,
        useAccelerateEndpoint: o ?? !1,
        disableMultiregionAccessPoints: a ?? !1,
        followRegionRedirects: s ?? !1,
        s3ExpressIdentityProvider:
          u ?? new j3e(async (d) => r().send(new n({ Bucket: d }))),
        bucketEndpoint: l ?? !1,
      });
    }, "resolveS3Config"),
    A3e = RY(),
    Qpr = {
      CopyObjectCommand: !0,
      UploadPartCopyCommand: !0,
      CompleteMultipartUploadCommand: !0,
    },
    Ypr = 3e3,
    V3e = ot(
      (e) => (t, r) => async (n) => {
        let i = await t(n),
          { response: o } = i;
        if (!CO.HttpResponse.isInstance(o)) return i;
        let { statusCode: a, body: s } = o;
        if (
          a < 200 ||
          a >= 300 ||
          !(
            typeof s?.stream == "function" ||
            typeof s?.pipe == "function" ||
            typeof s?.tee == "function"
          )
        )
          return i;
        let l = s,
          d = s;
        s &&
          typeof s == "object" &&
          !(s instanceof Uint8Array) &&
          ([l, d] = await (0, A3e.splitStream)(s)),
          (o.body = d);
        let f = await Xpr(l, {
          streamCollector: ot(
            async (h) => (0, A3e.headStream)(h, Ypr),
            "streamCollector",
          ),
        });
        typeof l?.destroy == "function" && l.destroy();
        let m = e.utf8Encoder(f.subarray(f.length - 16));
        if (f.length === 0 && Qpr[r.commandName]) {
          let h = new Error("S3 aborted request");
          throw ((h.name = "InternalError"), h);
        }
        return m && m.endsWith("</Error>") && (o.statusCode = 400), i;
      },
      "throw200ExceptionsMiddleware",
    ),
    Xpr = ot(
      (e = new Uint8Array(), t) =>
        e instanceof Uint8Array
          ? Promise.resolve(e)
          : t.streamCollector(e) || Promise.resolve(new Uint8Array()),
      "collectBody",
    ),
    $3e = {
      relation: "after",
      toMiddleware: "deserializerMiddleware",
      tags: ["THROW_200_EXCEPTIONS", "S3"],
      name: "throw200ExceptionsMiddleware",
      override: !0,
    },
    Jpr = ot(
      (e) => ({
        applyToStack: ot((t) => {
          t.addRelativeTo(V3e(e), $3e);
        }, "applyToStack"),
      }),
      "getThrow200ExceptionsPlugin",
    ),
    Zpr = AX();
  function z3e(e) {
    return (t, r) => async (n) => {
      if (e.bucketEndpoint) {
        let i = r.endpointV2;
        if (i) {
          let o = n.input.Bucket;
          if (typeof o == "string")
            try {
              let a = new URL(o);
              r.endpointV2 = { ...i, url: a };
            } catch (a) {
              let s = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${o} could not be parsed as URL.`;
              throw (
                (r.logger?.constructor?.name === "NoOpLogger"
                  ? console.warn(s)
                  : r.logger?.warn?.(s),
                a)
              );
            }
        }
      }
      return t(n);
    };
  }
  ot(z3e, "bucketEndpointMiddleware");
  var emr = {
    name: "bucketEndpointMiddleware",
    override: !0,
    relation: "after",
    toMiddleware: "endpointV2Middleware",
  };
  function DX({ bucketEndpoint: e }) {
    return (t) => async (r) => {
      let {
        input: { Bucket: n },
      } = r;
      if (
        !e &&
        typeof n == "string" &&
        !(0, Zpr.validate)(n) &&
        n.indexOf("/") >= 0
      ) {
        let i = new Error(`Bucket name shouldn't contain '/', received '${n}'`);
        throw ((i.name = "InvalidBucketName"), i);
      }
      return t({ ...r });
    };
  }
  ot(DX, "validateBucketNameMiddleware");
  var K3e = {
      step: "initialize",
      tags: ["VALIDATE_BUCKET_NAME"],
      name: "validateBucketNameMiddleware",
      override: !0,
    },
    tmr = ot(
      (e) => ({
        applyToStack: ot((t) => {
          t.add(DX(e), K3e), t.addRelativeTo(z3e(e), emr);
        }, "applyToStack"),
      }),
      "getValidateBucketNamePlugin",
    );
});
var LX,
  rmr,
  Q3e = w(() => {
    c();
    (LX = A(Ul())),
      (rmr = (e) =>
        e[LX.SMITHY_CONTEXT_KEY] || (e[LX.SMITHY_CONTEXT_KEY] = {}));
  });
var tc = g((iUn, Z3e) => {
  c();
  var xF = Object.defineProperty,
    nmr = Object.getOwnPropertyDescriptor,
    imr = Object.getOwnPropertyNames,
    omr = Object.prototype.hasOwnProperty,
    X3e = (e, t) => xF(e, "name", { value: t, configurable: !0 }),
    amr = (e, t) => {
      for (var r in t) xF(e, r, { get: t[r], enumerable: !0 });
    },
    smr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of imr(t))
          !omr.call(e, i) &&
            i !== r &&
            xF(e, i, {
              get: () => t[i],
              enumerable: !(n = nmr(t, i)) || n.enumerable,
            });
      return e;
    },
    cmr = (e) => smr(xF({}, "__esModule", { value: !0 }), e),
    J3e = {};
  amr(J3e, { getSmithyContext: () => umr, normalizeProvider: () => lmr });
  Z3e.exports = cmr(J3e);
  var Y3e = Ul(),
    umr = X3e(
      (e) => e[Y3e.SMITHY_CONTEXT_KEY] || (e[Y3e.SMITHY_CONTEXT_KEY] = {}),
      "getSmithyContext",
    ),
    lmr = X3e((e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    }, "normalizeProvider");
});
var eGe,
  tGe = w(() => {
    c();
    eGe = (e, t) => {
      if (!t || t.length === 0) return e;
      let r = [];
      for (let n of t)
        for (let i of e) i.schemeId.split("#")[1] === n && r.push(i);
      for (let n of e)
        r.find(({ schemeId: i }) => i === n.schemeId) || r.push(n);
      return r;
    };
  });
function dmr(e) {
  let t = new Map();
  for (let r of e) t.set(r.schemeId, r);
  return t;
}
var cUn,
  rGe,
  wO,
  NF = w(() => {
    c();
    (cUn = A(Ul())), (rGe = A(tc()));
    tGe();
    wO = (e, t) => (r, n) => async (i) => {
      let o = e.httpAuthSchemeProvider(
          await t.httpAuthSchemeParametersProvider(e, n, i.input),
        ),
        a = e.authSchemePreference ? await e.authSchemePreference() : [],
        s = eGe(o, a),
        u = dmr(e.httpAuthSchemes),
        l = (0, rGe.getSmithyContext)(n),
        d = [];
      for (let f of s) {
        let m = u.get(f.schemeId);
        if (!m) {
          d.push(
            `HttpAuthScheme \`${f.schemeId}\` was not enabled for this service.`,
          );
          continue;
        }
        let h = m.identityProvider(await t.identityProviderConfigProvider(e));
        if (!h) {
          d.push(
            `HttpAuthScheme \`${f.schemeId}\` did not have an IdentityProvider configured.`,
          );
          continue;
        }
        let { identityProperties: y = {}, signingProperties: _ = {} } =
          f.propertiesExtractor?.(e, n) || {};
        (f.identityProperties = Object.assign(f.identityProperties || {}, y)),
          (f.signingProperties = Object.assign(f.signingProperties || {}, _)),
          (l.selectedHttpAuthScheme = {
            httpAuthOption: f,
            identity: await h(f.identityProperties),
            signer: m.signer,
          });
        break;
      }
      if (!l.selectedHttpAuthScheme)
        throw new Error(
          d.join(`
`),
        );
      return r(i);
    };
  });
var nGe,
  OO,
  iGe = w(() => {
    c();
    NF();
    (nGe = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: "endpointV2Middleware",
    }),
      (OO = (
        e,
        {
          httpAuthSchemeParametersProvider: t,
          identityProviderConfigProvider: r,
        },
      ) => ({
        applyToStack: (n) => {
          n.addRelativeTo(
            wO(e, {
              httpAuthSchemeParametersProvider: t,
              identityProviderConfigProvider: r,
            }),
            nGe,
          );
        },
      }));
  });
var ip = g((gUn, dGe) => {
  c();
  var kF = Object.defineProperty,
    fmr = Object.getOwnPropertyDescriptor,
    pmr = Object.getOwnPropertyNames,
    mmr = Object.prototype.hasOwnProperty,
    MX = (e, t) => kF(e, "name", { value: t, configurable: !0 }),
    hmr = (e, t) => {
      for (var r in t) kF(e, r, { get: t[r], enumerable: !0 });
    },
    gmr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of pmr(t))
          !mmr.call(e, i) &&
            i !== r &&
            kF(e, i, {
              get: () => t[i],
              enumerable: !(n = fmr(t, i)) || n.enumerable,
            });
      return e;
    },
    vmr = (e) => gmr(kF({}, "__esModule", { value: !0 }), e),
    oGe = {};
  hmr(oGe, {
    deserializerMiddleware: () => aGe,
    deserializerMiddlewareOption: () => cGe,
    getSerdePlugin: () => lGe,
    serializerMiddleware: () => sGe,
    serializerMiddlewareOption: () => uGe,
  });
  dGe.exports = vmr(oGe);
  var aGe = MX(
      (e, t) => (r, n) => async (i) => {
        let { response: o } = await r(i);
        try {
          let a = await t(o, e);
          return { response: o, output: a };
        } catch (a) {
          if (
            (Object.defineProperty(a, "$response", { value: o }),
            !("$metadata" in a))
          ) {
            let s =
              "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
            try {
              a.message +=
                `
  ` + s;
            } catch {
              !n.logger || n.logger?.constructor?.name === "NoOpLogger"
                ? console.warn(s)
                : n.logger?.warn?.(s);
            }
            typeof a.$responseBodyText < "u" &&
              a.$response &&
              (a.$response.body = a.$responseBodyText);
          }
          throw a;
        }
      },
      "deserializerMiddleware",
    ),
    sGe = MX(
      (e, t) => (r, n) => async (i) => {
        let o =
          n.endpointV2?.url && e.urlParser
            ? async () => e.urlParser(n.endpointV2.url)
            : e.endpoint;
        if (!o) throw new Error("No valid endpoint provider available.");
        let a = await t(i.input, { ...e, endpoint: o });
        return r({ ...i, request: a });
      },
      "serializerMiddleware",
    ),
    cGe = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: !0,
    },
    uGe = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: !0,
    };
  function lGe(e, t, r) {
    return {
      applyToStack: (n) => {
        n.add(aGe(e, r), cGe), n.add(sGe(e, t), uGe);
      },
    };
  }
  MX(lGe, "getSerdePlugin");
});
var fGe,
  pGe,
  ymr,
  mGe = w(() => {
    c();
    fGe = A(ip());
    NF();
    (pGe = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: fGe.serializerMiddlewareOption.name,
    }),
      (ymr = (
        e,
        {
          httpAuthSchemeParametersProvider: t,
          identityProviderConfigProvider: r,
        },
      ) => ({
        applyToStack: (n) => {
          n.addRelativeTo(
            wO(e, {
              httpAuthSchemeParametersProvider: t,
              identityProviderConfigProvider: r,
            }),
            pGe,
          );
        },
      }));
  });
var hGe = w(() => {
  c();
  NF();
  iGe();
  mGe();
});
var gGe,
  TUn,
  vGe,
  _mr,
  Emr,
  qX,
  jX = w(() => {
    c();
    (gGe = A(ln())),
      (TUn = A(Ul())),
      (vGe = A(tc())),
      (_mr = (e) => (t) => {
        throw t;
      }),
      (Emr = (e, t) => {}),
      (qX = (e) => (t, r) => async (n) => {
        if (!gGe.HttpRequest.isInstance(n.request)) return t(n);
        let o = (0, vGe.getSmithyContext)(r).selectedHttpAuthScheme;
        if (!o)
          throw new Error(
            "No HttpAuthScheme was selected: unable to sign request",
          );
        let {
            httpAuthOption: { signingProperties: a = {} },
            identity: s,
            signer: u,
          } = o,
          l = await t({ ...n, request: await u.sign(n.request, s, a) }).catch(
            (u.errorHandler || _mr)(a),
          );
        return (u.successHandler || Emr)(l.response, a), l;
      });
  });
var yGe,
  TO,
  _Ge = w(() => {
    c();
    jX();
    (yGe = {
      step: "finalizeRequest",
      tags: ["HTTP_SIGNING"],
      name: "httpSigningMiddleware",
      aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
      override: !0,
      relation: "after",
      toMiddleware: "retryMiddleware",
    }),
      (TO = (e) => ({
        applyToStack: (t) => {
          t.addRelativeTo(qX(e), yGe);
        },
      }));
  });
var EGe = w(() => {
  c();
  jX();
  _Ge();
});
var op,
  bGe = w(() => {
    c();
    op = (e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    };
  });
function SGe(e, t, r, n, i) {
  return async function* (a, s, ...u) {
    let l = s,
      d = a.startingToken ?? l[r],
      f = !0,
      m;
    for (; f; ) {
      if (((l[r] = d), i && (l[i] = l[i] ?? a.pageSize), a.client instanceof e))
        m = await bmr(t, a.client, s, a.withCommand, ...u);
      else throw new Error(`Invalid client, expected instance of ${e.name}`);
      yield m;
      let h = d;
      (d = Smr(m, n)), (f = !!(d && (!a.stopOnSameToken || d !== h)));
    }
    return void 0;
  };
}
var bmr,
  Smr,
  CGe = w(() => {
    c();
    bmr = async (e, t, r, n = (o) => o, ...i) => {
      let o = new e(r);
      return (o = n(o) ?? o), await t.send(o, ...i);
    };
    Smr = (e, t) => {
      let r = e,
        n = t.split(".");
      for (let i of n) {
        if (!r || typeof r != "object") return;
        r = r[i];
      }
      return r;
    };
  });
var wGe = g((DF) => {
  "use strict";
  c();
  Object.defineProperty(DF, "__esModule", { value: !0 });
  DF.fromBase64 = void 0;
  var Cmr = Hi(),
    wmr = /^[A-Za-z0-9+/]*={0,2}$/,
    Omr = (e) => {
      if ((e.length * 3) % 4 !== 0)
        throw new TypeError("Incorrect padding on base64 string.");
      if (!wmr.exec(e)) throw new TypeError("Invalid base64 string.");
      let t = (0, Cmr.fromString)(e, "base64");
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    };
  DF.fromBase64 = Omr;
});
var OGe = g((LF) => {
  "use strict";
  c();
  Object.defineProperty(LF, "__esModule", { value: !0 });
  LF.toBase64 = void 0;
  var Tmr = Hi(),
    Amr = Fe(),
    Pmr = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = (0, Amr.fromUtf8)(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.",
        );
      return (0, Tmr.fromArrayBuffer)(
        t.buffer,
        t.byteOffset,
        t.byteLength,
      ).toString("base64");
    };
  LF.toBase64 = Pmr;
});
var fu = g(($Un, MF) => {
  c();
  var TGe = Object.defineProperty,
    Rmr = Object.getOwnPropertyDescriptor,
    Imr = Object.getOwnPropertyNames,
    xmr = Object.prototype.hasOwnProperty,
    FX = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Imr(t))
          !xmr.call(e, i) &&
            i !== r &&
            TGe(e, i, {
              get: () => t[i],
              enumerable: !(n = Rmr(t, i)) || n.enumerable,
            });
      return e;
    },
    AGe = (e, t, r) => (FX(e, t, "default"), r && FX(r, t, "default")),
    Nmr = (e) => FX(TGe({}, "__esModule", { value: !0 }), e),
    BX = {};
  MF.exports = Nmr(BX);
  AGe(BX, wGe(), MF.exports);
  AGe(BX, OGe(), MF.exports);
});
var HX = g((qF) => {
  "use strict";
  c();
  Object.defineProperty(qF, "__esModule", { value: !0 });
  qF.ChecksumStream = void 0;
  var kmr = fu(),
    Dmr = G("stream"),
    UX = class extends Dmr.Duplex {
      constructor({
        expectedChecksum: t,
        checksum: r,
        source: n,
        checksumSourceLocation: i,
        base64Encoder: o,
      }) {
        var a, s;
        if ((super(), typeof n.pipe == "function")) this.source = n;
        else
          throw new Error(
            `@smithy/util-stream: unsupported source type ${(s = (a = n?.constructor) === null || a === void 0 ? void 0 : a.name) !== null && s !== void 0 ? s : n} in ChecksumStream.`,
          );
        (this.base64Encoder = o ?? kmr.toBase64),
          (this.expectedChecksum = t),
          (this.checksum = r),
          (this.checksumSourceLocation = i),
          this.source.pipe(this);
      }
      _read(t) {}
      _write(t, r, n) {
        try {
          this.checksum.update(t), this.push(t);
        } catch (i) {
          return n(i);
        }
        return n();
      }
      async _final(t) {
        try {
          let r = await this.checksum.digest(),
            n = this.base64Encoder(r);
          if (this.expectedChecksum !== n)
            return t(
              new Error(
                `Checksum mismatch: expected "${this.expectedChecksum}" but received "${n}" in response header "${this.checksumSourceLocation}".`,
              ),
            );
        } catch (r) {
          return t(r);
        }
        return this.push(null), t();
      }
    };
  qF.ChecksumStream = UX;
});
var ap = g((dE) => {
  "use strict";
  c();
  Object.defineProperty(dE, "__esModule", { value: !0 });
  dE.isBlob = dE.isReadableStream = void 0;
  var Lmr = (e) => {
    var t;
    return (
      typeof ReadableStream == "function" &&
      (((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) ===
        ReadableStream.name ||
        e instanceof ReadableStream)
    );
  };
  dE.isReadableStream = Lmr;
  var Mmr = (e) => {
    var t;
    return (
      typeof Blob == "function" &&
      (((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) ===
        Blob.name ||
        e instanceof Blob)
    );
  };
  dE.isBlob = Mmr;
});
var PGe = g((jF) => {
  "use strict";
  c();
  Object.defineProperty(jF, "__esModule", { value: !0 });
  jF.ChecksumStream = void 0;
  var qmr =
      typeof ReadableStream == "function" ? ReadableStream : function () {},
    GX = class extends qmr {};
  jF.ChecksumStream = GX;
});
var RGe = g((FF) => {
  "use strict";
  c();
  Object.defineProperty(FF, "__esModule", { value: !0 });
  FF.createChecksumStream = void 0;
  var jmr = fu(),
    Fmr = ap(),
    Bmr = PGe(),
    Umr = ({
      expectedChecksum: e,
      checksum: t,
      source: r,
      checksumSourceLocation: n,
      base64Encoder: i,
    }) => {
      var o, a;
      if (!(0, Fmr.isReadableStream)(r))
        throw new Error(
          `@smithy/util-stream: unsupported source type ${(a = (o = r?.constructor) === null || o === void 0 ? void 0 : o.name) !== null && a !== void 0 ? a : r} in ChecksumStream.`,
        );
      let s = i ?? jmr.toBase64;
      if (typeof TransformStream != "function")
        throw new Error(
          "@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.",
        );
      let u = new TransformStream({
        start() {},
        async transform(d, f) {
          t.update(d), f.enqueue(d);
        },
        async flush(d) {
          let f = await t.digest(),
            m = s(f);
          if (e !== m) {
            let h = new Error(
              `Checksum mismatch: expected "${e}" but received "${m}" in response header "${n}".`,
            );
            d.error(h);
          } else d.terminate();
        },
      });
      r.pipeThrough(u);
      let l = u.readable;
      return Object.setPrototypeOf(l, Bmr.ChecksumStream.prototype), l;
    };
  FF.createChecksumStream = Umr;
});
var IGe = g((BF) => {
  "use strict";
  c();
  Object.defineProperty(BF, "__esModule", { value: !0 });
  BF.createChecksumStream = void 0;
  var Hmr = ap(),
    Gmr = HX(),
    Vmr = RGe();
  function $mr(e) {
    return typeof ReadableStream == "function" &&
      (0, Hmr.isReadableStream)(e.source)
      ? (0, Vmr.createChecksumStream)(e)
      : new Gmr.ChecksumStream(e);
  }
  BF.createChecksumStream = $mr;
});
var $X = g((UF) => {
  "use strict";
  c();
  Object.defineProperty(UF, "__esModule", { value: !0 });
  UF.ByteArrayCollector = void 0;
  var VX = class {
    constructor(t) {
      (this.allocByteArray = t), (this.byteLength = 0), (this.byteArrays = []);
    }
    push(t) {
      this.byteArrays.push(t), (this.byteLength += t.byteLength);
    }
    flush() {
      if (this.byteArrays.length === 1) {
        let n = this.byteArrays[0];
        return this.reset(), n;
      }
      let t = this.allocByteArray(this.byteLength),
        r = 0;
      for (let n = 0; n < this.byteArrays.length; ++n) {
        let i = this.byteArrays[n];
        t.set(i, r), (r += i.byteLength);
      }
      return this.reset(), t;
    }
    reset() {
      (this.byteArrays = []), (this.byteLength = 0);
    }
  };
  UF.ByteArrayCollector = VX;
});
var DGe = g((Fo) => {
  "use strict";
  c();
  Object.defineProperty(Fo, "__esModule", { value: !0 });
  Fo.modeOf =
    Fo.sizeOf =
    Fo.flush =
    Fo.merge =
    Fo.createBufferedReadable =
    Fo.createBufferedReadableStream =
      void 0;
  var zmr = $X();
  function xGe(e, t, r) {
    let n = e.getReader(),
      i = !1,
      o = 0,
      a = ["", new zmr.ByteArrayCollector((l) => new Uint8Array(l))],
      s = -1,
      u = async (l) => {
        let { value: d, done: f } = await n.read(),
          m = d;
        if (f) {
          if (s !== -1) {
            let h = HF(a, s);
            fE(h) > 0 && l.enqueue(h);
          }
          l.close();
        } else {
          let h = kGe(m, !1);
          if ((s !== h && (s >= 0 && l.enqueue(HF(a, s)), (s = h)), s === -1)) {
            l.enqueue(m);
            return;
          }
          let y = fE(m);
          o += y;
          let _ = fE(a[s]);
          if (y >= t && _ === 0) l.enqueue(m);
          else {
            let E = NGe(a, s, m);
            !i &&
              o > t * 2 &&
              ((i = !0),
              r?.warn(
                `@smithy/util-stream - stream chunk size ${y} is below threshold of ${t}, automatically buffering.`,
              )),
              E >= t ? l.enqueue(HF(a, s)) : await u(l);
          }
        }
      };
    return new ReadableStream({ pull: u });
  }
  Fo.createBufferedReadableStream = xGe;
  Fo.createBufferedReadable = xGe;
  function NGe(e, t, r) {
    switch (t) {
      case 0:
        return (e[0] += r), fE(e[0]);
      case 1:
      case 2:
        return e[t].push(r), fE(e[t]);
    }
  }
  Fo.merge = NGe;
  function HF(e, t) {
    switch (t) {
      case 0:
        let r = e[0];
        return (e[0] = ""), r;
      case 1:
      case 2:
        return e[t].flush();
    }
    throw new Error(
      `@smithy/util-stream - invalid index ${t} given to flush()`,
    );
  }
  Fo.flush = HF;
  function fE(e) {
    var t, r;
    return (r =
      (t = e?.byteLength) !== null && t !== void 0 ? t : e?.length) !== null &&
      r !== void 0
      ? r
      : 0;
  }
  Fo.sizeOf = fE;
  function kGe(e, t = !0) {
    return t && typeof Buffer < "u" && e instanceof Buffer
      ? 2
      : e instanceof Uint8Array
        ? 1
        : typeof e == "string"
          ? 0
          : -1;
  }
  Fo.modeOf = kGe;
});
var MGe = g((GF) => {
  "use strict";
  c();
  Object.defineProperty(GF, "__esModule", { value: !0 });
  GF.createBufferedReadable = void 0;
  var Kmr = G("node:stream"),
    LGe = $X(),
    Gl = DGe(),
    Wmr = ap();
  function Qmr(e, t, r) {
    if ((0, Wmr.isReadableStream)(e))
      return (0, Gl.createBufferedReadableStream)(e, t, r);
    let n = new Kmr.Readable({ read() {} }),
      i = !1,
      o = 0,
      a = [
        "",
        new LGe.ByteArrayCollector((u) => new Uint8Array(u)),
        new LGe.ByteArrayCollector((u) => Buffer.from(new Uint8Array(u))),
      ],
      s = -1;
    return (
      e.on("data", (u) => {
        let l = (0, Gl.modeOf)(u, !0);
        if (
          (s !== l && (s >= 0 && n.push((0, Gl.flush)(a, s)), (s = l)),
          s === -1)
        ) {
          n.push(u);
          return;
        }
        let d = (0, Gl.sizeOf)(u);
        o += d;
        let f = (0, Gl.sizeOf)(a[s]);
        if (d >= t && f === 0) n.push(u);
        else {
          let m = (0, Gl.merge)(a, s, u);
          !i &&
            o > t * 2 &&
            ((i = !0),
            r?.warn(
              `@smithy/util-stream - stream chunk size ${d} is below threshold of ${t}, automatically buffering.`,
            )),
            m >= t && n.push((0, Gl.flush)(a, s));
        }
      }),
      e.on("end", () => {
        if (s !== -1) {
          let u = (0, Gl.flush)(a, s);
          (0, Gl.sizeOf)(u) > 0 && n.push(u);
        }
        n.push(null);
      }),
      n
    );
  }
  GF.createBufferedReadable = Qmr;
});
var qGe = g((VF) => {
  "use strict";
  c();
  Object.defineProperty(VF, "__esModule", { value: !0 });
  VF.getAwsChunkedEncodingStream = void 0;
  var Ymr = G("stream"),
    Xmr = (e, t) => {
      let {
          base64Encoder: r,
          bodyLengthChecker: n,
          checksumAlgorithmFn: i,
          checksumLocationName: o,
          streamHasher: a,
        } = t,
        s = r !== void 0 && i !== void 0 && o !== void 0 && a !== void 0,
        u = s ? a(i, e) : void 0,
        l = new Ymr.Readable({ read: () => {} });
      return (
        e.on("data", (d) => {
          let f = n(d) || 0;
          l.push(`${f.toString(16)}\r
`),
            l.push(d),
            l.push(`\r
`);
        }),
        e.on("end", async () => {
          if (
            (l.push(`0\r
`),
            s)
          ) {
            let d = r(await u);
            l.push(`${o}:${d}\r
`),
              l.push(`\r
`);
          }
          l.push(null);
        }),
        l
      );
    };
  VF.getAwsChunkedEncodingStream = Xmr;
});
var jGe = g(($F) => {
  "use strict";
  c();
  Object.defineProperty($F, "__esModule", { value: !0 });
  $F.headStream = void 0;
  async function Jmr(e, t) {
    var r;
    let n = 0,
      i = [],
      o = e.getReader(),
      a = !1;
    for (; !a; ) {
      let { done: l, value: d } = await o.read();
      if (
        (d &&
          (i.push(d),
          (n += (r = d?.byteLength) !== null && r !== void 0 ? r : 0)),
        n >= t)
      )
        break;
      a = l;
    }
    o.releaseLock();
    let s = new Uint8Array(Math.min(t, n)),
      u = 0;
    for (let l of i) {
      if (l.byteLength > s.byteLength - u) {
        s.set(l.subarray(0, s.byteLength - u), u);
        break;
      } else s.set(l, u);
      u += l.length;
    }
    return s;
  }
  $F.headStream = Jmr;
});
var FGe = g((zF) => {
  "use strict";
  c();
  Object.defineProperty(zF, "__esModule", { value: !0 });
  zF.headStream = void 0;
  var Zmr = G("stream"),
    ehr = jGe(),
    thr = ap(),
    rhr = (e, t) =>
      (0, thr.isReadableStream)(e)
        ? (0, ehr.headStream)(e, t)
        : new Promise((r, n) => {
            let i = new zX();
            (i.limit = t),
              e.pipe(i),
              e.on("error", (o) => {
                i.end(), n(o);
              }),
              i.on("error", n),
              i.on("finish", function () {
                let o = new Uint8Array(Buffer.concat(this.buffers));
                r(o);
              });
          });
  zF.headStream = rhr;
  var zX = class extends Zmr.Writable {
    constructor() {
      super(...arguments),
        (this.buffers = []),
        (this.limit = 1 / 0),
        (this.bytesBuffered = 0);
    }
    _write(t, r, n) {
      var i;
      if (
        (this.buffers.push(t),
        (this.bytesBuffered +=
          (i = t.byteLength) !== null && i !== void 0 ? i : 0),
        this.bytesBuffered >= this.limit)
      ) {
        let o = this.bytesBuffered - this.limit,
          a = this.buffers[this.buffers.length - 1];
        (this.buffers[this.buffers.length - 1] = a.subarray(
          0,
          a.byteLength - o,
        )),
          this.emit("finish");
      }
      n();
    }
  };
});
var WX = g((hHn, HGe) => {
  c();
  var KF = Object.defineProperty,
    nhr = Object.getOwnPropertyDescriptor,
    ihr = Object.getOwnPropertyNames,
    ohr = Object.prototype.hasOwnProperty,
    KX = (e, t) => KF(e, "name", { value: t, configurable: !0 }),
    ahr = (e, t) => {
      for (var r in t) KF(e, r, { get: t[r], enumerable: !0 });
    },
    shr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of ihr(t))
          !ohr.call(e, i) &&
            i !== r &&
            KF(e, i, {
              get: () => t[i],
              enumerable: !(n = nhr(t, i)) || n.enumerable,
            });
      return e;
    },
    chr = (e) => shr(KF({}, "__esModule", { value: !0 }), e),
    BGe = {};
  ahr(BGe, { escapeUri: () => UGe, escapeUriPath: () => lhr });
  HGe.exports = chr(BGe);
  var UGe = KX(
      (e) => encodeURIComponent(e).replace(/[!'()*]/g, uhr),
      "escapeUri",
    ),
    uhr = KX(
      (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`,
      "hexEncode",
    ),
    lhr = KX((e) => e.split("/").map(UGe).join("/"), "escapeUriPath");
});
var YX = g((vHn, $Ge) => {
  c();
  var WF = Object.defineProperty,
    dhr = Object.getOwnPropertyDescriptor,
    fhr = Object.getOwnPropertyNames,
    phr = Object.prototype.hasOwnProperty,
    mhr = (e, t) => WF(e, "name", { value: t, configurable: !0 }),
    hhr = (e, t) => {
      for (var r in t) WF(e, r, { get: t[r], enumerable: !0 });
    },
    ghr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of fhr(t))
          !phr.call(e, i) &&
            i !== r &&
            WF(e, i, {
              get: () => t[i],
              enumerable: !(n = dhr(t, i)) || n.enumerable,
            });
      return e;
    },
    vhr = (e) => ghr(WF({}, "__esModule", { value: !0 }), e),
    GGe = {};
  hhr(GGe, { buildQueryString: () => VGe });
  $Ge.exports = vhr(GGe);
  var QX = WX();
  function VGe(e) {
    let t = [];
    for (let r of Object.keys(e).sort()) {
      let n = e[r];
      if (((r = (0, QX.escapeUri)(r)), Array.isArray(n)))
        for (let i = 0, o = n.length; i < o; i++)
          t.push(`${r}=${(0, QX.escapeUri)(n[i])}`);
      else {
        let i = r;
        (n || typeof n == "string") && (i += `=${(0, QX.escapeUri)(n)}`),
          t.push(i);
      }
    }
    return t.join("&");
  }
  mhr(VGe, "buildQueryString");
});
var Lh = g((_Hn, aVe) => {
  c();
  var yhr = Object.create,
    AO = Object.defineProperty,
    _hr = Object.getOwnPropertyDescriptor,
    Ehr = Object.getOwnPropertyNames,
    bhr = Object.getPrototypeOf,
    Shr = Object.prototype.hasOwnProperty,
    gr = (e, t) => AO(e, "name", { value: t, configurable: !0 }),
    Chr = (e, t) => {
      for (var r in t) AO(e, r, { get: t[r], enumerable: !0 });
    },
    YGe = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Ehr(t))
          !Shr.call(e, i) &&
            i !== r &&
            AO(e, i, {
              get: () => t[i],
              enumerable: !(n = _hr(t, i)) || n.enumerable,
            });
      return e;
    },
    whr = (e, t, r) => (
      (r = e != null ? yhr(bhr(e)) : {}),
      YGe(
        t || !e || !e.__esModule
          ? AO(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    Ohr = (e) => YGe(AO({}, "__esModule", { value: !0 }), e),
    XGe = {};
  Chr(XGe, {
    DEFAULT_REQUEST_TIMEOUT: () => nVe,
    NodeHttp2Handler: () => Lhr,
    NodeHttpHandler: () => xhr,
    streamCollector: () => qhr,
  });
  aVe.exports = Ohr(XGe);
  var JGe = ln(),
    ZGe = YX(),
    XX = G("http"),
    JX = G("https"),
    Thr = ["ECONNRESET", "EPIPE", "ETIMEDOUT"],
    eVe = gr((e) => {
      let t = {};
      for (let r of Object.keys(e)) {
        let n = e[r];
        t[r] = Array.isArray(n) ? n.join(",") : n;
      }
      return t;
    }, "getTransformedHeaders"),
    Bo = {
      setTimeout: (e, t) => setTimeout(e, t),
      clearTimeout: (e) => clearTimeout(e),
    },
    zGe = 1e3,
    Ahr = gr((e, t, r = 0) => {
      if (!r) return -1;
      let n = gr((i) => {
        let o = Bo.setTimeout(() => {
            e.destroy(),
              t(
                Object.assign(
                  new Error(
                    `Socket timed out without establishing a connection within ${r} ms`,
                  ),
                  { name: "TimeoutError" },
                ),
              );
          }, r - i),
          a = gr((s) => {
            s?.connecting
              ? s.on("connect", () => {
                  Bo.clearTimeout(o);
                })
              : Bo.clearTimeout(o);
          }, "doWithSocket");
        e.socket ? a(e.socket) : e.on("socket", a);
      }, "registerTimeout");
      return r < 2e3 ? (n(0), 0) : Bo.setTimeout(n.bind(null, zGe), zGe);
    }, "setConnectionTimeout"),
    Phr = 3e3,
    Rhr = gr((e, { keepAlive: t, keepAliveMsecs: r }, n = Phr) => {
      if (t !== !0) return -1;
      let i = gr(() => {
        e.socket
          ? e.socket.setKeepAlive(t, r || 0)
          : e.on("socket", (o) => {
              o.setKeepAlive(t, r || 0);
            });
      }, "registerListener");
      return n === 0 ? (i(), 0) : Bo.setTimeout(i, n);
    }, "setSocketKeepAlive"),
    KGe = 3e3,
    Ihr = gr((e, t, r = nVe) => {
      let n = gr((i) => {
        let o = r - i,
          a = gr(() => {
            e.destroy(),
              t(
                Object.assign(new Error(`Connection timed out after ${r} ms`), {
                  name: "TimeoutError",
                }),
              );
          }, "onTimeout");
        e.socket
          ? (e.socket.setTimeout(o, a),
            e.on("close", () => e.socket?.removeListener("timeout", a)))
          : e.setTimeout(o, a);
      }, "registerTimeout");
      return 0 < r && r < 6e3
        ? (n(0), 0)
        : Bo.setTimeout(n.bind(null, r === 0 ? 0 : KGe), KGe);
    }, "setSocketTimeout"),
    tVe = G("stream"),
    WGe = 6e3;
  async function e7(e, t, r = WGe) {
    let n = t.headers ?? {},
      i = n.Expect || n.expect,
      o = -1,
      a = !0;
    i === "100-continue" &&
      (a = await Promise.race([
        new Promise((s) => {
          o = Number(Bo.setTimeout(() => s(!0), Math.max(WGe, r)));
        }),
        new Promise((s) => {
          e.on("continue", () => {
            Bo.clearTimeout(o), s(!0);
          }),
            e.on("response", () => {
              Bo.clearTimeout(o), s(!1);
            }),
            e.on("error", () => {
              Bo.clearTimeout(o), s(!1);
            });
        }),
      ])),
      a && rVe(e, t.body);
  }
  gr(e7, "writeRequestBody");
  function rVe(e, t) {
    if (t instanceof tVe.Readable) {
      t.pipe(e);
      return;
    }
    if (t) {
      if (Buffer.isBuffer(t) || typeof t == "string") {
        e.end(t);
        return;
      }
      let r = t;
      if (
        typeof r == "object" &&
        r.buffer &&
        typeof r.byteOffset == "number" &&
        typeof r.byteLength == "number"
      ) {
        e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength));
        return;
      }
      e.end(Buffer.from(t));
      return;
    }
    e.end();
  }
  gr(rVe, "writeBody");
  var nVe = 0,
    xhr = class ZX {
      constructor(t) {
        (this.socketWarningTimestamp = 0),
          (this.metadata = { handlerProtocol: "http/1.1" }),
          (this.configProvider = new Promise((r, n) => {
            typeof t == "function"
              ? t()
                  .then((i) => {
                    r(this.resolveDefaultConfig(i));
                  })
                  .catch(n)
              : r(this.resolveDefaultConfig(t));
          }));
      }
      static {
        gr(this, "NodeHttpHandler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new ZX(t);
      }
      static checkSocketUsage(t, r, n = console) {
        let { sockets: i, requests: o, maxSockets: a } = t;
        if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r)
          return r;
        if (i && o)
          for (let u in i) {
            let l = i[u]?.length ?? 0,
              d = o[u]?.length ?? 0;
            if (l >= a && d >= 2 * a)
              return (
                n?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${l} and ${d} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`),
                Date.now()
              );
          }
        return r;
      }
      resolveDefaultConfig(t) {
        let {
            requestTimeout: r,
            connectionTimeout: n,
            socketTimeout: i,
            socketAcquisitionWarningTimeout: o,
            httpAgent: a,
            httpsAgent: s,
          } = t || {},
          u = !0,
          l = 50;
        return {
          connectionTimeout: n,
          requestTimeout: r ?? i,
          socketAcquisitionWarningTimeout: o,
          httpAgent:
            a instanceof XX.Agent || typeof a?.destroy == "function"
              ? a
              : new XX.Agent({ keepAlive: u, maxSockets: l, ...a }),
          httpsAgent:
            s instanceof JX.Agent || typeof s?.destroy == "function"
              ? s
              : new JX.Agent({ keepAlive: u, maxSockets: l, ...s }),
          logger: console,
        };
      }
      destroy() {
        this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy();
      }
      async handle(t, { abortSignal: r } = {}) {
        return (
          this.config || (this.config = await this.configProvider),
          new Promise((n, i) => {
            let o,
              a = [],
              s = gr(async (C) => {
                await o, a.forEach(Bo.clearTimeout), n(C);
              }, "resolve"),
              u = gr(async (C) => {
                await o, a.forEach(Bo.clearTimeout), i(C);
              }, "reject");
            if (!this.config)
              throw new Error(
                "Node HTTP request handler config is not resolved",
              );
            if (r?.aborted) {
              let C = new Error("Request aborted");
              (C.name = "AbortError"), u(C);
              return;
            }
            let l = t.protocol === "https:",
              d = l ? this.config.httpsAgent : this.config.httpAgent;
            a.push(
              Bo.setTimeout(
                () => {
                  this.socketWarningTimestamp = ZX.checkSocketUsage(
                    d,
                    this.socketWarningTimestamp,
                    this.config.logger,
                  );
                },
                this.config.socketAcquisitionWarningTimeout ??
                  (this.config.requestTimeout ?? 2e3) +
                    (this.config.connectionTimeout ?? 1e3),
              ),
            );
            let f = (0, ZGe.buildQueryString)(t.query || {}),
              m;
            if (t.username != null || t.password != null) {
              let C = t.username ?? "",
                P = t.password ?? "";
              m = `${C}:${P}`;
            }
            let h = t.path;
            f && (h += `?${f}`), t.fragment && (h += `#${t.fragment}`);
            let y = t.hostname ?? "";
            y[0] === "[" && y.endsWith("]")
              ? (y = t.hostname.slice(1, -1))
              : (y = t.hostname);
            let _ = {
                headers: t.headers,
                host: y,
                method: t.method,
                path: h,
                port: t.port,
                agent: d,
                auth: m,
              },
              b = (l ? JX.request : XX.request)(_, (C) => {
                let P = new JGe.HttpResponse({
                  statusCode: C.statusCode || -1,
                  reason: C.statusMessage,
                  headers: eVe(C.headers),
                  body: C,
                });
                s({ response: P });
              });
            if (
              (b.on("error", (C) => {
                Thr.includes(C.code)
                  ? u(Object.assign(C, { name: "TimeoutError" }))
                  : u(C);
              }),
              r)
            ) {
              let C = gr(() => {
                b.destroy();
                let P = new Error("Request aborted");
                (P.name = "AbortError"), u(P);
              }, "onAbort");
              if (typeof r.addEventListener == "function") {
                let P = r;
                P.addEventListener("abort", C, { once: !0 }),
                  b.once("close", () => P.removeEventListener("abort", C));
              } else r.onabort = C;
            }
            a.push(Ahr(b, u, this.config.connectionTimeout)),
              a.push(Ihr(b, u, this.config.requestTimeout));
            let O = _.agent;
            typeof O == "object" &&
              "keepAlive" in O &&
              a.push(
                Rhr(b, {
                  keepAlive: O.keepAlive,
                  keepAliveMsecs: O.keepAliveMsecs,
                }),
              ),
              (o = e7(b, t, this.config.requestTimeout).catch(
                (C) => (a.forEach(Bo.clearTimeout), i(C)),
              ));
          })
        );
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then((n) => ({
            ...n,
            [t]: r,
          })));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    },
    QGe = G("http2"),
    Nhr = whr(G("http2")),
    khr = class {
      constructor(e) {
        (this.sessions = []), (this.sessions = e ?? []);
      }
      static {
        gr(this, "NodeHttp2ConnectionPool");
      }
      poll() {
        if (this.sessions.length > 0) return this.sessions.shift();
      }
      offerLast(e) {
        this.sessions.push(e);
      }
      contains(e) {
        return this.sessions.includes(e);
      }
      remove(e) {
        this.sessions = this.sessions.filter((t) => t !== e);
      }
      [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
      }
      destroy(e) {
        for (let t of this.sessions) t === e && (t.destroyed || t.destroy());
      }
    },
    Dhr = class {
      constructor(e) {
        if (
          ((this.sessionCache = new Map()),
          (this.config = e),
          this.config.maxConcurrency && this.config.maxConcurrency <= 0)
        )
          throw new RangeError("maxConcurrency must be greater than zero.");
      }
      static {
        gr(this, "NodeHttp2ConnectionManager");
      }
      lease(e, t) {
        let r = this.getUrlString(e),
          n = this.sessionCache.get(r);
        if (n) {
          let s = n.poll();
          if (s && !this.config.disableConcurrency) return s;
        }
        let i = Nhr.default.connect(r);
        this.config.maxConcurrency &&
          i.settings(
            { maxConcurrentStreams: this.config.maxConcurrency },
            (s) => {
              if (s)
                throw new Error(
                  "Fail to set maxConcurrentStreams to " +
                    this.config.maxConcurrency +
                    "when creating new session for " +
                    e.destination.toString(),
                );
            },
          ),
          i.unref();
        let o = gr(() => {
          i.destroy(), this.deleteSession(r, i);
        }, "destroySessionCb");
        i.on("goaway", o),
          i.on("error", o),
          i.on("frameError", o),
          i.on("close", () => this.deleteSession(r, i)),
          t.requestTimeout && i.setTimeout(t.requestTimeout, o);
        let a = this.sessionCache.get(r) || new khr();
        return a.offerLast(i), this.sessionCache.set(r, a), i;
      }
      deleteSession(e, t) {
        let r = this.sessionCache.get(e);
        r && r.contains(t) && (r.remove(t), this.sessionCache.set(e, r));
      }
      release(e, t) {
        let r = this.getUrlString(e);
        this.sessionCache.get(r)?.offerLast(t);
      }
      destroy() {
        for (let [e, t] of this.sessionCache) {
          for (let r of t) r.destroyed || r.destroy(), t.remove(r);
          this.sessionCache.delete(e);
        }
      }
      setMaxConcurrentStreams(e) {
        if (e && e <= 0)
          throw new RangeError(
            "maxConcurrentStreams must be greater than zero.",
          );
        this.config.maxConcurrency = e;
      }
      setDisableConcurrentStreams(e) {
        this.config.disableConcurrency = e;
      }
      getUrlString(e) {
        return e.destination.toString();
      }
    },
    Lhr = class iVe {
      constructor(t) {
        (this.metadata = { handlerProtocol: "h2" }),
          (this.connectionManager = new Dhr({})),
          (this.configProvider = new Promise((r, n) => {
            typeof t == "function"
              ? t()
                  .then((i) => {
                    r(i || {});
                  })
                  .catch(n)
              : r(t || {});
          }));
      }
      static {
        gr(this, "NodeHttp2Handler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new iVe(t);
      }
      destroy() {
        this.connectionManager.destroy();
      }
      async handle(t, { abortSignal: r } = {}) {
        this.config ||
          ((this.config = await this.configProvider),
          this.connectionManager.setDisableConcurrentStreams(
            this.config.disableConcurrentStreams || !1,
          ),
          this.config.maxConcurrentStreams &&
            this.connectionManager.setMaxConcurrentStreams(
              this.config.maxConcurrentStreams,
            ));
        let { requestTimeout: n, disableConcurrentStreams: i } = this.config;
        return new Promise((o, a) => {
          let s = !1,
            u,
            l = gr(async (L) => {
              await u, o(L);
            }, "resolve"),
            d = gr(async (L) => {
              await u, a(L);
            }, "reject");
          if (r?.aborted) {
            s = !0;
            let L = new Error("Request aborted");
            (L.name = "AbortError"), d(L);
            return;
          }
          let { hostname: f, method: m, port: h, protocol: y, query: _ } = t,
            E = "";
          if (t.username != null || t.password != null) {
            let L = t.username ?? "",
              Z = t.password ?? "";
            E = `${L}:${Z}@`;
          }
          let b = `${y}//${E}${f}${h ? `:${h}` : ""}`,
            O = { destination: new URL(b) },
            C = this.connectionManager.lease(O, {
              requestTimeout: this.config?.sessionTimeout,
              disableConcurrentStreams: i || !1,
            }),
            P = gr((L) => {
              i && this.destroySession(C), (s = !0), d(L);
            }, "rejectWithDestroy"),
            k = (0, ZGe.buildQueryString)(_ || {}),
            H = t.path;
          k && (H += `?${k}`), t.fragment && (H += `#${t.fragment}`);
          let B = C.request({
            ...t.headers,
            [QGe.constants.HTTP2_HEADER_PATH]: H,
            [QGe.constants.HTTP2_HEADER_METHOD]: m,
          });
          if (
            (C.ref(),
            B.on("response", (L) => {
              let Z = new JGe.HttpResponse({
                statusCode: L[":status"] || -1,
                headers: eVe(L),
                body: B,
              });
              (s = !0),
                l({ response: Z }),
                i && (C.close(), this.connectionManager.deleteSession(b, C));
            }),
            n &&
              B.setTimeout(n, () => {
                B.close();
                let L = new Error(
                  `Stream timed out because of no activity for ${n} ms`,
                );
                (L.name = "TimeoutError"), P(L);
              }),
            r)
          ) {
            let L = gr(() => {
              B.close();
              let Z = new Error("Request aborted");
              (Z.name = "AbortError"), P(Z);
            }, "onAbort");
            if (typeof r.addEventListener == "function") {
              let Z = r;
              Z.addEventListener("abort", L, { once: !0 }),
                B.once("close", () => Z.removeEventListener("abort", L));
            } else r.onabort = L;
          }
          B.on("frameError", (L, Z, ft) => {
            P(
              new Error(
                `Frame type id ${L} in stream id ${ft} has failed with code ${Z}.`,
              ),
            );
          }),
            B.on("error", P),
            B.on("aborted", () => {
              P(
                new Error(
                  `HTTP/2 stream is abnormally aborted in mid-communication with result code ${B.rstCode}.`,
                ),
              );
            }),
            B.on("close", () => {
              C.unref(),
                i && C.destroy(),
                s ||
                  P(
                    new Error(
                      "Unexpected error: http2 request did not get a response",
                    ),
                  );
            }),
            (u = e7(B, t, n));
        });
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then((n) => ({
            ...n,
            [t]: r,
          })));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
      destroySession(t) {
        t.destroyed || t.destroy();
      }
    },
    Mhr = class extends tVe.Writable {
      constructor() {
        super(...arguments), (this.bufferedBytes = []);
      }
      static {
        gr(this, "Collector");
      }
      _write(e, t, r) {
        this.bufferedBytes.push(e), r();
      }
    },
    qhr = gr(
      (e) =>
        jhr(e)
          ? oVe(e)
          : new Promise((t, r) => {
              let n = new Mhr();
              e.pipe(n),
                e.on("error", (i) => {
                  n.end(), r(i);
                }),
                n.on("error", r),
                n.on("finish", function () {
                  let i = new Uint8Array(Buffer.concat(this.bufferedBytes));
                  t(i);
                });
            }),
      "streamCollector",
    ),
    jhr = gr(
      (e) => typeof ReadableStream == "function" && e instanceof ReadableStream,
      "isReadableStreamInstance",
    );
  async function oVe(e) {
    let t = [],
      r = e.getReader(),
      n = !1,
      i = 0;
    for (; !n; ) {
      let { done: s, value: u } = await r.read();
      u && (t.push(u), (i += u.length)), (n = s);
    }
    let o = new Uint8Array(i),
      a = 0;
    for (let s of t) o.set(s, a), (a += s.length);
    return o;
  }
  gr(oVe, "collectReadableStream");
});
var hVe = g((wHn, mVe) => {
  c();
  var YF = Object.defineProperty,
    Fhr = Object.getOwnPropertyDescriptor,
    Bhr = Object.getOwnPropertyNames,
    Uhr = Object.prototype.hasOwnProperty,
    pu = (e, t) => YF(e, "name", { value: t, configurable: !0 }),
    Hhr = (e, t) => {
      for (var r in t) YF(e, r, { get: t[r], enumerable: !0 });
    },
    Ghr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Bhr(t))
          !Uhr.call(e, i) &&
            i !== r &&
            YF(e, i, {
              get: () => t[i],
              enumerable: !(n = Fhr(t, i)) || n.enumerable,
            });
      return e;
    },
    Vhr = (e) => Ghr(YF({}, "__esModule", { value: !0 }), e),
    cVe = {};
  Hhr(cVe, {
    FetchHttpHandler: () => zhr,
    keepAliveSupport: () => QF,
    streamCollector: () => Whr,
  });
  mVe.exports = Vhr(cVe);
  var sVe = ln(),
    $hr = YX();
  function t7(e, t) {
    return new Request(e, t);
  }
  pu(t7, "createRequest");
  function uVe(e = 0) {
    return new Promise((t, r) => {
      e &&
        setTimeout(() => {
          let n = new Error(`Request did not complete within ${e} ms`);
          (n.name = "TimeoutError"), r(n);
        }, e);
    });
  }
  pu(uVe, "requestTimeout");
  var QF = { supported: void 0 },
    zhr = class lVe {
      static {
        pu(this, "FetchHttpHandler");
      }
      static create(t) {
        return typeof t?.handle == "function" ? t : new lVe(t);
      }
      constructor(t) {
        typeof t == "function"
          ? (this.configProvider = t().then((r) => r || {}))
          : ((this.config = t ?? {}),
            (this.configProvider = Promise.resolve(this.config))),
          QF.supported === void 0 &&
            (QF.supported =
              typeof Request < "u" && "keepalive" in t7("https://[::1]"));
      }
      destroy() {}
      async handle(t, { abortSignal: r } = {}) {
        this.config || (this.config = await this.configProvider);
        let n = this.config.requestTimeout,
          i = this.config.keepAlive === !0,
          o = this.config.credentials;
        if (r?.aborted) {
          let b = new Error("Request aborted");
          return (b.name = "AbortError"), Promise.reject(b);
        }
        let a = t.path,
          s = (0, $hr.buildQueryString)(t.query || {});
        s && (a += `?${s}`), t.fragment && (a += `#${t.fragment}`);
        let u = "";
        if (t.username != null || t.password != null) {
          let b = t.username ?? "",
            O = t.password ?? "";
          u = `${b}:${O}@`;
        }
        let { port: l, method: d } = t,
          f = `${t.protocol}//${u}${t.hostname}${l ? `:${l}` : ""}${a}`,
          m = d === "GET" || d === "HEAD" ? void 0 : t.body,
          h = {
            body: m,
            headers: new Headers(t.headers),
            method: d,
            credentials: o,
          };
        this.config?.cache && (h.cache = this.config.cache),
          m && (h.duplex = "half"),
          typeof AbortController < "u" && (h.signal = r),
          QF.supported && (h.keepalive = i),
          typeof this.config.requestInit == "function" &&
            Object.assign(h, this.config.requestInit(t));
        let y = pu(() => {}, "removeSignalEventListener"),
          _ = t7(f, h),
          E = [
            fetch(_).then((b) => {
              let O = b.headers,
                C = {};
              for (let k of O.entries()) C[k[0]] = k[1];
              return b.body != null
                ? {
                    response: new sVe.HttpResponse({
                      headers: C,
                      reason: b.statusText,
                      statusCode: b.status,
                      body: b.body,
                    }),
                  }
                : b.blob().then((k) => ({
                    response: new sVe.HttpResponse({
                      headers: C,
                      reason: b.statusText,
                      statusCode: b.status,
                      body: k,
                    }),
                  }));
            }),
            uVe(n),
          ];
        return (
          r &&
            E.push(
              new Promise((b, O) => {
                let C = pu(() => {
                  let P = new Error("Request aborted");
                  (P.name = "AbortError"), O(P);
                }, "onAbort");
                if (typeof r.addEventListener == "function") {
                  let P = r;
                  P.addEventListener("abort", C, { once: !0 }),
                    (y = pu(
                      () => P.removeEventListener("abort", C),
                      "removeSignalEventListener",
                    ));
                } else r.onabort = C;
              }),
            ),
          Promise.race(E).finally(y)
        );
      }
      updateHttpClientConfig(t, r) {
        (this.config = void 0),
          (this.configProvider = this.configProvider.then(
            (n) => ((n[t] = r), n),
          ));
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    },
    Khr = fu(),
    Whr = pu(
      async (e) =>
        (typeof Blob == "function" && e instanceof Blob) ||
        e.constructor?.name === "Blob"
          ? Blob.prototype.arrayBuffer !== void 0
            ? new Uint8Array(await e.arrayBuffer())
            : dVe(e)
          : fVe(e),
      "streamCollector",
    );
  async function dVe(e) {
    let t = await pVe(e),
      r = (0, Khr.fromBase64)(t);
    return new Uint8Array(r);
  }
  pu(dVe, "collectBlob");
  async function fVe(e) {
    let t = [],
      r = e.getReader(),
      n = !1,
      i = 0;
    for (; !n; ) {
      let { done: s, value: u } = await r.read();
      u && (t.push(u), (i += u.length)), (n = s);
    }
    let o = new Uint8Array(i),
      a = 0;
    for (let s of t) o.set(s, a), (a += s.length);
    return o;
  }
  pu(fVe, "collectStream");
  function pVe(e) {
    return new Promise((t, r) => {
      let n = new FileReader();
      (n.onloadend = () => {
        if (n.readyState !== 2) return r(new Error("Reader aborted too early"));
        let i = n.result ?? "",
          o = i.indexOf(","),
          a = o > -1 ? o + 1 : i.length;
        t(i.substring(a));
      }),
        (n.onabort = () => r(new Error("Read aborted"))),
        (n.onerror = () => r(n.error)),
        n.readAsDataURL(e);
    });
  }
  pu(pVe, "readToBase64");
});
var _Ve = g((XF) => {
  "use strict";
  c();
  Object.defineProperty(XF, "__esModule", { value: !0 });
  XF.sdkStreamMixin = void 0;
  var Qhr = hVe(),
    Yhr = fu(),
    Xhr = zs(),
    Jhr = Fe(),
    gVe = ap(),
    vVe = "The stream has already been transformed.",
    Zhr = (e) => {
      var t, r;
      if (!yVe(e) && !(0, gVe.isReadableStream)(e)) {
        let a =
          ((r =
            (t = e?.__proto__) === null || t === void 0
              ? void 0
              : t.constructor) === null || r === void 0
            ? void 0
            : r.name) || e;
        throw new Error(
          `Unexpected stream implementation, expect Blob or ReadableStream, got ${a}`,
        );
      }
      let n = !1,
        i = async () => {
          if (n) throw new Error(vVe);
          return (n = !0), await (0, Qhr.streamCollector)(e);
        },
        o = (a) => {
          if (typeof a.stream != "function")
            throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
          return a.stream();
        };
      return Object.assign(e, {
        transformToByteArray: i,
        transformToString: async (a) => {
          let s = await i();
          if (a === "base64") return (0, Yhr.toBase64)(s);
          if (a === "hex") return (0, Xhr.toHex)(s);
          if (a === void 0 || a === "utf8" || a === "utf-8")
            return (0, Jhr.toUtf8)(s);
          if (typeof TextDecoder == "function")
            return new TextDecoder(a).decode(s);
          throw new Error(
            "TextDecoder is not available, please make sure polyfill is provided.",
          );
        },
        transformToWebStream: () => {
          if (n) throw new Error(vVe);
          if (((n = !0), yVe(e))) return o(e);
          if ((0, gVe.isReadableStream)(e)) return e;
          throw new Error(`Cannot transform payload to web stream, got ${e}`);
        },
      });
    };
  XF.sdkStreamMixin = Zhr;
  var yVe = (e) => typeof Blob == "function" && e instanceof Blob;
});
var bVe = g((JF) => {
  "use strict";
  c();
  Object.defineProperty(JF, "__esModule", { value: !0 });
  JF.sdkStreamMixin = void 0;
  var egr = Lh(),
    tgr = Hi(),
    r7 = G("stream"),
    rgr = _Ve(),
    EVe = "The stream has already been transformed.",
    ngr = (e) => {
      var t, r;
      if (!(e instanceof r7.Readable))
        try {
          return (0, rgr.sdkStreamMixin)(e);
        } catch {
          let a =
            ((r =
              (t = e?.__proto__) === null || t === void 0
                ? void 0
                : t.constructor) === null || r === void 0
              ? void 0
              : r.name) || e;
          throw new Error(
            `Unexpected stream implementation, expect Stream.Readable instance, got ${a}`,
          );
        }
      let n = !1,
        i = async () => {
          if (n) throw new Error(EVe);
          return (n = !0), await (0, egr.streamCollector)(e);
        };
      return Object.assign(e, {
        transformToByteArray: i,
        transformToString: async (o) => {
          let a = await i();
          return o === void 0 || Buffer.isEncoding(o)
            ? (0, tgr.fromArrayBuffer)(
                a.buffer,
                a.byteOffset,
                a.byteLength,
              ).toString(o)
            : new TextDecoder(o).decode(a);
        },
        transformToWebStream: () => {
          if (n) throw new Error(EVe);
          if (e.readableFlowing !== null)
            throw new Error("The stream has been consumed by other callbacks.");
          if (typeof r7.Readable.toWeb != "function")
            throw new Error(
              "Readable.toWeb() is not supported. Please ensure a polyfill is available.",
            );
          return (n = !0), r7.Readable.toWeb(e);
        },
      });
    };
  JF.sdkStreamMixin = ngr;
});
var SVe = g((ZF) => {
  "use strict";
  c();
  Object.defineProperty(ZF, "__esModule", { value: !0 });
  ZF.splitStream = void 0;
  async function igr(e) {
    return typeof e.stream == "function" && (e = e.stream()), e.tee();
  }
  ZF.splitStream = igr;
});
var OVe = g((e1) => {
  "use strict";
  c();
  Object.defineProperty(e1, "__esModule", { value: !0 });
  e1.splitStream = void 0;
  var CVe = G("stream"),
    ogr = SVe(),
    wVe = ap();
  async function agr(e) {
    if ((0, wVe.isReadableStream)(e) || (0, wVe.isBlob)(e))
      return (0, ogr.splitStream)(e);
    let t = new CVe.PassThrough(),
      r = new CVe.PassThrough();
    return e.pipe(t), e.pipe(r), [t, r];
  }
  e1.splitStream = agr;
});
var r1 = g((DHn, hu) => {
  c();
  var t1 = Object.defineProperty,
    sgr = Object.getOwnPropertyDescriptor,
    cgr = Object.getOwnPropertyNames,
    ugr = Object.prototype.hasOwnProperty,
    o7 = (e, t) => t1(e, "name", { value: t, configurable: !0 }),
    lgr = (e, t) => {
      for (var r in t) t1(e, r, { get: t[r], enumerable: !0 });
    },
    n7 = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of cgr(t))
          !ugr.call(e, i) &&
            i !== r &&
            t1(e, i, {
              get: () => t[i],
              enumerable: !(n = sgr(t, i)) || n.enumerable,
            });
      return e;
    },
    sp = (e, t, r) => (n7(e, t, "default"), r && n7(r, t, "default")),
    dgr = (e) => n7(t1({}, "__esModule", { value: !0 }), e),
    mu = {};
  lgr(mu, { Uint8ArrayBlobAdapter: () => i7 });
  hu.exports = dgr(mu);
  var TVe = fu(),
    AVe = Fe();
  function PVe(e, t = "utf-8") {
    return t === "base64" ? (0, TVe.toBase64)(e) : (0, AVe.toUtf8)(e);
  }
  o7(PVe, "transformToString");
  function RVe(e, t) {
    return t === "base64"
      ? i7.mutate((0, TVe.fromBase64)(e))
      : i7.mutate((0, AVe.fromUtf8)(e));
  }
  o7(RVe, "transformFromString");
  var i7 = class IVe extends Uint8Array {
    static {
      o7(this, "Uint8ArrayBlobAdapter");
    }
    static fromString(t, r = "utf-8") {
      switch (typeof t) {
        case "string":
          return RVe(t, r);
        default:
          throw new Error(
            `Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`,
          );
      }
    }
    static mutate(t) {
      return Object.setPrototypeOf(t, IVe.prototype), t;
    }
    transformToString(t = "utf-8") {
      return PVe(this, t);
    }
  };
  sp(mu, HX(), hu.exports);
  sp(mu, IGe(), hu.exports);
  sp(mu, MGe(), hu.exports);
  sp(mu, qGe(), hu.exports);
  sp(mu, FGe(), hu.exports);
  sp(mu, bVe(), hu.exports);
  sp(mu, OVe(), hu.exports);
  sp(mu, ap(), hu.exports);
});
var n1,
  fgr,
  xVe = w(() => {
    c();
    (n1 = A(r1())),
      (fgr = async (e = new Uint8Array(), t) => {
        if (e instanceof Uint8Array) return n1.Uint8ArrayBlobAdapter.mutate(e);
        if (!e) return n1.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
        let r = t.streamCollector(e);
        return n1.Uint8ArrayBlobAdapter.mutate(await r);
      });
  });
function i1(e) {
  return encodeURIComponent(e).replace(/[!'()*]/g, function (t) {
    return "%" + t.charCodeAt(0).toString(16).toUpperCase();
  });
}
var a7 = w(() => {
  c();
});
var s7,
  c7 = w(() => {
    c();
    a7();
    s7 = (e, t, r, n, i, o) => {
      if (t != null && t[r] !== void 0) {
        let a = n();
        if (a.length <= 0)
          throw new Error(
            "Empty value provided for input HTTP label: " + r + ".",
          );
        e = e.replace(
          i,
          o
            ? a
                .split("/")
                .map((s) => i1(s))
                .join("/")
            : i1(a),
        );
      } else
        throw new Error("No value provided for input HTTP label: " + r + ".");
      return e;
    };
  });
function PO(e, t) {
  return new o1(e, t);
}
var NVe,
  o1,
  kVe = w(() => {
    c();
    NVe = A(ln());
    c7();
    o1 = class {
      constructor(t, r) {
        (this.input = t),
          (this.context = r),
          (this.query = {}),
          (this.method = ""),
          (this.headers = {}),
          (this.path = ""),
          (this.body = null),
          (this.hostname = ""),
          (this.resolvePathStack = []);
      }
      async build() {
        let {
          hostname: t,
          protocol: r = "https",
          port: n,
          path: i,
        } = await this.context.endpoint();
        this.path = i;
        for (let o of this.resolvePathStack) o(this.path);
        return new NVe.HttpRequest({
          protocol: r,
          hostname: this.hostname || t,
          port: n,
          method: this.method,
          path: this.path,
          query: this.query,
          body: this.body,
          headers: this.headers,
        });
      }
      hn(t) {
        return (this.hostname = t), this;
      }
      bp(t) {
        return (
          this.resolvePathStack.push((r) => {
            this.path = `${r?.endsWith("/") ? r.slice(0, -1) : r || ""}` + t;
          }),
          this
        );
      }
      p(t, r, n, i) {
        return (
          this.resolvePathStack.push((o) => {
            this.path = s7(o, this.input, t, r, n, i);
          }),
          this
        );
      }
      h(t) {
        return (this.headers = t), this;
      }
      q(t) {
        return (this.query = t), this;
      }
      b(t) {
        return (this.body = t), this;
      }
      m(t) {
        return (this.method = t), this;
      }
    };
  });
var DVe = {};
bn(DVe, {
  RequestBuilder: () => o1,
  collectBody: () => fgr,
  extendedEncodeURIComponent: () => i1,
  requestBuilder: () => PO,
  resolvedPath: () => s7,
});
var u7 = w(() => {
  c();
  xVe();
  a7();
  kVe();
  c7();
});
var LVe = w(() => {
  c();
  u7();
});
function pgr(e, t, r) {
  e.__smithy_context
    ? e.__smithy_context.features || (e.__smithy_context.features = {})
    : (e.__smithy_context = { features: {} }),
    (e.__smithy_context.features[t] = r);
}
var MVe = w(() => {
  c();
});
var Mh,
  qVe = w(() => {
    c();
    Mh = class {
      constructor(t) {
        this.authSchemes = new Map();
        for (let [r, n] of Object.entries(t))
          n !== void 0 && this.authSchemes.set(r, n);
      }
      getIdentityProvider(t) {
        return this.authSchemes.get(t);
      }
    };
  });
var jVe,
  l7,
  d7,
  FVe = w(() => {
    c();
    (jVe = A(ln())),
      (l7 = A(Ul())),
      (d7 = class {
        async sign(t, r, n) {
          if (!n)
            throw new Error(
              "request could not be signed with `apiKey` since the `name` and `in` signer properties are missing",
            );
          if (!n.name)
            throw new Error(
              "request could not be signed with `apiKey` since the `name` signer property is missing",
            );
          if (!n.in)
            throw new Error(
              "request could not be signed with `apiKey` since the `in` signer property is missing",
            );
          if (!r.apiKey)
            throw new Error(
              "request could not be signed with `apiKey` since the `apiKey` is not defined",
            );
          let i = jVe.HttpRequest.clone(t);
          if (n.in === l7.HttpApiKeyAuthLocation.QUERY)
            i.query[n.name] = r.apiKey;
          else if (n.in === l7.HttpApiKeyAuthLocation.HEADER)
            i.headers[n.name] = n.scheme ? `${n.scheme} ${r.apiKey}` : r.apiKey;
          else
            throw new Error(
              "request can only be signed with `apiKey` locations `query` or `header`, but found: `" +
                n.in +
                "`",
            );
          return i;
        }
      });
  });
var BVe,
  f7,
  UVe = w(() => {
    c();
    (BVe = A(ln())),
      (f7 = class {
        async sign(t, r, n) {
          let i = BVe.HttpRequest.clone(t);
          if (!r.token)
            throw new Error(
              "request could not be signed with `token` since the `token` is not defined",
            );
          return (i.headers.Authorization = `Bearer ${r.token}`), i;
        }
      });
  });
var Vl,
  HVe = w(() => {
    c();
    Vl = class {
      async sign(t, r, n) {
        return t;
      }
    };
  });
var GVe = w(() => {
  c();
  FVe();
  UVe();
  HVe();
});
var VVe,
  mgr,
  p7,
  a1,
  m7,
  $Ve = w(() => {
    c();
    (VVe = (e) => (t) => a1(t) && t.expiration.getTime() - Date.now() < e),
      (mgr = 3e5),
      (p7 = VVe(3e5)),
      (a1 = (e) => e.expiration !== void 0),
      (m7 = (e, t, r) => {
        if (e === void 0) return;
        let n = typeof e != "function" ? async () => Promise.resolve(e) : e,
          i,
          o,
          a,
          s = !1,
          u = async (l) => {
            o || (o = n(l));
            try {
              (i = await o), (a = !0), (s = !1);
            } finally {
              o = void 0;
            }
            return i;
          };
        return t === void 0
          ? async (l) => ((!a || l?.forceRefresh) && (i = await u(l)), i)
          : async (l) => (
              (!a || l?.forceRefresh) && (i = await u(l)),
              s ? i : r(i) ? (t(i) && (await u(l)), i) : ((s = !0), i)
            );
      });
  });
var zVe = w(() => {
  c();
  qVe();
  GVe();
  $Ve();
});
var rc = {};
bn(rc, {
  DefaultIdentityProviderConfig: () => Mh,
  EXPIRATION_MS: () => mgr,
  HttpApiKeyAuthSigner: () => d7,
  HttpBearerAuthSigner: () => f7,
  NoAuthSigner: () => Vl,
  createIsIdentityExpiredFunction: () => VVe,
  createPaginator: () => SGe,
  doesIdentityRequireRefresh: () => a1,
  getHttpAuthSchemeEndpointRuleSetPlugin: () => OO,
  getHttpAuthSchemePlugin: () => ymr,
  getHttpSigningPlugin: () => TO,
  getSmithyContext: () => rmr,
  httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => nGe,
  httpAuthSchemeMiddleware: () => wO,
  httpAuthSchemeMiddlewareOptions: () => pGe,
  httpSigningMiddleware: () => qX,
  httpSigningMiddlewareOptions: () => yGe,
  isIdentityExpired: () => p7,
  memoizeIdentityProvider: () => m7,
  normalizeProvider: () => op,
  requestBuilder: () => PO,
  setFeature: () => pgr,
});
var Gn = w(() => {
  c();
  Q3e();
  hGe();
  EGe();
  bGe();
  CGe();
  LVe();
  MVe();
  zVe();
});
var pE = g((x3n, t$e) => {
  c();
  var s1 = Object.defineProperty,
    hgr = Object.getOwnPropertyDescriptor,
    ggr = Object.getOwnPropertyNames,
    vgr = Object.prototype.hasOwnProperty,
    rr = (e, t) => s1(e, "name", { value: t, configurable: !0 }),
    ygr = (e, t) => {
      for (var r in t) s1(e, r, { get: t[r], enumerable: !0 });
    },
    _gr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of ggr(t))
          !vgr.call(e, i) &&
            i !== r &&
            s1(e, i, {
              get: () => t[i],
              enumerable: !(n = hgr(t, i)) || n.enumerable,
            });
      return e;
    },
    Egr = (e) => _gr(s1({}, "__esModule", { value: !0 }), e),
    KVe = {};
  ygr(KVe, {
    EndpointCache: () => bgr,
    EndpointError: () => Uo,
    customEndpointFunctions: () => g7,
    isIpAddress: () => WVe,
    isValidHostLabel: () => y7,
    resolveEndpoint: () => Bgr,
  });
  t$e.exports = Egr(KVe);
  var bgr = class {
      constructor({ size: e, params: t }) {
        (this.data = new Map()),
          (this.parameters = []),
          (this.capacity = e ?? 50),
          t && (this.parameters = t);
      }
      static {
        rr(this, "EndpointCache");
      }
      get(e, t) {
        let r = this.hash(e);
        if (r === !1) return t();
        if (!this.data.has(r)) {
          if (this.data.size > this.capacity + 10) {
            let n = this.data.keys(),
              i = 0;
            for (;;) {
              let { value: o, done: a } = n.next();
              if ((this.data.delete(o), a || ++i > 10)) break;
            }
          }
          this.data.set(r, t());
        }
        return this.data.get(r);
      }
      size() {
        return this.data.size;
      }
      hash(e) {
        let t = "",
          { parameters: r } = this;
        if (r.length === 0) return !1;
        for (let n of r) {
          let i = String(e[n] ?? "");
          if (i.includes("|;")) return !1;
          t += i + "|;";
        }
        return t;
      }
    },
    Sgr = new RegExp(
      "^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$",
    ),
    WVe = rr(
      (e) => Sgr.test(e) || (e.startsWith("[") && e.endsWith("]")),
      "isIpAddress",
    ),
    Cgr = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"),
    y7 = rr((e, t = !1) => {
      if (!t) return Cgr.test(e);
      let r = e.split(".");
      for (let n of r) if (!y7(n)) return !1;
      return !0;
    }, "isValidHostLabel"),
    g7 = {},
    RO = "endpoints";
  function $l(e) {
    return typeof e != "object" || e == null
      ? e
      : "ref" in e
        ? `$${$l(e.ref)}`
        : "fn" in e
          ? `${e.fn}(${(e.argv || []).map($l).join(", ")})`
          : JSON.stringify(e, null, 2);
  }
  rr($l, "toDebugString");
  var Uo = class extends Error {
      static {
        rr(this, "EndpointError");
      }
      constructor(e) {
        super(e), (this.name = "EndpointError");
      }
    },
    wgr = rr((e, t) => e === t, "booleanEquals"),
    Ogr = rr((e) => {
      let t = e.split("."),
        r = [];
      for (let n of t) {
        let i = n.indexOf("[");
        if (i !== -1) {
          if (n.indexOf("]") !== n.length - 1)
            throw new Uo(`Path: '${e}' does not end with ']'`);
          let o = n.slice(i + 1, -1);
          if (Number.isNaN(parseInt(o)))
            throw new Uo(`Invalid array index: '${o}' in path: '${e}'`);
          i !== 0 && r.push(n.slice(0, i)), r.push(o);
        } else r.push(n);
      }
      return r;
    }, "getAttrPathList"),
    QVe = rr(
      (e, t) =>
        Ogr(t).reduce((r, n) => {
          if (typeof r != "object")
            throw new Uo(
              `Index '${n}' in '${t}' not found in '${JSON.stringify(e)}'`,
            );
          return Array.isArray(r) ? r[parseInt(n)] : r[n];
        }, e),
      "getAttr",
    ),
    Tgr = rr((e) => e != null, "isSet"),
    Agr = rr((e) => !e, "not"),
    v7 = Ul(),
    h7 = { [v7.EndpointURLScheme.HTTP]: 80, [v7.EndpointURLScheme.HTTPS]: 443 },
    Pgr = rr((e) => {
      let t = (() => {
        try {
          if (e instanceof URL) return e;
          if (typeof e == "object" && "hostname" in e) {
            let {
                hostname: m,
                port: h,
                protocol: y = "",
                path: _ = "",
                query: E = {},
              } = e,
              b = new URL(`${y}//${m}${h ? `:${h}` : ""}${_}`);
            return (
              (b.search = Object.entries(E)
                .map(([O, C]) => `${O}=${C}`)
                .join("&")),
              b
            );
          }
          return new URL(e);
        } catch {
          return null;
        }
      })();
      if (!t)
        return (
          console.error(
            `Unable to parse ${JSON.stringify(e)} as a whatwg URL.`,
          ),
          null
        );
      let r = t.href,
        { host: n, hostname: i, pathname: o, protocol: a, search: s } = t;
      if (s) return null;
      let u = a.slice(0, -1);
      if (!Object.values(v7.EndpointURLScheme).includes(u)) return null;
      let l = WVe(i),
        d =
          r.includes(`${n}:${h7[u]}`) ||
          (typeof e == "string" && e.includes(`${n}:${h7[u]}`)),
        f = `${n}${d ? `:${h7[u]}` : ""}`;
      return {
        scheme: u,
        authority: f,
        path: o,
        normalizedPath: o.endsWith("/") ? o : `${o}/`,
        isIp: l,
      };
    }, "parseURL"),
    Rgr = rr((e, t) => e === t, "stringEquals"),
    Igr = rr(
      (e, t, r, n) =>
        t >= r || e.length < r
          ? null
          : n
            ? e.substring(e.length - r, e.length - t)
            : e.substring(t, r),
      "substring",
    ),
    xgr = rr(
      (e) =>
        encodeURIComponent(e).replace(
          /[!*'()]/g,
          (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`,
        ),
      "uriEncode",
    ),
    Ngr = {
      booleanEquals: wgr,
      getAttr: QVe,
      isSet: Tgr,
      isValidHostLabel: y7,
      not: Agr,
      parseURL: Pgr,
      stringEquals: Rgr,
      substring: Igr,
      uriEncode: xgr,
    },
    YVe = rr((e, t) => {
      let r = [],
        n = { ...t.endpointParams, ...t.referenceRecord },
        i = 0;
      for (; i < e.length; ) {
        let o = e.indexOf("{", i);
        if (o === -1) {
          r.push(e.slice(i));
          break;
        }
        r.push(e.slice(i, o));
        let a = e.indexOf("}", o);
        if (a === -1) {
          r.push(e.slice(o));
          break;
        }
        e[o + 1] === "{" &&
          e[a + 1] === "}" &&
          (r.push(e.slice(o + 1, a)), (i = a + 2));
        let s = e.substring(o + 1, a);
        if (s.includes("#")) {
          let [u, l] = s.split("#");
          r.push(QVe(n[u], l));
        } else r.push(n[s]);
        i = a + 1;
      }
      return r.join("");
    }, "evaluateTemplate"),
    kgr = rr(
      ({ ref: e }, t) => ({ ...t.endpointParams, ...t.referenceRecord })[e],
      "getReferenceValue",
    ),
    c1 = rr((e, t, r) => {
      if (typeof e == "string") return YVe(e, r);
      if (e.fn) return XVe(e, r);
      if (e.ref) return kgr(e, r);
      throw new Uo(
        `'${t}': ${String(e)} is not a string, function or reference.`,
      );
    }, "evaluateExpression"),
    XVe = rr(({ fn: e, argv: t }, r) => {
      let n = t.map((o) =>
          ["boolean", "number"].includes(typeof o) ? o : c1(o, "arg", r),
        ),
        i = e.split(".");
      return i[0] in g7 && i[1] != null ? g7[i[0]][i[1]](...n) : Ngr[e](...n);
    }, "callFunction"),
    Dgr = rr(({ assign: e, ...t }, r) => {
      if (e && e in r.referenceRecord)
        throw new Uo(`'${e}' is already defined in Reference Record.`);
      let n = XVe(t, r);
      return (
        r.logger?.debug?.(`${RO} evaluateCondition: ${$l(t)} = ${$l(n)}`),
        {
          result: n === "" ? !0 : !!n,
          ...(e != null && { toAssign: { name: e, value: n } }),
        }
      );
    }, "evaluateCondition"),
    _7 = rr((e = [], t) => {
      let r = {};
      for (let n of e) {
        let { result: i, toAssign: o } = Dgr(n, {
          ...t,
          referenceRecord: { ...t.referenceRecord, ...r },
        });
        if (!i) return { result: i };
        o &&
          ((r[o.name] = o.value),
          t.logger?.debug?.(`${RO} assign: ${o.name} := ${$l(o.value)}`));
      }
      return { result: !0, referenceRecord: r };
    }, "evaluateConditions"),
    Lgr = rr(
      (e, t) =>
        Object.entries(e).reduce(
          (r, [n, i]) => ({
            ...r,
            [n]: i.map((o) => {
              let a = c1(o, "Header value entry", t);
              if (typeof a != "string")
                throw new Uo(`Header '${n}' value '${a}' is not a string`);
              return a;
            }),
          }),
          {},
        ),
      "getEndpointHeaders",
    ),
    JVe = rr((e, t) => {
      if (Array.isArray(e)) return e.map((r) => JVe(r, t));
      switch (typeof e) {
        case "string":
          return YVe(e, t);
        case "object":
          if (e === null) throw new Uo(`Unexpected endpoint property: ${e}`);
          return ZVe(e, t);
        case "boolean":
          return e;
        default:
          throw new Uo(`Unexpected endpoint property type: ${typeof e}`);
      }
    }, "getEndpointProperty"),
    ZVe = rr(
      (e, t) =>
        Object.entries(e).reduce((r, [n, i]) => ({ ...r, [n]: JVe(i, t) }), {}),
      "getEndpointProperties",
    ),
    Mgr = rr((e, t) => {
      let r = c1(e, "Endpoint URL", t);
      if (typeof r == "string")
        try {
          return new URL(r);
        } catch (n) {
          throw (console.error(`Failed to construct URL with ${r}`, n), n);
        }
      throw new Uo(`Endpoint URL must be a string, got ${typeof r}`);
    }, "getEndpointUrl"),
    qgr = rr((e, t) => {
      let { conditions: r, endpoint: n } = e,
        { result: i, referenceRecord: o } = _7(r, t);
      if (!i) return;
      let a = { ...t, referenceRecord: { ...t.referenceRecord, ...o } },
        { url: s, properties: u, headers: l } = n;
      return (
        t.logger?.debug?.(`${RO} Resolving endpoint from template: ${$l(n)}`),
        {
          ...(l != null && { headers: Lgr(l, a) }),
          ...(u != null && { properties: ZVe(u, a) }),
          url: Mgr(s, a),
        }
      );
    }, "evaluateEndpointRule"),
    jgr = rr((e, t) => {
      let { conditions: r, error: n } = e,
        { result: i, referenceRecord: o } = _7(r, t);
      if (i)
        throw new Uo(
          c1(n, "Error", {
            ...t,
            referenceRecord: { ...t.referenceRecord, ...o },
          }),
        );
    }, "evaluateErrorRule"),
    Fgr = rr((e, t) => {
      let { conditions: r, rules: n } = e,
        { result: i, referenceRecord: o } = _7(r, t);
      if (i)
        return e$e(n, {
          ...t,
          referenceRecord: { ...t.referenceRecord, ...o },
        });
    }, "evaluateTreeRule"),
    e$e = rr((e, t) => {
      for (let r of e)
        if (r.type === "endpoint") {
          let n = qgr(r, t);
          if (n) return n;
        } else if (r.type === "error") jgr(r, t);
        else if (r.type === "tree") {
          let n = Fgr(r, t);
          if (n) return n;
        } else throw new Uo(`Unknown endpoint rule: ${r}`);
      throw new Uo("Rules evaluation failed");
    }, "evaluateRules"),
    Bgr = rr((e, t) => {
      let { endpointParams: r, logger: n } = t,
        { parameters: i, rules: o } = e;
      t.logger?.debug?.(`${RO} Initial EndpointParams: ${$l(r)}`);
      let a = Object.entries(i)
        .filter(([, l]) => l.default != null)
        .map(([l, d]) => [l, d.default]);
      if (a.length > 0) for (let [l, d] of a) r[l] = r[l] ?? d;
      let s = Object.entries(i)
        .filter(([, l]) => l.required)
        .map(([l]) => l);
      for (let l of s)
        if (r[l] == null) throw new Uo(`Missing required parameter: '${l}'`);
      let u = e$e(o, { endpointParams: r, logger: n, referenceRecord: {} });
      return t.logger?.debug?.(`${RO} Resolved endpoint: ${$l(u)}`), u;
    }, "resolveEndpoint");
});
var hE = g((L3n, d$e) => {
  "use strict";
  c();
  var u1 = Object.defineProperty,
    Ugr = Object.getOwnPropertyDescriptor,
    Hgr = Object.getOwnPropertyNames,
    Ggr = Object.prototype.hasOwnProperty,
    mE = (e, t) => u1(e, "name", { value: t, configurable: !0 }),
    Vgr = (e, t) => {
      for (var r in t) u1(e, r, { get: t[r], enumerable: !0 });
    },
    $gr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Hgr(t))
          !Ggr.call(e, i) &&
            i !== r &&
            u1(e, i, {
              get: () => t[i],
              enumerable: !(n = Ugr(t, i)) || n.enumerable,
            });
      return e;
    },
    zgr = (e) => $gr(u1({}, "__esModule", { value: !0 }), e),
    n$e = {};
  Vgr(n$e, {
    ConditionObject: () => Rr.ConditionObject,
    DeprecatedObject: () => Rr.DeprecatedObject,
    EndpointError: () => Rr.EndpointError,
    EndpointObject: () => Rr.EndpointObject,
    EndpointObjectHeaders: () => Rr.EndpointObjectHeaders,
    EndpointObjectProperties: () => Rr.EndpointObjectProperties,
    EndpointParams: () => Rr.EndpointParams,
    EndpointResolverOptions: () => Rr.EndpointResolverOptions,
    EndpointRuleObject: () => Rr.EndpointRuleObject,
    ErrorRuleObject: () => Rr.ErrorRuleObject,
    EvaluateOptions: () => Rr.EvaluateOptions,
    Expression: () => Rr.Expression,
    FunctionArgv: () => Rr.FunctionArgv,
    FunctionObject: () => Rr.FunctionObject,
    FunctionReturn: () => Rr.FunctionReturn,
    ParameterObject: () => Rr.ParameterObject,
    ReferenceObject: () => Rr.ReferenceObject,
    ReferenceRecord: () => Rr.ReferenceRecord,
    RuleSetObject: () => Rr.RuleSetObject,
    RuleSetRules: () => Rr.RuleSetRules,
    TreeRuleObject: () => Rr.TreeRuleObject,
    awsEndpointFunctions: () => l$e,
    getUserAgentPrefix: () => Ygr,
    isIpAddress: () => Rr.isIpAddress,
    partition: () => c$e,
    resolveEndpoint: () => Rr.resolveEndpoint,
    setPartitionInfo: () => u$e,
    useDefaultPartitionInfo: () => Qgr,
  });
  d$e.exports = zgr(n$e);
  var Rr = pE(),
    i$e = mE((e, t = !1) => {
      if (t) {
        for (let r of e.split(".")) if (!i$e(r)) return !1;
        return !0;
      }
      return !(
        !(0, Rr.isValidHostLabel)(e) ||
        e.length < 3 ||
        e.length > 63 ||
        e !== e.toLowerCase() ||
        (0, Rr.isIpAddress)(e)
      );
    }, "isVirtualHostableS3Bucket"),
    r$e = ":",
    Kgr = "/",
    Wgr = mE((e) => {
      let t = e.split(r$e);
      if (t.length < 6) return null;
      let [r, n, i, o, a, ...s] = t;
      if (r !== "arn" || n === "" || i === "" || s.join(r$e) === "")
        return null;
      let u = s.map((l) => l.split(Kgr)).flat();
      return {
        partition: n,
        service: i,
        region: o,
        accountId: a,
        resourceId: u,
      };
    }, "parseArn"),
    o$e = {
      partitions: [
        {
          id: "aws",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-east-1",
            name: "aws",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
          regions: {
            "af-south-1": { description: "Africa (Cape Town)" },
            "ap-east-1": { description: "Asia Pacific (Hong Kong)" },
            "ap-northeast-1": { description: "Asia Pacific (Tokyo)" },
            "ap-northeast-2": { description: "Asia Pacific (Seoul)" },
            "ap-northeast-3": { description: "Asia Pacific (Osaka)" },
            "ap-south-1": { description: "Asia Pacific (Mumbai)" },
            "ap-south-2": { description: "Asia Pacific (Hyderabad)" },
            "ap-southeast-1": { description: "Asia Pacific (Singapore)" },
            "ap-southeast-2": { description: "Asia Pacific (Sydney)" },
            "ap-southeast-3": { description: "Asia Pacific (Jakarta)" },
            "ap-southeast-4": { description: "Asia Pacific (Melbourne)" },
            "ap-southeast-5": { description: "Asia Pacific (Malaysia)" },
            "ap-southeast-7": { description: "Asia Pacific (Thailand)" },
            "aws-global": { description: "AWS Standard global region" },
            "ca-central-1": { description: "Canada (Central)" },
            "ca-west-1": { description: "Canada West (Calgary)" },
            "eu-central-1": { description: "Europe (Frankfurt)" },
            "eu-central-2": { description: "Europe (Zurich)" },
            "eu-north-1": { description: "Europe (Stockholm)" },
            "eu-south-1": { description: "Europe (Milan)" },
            "eu-south-2": { description: "Europe (Spain)" },
            "eu-west-1": { description: "Europe (Ireland)" },
            "eu-west-2": { description: "Europe (London)" },
            "eu-west-3": { description: "Europe (Paris)" },
            "il-central-1": { description: "Israel (Tel Aviv)" },
            "me-central-1": { description: "Middle East (UAE)" },
            "me-south-1": { description: "Middle East (Bahrain)" },
            "mx-central-1": { description: "Mexico (Central)" },
            "sa-east-1": { description: "South America (Sao Paulo)" },
            "us-east-1": { description: "US East (N. Virginia)" },
            "us-east-2": { description: "US East (Ohio)" },
            "us-west-1": { description: "US West (N. California)" },
            "us-west-2": { description: "US West (Oregon)" },
          },
        },
        {
          id: "aws-cn",
          outputs: {
            dnsSuffix: "amazonaws.com.cn",
            dualStackDnsSuffix: "api.amazonwebservices.com.cn",
            implicitGlobalRegion: "cn-northwest-1",
            name: "aws-cn",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^cn\\-\\w+\\-\\d+$",
          regions: {
            "aws-cn-global": { description: "AWS China global region" },
            "cn-north-1": { description: "China (Beijing)" },
            "cn-northwest-1": { description: "China (Ningxia)" },
          },
        },
        {
          id: "aws-us-gov",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-gov-west-1",
            name: "aws-us-gov",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
          regions: {
            "aws-us-gov-global": {
              description: "AWS GovCloud (US) global region",
            },
            "us-gov-east-1": { description: "AWS GovCloud (US-East)" },
            "us-gov-west-1": { description: "AWS GovCloud (US-West)" },
          },
        },
        {
          id: "aws-iso",
          outputs: {
            dnsSuffix: "c2s.ic.gov",
            dualStackDnsSuffix: "c2s.ic.gov",
            implicitGlobalRegion: "us-iso-east-1",
            name: "aws-iso",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-global": { description: "AWS ISO (US) global region" },
            "us-iso-east-1": { description: "US ISO East" },
            "us-iso-west-1": { description: "US ISO WEST" },
          },
        },
        {
          id: "aws-iso-b",
          outputs: {
            dnsSuffix: "sc2s.sgov.gov",
            dualStackDnsSuffix: "sc2s.sgov.gov",
            implicitGlobalRegion: "us-isob-east-1",
            name: "aws-iso-b",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-b-global": { description: "AWS ISOB (US) global region" },
            "us-isob-east-1": { description: "US ISOB East (Ohio)" },
          },
        },
        {
          id: "aws-iso-e",
          outputs: {
            dnsSuffix: "cloud.adc-e.uk",
            dualStackDnsSuffix: "cloud.adc-e.uk",
            implicitGlobalRegion: "eu-isoe-west-1",
            name: "aws-iso-e",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-e-global": {
              description: "AWS ISOE (Europe) global region",
            },
            "eu-isoe-west-1": { description: "EU ISOE West" },
          },
        },
        {
          id: "aws-iso-f",
          outputs: {
            dnsSuffix: "csp.hci.ic.gov",
            dualStackDnsSuffix: "csp.hci.ic.gov",
            implicitGlobalRegion: "us-isof-south-1",
            name: "aws-iso-f",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-f-global": { description: "AWS ISOF global region" },
            "us-isof-east-1": { description: "US ISOF EAST" },
            "us-isof-south-1": { description: "US ISOF SOUTH" },
          },
        },
        {
          id: "aws-eusc",
          outputs: {
            dnsSuffix: "amazonaws.eu",
            dualStackDnsSuffix: "amazonaws.eu",
            implicitGlobalRegion: "eusc-de-east-1",
            name: "aws-eusc",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
          regions: { "eusc-de-east-1": { description: "EU (Germany)" } },
        },
      ],
      version: "1.1",
    },
    a$e = o$e,
    s$e = "",
    c$e = mE((e) => {
      let { partitions: t } = a$e;
      for (let n of t) {
        let { regions: i, outputs: o } = n;
        for (let [a, s] of Object.entries(i))
          if (a === e) return { ...o, ...s };
      }
      for (let n of t) {
        let { regionRegex: i, outputs: o } = n;
        if (new RegExp(i).test(e)) return { ...o };
      }
      let r = t.find((n) => n.id === "aws");
      if (!r)
        throw new Error(
          "Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.",
        );
      return { ...r.outputs };
    }, "partition"),
    u$e = mE((e, t = "") => {
      (a$e = e), (s$e = t);
    }, "setPartitionInfo"),
    Qgr = mE(() => {
      u$e(o$e, "");
    }, "useDefaultPartitionInfo"),
    Ygr = mE(() => s$e, "getUserAgentPrefix"),
    l$e = { isVirtualHostableS3Bucket: i$e, parseArn: Wgr, partition: c$e };
  Rr.customEndpointFunctions.aws = l$e;
});
var l1,
  gE,
  f$e = w(() => {
    c();
    (l1 = { warningEmitted: !1 }),
      (gE = (e) => {
        e &&
          !l1.warningEmitted &&
          parseInt(e.substring(1, e.indexOf("."))) < 18 &&
          ((l1.warningEmitted = !0),
          process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`));
      });
  });
function cp(e, t, r) {
  return e.$source || (e.$source = {}), (e.$source[t] = r), e;
}
var p$e = w(() => {
  c();
});
function m$e(e, t, r) {
  e.__aws_sdk_context
    ? e.__aws_sdk_context.features || (e.__aws_sdk_context.features = {})
    : (e.__aws_sdk_context = { features: {} }),
    (e.__aws_sdk_context.features[t] = r);
}
var h$e = w(() => {
  c();
});
var qh = {};
bn(qh, {
  emitWarningIfUnsupportedVersion: () => gE,
  setCredentialFeature: () => cp,
  setFeature: () => m$e,
  state: () => l1,
});
var gu = w(() => {
  c();
  f$e();
  p$e();
  h$e();
});
var g$e,
  E7,
  v$e = w(() => {
    c();
    (g$e = A(ln())),
      (E7 = (e) =>
        g$e.HttpResponse.isInstance(e)
          ? (e.headers?.date ?? e.headers?.Date)
          : void 0);
  });
var vE,
  b7 = w(() => {
    c();
    vE = (e) => new Date(Date.now() + e);
  });
var y$e,
  _$e = w(() => {
    c();
    b7();
    y$e = (e, t) => Math.abs(vE(t).getTime() - e) >= 3e5;
  });
var S7,
  E$e = w(() => {
    c();
    _$e();
    S7 = (e, t) => {
      let r = Date.parse(e);
      return y$e(r, t) ? r - Date.now() : t;
    };
  });
var C7 = w(() => {
  c();
  v$e();
  b7();
  E$e();
});
var b$e,
  IO,
  xO,
  ma,
  S$e,
  w7 = w(() => {
    c();
    b$e = A(ln());
    C7();
    (IO = (e, t) => {
      if (!t)
        throw new Error(
          `Property \`${e}\` is not resolved for AWS SDK SigV4Auth`,
        );
      return t;
    }),
      (xO = async (e) => {
        let t = IO("context", e.context),
          r = IO("config", e.config),
          n = t.endpointV2?.properties?.authSchemes?.[0],
          o = await IO("signer", r.signer)(n),
          a = e?.signingRegion,
          s = e?.signingRegionSet,
          u = e?.signingName;
        return {
          config: r,
          signer: o,
          signingRegion: a,
          signingRegionSet: s,
          signingName: u,
        };
      }),
      (ma = class {
        async sign(t, r, n) {
          if (!b$e.HttpRequest.isInstance(t))
            throw new Error(
              "The request is not an instance of `HttpRequest` and cannot be signed",
            );
          let i = await xO(n),
            { config: o, signer: a } = i,
            { signingRegion: s, signingName: u } = i,
            l = n.context;
          if (l?.authSchemes?.length ?? !1) {
            let [f, m] = l.authSchemes;
            f?.name === "sigv4a" &&
              m?.name === "sigv4" &&
              ((s = m?.signingRegion ?? s), (u = m?.signingName ?? u));
          }
          return await a.sign(t, {
            signingDate: vE(o.systemClockOffset),
            signingRegion: s,
            signingService: u,
          });
        }
        errorHandler(t) {
          return (r) => {
            let n = r.ServerTime ?? E7(r.$response);
            if (n) {
              let i = IO("config", t.config),
                o = i.systemClockOffset;
              (i.systemClockOffset = S7(n, i.systemClockOffset)),
                i.systemClockOffset !== o &&
                  r.$metadata &&
                  (r.$metadata.clockSkewCorrected = !0);
            }
            throw r;
          };
        }
        successHandler(t, r) {
          let n = E7(t);
          if (n) {
            let i = IO("config", r.config);
            i.systemClockOffset = S7(n, i.systemClockOffset);
          }
        }
      }),
      (S$e = ma);
  });
var C$e,
  d1,
  w$e = w(() => {
    c();
    C$e = A(ln());
    C7();
    w7();
    d1 = class extends ma {
      async sign(t, r, n) {
        if (!C$e.HttpRequest.isInstance(t))
          throw new Error(
            "The request is not an instance of `HttpRequest` and cannot be signed",
          );
        let {
            config: i,
            signer: o,
            signingRegion: a,
            signingRegionSet: s,
            signingName: u,
          } = await xO(n),
          d = ((await i.sigv4aSigningRegionSet?.()) ?? s ?? [a]).join(",");
        return await o.sign(t, {
          signingDate: vE(i.systemClockOffset),
          signingRegion: d,
          signingService: u,
        });
      }
    };
  });
var O7,
  O$e = w(() => {
    c();
    O7 = (e) =>
      typeof e == "string" && e.length > 0
        ? e.split(",").map((t) => t.trim())
        : [];
  });
var T$e,
  A$e,
  NO,
  P$e = w(() => {
    c();
    O$e();
    (T$e = "AWS_AUTH_SCHEME_PREFERENCE"),
      (A$e = "auth_scheme_preference"),
      (NO = {
        environmentVariableSelector: (e) => {
          if (T$e in e) return O7(e[T$e]);
        },
        configFileSelector: (e) => {
          if (A$e in e) return O7(e[A$e]);
        },
        default: [],
      });
  });
var Ho = g((EGn, k$e) => {
  c();
  var f1 = Object.defineProperty,
    Xgr = Object.getOwnPropertyDescriptor,
    Jgr = Object.getOwnPropertyNames,
    Zgr = Object.prototype.hasOwnProperty,
    jh = (e, t) => f1(e, "name", { value: t, configurable: !0 }),
    evr = (e, t) => {
      for (var r in t) f1(e, r, { get: t[r], enumerable: !0 });
    },
    tvr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Jgr(t))
          !Zgr.call(e, i) &&
            i !== r &&
            f1(e, i, {
              get: () => t[i],
              enumerable: !(n = Xgr(t, i)) || n.enumerable,
            });
      return e;
    },
    rvr = (e) => tvr(f1({}, "__esModule", { value: !0 }), e),
    R$e = {};
  evr(R$e, {
    CredentialsProviderError: () => nvr,
    ProviderError: () => p1,
    TokenProviderError: () => ivr,
    chain: () => ovr,
    fromStatic: () => avr,
    memoize: () => svr,
  });
  k$e.exports = rvr(R$e);
  var p1 = class I$e extends Error {
      constructor(t, r = !0) {
        let n,
          i = !0;
        typeof r == "boolean"
          ? ((n = void 0), (i = r))
          : r != null &&
            typeof r == "object" &&
            ((n = r.logger), (i = r.tryNextLink ?? !0)),
          super(t),
          (this.name = "ProviderError"),
          (this.tryNextLink = i),
          Object.setPrototypeOf(this, I$e.prototype),
          n?.debug?.(`@smithy/property-provider ${i ? "->" : "(!)"} ${t}`);
      }
      static {
        jh(this, "ProviderError");
      }
      static from(t, r = !0) {
        return Object.assign(new this(t.message, r), t);
      }
    },
    nvr = class x$e extends p1 {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "CredentialsProviderError"),
          Object.setPrototypeOf(this, x$e.prototype);
      }
      static {
        jh(this, "CredentialsProviderError");
      }
    },
    ivr = class N$e extends p1 {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "TokenProviderError"),
          Object.setPrototypeOf(this, N$e.prototype);
      }
      static {
        jh(this, "TokenProviderError");
      }
    },
    ovr = jh(
      (...e) =>
        async () => {
          if (e.length === 0) throw new p1("No providers in chain");
          let t;
          for (let r of e)
            try {
              return await r();
            } catch (n) {
              if (((t = n), n?.tryNextLink)) continue;
              throw n;
            }
          throw t;
        },
      "chain",
    ),
    avr = jh((e) => () => Promise.resolve(e), "fromStatic"),
    svr = jh((e, t, r) => {
      let n,
        i,
        o,
        a = !1,
        s = jh(async () => {
          i || (i = e());
          try {
            (n = await i), (o = !0), (a = !1);
          } finally {
            i = void 0;
          }
          return n;
        }, "coalesceProvider");
      return t === void 0
        ? async (u) => ((!o || u?.forceRefresh) && (n = await s()), n)
        : async (u) => (
            (!o || u?.forceRefresh) && (n = await s()),
            a ? n : r && !r(n) ? ((a = !0), n) : (t(n) && (await s()), n)
          );
    }, "memoize");
});
var T7,
  cvr,
  uvr,
  D$e = w(() => {
    c();
    Gn();
    (T7 = A(Ho())),
      (cvr = (e) => (
        (e.sigv4aSigningRegionSet = op(e.sigv4aSigningRegionSet)), e
      )),
      (uvr = {
        environmentVariableSelector(e) {
          if (e.AWS_SIGV4A_SIGNING_REGION_SET)
            return e.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((t) =>
              t.trim(),
            );
          throw new T7.ProviderError(
            "AWS_SIGV4A_SIGNING_REGION_SET not set in env.",
            { tryNextLink: !0 },
          );
        },
        configFileSelector(e) {
          if (e.sigv4a_signing_region_set)
            return (e.sigv4a_signing_region_set ?? "")
              .split(",")
              .map((t) => t.trim());
          throw new T7.ProviderError(
            "sigv4a_signing_region_set not set in profile.",
            { tryNextLink: !0 },
          );
        },
        default: void 0,
      });
  });
var uze = g((OGn, cze) => {
  c();
  var E1 = Object.defineProperty,
    lvr = Object.getOwnPropertyDescriptor,
    dvr = Object.getOwnPropertyNames,
    fvr = Object.prototype.hasOwnProperty,
    Ri = (e, t) => E1(e, "name", { value: t, configurable: !0 }),
    pvr = (e, t) => {
      for (var r in t) E1(e, r, { get: t[r], enumerable: !0 });
    },
    mvr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of dvr(t))
          !fvr.call(e, i) &&
            i !== r &&
            E1(e, i, {
              get: () => t[i],
              enumerable: !(n = lvr(t, i)) || n.enumerable,
            });
      return e;
    },
    hvr = (e) => mvr(E1({}, "__esModule", { value: !0 }), e),
    F$e = {};
  pvr(F$e, {
    ALGORITHM_IDENTIFIER: () => m1,
    ALGORITHM_IDENTIFIER_V4A: () => _vr,
    ALGORITHM_QUERY_PARAM: () => B$e,
    ALWAYS_UNSIGNABLE_HEADERS: () => W$e,
    AMZ_DATE_HEADER: () => D7,
    AMZ_DATE_QUERY_PARAM: () => I7,
    AUTH_HEADER: () => k7,
    CREDENTIAL_QUERY_PARAM: () => U$e,
    DATE_HEADER: () => V$e,
    EVENT_ALGORITHM_IDENTIFIER: () => X$e,
    EXPIRES_QUERY_PARAM: () => G$e,
    GENERATED_HEADERS: () => $$e,
    HOST_HEADER: () => vvr,
    KEY_TYPE_IDENTIFIER: () => L7,
    MAX_CACHE_SIZE: () => Z$e,
    MAX_PRESIGNED_TTL: () => eze,
    PROXY_HEADER_PATTERN: () => Q$e,
    REGION_SET_PARAM: () => gvr,
    SEC_HEADER_PATTERN: () => Y$e,
    SHA256_HEADER: () => _1,
    SIGNATURE_HEADER: () => z$e,
    SIGNATURE_QUERY_PARAM: () => x7,
    SIGNED_HEADERS_QUERY_PARAM: () => H$e,
    SignatureV4: () => Ivr,
    SignatureV4Base: () => sze,
    TOKEN_HEADER: () => K$e,
    TOKEN_QUERY_PARAM: () => N7,
    UNSIGNABLE_PATTERNS: () => yvr,
    UNSIGNED_PAYLOAD: () => J$e,
    clearCredentialCache: () => bvr,
    createScope: () => g1,
    getCanonicalHeaders: () => A7,
    getCanonicalQuery: () => aze,
    getPayloadHash: () => v1,
    getSigningKey: () => tze,
    hasHeader: () => nze,
    moveHeadersToQuery: () => oze,
    prepareRequest: () => R7,
    signatureV4aContainer: () => xvr,
  });
  cze.exports = hvr(F$e);
  var L$e = Fe(),
    B$e = "X-Amz-Algorithm",
    U$e = "X-Amz-Credential",
    I7 = "X-Amz-Date",
    H$e = "X-Amz-SignedHeaders",
    G$e = "X-Amz-Expires",
    x7 = "X-Amz-Signature",
    N7 = "X-Amz-Security-Token",
    gvr = "X-Amz-Region-Set",
    k7 = "authorization",
    D7 = I7.toLowerCase(),
    V$e = "date",
    $$e = [k7, D7, V$e],
    z$e = x7.toLowerCase(),
    _1 = "x-amz-content-sha256",
    K$e = N7.toLowerCase(),
    vvr = "host",
    W$e = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0,
    },
    Q$e = /^proxy-/,
    Y$e = /^sec-/,
    yvr = [/^proxy-/i, /^sec-/i],
    m1 = "AWS4-HMAC-SHA256",
    _vr = "AWS4-ECDSA-P256-SHA256",
    X$e = "AWS4-HMAC-SHA256-PAYLOAD",
    J$e = "UNSIGNED-PAYLOAD",
    Z$e = 50,
    L7 = "aws4_request",
    eze = 60 * 60 * 24 * 7,
    up = zs(),
    Evr = Fe(),
    yE = {},
    h1 = [],
    g1 = Ri((e, t, r) => `${e}/${t}/${r}/${L7}`, "createScope"),
    tze = Ri(async (e, t, r, n, i) => {
      let o = await M$e(e, t.secretAccessKey, t.accessKeyId),
        a = `${r}:${n}:${i}:${(0, up.toHex)(o)}:${t.sessionToken}`;
      if (a in yE) return yE[a];
      for (h1.push(a); h1.length > Z$e; ) delete yE[h1.shift()];
      let s = `AWS4${t.secretAccessKey}`;
      for (let u of [r, n, i, L7]) s = await M$e(e, s, u);
      return (yE[a] = s);
    }, "getSigningKey"),
    bvr = Ri(() => {
      (h1.length = 0),
        Object.keys(yE).forEach((e) => {
          delete yE[e];
        });
    }, "clearCredentialCache"),
    M$e = Ri((e, t, r) => {
      let n = new e(t);
      return n.update((0, Evr.toUint8Array)(r)), n.digest();
    }, "hmac"),
    A7 = Ri(({ headers: e }, t, r) => {
      let n = {};
      for (let i of Object.keys(e).sort()) {
        if (e[i] == null) continue;
        let o = i.toLowerCase();
        ((o in W$e || t?.has(o) || Q$e.test(o) || Y$e.test(o)) &&
          (!r || (r && !r.has(o)))) ||
          (n[o] = e[i].trim().replace(/\s+/g, " "));
      }
      return n;
    }, "getCanonicalHeaders"),
    Svr = hf(),
    Cvr = Fe(),
    v1 = Ri(async ({ headers: e, body: t }, r) => {
      for (let n of Object.keys(e)) if (n.toLowerCase() === _1) return e[n];
      if (t == null)
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      if (
        typeof t == "string" ||
        ArrayBuffer.isView(t) ||
        (0, Svr.isArrayBuffer)(t)
      ) {
        let n = new r();
        return (
          n.update((0, Cvr.toUint8Array)(t)), (0, up.toHex)(await n.digest())
        );
      }
      return J$e;
    }, "getPayloadHash"),
    q$e = Fe(),
    wvr = class {
      static {
        Ri(this, "HeaderFormatter");
      }
      format(e) {
        let t = [];
        for (let i of Object.keys(e)) {
          let o = (0, q$e.fromUtf8)(i);
          t.push(
            Uint8Array.from([o.byteLength]),
            o,
            this.formatHeaderValue(e[i]),
          );
        }
        let r = new Uint8Array(t.reduce((i, o) => i + o.byteLength, 0)),
          n = 0;
        for (let i of t) r.set(i, n), (n += i.byteLength);
        return r;
      }
      formatHeaderValue(e) {
        switch (e.type) {
          case "boolean":
            return Uint8Array.from([e.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, e.value]);
          case "short":
            let t = new DataView(new ArrayBuffer(3));
            return (
              t.setUint8(0, 3),
              t.setInt16(1, e.value, !1),
              new Uint8Array(t.buffer)
            );
          case "integer":
            let r = new DataView(new ArrayBuffer(5));
            return (
              r.setUint8(0, 4),
              r.setInt32(1, e.value, !1),
              new Uint8Array(r.buffer)
            );
          case "long":
            let n = new Uint8Array(9);
            return (n[0] = 5), n.set(e.value.bytes, 1), n;
          case "binary":
            let i = new DataView(new ArrayBuffer(3 + e.value.byteLength));
            i.setUint8(0, 6), i.setUint16(1, e.value.byteLength, !1);
            let o = new Uint8Array(i.buffer);
            return o.set(e.value, 3), o;
          case "string":
            let a = (0, q$e.fromUtf8)(e.value),
              s = new DataView(new ArrayBuffer(3 + a.byteLength));
            s.setUint8(0, 7), s.setUint16(1, a.byteLength, !1);
            let u = new Uint8Array(s.buffer);
            return u.set(a, 3), u;
          case "timestamp":
            let l = new Uint8Array(9);
            return (
              (l[0] = 8), l.set(Tvr.fromNumber(e.value.valueOf()).bytes, 1), l
            );
          case "uuid":
            if (!Ovr.test(e.value))
              throw new Error(`Invalid UUID received: ${e.value}`);
            let d = new Uint8Array(17);
            return (
              (d[0] = 9),
              d.set((0, up.fromHex)(e.value.replace(/\-/g, "")), 1),
              d
            );
        }
      }
    },
    Ovr = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    Tvr = class rze {
      constructor(t) {
        if (((this.bytes = t), t.byteLength !== 8))
          throw new Error("Int64 buffers must be exactly 8 bytes");
      }
      static {
        Ri(this, "Int64");
      }
      static fromNumber(t) {
        if (t > 9223372036854776e3 || t < -9223372036854776e3)
          throw new Error(
            `${t} is too large (or, if negative, too small) to represent as an Int64`,
          );
        let r = new Uint8Array(8);
        for (
          let n = 7, i = Math.abs(Math.round(t));
          n > -1 && i > 0;
          n--, i /= 256
        )
          r[n] = i;
        return t < 0 && P7(r), new rze(r);
      }
      valueOf() {
        let t = this.bytes.slice(0),
          r = t[0] & 128;
        return r && P7(t), parseInt((0, up.toHex)(t), 16) * (r ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  function P7(e) {
    for (let t = 0; t < 8; t++) e[t] ^= 255;
    for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
  }
  Ri(P7, "negate");
  var nze = Ri((e, t) => {
      e = e.toLowerCase();
      for (let r of Object.keys(t)) if (e === r.toLowerCase()) return !0;
      return !1;
    }, "hasHeader"),
    ize = ln(),
    oze = Ri((e, t = {}) => {
      let { headers: r, query: n = {} } = ize.HttpRequest.clone(e);
      for (let i of Object.keys(r)) {
        let o = i.toLowerCase();
        ((o.slice(0, 6) === "x-amz-" && !t.unhoistableHeaders?.has(o)) ||
          t.hoistableHeaders?.has(o)) &&
          ((n[i] = r[i]), delete r[i]);
      }
      return { ...e, headers: r, query: n };
    }, "moveHeadersToQuery"),
    R7 = Ri((e) => {
      e = ize.HttpRequest.clone(e);
      for (let t of Object.keys(e.headers))
        $$e.indexOf(t.toLowerCase()) > -1 && delete e.headers[t];
      return e;
    }, "prepareRequest"),
    j$e = tc(),
    Avr = Fe(),
    y1 = WX(),
    aze = Ri(({ query: e = {} }) => {
      let t = [],
        r = {};
      for (let n of Object.keys(e)) {
        if (n.toLowerCase() === z$e) continue;
        let i = (0, y1.escapeUri)(n);
        t.push(i);
        let o = e[n];
        typeof o == "string"
          ? (r[i] = `${i}=${(0, y1.escapeUri)(o)}`)
          : Array.isArray(o) &&
            (r[i] = o
              .slice(0)
              .reduce((a, s) => a.concat([`${i}=${(0, y1.escapeUri)(s)}`]), [])
              .sort()
              .join("&"));
      }
      return t
        .sort()
        .map((n) => r[n])
        .filter((n) => n)
        .join("&");
    }, "getCanonicalQuery"),
    Pvr = Ri(
      (e) =>
        Rvr(e)
          .toISOString()
          .replace(/\.\d{3}Z$/, "Z"),
      "iso8601",
    ),
    Rvr = Ri(
      (e) =>
        typeof e == "number"
          ? new Date(e * 1e3)
          : typeof e == "string"
            ? Number(e)
              ? new Date(Number(e) * 1e3)
              : new Date(e)
            : e,
      "toDate",
    ),
    sze = class {
      static {
        Ri(this, "SignatureV4Base");
      }
      constructor({
        applyChecksum: e,
        credentials: t,
        region: r,
        service: n,
        sha256: i,
        uriEscapePath: o = !0,
      }) {
        (this.service = n),
          (this.sha256 = i),
          (this.uriEscapePath = o),
          (this.applyChecksum = typeof e == "boolean" ? e : !0),
          (this.regionProvider = (0, j$e.normalizeProvider)(r)),
          (this.credentialProvider = (0, j$e.normalizeProvider)(t));
      }
      createCanonicalRequest(e, t, r) {
        let n = Object.keys(t).sort();
        return `${e.method}
${this.getCanonicalPath(e)}
${aze(e)}
${n.map((i) => `${i}:${t[i]}`).join(`
`)}

${n.join(";")}
${r}`;
      }
      async createStringToSign(e, t, r, n) {
        let i = new this.sha256();
        i.update((0, Avr.toUint8Array)(r));
        let o = await i.digest();
        return `${n}
${e}
${t}
${(0, up.toHex)(o)}`;
      }
      getCanonicalPath({ path: e }) {
        if (this.uriEscapePath) {
          let t = [];
          for (let i of e.split("/"))
            i?.length !== 0 && i !== "." && (i === ".." ? t.pop() : t.push(i));
          let r = `${e?.startsWith("/") ? "/" : ""}${t.join("/")}${t.length > 0 && e?.endsWith("/") ? "/" : ""}`;
          return (0, y1.escapeUri)(r).replace(/%2F/g, "/");
        }
        return e;
      }
      validateResolvedCredentials(e) {
        if (
          typeof e != "object" ||
          typeof e.accessKeyId != "string" ||
          typeof e.secretAccessKey != "string"
        )
          throw new Error("Resolved credential object is not valid");
      }
      formatDate(e) {
        let t = Pvr(e).replace(/[\-:]/g, "");
        return { longDate: t, shortDate: t.slice(0, 8) };
      }
      getCanonicalHeaderList(e) {
        return Object.keys(e).sort().join(";");
      }
    },
    Ivr = class extends sze {
      constructor({
        applyChecksum: e,
        credentials: t,
        region: r,
        service: n,
        sha256: i,
        uriEscapePath: o = !0,
      }) {
        super({
          applyChecksum: e,
          credentials: t,
          region: r,
          service: n,
          sha256: i,
          uriEscapePath: o,
        }),
          (this.headerFormatter = new wvr());
      }
      static {
        Ri(this, "SignatureV4");
      }
      async presign(e, t = {}) {
        let {
            signingDate: r = new Date(),
            expiresIn: n = 3600,
            unsignableHeaders: i,
            unhoistableHeaders: o,
            signableHeaders: a,
            hoistableHeaders: s,
            signingRegion: u,
            signingService: l,
          } = t,
          d = await this.credentialProvider();
        this.validateResolvedCredentials(d);
        let f = u ?? (await this.regionProvider()),
          { longDate: m, shortDate: h } = this.formatDate(r);
        if (n > eze)
          return Promise.reject(
            "Signature version 4 presigned URLs must have an expiration date less than one week in the future",
          );
        let y = g1(h, f, l ?? this.service),
          _ = oze(R7(e), { unhoistableHeaders: o, hoistableHeaders: s });
        d.sessionToken && (_.query[N7] = d.sessionToken),
          (_.query[B$e] = m1),
          (_.query[U$e] = `${d.accessKeyId}/${y}`),
          (_.query[I7] = m),
          (_.query[G$e] = n.toString(10));
        let E = A7(_, i, a);
        return (
          (_.query[H$e] = this.getCanonicalHeaderList(E)),
          (_.query[x7] = await this.getSignature(
            m,
            y,
            this.getSigningKey(d, f, h, l),
            this.createCanonicalRequest(_, E, await v1(e, this.sha256)),
          )),
          _
        );
      }
      async sign(e, t) {
        return typeof e == "string"
          ? this.signString(e, t)
          : e.headers && e.payload
            ? this.signEvent(e, t)
            : e.message
              ? this.signMessage(e, t)
              : this.signRequest(e, t);
      }
      async signEvent(
        { headers: e, payload: t },
        {
          signingDate: r = new Date(),
          priorSignature: n,
          signingRegion: i,
          signingService: o,
        },
      ) {
        let a = i ?? (await this.regionProvider()),
          { shortDate: s, longDate: u } = this.formatDate(r),
          l = g1(s, a, o ?? this.service),
          d = await v1({ headers: {}, body: t }, this.sha256),
          f = new this.sha256();
        f.update(e);
        let m = (0, up.toHex)(await f.digest()),
          h = [X$e, u, l, n, m, d].join(`
`);
        return this.signString(h, {
          signingDate: r,
          signingRegion: a,
          signingService: o,
        });
      }
      async signMessage(
        e,
        { signingDate: t = new Date(), signingRegion: r, signingService: n },
      ) {
        return this.signEvent(
          {
            headers: this.headerFormatter.format(e.message.headers),
            payload: e.message.body,
          },
          {
            signingDate: t,
            signingRegion: r,
            signingService: n,
            priorSignature: e.priorSignature,
          },
        ).then((o) => ({ message: e.message, signature: o }));
      }
      async signString(
        e,
        {
          signingDate: t = new Date(),
          signingRegion: r,
          signingService: n,
        } = {},
      ) {
        let i = await this.credentialProvider();
        this.validateResolvedCredentials(i);
        let o = r ?? (await this.regionProvider()),
          { shortDate: a } = this.formatDate(t),
          s = new this.sha256(await this.getSigningKey(i, o, a, n));
        return (
          s.update((0, L$e.toUint8Array)(e)), (0, up.toHex)(await s.digest())
        );
      }
      async signRequest(
        e,
        {
          signingDate: t = new Date(),
          signableHeaders: r,
          unsignableHeaders: n,
          signingRegion: i,
          signingService: o,
        } = {},
      ) {
        let a = await this.credentialProvider();
        this.validateResolvedCredentials(a);
        let s = i ?? (await this.regionProvider()),
          u = R7(e),
          { longDate: l, shortDate: d } = this.formatDate(t),
          f = g1(d, s, o ?? this.service);
        (u.headers[D7] = l),
          a.sessionToken && (u.headers[K$e] = a.sessionToken);
        let m = await v1(u, this.sha256);
        !nze(_1, u.headers) && this.applyChecksum && (u.headers[_1] = m);
        let h = A7(u, n, r),
          y = await this.getSignature(
            l,
            f,
            this.getSigningKey(a, s, d, o),
            this.createCanonicalRequest(u, h, m),
          );
        return (
          (u.headers[k7] =
            `${m1} Credential=${a.accessKeyId}/${f}, SignedHeaders=${this.getCanonicalHeaderList(h)}, Signature=${y}`),
          u
        );
      }
      async getSignature(e, t, r, n) {
        let i = await this.createStringToSign(e, t, n, m1),
          o = new this.sha256(await r);
        return (
          o.update((0, L$e.toUint8Array)(i)), (0, up.toHex)(await o.digest())
        );
      }
      getSigningKey(e, t, r, n) {
        return tze(this.sha256, e, r, t, n || this.service);
      }
    },
    xvr = { SignatureV4a: null };
});
function kvr(e, { credentials: t, credentialDefaultProvider: r }) {
  let n;
  return (
    t
      ? t?.memoized
        ? (n = t)
        : (n = m7(t, p7, a1))
      : r
        ? (n = op(r(Object.assign({}, e, { parentClientConfig: e }))))
        : (n = async () => {
            throw new Error(
              "@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.",
            );
          }),
    (n.memoized = !0),
    n
  );
}
function Dvr(e, t) {
  if (t.configBound) return t;
  let r = async (n) => t({ ...n, callerClientConfig: e });
  return (r.memoized = t.memoized), (r.configBound = !0), r;
}
var M7,
  _E,
  Nvr,
  lze = w(() => {
    c();
    gu();
    Gn();
    (M7 = A(uze())),
      (_E = (e) => {
        let t = e.credentials,
          r = !!e.credentials,
          n;
        Object.defineProperty(e, "credentials", {
          set(l) {
            l && l !== t && l !== n && (r = !0), (t = l);
            let d = kvr(e, {
                credentials: t,
                credentialDefaultProvider: e.credentialDefaultProvider,
              }),
              f = Dvr(e, d);
            r && !f.attributed
              ? ((n = async (m) =>
                  f(m).then((h) => cp(h, "CREDENTIALS_CODE", "e"))),
                (n.memoized = f.memoized),
                (n.configBound = f.configBound),
                (n.attributed = !0))
              : (n = f);
          },
          get() {
            return n;
          },
          enumerable: !0,
          configurable: !0,
        }),
          (e.credentials = t);
        let {
            signingEscapePath: i = !0,
            systemClockOffset: o = e.systemClockOffset || 0,
            sha256: a,
          } = e,
          s;
        return (
          e.signer
            ? (s = op(e.signer))
            : e.regionInfoProvider
              ? (s = () =>
                  op(e.region)()
                    .then(async (l) => [
                      (await e.regionInfoProvider(l, {
                        useFipsEndpoint: await e.useFipsEndpoint(),
                        useDualstackEndpoint: await e.useDualstackEndpoint(),
                      })) || {},
                      l,
                    ])
                    .then(([l, d]) => {
                      let { signingRegion: f, signingService: m } = l;
                      (e.signingRegion = e.signingRegion || f || d),
                        (e.signingName = e.signingName || m || e.serviceId);
                      let h = {
                          ...e,
                          credentials: e.credentials,
                          region: e.signingRegion,
                          service: e.signingName,
                          sha256: a,
                          uriEscapePath: i,
                        },
                        y = e.signerConstructor || M7.SignatureV4;
                      return new y(h);
                    }))
              : (s = async (l) => {
                  l = Object.assign(
                    {},
                    {
                      name: "sigv4",
                      signingName: e.signingName || e.defaultSigningName,
                      signingRegion: await op(e.region)(),
                      properties: {},
                    },
                    l,
                  );
                  let d = l.signingRegion,
                    f = l.signingName;
                  (e.signingRegion = e.signingRegion || d),
                    (e.signingName = e.signingName || f || e.serviceId);
                  let m = {
                      ...e,
                      credentials: e.credentials,
                      region: e.signingRegion,
                      service: e.signingName,
                      sha256: a,
                      uriEscapePath: i,
                    },
                    h = e.signerConstructor || M7.SignatureV4;
                  return new h(m);
                }),
          Object.assign(e, {
            systemClockOffset: o,
            signingEscapePath: i,
            signer: s,
          })
        );
      }),
      (Nvr = _E);
  });
var dze = w(() => {
  c();
  w7();
  w$e();
  P$e();
  D$e();
  lze();
});
var fze = w(() => {
  c();
  dze();
});
var Lvr,
  Mvr,
  qvr,
  pze = w(() => {
    c();
    (Lvr = (e) => {
      if (e == null) return e;
      if (typeof e == "number" || typeof e == "bigint") {
        let t = new Error(`Received number ${e} where a string was expected.`);
        return (t.name = "Warning"), console.warn(t), String(e);
      }
      if (typeof e == "boolean") {
        let t = new Error(`Received boolean ${e} where a string was expected.`);
        return (t.name = "Warning"), console.warn(t), String(e);
      }
      return e;
    }),
      (Mvr = (e) => {
        if (e == null) return e;
        if (typeof e == "string") {
          let t = e.toLowerCase();
          if (e !== "" && t !== "false" && t !== "true") {
            let r = new Error(
              `Received string "${e}" where a boolean was expected.`,
            );
            (r.name = "Warning"), console.warn(r);
          }
          return e !== "" && t !== "false";
        }
        return e;
      }),
      (qvr = (e) => {
        if (e == null) return e;
        if (typeof e == "string") {
          let t = Number(e);
          if (t.toString() !== e) {
            let r = new Error(
              `Received string "${e}" where a number was expected.`,
            );
            return (r.name = "Warning"), console.warn(r), e;
          }
          return t;
        }
        return e;
      });
  });
var yze = g((zGn, vze) => {
  c();
  var b1 = Object.defineProperty,
    jvr = Object.getOwnPropertyDescriptor,
    Fvr = Object.getOwnPropertyNames,
    Bvr = Object.prototype.hasOwnProperty,
    os = (e, t) => b1(e, "name", { value: t, configurable: !0 }),
    Uvr = (e, t) => {
      for (var r in t) b1(e, r, { get: t[r], enumerable: !0 });
    },
    Hvr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Fvr(t))
          !Bvr.call(e, i) &&
            i !== r &&
            b1(e, i, {
              get: () => t[i],
              enumerable: !(n = jvr(t, i)) || n.enumerable,
            });
      return e;
    },
    Gvr = (e) => Hvr(b1({}, "__esModule", { value: !0 }), e),
    gze = {};
  Uvr(gze, { constructStack: () => q7 });
  vze.exports = Gvr(gze);
  var Fh = os((e, t) => {
      let r = [];
      if ((e && r.push(e), t)) for (let n of t) r.push(n);
      return r;
    }, "getAllAliases"),
    lp = os(
      (e, t) =>
        `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`,
      "getMiddlewareNameWithAliases",
    ),
    q7 = os(() => {
      let e = [],
        t = [],
        r = !1,
        n = new Set(),
        i = os(
          (f) =>
            f.sort(
              (m, h) =>
                mze[h.step] - mze[m.step] ||
                hze[h.priority || "normal"] - hze[m.priority || "normal"],
            ),
          "sort",
        ),
        o = os((f) => {
          let m = !1,
            h = os((y) => {
              let _ = Fh(y.name, y.aliases);
              if (_.includes(f)) {
                m = !0;
                for (let E of _) n.delete(E);
                return !1;
              }
              return !0;
            }, "filterCb");
          return (e = e.filter(h)), (t = t.filter(h)), m;
        }, "removeByName"),
        a = os((f) => {
          let m = !1,
            h = os((y) => {
              if (y.middleware === f) {
                m = !0;
                for (let _ of Fh(y.name, y.aliases)) n.delete(_);
                return !1;
              }
              return !0;
            }, "filterCb");
          return (e = e.filter(h)), (t = t.filter(h)), m;
        }, "removeByReference"),
        s = os(
          (f) => (
            e.forEach((m) => {
              f.add(m.middleware, { ...m });
            }),
            t.forEach((m) => {
              f.addRelativeTo(m.middleware, { ...m });
            }),
            f.identifyOnResolve?.(d.identifyOnResolve()),
            f
          ),
          "cloneTo",
        ),
        u = os((f) => {
          let m = [];
          return (
            f.before.forEach((h) => {
              h.before.length === 0 && h.after.length === 0
                ? m.push(h)
                : m.push(...u(h));
            }),
            m.push(f),
            f.after.reverse().forEach((h) => {
              h.before.length === 0 && h.after.length === 0
                ? m.push(h)
                : m.push(...u(h));
            }),
            m
          );
        }, "expandRelativeMiddlewareList"),
        l = os((f = !1) => {
          let m = [],
            h = [],
            y = {};
          return (
            e.forEach((E) => {
              let b = { ...E, before: [], after: [] };
              for (let O of Fh(b.name, b.aliases)) y[O] = b;
              m.push(b);
            }),
            t.forEach((E) => {
              let b = { ...E, before: [], after: [] };
              for (let O of Fh(b.name, b.aliases)) y[O] = b;
              h.push(b);
            }),
            h.forEach((E) => {
              if (E.toMiddleware) {
                let b = y[E.toMiddleware];
                if (b === void 0) {
                  if (f) return;
                  throw new Error(
                    `${E.toMiddleware} is not found when adding ${lp(E.name, E.aliases)} middleware ${E.relation} ${E.toMiddleware}`,
                  );
                }
                E.relation === "after" && b.after.push(E),
                  E.relation === "before" && b.before.push(E);
              }
            }),
            i(m)
              .map(u)
              .reduce((E, b) => (E.push(...b), E), [])
          );
        }, "getMiddlewareList"),
        d = {
          add: (f, m = {}) => {
            let { name: h, override: y, aliases: _ } = m,
              E = {
                step: "initialize",
                priority: "normal",
                middleware: f,
                ...m,
              },
              b = Fh(h, _);
            if (b.length > 0) {
              if (b.some((O) => n.has(O))) {
                if (!y)
                  throw new Error(`Duplicate middleware name '${lp(h, _)}'`);
                for (let O of b) {
                  let C = e.findIndex(
                    (k) => k.name === O || k.aliases?.some((H) => H === O),
                  );
                  if (C === -1) continue;
                  let P = e[C];
                  if (P.step !== E.step || E.priority !== P.priority)
                    throw new Error(
                      `"${lp(P.name, P.aliases)}" middleware with ${P.priority} priority in ${P.step} step cannot be overridden by "${lp(h, _)}" middleware with ${E.priority} priority in ${E.step} step.`,
                    );
                  e.splice(C, 1);
                }
              }
              for (let O of b) n.add(O);
            }
            e.push(E);
          },
          addRelativeTo: (f, m) => {
            let { name: h, override: y, aliases: _ } = m,
              E = { middleware: f, ...m },
              b = Fh(h, _);
            if (b.length > 0) {
              if (b.some((O) => n.has(O))) {
                if (!y)
                  throw new Error(`Duplicate middleware name '${lp(h, _)}'`);
                for (let O of b) {
                  let C = t.findIndex(
                    (k) => k.name === O || k.aliases?.some((H) => H === O),
                  );
                  if (C === -1) continue;
                  let P = t[C];
                  if (
                    P.toMiddleware !== E.toMiddleware ||
                    P.relation !== E.relation
                  )
                    throw new Error(
                      `"${lp(P.name, P.aliases)}" middleware ${P.relation} "${P.toMiddleware}" middleware cannot be overridden by "${lp(h, _)}" middleware ${E.relation} "${E.toMiddleware}" middleware.`,
                    );
                  t.splice(C, 1);
                }
              }
              for (let O of b) n.add(O);
            }
            t.push(E);
          },
          clone: () => s(q7()),
          use: (f) => {
            f.applyToStack(d);
          },
          remove: (f) => (typeof f == "string" ? o(f) : a(f)),
          removeByTag: (f) => {
            let m = !1,
              h = os((y) => {
                let { tags: _, name: E, aliases: b } = y;
                if (_ && _.includes(f)) {
                  let O = Fh(E, b);
                  for (let C of O) n.delete(C);
                  return (m = !0), !1;
                }
                return !0;
              }, "filterCb");
            return (e = e.filter(h)), (t = t.filter(h)), m;
          },
          concat: (f) => {
            let m = s(q7());
            return (
              m.use(f),
              m.identifyOnResolve(
                r || m.identifyOnResolve() || (f.identifyOnResolve?.() ?? !1),
              ),
              m
            );
          },
          applyToStack: s,
          identify: () =>
            l(!0).map((f) => {
              let m = f.step ?? f.relation + " " + f.toMiddleware;
              return lp(f.name, f.aliases) + " - " + m;
            }),
          identifyOnResolve(f) {
            return typeof f == "boolean" && (r = f), r;
          },
          resolve: (f, m) => {
            for (let h of l()
              .map((y) => y.middleware)
              .reverse())
              f = h(f, m);
            return r && console.log(d.identify()), f;
          },
        };
      return d;
    }, "constructStack"),
    mze = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1,
    },
    hze = { high: 3, normal: 2, low: 1 };
});
var At = g((WGn, Mze) => {
  c();
  var w1 = Object.defineProperty,
    Vvr = Object.getOwnPropertyDescriptor,
    $vr = Object.getOwnPropertyNames,
    zvr = Object.prototype.hasOwnProperty,
    me = (e, t) => w1(e, "name", { value: t, configurable: !0 }),
    Kvr = (e, t) => {
      for (var r in t) w1(e, r, { get: t[r], enumerable: !0 });
    },
    Wvr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of $vr(t))
          !zvr.call(e, i) &&
            i !== r &&
            w1(e, i, {
              get: () => t[i],
              enumerable: !(n = Vvr(t, i)) || n.enumerable,
            });
      return e;
    },
    Qvr = (e) => Wvr(w1({}, "__esModule", { value: !0 }), e),
    Eze = {};
  Kvr(Eze, {
    Client: () => Yvr,
    Command: () => Sze,
    LazyJsonString: () => Bh,
    NoOpLogger: () => zyr,
    SENSITIVE_STRING: () => Jvr,
    ServiceException: () => kyr,
    _json: () => V7,
    collectBody: () => j7.collectBody,
    convertMap: () => Kyr,
    createAggregatedClient: () => Zvr,
    dateToUtcString: () => Pze,
    decorateServiceException: () => Rze,
    emitWarningIfUnsupportedVersion: () => qyr,
    expectBoolean: () => tyr,
    expectByte: () => G7,
    expectFloat32: () => S1,
    expectInt: () => nyr,
    expectInt32: () => U7,
    expectLong: () => MO,
    expectNonNull: () => oyr,
    expectNumber: () => LO,
    expectObject: () => Cze,
    expectShort: () => H7,
    expectString: () => ayr,
    expectUnion: () => syr,
    extendedEncodeURIComponent: () => j7.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => Vyr,
    getDefaultClientConfiguration: () => Hyr,
    getDefaultExtensionConfiguration: () => xze,
    getValueFromTextNode: () => Nze,
    handleFloat: () => lyr,
    isSerializableHeaderValue: () => $yr,
    limitedParseDouble: () => K7,
    limitedParseFloat: () => dyr,
    limitedParseFloat32: () => fyr,
    loadConfigsForDefaultMode: () => Myr,
    logger: () => qO,
    map: () => Q7,
    parseBoolean: () => eyr,
    parseEpochTimestamp: () => wyr,
    parseRfc3339DateTime: () => vyr,
    parseRfc3339DateTimeWithOffset: () => _yr,
    parseRfc7231DateTime: () => Cyr,
    quoteHeader: () => Dze,
    resolveDefaultRuntimeConfig: () => Gyr,
    resolvedPath: () => j7.resolvedPath,
    serializeDateTime: () => Zyr,
    serializeFloat: () => Jyr,
    splitEvery: () => Lze,
    splitHeader: () => e_r,
    strictParseByte: () => Aze,
    strictParseDouble: () => z7,
    strictParseFloat: () => cyr,
    strictParseFloat32: () => wze,
    strictParseInt: () => pyr,
    strictParseInt32: () => myr,
    strictParseLong: () => Tze,
    strictParseShort: () => EE,
    take: () => Wyr,
    throwDefaultError: () => Ize,
    withBaseException: () => Dyr,
  });
  Mze.exports = Qvr(Eze);
  var bze = yze(),
    Yvr = class {
      constructor(e) {
        (this.config = e), (this.middlewareStack = (0, bze.constructStack)());
      }
      static {
        me(this, "Client");
      }
      send(e, t, r) {
        let n = typeof t != "function" ? t : void 0,
          i = typeof t == "function" ? t : r,
          o = n === void 0 && this.config.cacheMiddleware === !0,
          a;
        if (o) {
          this.handlers || (this.handlers = new WeakMap());
          let s = this.handlers;
          s.has(e.constructor)
            ? (a = s.get(e.constructor))
            : ((a = e.resolveMiddleware(this.middlewareStack, this.config, n)),
              s.set(e.constructor, a));
        } else
          delete this.handlers,
            (a = e.resolveMiddleware(this.middlewareStack, this.config, n));
        if (i)
          a(e)
            .then(
              (s) => i(null, s.output),
              (s) => i(s),
            )
            .catch(() => {});
        else return a(e).then((s) => s.output);
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers;
      }
    },
    j7 = (u7(), ue(DVe)),
    B7 = Ul(),
    Sze = class {
      constructor() {
        this.middlewareStack = (0, bze.constructStack)();
      }
      static {
        me(this, "Command");
      }
      static classBuilder() {
        return new Xvr();
      }
      resolveMiddlewareWithContext(
        e,
        t,
        r,
        {
          middlewareFn: n,
          clientName: i,
          commandName: o,
          inputFilterSensitiveLog: a,
          outputFilterSensitiveLog: s,
          smithyContext: u,
          additionalContext: l,
          CommandCtor: d,
        },
      ) {
        for (let _ of n.bind(this)(d, e, t, r)) this.middlewareStack.use(_);
        let f = e.concat(this.middlewareStack),
          { logger: m } = t,
          h = {
            logger: m,
            clientName: i,
            commandName: o,
            inputFilterSensitiveLog: a,
            outputFilterSensitiveLog: s,
            [B7.SMITHY_CONTEXT_KEY]: { commandInstance: this, ...u },
            ...l,
          },
          { requestHandler: y } = t;
        return f.resolve((_) => y.handle(_.request, r || {}), h);
      }
    },
    Xvr = class {
      constructor() {
        (this._init = () => {}),
          (this._ep = {}),
          (this._middlewareFn = () => []),
          (this._commandName = ""),
          (this._clientName = ""),
          (this._additionalContext = {}),
          (this._smithyContext = {}),
          (this._inputFilterSensitiveLog = (e) => e),
          (this._outputFilterSensitiveLog = (e) => e),
          (this._serializer = null),
          (this._deserializer = null);
      }
      static {
        me(this, "ClassBuilder");
      }
      init(e) {
        this._init = e;
      }
      ep(e) {
        return (this._ep = e), this;
      }
      m(e) {
        return (this._middlewareFn = e), this;
      }
      s(e, t, r = {}) {
        return (this._smithyContext = { service: e, operation: t, ...r }), this;
      }
      c(e = {}) {
        return (this._additionalContext = e), this;
      }
      n(e, t) {
        return (this._clientName = e), (this._commandName = t), this;
      }
      f(e = (r) => r, t = (r) => r) {
        return (
          (this._inputFilterSensitiveLog = e),
          (this._outputFilterSensitiveLog = t),
          this
        );
      }
      ser(e) {
        return (this._serializer = e), this;
      }
      de(e) {
        return (this._deserializer = e), this;
      }
      build() {
        let e = this,
          t;
        return (t = class extends Sze {
          constructor(...[r]) {
            super(),
              (this.serialize = e._serializer),
              (this.deserialize = e._deserializer),
              (this.input = r ?? {}),
              e._init(this);
          }
          static {
            me(this, "CommandRef");
          }
          static getEndpointParameterInstructions() {
            return e._ep;
          }
          resolveMiddleware(r, n, i) {
            return this.resolveMiddlewareWithContext(r, n, i, {
              CommandCtor: t,
              middlewareFn: e._middlewareFn,
              clientName: e._clientName,
              commandName: e._commandName,
              inputFilterSensitiveLog: e._inputFilterSensitiveLog,
              outputFilterSensitiveLog: e._outputFilterSensitiveLog,
              smithyContext: e._smithyContext,
              additionalContext: e._additionalContext,
            });
          }
        });
      }
    },
    Jvr = "***SensitiveInformation***",
    Zvr = me((e, t) => {
      for (let r of Object.keys(e)) {
        let n = e[r],
          i = me(async function (a, s, u) {
            let l = new n(a);
            if (typeof s == "function") this.send(l, s);
            else if (typeof u == "function") {
              if (typeof s != "object")
                throw new Error(`Expected http options but got ${typeof s}`);
              this.send(l, s || {}, u);
            } else return this.send(l, s);
          }, "methodImpl"),
          o = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, "");
        t.prototype[o] = i;
      }
    }, "createAggregatedClient"),
    eyr = me((e) => {
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw new Error(`Unable to parse boolean value "${e}"`);
      }
    }, "parseBoolean"),
    tyr = me((e) => {
      if (e != null) {
        if (typeof e == "number") {
          if (
            ((e === 0 || e === 1) &&
              qO.warn(C1(`Expected boolean, got ${typeof e}: ${e}`)),
            e === 0)
          )
            return !1;
          if (e === 1) return !0;
        }
        if (typeof e == "string") {
          let t = e.toLowerCase();
          if (
            ((t === "false" || t === "true") &&
              qO.warn(C1(`Expected boolean, got ${typeof e}: ${e}`)),
            t === "false")
          )
            return !1;
          if (t === "true") return !0;
        }
        if (typeof e == "boolean") return e;
        throw new TypeError(`Expected boolean, got ${typeof e}: ${e}`);
      }
    }, "expectBoolean"),
    LO = me((e) => {
      if (e != null) {
        if (typeof e == "string") {
          let t = parseFloat(e);
          if (!Number.isNaN(t))
            return (
              String(t) !== String(e) &&
                qO.warn(C1(`Expected number but observed string: ${e}`)),
              t
            );
        }
        if (typeof e == "number") return e;
        throw new TypeError(`Expected number, got ${typeof e}: ${e}`);
      }
    }, "expectNumber"),
    ryr = Math.ceil(2 ** 127 * (2 - 2 ** -23)),
    S1 = me((e) => {
      let t = LO(e);
      if (
        t !== void 0 &&
        !Number.isNaN(t) &&
        t !== 1 / 0 &&
        t !== -1 / 0 &&
        Math.abs(t) > ryr
      )
        throw new TypeError(`Expected 32-bit float, got ${e}`);
      return t;
    }, "expectFloat32"),
    MO = me((e) => {
      if (e != null) {
        if (Number.isInteger(e) && !Number.isNaN(e)) return e;
        throw new TypeError(`Expected integer, got ${typeof e}: ${e}`);
      }
    }, "expectLong"),
    nyr = MO,
    U7 = me((e) => $7(e, 32), "expectInt32"),
    H7 = me((e) => $7(e, 16), "expectShort"),
    G7 = me((e) => $7(e, 8), "expectByte"),
    $7 = me((e, t) => {
      let r = MO(e);
      if (r !== void 0 && iyr(r, t) !== r)
        throw new TypeError(`Expected ${t}-bit integer, got ${e}`);
      return r;
    }, "expectSizedInt"),
    iyr = me((e, t) => {
      switch (t) {
        case 32:
          return Int32Array.of(e)[0];
        case 16:
          return Int16Array.of(e)[0];
        case 8:
          return Int8Array.of(e)[0];
      }
    }, "castInt"),
    oyr = me((e, t) => {
      if (e == null)
        throw t
          ? new TypeError(`Expected a non-null value for ${t}`)
          : new TypeError("Expected a non-null value");
      return e;
    }, "expectNonNull"),
    Cze = me((e) => {
      if (e == null) return;
      if (typeof e == "object" && !Array.isArray(e)) return e;
      let t = Array.isArray(e) ? "array" : typeof e;
      throw new TypeError(`Expected object, got ${t}: ${e}`);
    }, "expectObject"),
    ayr = me((e) => {
      if (e != null) {
        if (typeof e == "string") return e;
        if (["boolean", "number", "bigint"].includes(typeof e))
          return (
            qO.warn(C1(`Expected string, got ${typeof e}: ${e}`)), String(e)
          );
        throw new TypeError(`Expected string, got ${typeof e}: ${e}`);
      }
    }, "expectString"),
    syr = me((e) => {
      if (e == null) return;
      let t = Cze(e),
        r = Object.entries(t)
          .filter(([, n]) => n != null)
          .map(([n]) => n);
      if (r.length === 0)
        throw new TypeError(
          "Unions must have exactly one non-null member. None were found.",
        );
      if (r.length > 1)
        throw new TypeError(
          `Unions must have exactly one non-null member. Keys ${r} were not null.`,
        );
      return t;
    }, "expectUnion"),
    z7 = me((e) => LO(typeof e == "string" ? SE(e) : e), "strictParseDouble"),
    cyr = z7,
    wze = me((e) => S1(typeof e == "string" ? SE(e) : e), "strictParseFloat32"),
    uyr = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    SE = me((e) => {
      let t = e.match(uyr);
      if (t === null || t[0].length !== e.length)
        throw new TypeError("Expected real number, got implicit NaN");
      return parseFloat(e);
    }, "parseNumber"),
    K7 = me(
      (e) => (typeof e == "string" ? Oze(e) : LO(e)),
      "limitedParseDouble",
    ),
    lyr = K7,
    dyr = K7,
    fyr = me(
      (e) => (typeof e == "string" ? Oze(e) : S1(e)),
      "limitedParseFloat32",
    ),
    Oze = me((e) => {
      switch (e) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw new Error(`Unable to parse float value: ${e}`);
      }
    }, "parseFloatString"),
    Tze = me((e) => MO(typeof e == "string" ? SE(e) : e), "strictParseLong"),
    pyr = Tze,
    myr = me((e) => U7(typeof e == "string" ? SE(e) : e), "strictParseInt32"),
    EE = me((e) => H7(typeof e == "string" ? SE(e) : e), "strictParseShort"),
    Aze = me((e) => G7(typeof e == "string" ? SE(e) : e), "strictParseByte"),
    C1 = me(
      (e) =>
        String(new TypeError(e).stack || e)
          .split(
            `
`,
          )
          .slice(0, 5)
          .filter((t) => !t.includes("stackTraceWarning")).join(`
`),
      "stackTraceWarning",
    ),
    qO = { warn: console.warn },
    hyr = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    W7 = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
  function Pze(e) {
    let t = e.getUTCFullYear(),
      r = e.getUTCMonth(),
      n = e.getUTCDay(),
      i = e.getUTCDate(),
      o = e.getUTCHours(),
      a = e.getUTCMinutes(),
      s = e.getUTCSeconds(),
      u = i < 10 ? `0${i}` : `${i}`,
      l = o < 10 ? `0${o}` : `${o}`,
      d = a < 10 ? `0${a}` : `${a}`,
      f = s < 10 ? `0${s}` : `${s}`;
    return `${hyr[n]}, ${u} ${W7[r]} ${t} ${l}:${d}:${f} GMT`;
  }
  me(Pze, "dateToUtcString");
  var gyr = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/,
    ),
    vyr = me((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      let t = gyr.exec(e);
      if (!t) throw new TypeError("Invalid RFC-3339 date-time value");
      let [r, n, i, o, a, s, u, l] = t,
        d = EE(bE(n)),
        f = vu(i, "month", 1, 12),
        m = vu(o, "day", 1, 31);
      return DO(d, f, m, {
        hours: a,
        minutes: s,
        seconds: u,
        fractionalMilliseconds: l,
      });
    }, "parseRfc3339DateTime"),
    yyr = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/,
    ),
    _yr = me((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      let t = yyr.exec(e);
      if (!t) throw new TypeError("Invalid RFC-3339 date-time value");
      let [r, n, i, o, a, s, u, l, d] = t,
        f = EE(bE(n)),
        m = vu(i, "month", 1, 12),
        h = vu(o, "day", 1, 31),
        y = DO(f, m, h, {
          hours: a,
          minutes: s,
          seconds: u,
          fractionalMilliseconds: l,
        });
      return d.toUpperCase() != "Z" && y.setTime(y.getTime() - Nyr(d)), y;
    }, "parseRfc3339DateTimeWithOffset"),
    Eyr = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    byr = new RegExp(
      /^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    Syr = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/,
    ),
    Cyr = me((e) => {
      if (e == null) return;
      if (typeof e != "string")
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
      let t = Eyr.exec(e);
      if (t) {
        let [r, n, i, o, a, s, u, l] = t;
        return DO(EE(bE(o)), F7(i), vu(n, "day", 1, 31), {
          hours: a,
          minutes: s,
          seconds: u,
          fractionalMilliseconds: l,
        });
      }
      if (((t = byr.exec(e)), t)) {
        let [r, n, i, o, a, s, u, l] = t;
        return Ayr(
          DO(Oyr(o), F7(i), vu(n, "day", 1, 31), {
            hours: a,
            minutes: s,
            seconds: u,
            fractionalMilliseconds: l,
          }),
        );
      }
      if (((t = Syr.exec(e)), t)) {
        let [r, n, i, o, a, s, u, l] = t;
        return DO(EE(bE(l)), F7(n), vu(i.trimLeft(), "day", 1, 31), {
          hours: o,
          minutes: a,
          seconds: s,
          fractionalMilliseconds: u,
        });
      }
      throw new TypeError("Invalid RFC-7231 date-time value");
    }, "parseRfc7231DateTime"),
    wyr = me((e) => {
      if (e == null) return;
      let t;
      if (typeof e == "number") t = e;
      else if (typeof e == "string") t = z7(e);
      else if (typeof e == "object" && e.tag === 1) t = e.value;
      else
        throw new TypeError(
          "Epoch timestamps must be expressed as floating point numbers or their string representation",
        );
      if (Number.isNaN(t) || t === 1 / 0 || t === -1 / 0)
        throw new TypeError(
          "Epoch timestamps must be valid, non-Infinite, non-NaN numerics",
        );
      return new Date(Math.round(t * 1e3));
    }, "parseEpochTimestamp"),
    DO = me((e, t, r, n) => {
      let i = t - 1;
      return (
        Ryr(e, i, r),
        new Date(
          Date.UTC(
            e,
            i,
            r,
            vu(n.hours, "hour", 0, 23),
            vu(n.minutes, "minute", 0, 59),
            vu(n.seconds, "seconds", 0, 60),
            xyr(n.fractionalMilliseconds),
          ),
        )
      );
    }, "buildDate"),
    Oyr = me((e) => {
      let t = new Date().getUTCFullYear(),
        r = Math.floor(t / 100) * 100 + EE(bE(e));
      return r < t ? r + 100 : r;
    }, "parseTwoDigitYear"),
    Tyr = 50 * 365 * 24 * 60 * 60 * 1e3,
    Ayr = me(
      (e) =>
        e.getTime() - new Date().getTime() > Tyr
          ? new Date(
              Date.UTC(
                e.getUTCFullYear() - 100,
                e.getUTCMonth(),
                e.getUTCDate(),
                e.getUTCHours(),
                e.getUTCMinutes(),
                e.getUTCSeconds(),
                e.getUTCMilliseconds(),
              ),
            )
          : e,
      "adjustRfc850Year",
    ),
    F7 = me((e) => {
      let t = W7.indexOf(e);
      if (t < 0) throw new TypeError(`Invalid month: ${e}`);
      return t + 1;
    }, "parseMonthByShortName"),
    Pyr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    Ryr = me((e, t, r) => {
      let n = Pyr[t];
      if ((t === 1 && Iyr(e) && (n = 29), r > n))
        throw new TypeError(`Invalid day for ${W7[t]} in ${e}: ${r}`);
    }, "validateDayOfMonth"),
    Iyr = me(
      (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0),
      "isLeapYear",
    ),
    vu = me((e, t, r, n) => {
      let i = Aze(bE(e));
      if (i < r || i > n)
        throw new TypeError(`${t} must be between ${r} and ${n}, inclusive`);
      return i;
    }, "parseDateValue"),
    xyr = me((e) => (e == null ? 0 : wze("0." + e) * 1e3), "parseMilliseconds"),
    Nyr = me((e) => {
      let t = e[0],
        r = 1;
      if (t == "+") r = 1;
      else if (t == "-") r = -1;
      else throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`);
      let n = Number(e.substring(1, 3)),
        i = Number(e.substring(4, 6));
      return r * (n * 60 + i) * 60 * 1e3;
    }, "parseOffsetToMilliseconds"),
    bE = me((e) => {
      let t = 0;
      for (; t < e.length - 1 && e.charAt(t) === "0"; ) t++;
      return t === 0 ? e : e.slice(t);
    }, "stripLeadingZeroes"),
    kyr = class kO extends Error {
      static {
        me(this, "ServiceException");
      }
      constructor(t) {
        super(t.message),
          Object.setPrototypeOf(
            this,
            Object.getPrototypeOf(this).constructor.prototype,
          ),
          (this.name = t.name),
          (this.$fault = t.$fault),
          (this.$metadata = t.$metadata);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          kO.prototype.isPrototypeOf(r) ||
          (!!r.$fault &&
            !!r.$metadata &&
            (r.$fault === "client" || r.$fault === "server"))
        );
      }
      static [Symbol.hasInstance](t) {
        if (!t) return !1;
        let r = t;
        return this === kO
          ? kO.isInstance(t)
          : kO.isInstance(t)
            ? r.name && this.name
              ? this.prototype.isPrototypeOf(t) || r.name === this.name
              : this.prototype.isPrototypeOf(t)
            : !1;
      }
    },
    Rze = me((e, t = {}) => {
      Object.entries(t)
        .filter(([, n]) => n !== void 0)
        .forEach(([n, i]) => {
          (e[n] == null || e[n] === "") && (e[n] = i);
        });
      let r = e.message || e.Message || "UnknownError";
      return (e.message = r), delete e.Message, e;
    }, "decorateServiceException"),
    Ize = me(({ output: e, parsedBody: t, exceptionCtor: r, errorCode: n }) => {
      let i = Lyr(e),
        o = i.httpStatusCode ? i.httpStatusCode + "" : void 0,
        a = new r({
          name: t?.code || t?.Code || n || o || "UnknownError",
          $fault: "client",
          $metadata: i,
        });
      throw Rze(a, t);
    }, "throwDefaultError"),
    Dyr = me(
      (e) =>
        ({ output: t, parsedBody: r, errorCode: n }) => {
          Ize({ output: t, parsedBody: r, exceptionCtor: e, errorCode: n });
        },
      "withBaseException",
    ),
    Lyr = me(
      (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }),
      "deserializeMetadata",
    ),
    Myr = me((e) => {
      switch (e) {
        case "standard":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "in-region":
          return { retryMode: "standard", connectionTimeout: 1100 };
        case "cross-region":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "mobile":
          return { retryMode: "standard", connectionTimeout: 3e4 };
        default:
          return {};
      }
    }, "loadConfigsForDefaultMode"),
    _ze = !1,
    qyr = me((e) => {
      e && !_ze && parseInt(e.substring(1, e.indexOf("."))) < 16 && (_ze = !0);
    }, "emitWarningIfUnsupportedVersion"),
    jyr = me((e) => {
      let t = [];
      for (let r in B7.AlgorithmId) {
        let n = B7.AlgorithmId[r];
        e[n] !== void 0 &&
          t.push({ algorithmId: () => n, checksumConstructor: () => e[n] });
      }
      return {
        addChecksumAlgorithm(r) {
          t.push(r);
        },
        checksumAlgorithms() {
          return t;
        },
      };
    }, "getChecksumConfiguration"),
    Fyr = me((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    Byr = me(
      (e) => ({
        setRetryStrategy(t) {
          e.retryStrategy = t;
        },
        retryStrategy() {
          return e.retryStrategy;
        },
      }),
      "getRetryConfiguration",
    ),
    Uyr = me((e) => {
      let t = {};
      return (t.retryStrategy = e.retryStrategy()), t;
    }, "resolveRetryRuntimeConfig"),
    xze = me(
      (e) => Object.assign(jyr(e), Byr(e)),
      "getDefaultExtensionConfiguration",
    ),
    Hyr = xze,
    Gyr = me(
      (e) => Object.assign(Fyr(e), Uyr(e)),
      "resolveDefaultRuntimeConfig",
    ),
    Vyr = me((e) => (Array.isArray(e) ? e : [e]), "getArrayIfSingleItem"),
    Nze = me((e) => {
      let t = "#text";
      for (let r in e)
        e.hasOwnProperty(r) && e[r][t] !== void 0
          ? (e[r] = e[r][t])
          : typeof e[r] == "object" && e[r] !== null && (e[r] = Nze(e[r]));
      return e;
    }, "getValueFromTextNode"),
    $yr = me((e) => e != null, "isSerializableHeaderValue"),
    Bh = me(function (t) {
      return Object.assign(new String(t), {
        deserializeJSON() {
          return JSON.parse(String(t));
        },
        toString() {
          return String(t);
        },
        toJSON() {
          return String(t);
        },
      });
    }, "LazyJsonString");
  Bh.from = (e) =>
    e && typeof e == "object" && (e instanceof Bh || "deserializeJSON" in e)
      ? e
      : typeof e == "string" || Object.getPrototypeOf(e) === String.prototype
        ? Bh(String(e))
        : Bh(JSON.stringify(e));
  Bh.fromObject = Bh.from;
  var zyr = class {
    static {
      me(this, "NoOpLogger");
    }
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  };
  function Q7(e, t, r) {
    let n, i, o;
    if (typeof t > "u" && typeof r > "u") (n = {}), (o = e);
    else {
      if (((n = e), typeof t == "function"))
        return (i = t), (o = r), Qyr(n, i, o);
      o = t;
    }
    for (let a of Object.keys(o)) {
      if (!Array.isArray(o[a])) {
        n[a] = o[a];
        continue;
      }
      kze(n, null, o, a);
    }
    return n;
  }
  me(Q7, "map");
  var Kyr = me((e) => {
      let t = {};
      for (let [r, n] of Object.entries(e || {})) t[r] = [, n];
      return t;
    }, "convertMap"),
    Wyr = me((e, t) => {
      let r = {};
      for (let n in t) kze(r, e, t, n);
      return r;
    }, "take"),
    Qyr = me(
      (e, t, r) =>
        Q7(
          e,
          Object.entries(r).reduce(
            (n, [i, o]) => (
              Array.isArray(o)
                ? (n[i] = o)
                : typeof o == "function"
                  ? (n[i] = [t, o()])
                  : (n[i] = [t, o]),
              n
            ),
            {},
          ),
        ),
      "mapWithFilter",
    ),
    kze = me((e, t, r, n) => {
      if (t !== null) {
        let a = r[n];
        typeof a == "function" && (a = [, a]);
        let [s = Yyr, u = Xyr, l = n] = a;
        ((typeof s == "function" && s(t[l])) ||
          (typeof s != "function" && s)) &&
          (e[n] = u(t[l]));
        return;
      }
      let [i, o] = r[n];
      if (typeof o == "function") {
        let a,
          s = i === void 0 && (a = o()) != null,
          u =
            (typeof i == "function" && !!i(void 0)) ||
            (typeof i != "function" && !!i);
        s ? (e[n] = a) : u && (e[n] = o());
      } else {
        let a = i === void 0 && o != null,
          s =
            (typeof i == "function" && !!i(o)) ||
            (typeof i != "function" && !!i);
        (a || s) && (e[n] = o);
      }
    }, "applyInstruction"),
    Yyr = me((e) => e != null, "nonNullish"),
    Xyr = me((e) => e, "pass");
  function Dze(e) {
    return (
      (e.includes(",") || e.includes('"')) &&
        (e = `"${e.replace(/"/g, '\\"')}"`),
      e
    );
  }
  me(Dze, "quoteHeader");
  var Jyr = me((e) => {
      if (e !== e) return "NaN";
      switch (e) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return e;
      }
    }, "serializeFloat"),
    Zyr = me((e) => e.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    V7 = me((e) => {
      if (e == null) return {};
      if (Array.isArray(e)) return e.filter((t) => t != null).map(V7);
      if (typeof e == "object") {
        let t = {};
        for (let r of Object.keys(e)) e[r] != null && (t[r] = V7(e[r]));
        return t;
      }
      return e;
    }, "_json");
  function Lze(e, t, r) {
    if (r <= 0 || !Number.isInteger(r))
      throw new Error(
        "Invalid number of delimiters (" + r + ") for splitEvery.",
      );
    let n = e.split(t);
    if (r === 1) return n;
    let i = [],
      o = "";
    for (let a = 0; a < n.length; a++)
      o === "" ? (o = n[a]) : (o += t + n[a]),
        (a + 1) % r === 0 && (i.push(o), (o = ""));
    return o !== "" && i.push(o), i;
  }
  me(Lze, "splitEvery");
  var e_r = me((e) => {
    let t = e.length,
      r = [],
      n = !1,
      i,
      o = 0;
    for (let a = 0; a < t; ++a) {
      let s = e[a];
      switch (s) {
        case '"':
          i !== "\\" && (n = !n);
          break;
        case ",":
          n || (r.push(e.slice(o, a)), (o = a + 1));
          break;
        default:
      }
      i = s;
    }
    return (
      r.push(e.slice(o)),
      r.map((a) => {
        a = a.trim();
        let s = a.length;
        return s < 2
          ? a
          : (a[0] === '"' && a[s - 1] === '"' && (a = a.slice(1, s - 1)),
            a.replace(/\\"/g, '"'));
      })
    );
  }, "splitHeader");
});
var qze,
  t_r,
  jze = w(() => {
    c();
    (qze = A(At())),
      (t_r = (e) => {
        if (e != null)
          return (
            typeof e == "object" && "__type" in e && delete e.__type,
            (0, qze.expectUnion)(e)
          );
      });
  });
var Fze,
  O1,
  Y7 = w(() => {
    c();
    (Fze = A(At())),
      (O1 = (e, t) => (0, Fze.collectBody)(e, t).then((r) => t.utf8Encoder(r)));
  });
var T1,
  X7,
  J7,
  Bze = w(() => {
    c();
    Y7();
    (T1 = (e, t) =>
      O1(e, t).then((r) => {
        if (r.length)
          try {
            return JSON.parse(r);
          } catch (n) {
            throw (
              (n?.name === "SyntaxError" &&
                Object.defineProperty(n, "$responseBodyText", { value: r }),
              n)
            );
          }
        return {};
      })),
      (X7 = async (e, t) => {
        let r = await T1(e, t);
        return (r.message = r.message ?? r.Message), r;
      }),
      (J7 = (e, t) => {
        let r = (o, a) =>
            Object.keys(o).find((s) => s.toLowerCase() === a.toLowerCase()),
          n = (o) => {
            let a = o;
            return (
              typeof a == "number" && (a = a.toString()),
              a.indexOf(",") >= 0 && (a = a.split(",")[0]),
              a.indexOf(":") >= 0 && (a = a.split(":")[0]),
              a.indexOf("#") >= 0 && (a = a.split("#")[1]),
              a
            );
          },
          i = r(e.headers, "x-amzn-errortype");
        if (i !== void 0) return n(e.headers[i]);
        if (t.code !== void 0) return n(t.code);
        if (t.__type !== void 0) return n(t.__type);
      });
  });
var Uze,
  Hze,
  jO,
  Z7,
  r_r,
  Gze = w(() => {
    c();
    (Uze = A(At())), (Hze = A(UC()));
    Y7();
    (jO = (e, t) =>
      O1(e, t).then((r) => {
        if (r.length) {
          let n = new Hze.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: (u, l) =>
              l.trim() === "" &&
              l.includes(`
`)
                ? ""
                : void 0,
          });
          n.addEntity("#xD", "\r"),
            n.addEntity(
              "#10",
              `
`,
            );
          let i;
          try {
            i = n.parse(r, !0);
          } catch (u) {
            throw (
              (u &&
                typeof u == "object" &&
                Object.defineProperty(u, "$responseBodyText", { value: r }),
              u)
            );
          }
          let o = "#text",
            a = Object.keys(i)[0],
            s = i[a];
          return (
            s[o] && ((s[a] = s[o]), delete s[o]),
            (0, Uze.getValueFromTextNode)(s)
          );
        }
        return {};
      })),
      (Z7 = async (e, t) => {
        let r = await jO(e, t);
        return (
          r.Error && (r.Error.message = r.Error.message ?? r.Error.Message), r
        );
      }),
      (r_r = (e, t) => {
        if (t?.Error?.Code !== void 0) return t.Error.Code;
        if (t?.Code !== void 0) return t.Code;
        if (e.statusCode == 404) return "NotFound";
      });
  });
var Vze = w(() => {
  c();
  pze();
  jze();
  Bze();
  Gze();
});
var yu = {};
bn(yu, {
  AWSSDKSigV4Signer: () => S$e,
  AwsSdkSigV4ASigner: () => d1,
  AwsSdkSigV4Signer: () => ma,
  NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => NO,
  NODE_SIGV4A_CONFIG_OPTIONS: () => uvr,
  _toBool: () => Mvr,
  _toNum: () => qvr,
  _toStr: () => Lvr,
  awsExpectUnion: () => t_r,
  emitWarningIfUnsupportedVersion: () => gE,
  loadRestJsonErrorCode: () => J7,
  loadRestXmlErrorCode: () => r_r,
  parseJsonBody: () => T1,
  parseJsonErrorBody: () => X7,
  parseXmlBody: () => jO,
  parseXmlErrorBody: () => Z7,
  resolveAWSSDKSigV4Config: () => Nvr,
  resolveAwsSdkSigV4AConfig: () => cvr,
  resolveAwsSdkSigV4Config: () => _E,
  setCredentialFeature: () => cp,
  setFeature: () => m$e,
  state: () => l1,
  validateSigningProperties: () => xO,
});
var ri = w(() => {
  c();
  gu();
  fze();
  Vze();
});
var CE = g((bVn, r2e) => {
  "use strict";
  c();
  var P1 = Object.defineProperty,
    n_r = Object.getOwnPropertyDescriptor,
    i_r = Object.getOwnPropertyNames,
    o_r = Object.prototype.hasOwnProperty,
    zl = (e, t) => P1(e, "name", { value: t, configurable: !0 }),
    a_r = (e, t) => {
      for (var r in t) P1(e, r, { get: t[r], enumerable: !0 });
    },
    s_r = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of i_r(t))
          !o_r.call(e, i) &&
            i !== r &&
            P1(e, i, {
              get: () => t[i],
              enumerable: !(n = n_r(t, i)) || n.enumerable,
            });
      return e;
    },
    c_r = (e) => s_r(P1({}, "__esModule", { value: !0 }), e),
    Wze = {};
  a_r(Wze, {
    DEFAULT_UA_APP_ID: () => Qze,
    getUserAgentMiddlewareOptions: () => t2e,
    getUserAgentPlugin: () => g_r,
    resolveUserAgentConfig: () => Xze,
    userAgentMiddleware: () => e2e,
  });
  r2e.exports = c_r(Wze);
  var u_r = (Gn(), ue(rc)),
    Qze = void 0;
  function Yze(e) {
    return e === void 0 ? !0 : typeof e == "string" && e.length <= 50;
  }
  zl(Yze, "isValidUserAgentAppId");
  function Xze(e) {
    let t = (0, u_r.normalizeProvider)(e.userAgentAppId ?? Qze),
      { customUserAgent: r } = e;
    return Object.assign(e, {
      customUserAgent: typeof r == "string" ? [[r]] : r,
      userAgentAppId: zl(async () => {
        let n = await t();
        if (!Yze(n)) {
          let i =
            e.logger?.constructor?.name === "NoOpLogger" || !e.logger
              ? console
              : e.logger;
          typeof n != "string"
            ? i?.warn("userAgentAppId must be a string or undefined.")
            : n.length > 50 &&
              i?.warn(
                "The provided userAgentAppId exceeds the maximum length of 50 characters.",
              );
        }
        return n;
      }, "userAgentAppId"),
    });
  }
  zl(Xze, "resolveUserAgentConfig");
  var l_r = hE(),
    d_r = ln(),
    _u = (ri(), ue(yu)),
    f_r = /\d{12}\.ddb/;
  async function Jze(e, t, r) {
    if (
      (r.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" &&
        (0, _u.setFeature)(e, "PROTOCOL_RPC_V2_CBOR", "M"),
      typeof t.retryStrategy == "function")
    ) {
      let o = await t.retryStrategy();
      typeof o.acquireInitialRetryToken == "function"
        ? o.constructor?.name?.includes("Adaptive")
          ? (0, _u.setFeature)(e, "RETRY_MODE_ADAPTIVE", "F")
          : (0, _u.setFeature)(e, "RETRY_MODE_STANDARD", "E")
        : (0, _u.setFeature)(e, "RETRY_MODE_LEGACY", "D");
    }
    if (typeof t.accountIdEndpointMode == "function") {
      let o = e.endpointV2;
      switch (
        (String(o?.url?.hostname).match(f_r) &&
          (0, _u.setFeature)(e, "ACCOUNT_ID_ENDPOINT", "O"),
        await t.accountIdEndpointMode?.())
      ) {
        case "disabled":
          (0, _u.setFeature)(e, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          (0, _u.setFeature)(e, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          (0, _u.setFeature)(e, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break;
      }
    }
    let i = e.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (i?.$source) {
      let o = i;
      o.accountId && (0, _u.setFeature)(e, "RESOLVED_ACCOUNT_ID", "T");
      for (let [a, s] of Object.entries(o.$source ?? {}))
        (0, _u.setFeature)(e, a, s);
    }
  }
  zl(Jze, "checkFeatures");
  var $ze = "user-agent",
    eJ = "x-amz-user-agent",
    zze = " ",
    tJ = "/",
    p_r = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g,
    m_r = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g,
    Kze = "-",
    h_r = 1024;
  function Zze(e) {
    let t = "";
    for (let r in e) {
      let n = e[r];
      if (t.length + n.length + 1 <= h_r) {
        t.length ? (t += "," + n) : (t += n);
        continue;
      }
      break;
    }
    return t;
  }
  zl(Zze, "encodeFeatures");
  var e2e = zl(
      (e) => (t, r) => async (n) => {
        let { request: i } = n;
        if (!d_r.HttpRequest.isInstance(i)) return t(n);
        let { headers: o } = i,
          a = r?.userAgent?.map(A1) || [],
          s = (await e.defaultUserAgentProvider()).map(A1);
        await Jze(r, e, n);
        let u = r;
        s.push(
          `m/${Zze(Object.assign({}, r.__smithy_context?.features, u.__aws_sdk_context?.features))}`,
        );
        let l = e?.customUserAgent?.map(A1) || [],
          d = await e.userAgentAppId();
        d && s.push(A1([`app/${d}`]));
        let f = (0, l_r.getUserAgentPrefix)(),
          m = (f ? [f] : []).concat([...s, ...a, ...l]).join(zze),
          h = [...s.filter((y) => y.startsWith("aws-sdk-")), ...l].join(zze);
        return (
          e.runtime !== "browser"
            ? (h && (o[eJ] = o[eJ] ? `${o[$ze]} ${h}` : h), (o[$ze] = m))
            : (o[eJ] = m),
          t({ ...n, request: i })
        );
      },
      "userAgentMiddleware",
    ),
    A1 = zl((e) => {
      let t = e[0]
          .split(tJ)
          .map((a) => a.replace(p_r, Kze))
          .join(tJ),
        r = e[1]?.replace(m_r, Kze),
        n = t.indexOf(tJ),
        i = t.substring(0, n),
        o = t.substring(n + 1);
      return (
        i === "api" && (o = o.toLowerCase()),
        [i, o, r]
          .filter((a) => a && a.length > 0)
          .reduce((a, s, u) => {
            switch (u) {
              case 0:
                return s;
              case 1:
                return `${a}/${s}`;
              default:
                return `${a}#${s}`;
            }
          }, "")
      );
    }, "escapeUserAgent"),
    t2e = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: !0,
    },
    g_r = zl(
      (e) => ({
        applyToStack: zl((t) => {
          t.add(e2e(e), t2e);
        }, "applyToStack"),
      }),
      "getUserAgentPlugin",
    );
});
var Eu = g((CVn, p2e) => {
  c();
  var I1 = Object.defineProperty,
    v_r = Object.getOwnPropertyDescriptor,
    y_r = Object.getOwnPropertyNames,
    __r = Object.prototype.hasOwnProperty,
    nc = (e, t) => I1(e, "name", { value: t, configurable: !0 }),
    E_r = (e, t) => {
      for (var r in t) I1(e, r, { get: t[r], enumerable: !0 });
    },
    b_r = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of y_r(t))
          !__r.call(e, i) &&
            i !== r &&
            I1(e, i, {
              get: () => t[i],
              enumerable: !(n = v_r(t, i)) || n.enumerable,
            });
      return e;
    },
    S_r = (e) => b_r(I1({}, "__esModule", { value: !0 }), e),
    o2e = {};
  E_r(o2e, {
    CONFIG_USE_DUALSTACK_ENDPOINT: () => s2e,
    CONFIG_USE_FIPS_ENDPOINT: () => u2e,
    DEFAULT_USE_DUALSTACK_ENDPOINT: () => C_r,
    DEFAULT_USE_FIPS_ENDPOINT: () => O_r,
    ENV_USE_DUALSTACK_ENDPOINT: () => a2e,
    ENV_USE_FIPS_ENDPOINT: () => c2e,
    NODE_REGION_CONFIG_FILE_OPTIONS: () => x_r,
    NODE_REGION_CONFIG_OPTIONS: () => I_r,
    NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS: () => w_r,
    NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS: () => T_r,
    REGION_ENV_NAME: () => l2e,
    REGION_INI_NAME: () => d2e,
    getRegionInfo: () => M_r,
    resolveCustomEndpointsConfig: () => A_r,
    resolveEndpointsConfig: () => R_r,
    resolveRegionConfig: () => N_r,
  });
  p2e.exports = S_r(o2e);
  var dp = GC(),
    a2e = "AWS_USE_DUALSTACK_ENDPOINT",
    s2e = "use_dualstack_endpoint",
    C_r = !1,
    w_r = {
      environmentVariableSelector: (e) =>
        (0, dp.booleanSelector)(e, a2e, dp.SelectorType.ENV),
      configFileSelector: (e) =>
        (0, dp.booleanSelector)(e, s2e, dp.SelectorType.CONFIG),
      default: !1,
    },
    c2e = "AWS_USE_FIPS_ENDPOINT",
    u2e = "use_fips_endpoint",
    O_r = !1,
    T_r = {
      environmentVariableSelector: (e) =>
        (0, dp.booleanSelector)(e, c2e, dp.SelectorType.ENV),
      configFileSelector: (e) =>
        (0, dp.booleanSelector)(e, u2e, dp.SelectorType.CONFIG),
      default: !1,
    },
    R1 = tc(),
    A_r = nc((e) => {
      let { tls: t, endpoint: r, urlParser: n, useDualstackEndpoint: i } = e;
      return Object.assign(e, {
        tls: t ?? !0,
        endpoint: (0, R1.normalizeProvider)(typeof r == "string" ? n(r) : r),
        isCustomEndpoint: !0,
        useDualstackEndpoint: (0, R1.normalizeProvider)(i ?? !1),
      });
    }, "resolveCustomEndpointsConfig"),
    P_r = nc(async (e) => {
      let { tls: t = !0 } = e,
        r = await e.region();
      if (
        !new RegExp(
          /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/,
        ).test(r)
      )
        throw new Error("Invalid region in client config");
      let i = await e.useDualstackEndpoint(),
        o = await e.useFipsEndpoint(),
        { hostname: a } =
          (await e.regionInfoProvider(r, {
            useDualstackEndpoint: i,
            useFipsEndpoint: o,
          })) ?? {};
      if (!a) throw new Error("Cannot resolve hostname from client config");
      return e.urlParser(`${t ? "https:" : "http:"}//${a}`);
    }, "getEndpointFromRegion"),
    R_r = nc((e) => {
      let t = (0, R1.normalizeProvider)(e.useDualstackEndpoint ?? !1),
        { endpoint: r, useFipsEndpoint: n, urlParser: i, tls: o } = e;
      return Object.assign(e, {
        tls: o ?? !0,
        endpoint: r
          ? (0, R1.normalizeProvider)(typeof r == "string" ? i(r) : r)
          : () => P_r({ ...e, useDualstackEndpoint: t, useFipsEndpoint: n }),
        isCustomEndpoint: !!r,
        useDualstackEndpoint: t,
      });
    }, "resolveEndpointsConfig"),
    l2e = "AWS_REGION",
    d2e = "region",
    I_r = {
      environmentVariableSelector: (e) => e[l2e],
      configFileSelector: (e) => e[d2e],
      default: () => {
        throw new Error("Region is missing");
      },
    },
    x_r = { preferredFile: "credentials" },
    f2e = nc(
      (e) =>
        typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips")),
      "isFipsRegion",
    ),
    n2e = nc(
      (e) =>
        f2e(e)
          ? ["fips-aws-global", "aws-fips"].includes(e)
            ? "us-east-1"
            : e.replace(/fips-(dkr-|prod-)?|-fips/, "")
          : e,
      "getRealRegion",
    ),
    N_r = nc((e) => {
      let { region: t, useFipsEndpoint: r } = e;
      if (!t) throw new Error("Region is missing");
      return Object.assign(e, {
        region: async () => {
          if (typeof t == "string") return n2e(t);
          let n = await t();
          return n2e(n);
        },
        useFipsEndpoint: async () => {
          let n = typeof t == "string" ? t : await t();
          return f2e(n)
            ? !0
            : typeof r != "function"
              ? Promise.resolve(!!r)
              : r();
        },
      });
    }, "resolveRegionConfig"),
    i2e = nc(
      (e = [], { useFipsEndpoint: t, useDualstackEndpoint: r }) =>
        e.find(
          ({ tags: n }) =>
            t === n.includes("fips") && r === n.includes("dualstack"),
        )?.hostname,
      "getHostnameFromVariants",
    ),
    k_r = nc(
      (e, { regionHostname: t, partitionHostname: r }) =>
        t || (r ? r.replace("{region}", e) : void 0),
      "getResolvedHostname",
    ),
    D_r = nc(
      (e, { partitionHash: t }) =>
        Object.keys(t || {}).find((r) => t[r].regions.includes(e)) ?? "aws",
      "getResolvedPartition",
    ),
    L_r = nc((e, { signingRegion: t, regionRegex: r, useFipsEndpoint: n }) => {
      if (t) return t;
      if (n) {
        let i = r
            .replace("\\\\", "\\")
            .replace(/^\^/g, "\\.")
            .replace(/\$$/g, "\\."),
          o = e.match(i);
        if (o) return o[0].slice(1, -1);
      }
    }, "getResolvedSigningRegion"),
    M_r = nc(
      (
        e,
        {
          useFipsEndpoint: t = !1,
          useDualstackEndpoint: r = !1,
          signingService: n,
          regionHash: i,
          partitionHash: o,
        },
      ) => {
        let a = D_r(e, { partitionHash: o }),
          s = e in i ? e : (o[a]?.endpoint ?? e),
          u = { useFipsEndpoint: t, useDualstackEndpoint: r },
          l = i2e(i[s]?.variants, u),
          d = i2e(o[a]?.variants, u),
          f = k_r(s, { regionHostname: l, partitionHostname: d });
        if (f === void 0)
          throw new Error(
            `Endpoint resolution failed for: ${{ resolvedRegion: s, useFipsEndpoint: t, useDualstackEndpoint: r }}`,
          );
        let m = L_r(f, {
          signingRegion: i[s]?.signingRegion,
          regionRegex: o[a].regionRegex,
          useFipsEndpoint: t,
        });
        return {
          partition: a,
          signingService: n,
          hostname: f,
          ...(m && { signingRegion: m }),
          ...(i[s]?.signingService && { signingService: i[s].signingService }),
        };
      },
      "getRegionInfo",
    );
});
var g2e = g((OVn, h2e) => {
  c();
  var x1 = Object.defineProperty,
    q_r = Object.getOwnPropertyDescriptor,
    j_r = Object.getOwnPropertyNames,
    F_r = Object.prototype.hasOwnProperty,
    B_r = (e, t) => x1(e, "name", { value: t, configurable: !0 }),
    U_r = (e, t) => {
      for (var r in t) x1(e, r, { get: t[r], enumerable: !0 });
    },
    H_r = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of j_r(t))
          !F_r.call(e, i) &&
            i !== r &&
            x1(e, i, {
              get: () => t[i],
              enumerable: !(n = q_r(t, i)) || n.enumerable,
            });
      return e;
    },
    G_r = (e) => H_r(x1({}, "__esModule", { value: !0 }), e),
    m2e = {};
  U_r(m2e, { resolveEventStreamSerdeConfig: () => V_r });
  h2e.exports = G_r(m2e);
  var V_r = B_r(
    (e) =>
      Object.assign(e, {
        eventStreamMarshaller: e.eventStreamSerdeProvider(e),
      }),
    "resolveEventStreamSerdeConfig",
  );
});
var FO = g((AVn, b2e) => {
  c();
  var N1 = Object.defineProperty,
    $_r = Object.getOwnPropertyDescriptor,
    z_r = Object.getOwnPropertyNames,
    K_r = Object.prototype.hasOwnProperty,
    y2e = (e, t) => N1(e, "name", { value: t, configurable: !0 }),
    W_r = (e, t) => {
      for (var r in t) N1(e, r, { get: t[r], enumerable: !0 });
    },
    Q_r = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of z_r(t))
          !K_r.call(e, i) &&
            i !== r &&
            N1(e, i, {
              get: () => t[i],
              enumerable: !(n = $_r(t, i)) || n.enumerable,
            });
      return e;
    },
    Y_r = (e) => Q_r(N1({}, "__esModule", { value: !0 }), e),
    _2e = {};
  W_r(_2e, {
    contentLengthMiddleware: () => rJ,
    contentLengthMiddlewareOptions: () => E2e,
    getContentLengthPlugin: () => J_r,
  });
  b2e.exports = Y_r(_2e);
  var X_r = ln(),
    v2e = "content-length";
  function rJ(e) {
    return (t) => async (r) => {
      let n = r.request;
      if (X_r.HttpRequest.isInstance(n)) {
        let { body: i, headers: o } = n;
        if (
          i &&
          Object.keys(o)
            .map((a) => a.toLowerCase())
            .indexOf(v2e) === -1
        )
          try {
            let a = e(i);
            n.headers = { ...n.headers, [v2e]: String(a) };
          } catch {}
      }
      return t({ ...r, request: n });
    };
  }
  y2e(rJ, "contentLengthMiddleware");
  var E2e = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: !0,
    },
    J_r = y2e(
      (e) => ({
        applyToStack: (t) => {
          t.add(rJ(e.bodyLengthChecker), E2e);
        },
      }),
      "getContentLengthPlugin",
    );
});
import Z_r from "crypto";
function BO() {
  return (
    k1 > D1.length - 16 && (Z_r.randomFillSync(D1), (k1 = 0)),
    D1.slice(k1, (k1 += 16))
  );
}
var D1,
  k1,
  nJ = w(() => {
    c();
    (D1 = new Uint8Array(256)), (k1 = D1.length);
  });
var S2e,
  C2e = w(() => {
    c();
    S2e =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  });
function eEr(e) {
  return typeof e == "string" && S2e.test(e);
}
var fp,
  UO = w(() => {
    c();
    C2e();
    fp = eEr;
  });
function Uh(e, t = 0) {
  return (
    Ii[e[t + 0]] +
    Ii[e[t + 1]] +
    Ii[e[t + 2]] +
    Ii[e[t + 3]] +
    "-" +
    Ii[e[t + 4]] +
    Ii[e[t + 5]] +
    "-" +
    Ii[e[t + 6]] +
    Ii[e[t + 7]] +
    "-" +
    Ii[e[t + 8]] +
    Ii[e[t + 9]] +
    "-" +
    Ii[e[t + 10]] +
    Ii[e[t + 11]] +
    Ii[e[t + 12]] +
    Ii[e[t + 13]] +
    Ii[e[t + 14]] +
    Ii[e[t + 15]]
  );
}
function tEr(e, t = 0) {
  let r = Uh(e, t);
  if (!fp(r)) throw TypeError("Stringified UUID is invalid");
  return r;
}
var Ii,
  w2e,
  HO = w(() => {
    c();
    UO();
    Ii = [];
    for (let e = 0; e < 256; ++e) Ii.push((e + 256).toString(16).slice(1));
    w2e = tEr;
  });
function rEr(e, t, r) {
  let n = (t && r) || 0,
    i = t || new Array(16);
  e = e || {};
  let o = e.node || O2e,
    a = e.clockseq !== void 0 ? e.clockseq : iJ;
  if (o == null || a == null) {
    let m = e.random || (e.rng || BO)();
    o == null && (o = O2e = [m[0] | 1, m[1], m[2], m[3], m[4], m[5]]),
      a == null && (a = iJ = ((m[6] << 8) | m[7]) & 16383);
  }
  let s = e.msecs !== void 0 ? e.msecs : Date.now(),
    u = e.nsecs !== void 0 ? e.nsecs : aJ + 1,
    l = s - oJ + (u - aJ) / 1e4;
  if (
    (l < 0 && e.clockseq === void 0 && (a = (a + 1) & 16383),
    (l < 0 || s > oJ) && e.nsecs === void 0 && (u = 0),
    u >= 1e4)
  )
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  (oJ = s), (aJ = u), (iJ = a), (s += 122192928e5);
  let d = ((s & 268435455) * 1e4 + u) % 4294967296;
  (i[n++] = (d >>> 24) & 255),
    (i[n++] = (d >>> 16) & 255),
    (i[n++] = (d >>> 8) & 255),
    (i[n++] = d & 255);
  let f = ((s / 4294967296) * 1e4) & 268435455;
  (i[n++] = (f >>> 8) & 255),
    (i[n++] = f & 255),
    (i[n++] = ((f >>> 24) & 15) | 16),
    (i[n++] = (f >>> 16) & 255),
    (i[n++] = (a >>> 8) | 128),
    (i[n++] = a & 255);
  for (let m = 0; m < 6; ++m) i[n + m] = o[m];
  return t || Uh(i);
}
var O2e,
  iJ,
  oJ,
  aJ,
  T2e,
  A2e = w(() => {
    c();
    nJ();
    HO();
    (oJ = 0), (aJ = 0);
    T2e = rEr;
  });
function nEr(e) {
  if (!fp(e)) throw TypeError("Invalid UUID");
  let t,
    r = new Uint8Array(16);
  return (
    (r[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24),
    (r[1] = (t >>> 16) & 255),
    (r[2] = (t >>> 8) & 255),
    (r[3] = t & 255),
    (r[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8),
    (r[5] = t & 255),
    (r[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8),
    (r[7] = t & 255),
    (r[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8),
    (r[9] = t & 255),
    (r[10] = ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255),
    (r[11] = (t / 4294967296) & 255),
    (r[12] = (t >>> 24) & 255),
    (r[13] = (t >>> 16) & 255),
    (r[14] = (t >>> 8) & 255),
    (r[15] = t & 255),
    r
  );
}
var L1,
  sJ = w(() => {
    c();
    UO();
    L1 = nEr;
  });
function iEr(e) {
  e = unescape(encodeURIComponent(e));
  let t = [];
  for (let r = 0; r < e.length; ++r) t.push(e.charCodeAt(r));
  return t;
}
function GO(e, t, r) {
  function n(i, o, a, s) {
    var u;
    if (
      (typeof i == "string" && (i = iEr(i)),
      typeof o == "string" && (o = L1(o)),
      ((u = o) === null || u === void 0 ? void 0 : u.length) !== 16)
    )
      throw TypeError(
        "Namespace must be array-like (16 iterable integer values, 0-255)",
      );
    let l = new Uint8Array(16 + i.length);
    if (
      (l.set(o),
      l.set(i, o.length),
      (l = r(l)),
      (l[6] = (l[6] & 15) | t),
      (l[8] = (l[8] & 63) | 128),
      a)
    ) {
      s = s || 0;
      for (let d = 0; d < 16; ++d) a[s + d] = l[d];
      return a;
    }
    return Uh(l);
  }
  try {
    n.name = e;
  } catch {}
  return (n.DNS = oEr), (n.URL = aEr), n;
}
var oEr,
  aEr,
  cJ = w(() => {
    c();
    HO();
    sJ();
    (oEr = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"),
      (aEr = "6ba7b811-9dad-11d1-80b4-00c04fd430c8");
  });
import sEr from "crypto";
function cEr(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == "string" && (e = Buffer.from(e, "utf8")),
    sEr.createHash("md5").update(e).digest()
  );
}
var P2e,
  R2e = w(() => {
    c();
    P2e = cEr;
  });
var uEr,
  I2e,
  x2e = w(() => {
    c();
    cJ();
    R2e();
    (uEr = GO("v3", 48, P2e)), (I2e = uEr);
  });
import lEr from "crypto";
var uJ,
  N2e = w(() => {
    c();
    uJ = { randomUUID: lEr.randomUUID };
  });
function dEr(e, t, r) {
  if (uJ.randomUUID && !t && !e) return uJ.randomUUID();
  e = e || {};
  let n = e.random || (e.rng || BO)();
  if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), t)) {
    r = r || 0;
    for (let i = 0; i < 16; ++i) t[r + i] = n[i];
    return t;
  }
  return Uh(n);
}
var k2e,
  D2e = w(() => {
    c();
    N2e();
    nJ();
    HO();
    k2e = dEr;
  });
import fEr from "crypto";
function pEr(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == "string" && (e = Buffer.from(e, "utf8")),
    fEr.createHash("sha1").update(e).digest()
  );
}
var L2e,
  M2e = w(() => {
    c();
    L2e = pEr;
  });
var mEr,
  q2e,
  j2e = w(() => {
    c();
    cJ();
    M2e();
    (mEr = GO("v5", 80, L2e)), (q2e = mEr);
  });
var F2e,
  B2e = w(() => {
    c();
    F2e = "00000000-0000-0000-0000-000000000000";
  });
function hEr(e) {
  if (!fp(e)) throw TypeError("Invalid UUID");
  return parseInt(e.slice(14, 15), 16);
}
var U2e,
  H2e = w(() => {
    c();
    UO();
    U2e = hEr;
  });
var G2e = {};
bn(G2e, {
  NIL: () => F2e,
  parse: () => L1,
  stringify: () => w2e,
  v1: () => T2e,
  v3: () => I2e,
  v4: () => k2e,
  v5: () => q2e,
  validate: () => fp,
  version: () => U2e,
});
var V2e = w(() => {
  c();
  A2e();
  x2e();
  D2e();
  j2e();
  B2e();
  H2e();
  UO();
  HO();
  sJ();
});
var dJ = g((D$n, K2e) => {
  c();
  var M1 = Object.defineProperty,
    gEr = Object.getOwnPropertyDescriptor,
    vEr = Object.getOwnPropertyNames,
    yEr = Object.prototype.hasOwnProperty,
    wE = (e, t) => M1(e, "name", { value: t, configurable: !0 }),
    _Er = (e, t) => {
      for (var r in t) M1(e, r, { get: t[r], enumerable: !0 });
    },
    EEr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of vEr(t))
          !yEr.call(e, i) &&
            i !== r &&
            M1(e, i, {
              get: () => t[i],
              enumerable: !(n = gEr(t, i)) || n.enumerable,
            });
      return e;
    },
    bEr = (e) => EEr(M1({}, "__esModule", { value: !0 }), e),
    $2e = {};
  _Er($2e, {
    isClockSkewCorrectedError: () => z2e,
    isClockSkewError: () => PEr,
    isRetryableByTrait: () => AEr,
    isServerError: () => IEr,
    isThrottlingError: () => REr,
    isTransientError: () => lJ,
  });
  K2e.exports = bEr($2e);
  var SEr = [
      "AuthFailure",
      "InvalidSignatureException",
      "RequestExpired",
      "RequestInTheFuture",
      "RequestTimeTooSkewed",
      "SignatureDoesNotMatch",
    ],
    CEr = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException",
    ],
    wEr = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"],
    OEr = [500, 502, 503, 504],
    TEr = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"],
    AEr = wE((e) => e.$retryable !== void 0, "isRetryableByTrait"),
    PEr = wE((e) => SEr.includes(e.name), "isClockSkewError"),
    z2e = wE(
      (e) => e.$metadata?.clockSkewCorrected,
      "isClockSkewCorrectedError",
    ),
    REr = wE(
      (e) =>
        e.$metadata?.httpStatusCode === 429 ||
        CEr.includes(e.name) ||
        e.$retryable?.throttling == !0,
      "isThrottlingError",
    ),
    lJ = wE(
      (e, t = 0) =>
        z2e(e) ||
        wEr.includes(e.name) ||
        TEr.includes(e?.code || "") ||
        OEr.includes(e.$metadata?.httpStatusCode || 0) ||
        (e.cause !== void 0 && t <= 10 && lJ(e.cause, t + 1)),
      "isTransientError",
    ),
    IEr = wE((e) => {
      if (e.$metadata?.httpStatusCode !== void 0) {
        let t = e.$metadata.httpStatusCode;
        return 500 <= t && t <= 599 && !lJ(e);
      }
      return !1;
    }, "isServerError");
});
var OE = g((M$n, nKe) => {
  c();
  var q1 = Object.defineProperty,
    xEr = Object.getOwnPropertyDescriptor,
    NEr = Object.getOwnPropertyNames,
    kEr = Object.prototype.hasOwnProperty,
    ic = (e, t) => q1(e, "name", { value: t, configurable: !0 }),
    DEr = (e, t) => {
      for (var r in t) q1(e, r, { get: t[r], enumerable: !0 });
    },
    LEr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of NEr(t))
          !kEr.call(e, i) &&
            i !== r &&
            q1(e, i, {
              get: () => t[i],
              enumerable: !(n = xEr(t, i)) || n.enumerable,
            });
      return e;
    },
    MEr = (e) => LEr(q1({}, "__esModule", { value: !0 }), e),
    Q2e = {};
  DEr(Q2e, {
    AdaptiveRetryStrategy: () => HEr,
    ConfiguredRetryStrategy: () => GEr,
    DEFAULT_MAX_ATTEMPTS: () => fJ,
    DEFAULT_RETRY_DELAY_BASE: () => VO,
    DEFAULT_RETRY_MODE: () => qEr,
    DefaultRateLimiter: () => X2e,
    INITIAL_RETRY_TOKENS: () => pJ,
    INVOCATION_ID_HEADER: () => FEr,
    MAXIMUM_RETRY_DELAY: () => mJ,
    NO_RETRY_INCREMENT: () => rKe,
    REQUEST_HEADER: () => BEr,
    RETRY_COST: () => eKe,
    RETRY_MODES: () => Y2e,
    StandardRetryStrategy: () => hJ,
    THROTTLING_RETRY_DELAY_BASE: () => Z2e,
    TIMEOUT_RETRY_COST: () => tKe,
  });
  nKe.exports = MEr(Q2e);
  var Y2e = ((e) => ((e.STANDARD = "standard"), (e.ADAPTIVE = "adaptive"), e))(
      Y2e || {},
    ),
    fJ = 3,
    qEr = "standard",
    jEr = dJ(),
    X2e = class J2e {
      constructor(t) {
        (this.currentCapacity = 0),
          (this.enabled = !1),
          (this.lastMaxRate = 0),
          (this.measuredTxRate = 0),
          (this.requestCount = 0),
          (this.lastTimestamp = 0),
          (this.timeWindow = 0),
          (this.beta = t?.beta ?? 0.7),
          (this.minCapacity = t?.minCapacity ?? 1),
          (this.minFillRate = t?.minFillRate ?? 0.5),
          (this.scaleConstant = t?.scaleConstant ?? 0.4),
          (this.smooth = t?.smooth ?? 0.8);
        let r = this.getCurrentTimeInSeconds();
        (this.lastThrottleTime = r),
          (this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds())),
          (this.fillRate = this.minFillRate),
          (this.maxCapacity = this.minCapacity);
      }
      static {
        ic(this, "DefaultRateLimiter");
      }
      static {
        this.setTimeoutFn = setTimeout;
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(t) {
        if (this.enabled) {
          if ((this.refillTokenBucket(), t > this.currentCapacity)) {
            let r = ((t - this.currentCapacity) / this.fillRate) * 1e3;
            await new Promise((n) => J2e.setTimeoutFn(n, r));
          }
          this.currentCapacity = this.currentCapacity - t;
        }
      }
      refillTokenBucket() {
        let t = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = t;
          return;
        }
        let r = (t - this.lastTimestamp) * this.fillRate;
        (this.currentCapacity = Math.min(
          this.maxCapacity,
          this.currentCapacity + r,
        )),
          (this.lastTimestamp = t);
      }
      updateClientSendingRate(t) {
        let r;
        if ((this.updateMeasuredRate(), (0, jEr.isThrottlingError)(t))) {
          let i = this.enabled
            ? Math.min(this.measuredTxRate, this.fillRate)
            : this.measuredTxRate;
          (this.lastMaxRate = i),
            this.calculateTimeWindow(),
            (this.lastThrottleTime = this.getCurrentTimeInSeconds()),
            (r = this.cubicThrottle(i)),
            this.enableTokenBucket();
        } else
          this.calculateTimeWindow(),
            (r = this.cubicSuccess(this.getCurrentTimeInSeconds()));
        let n = Math.min(r, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(n);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(
          Math.pow(
            (this.lastMaxRate * (1 - this.beta)) / this.scaleConstant,
            1 / 3,
          ),
        );
      }
      cubicThrottle(t) {
        return this.getPrecise(t * this.beta);
      }
      cubicSuccess(t) {
        return this.getPrecise(
          this.scaleConstant *
            Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) +
            this.lastMaxRate,
        );
      }
      enableTokenBucket() {
        this.enabled = !0;
      }
      updateTokenBucketRate(t) {
        this.refillTokenBucket(),
          (this.fillRate = Math.max(t, this.minFillRate)),
          (this.maxCapacity = Math.max(t, this.minCapacity)),
          (this.currentCapacity = Math.min(
            this.currentCapacity,
            this.maxCapacity,
          ));
      }
      updateMeasuredRate() {
        let t = this.getCurrentTimeInSeconds(),
          r = Math.floor(t * 2) / 2;
        if ((this.requestCount++, r > this.lastTxRateBucket)) {
          let n = this.requestCount / (r - this.lastTxRateBucket);
          (this.measuredTxRate = this.getPrecise(
            n * this.smooth + this.measuredTxRate * (1 - this.smooth),
          )),
            (this.requestCount = 0),
            (this.lastTxRateBucket = r);
        }
      }
      getPrecise(t) {
        return parseFloat(t.toFixed(8));
      }
    },
    VO = 100,
    mJ = 20 * 1e3,
    Z2e = 500,
    pJ = 500,
    eKe = 5,
    tKe = 10,
    rKe = 1,
    FEr = "amz-sdk-invocation-id",
    BEr = "amz-sdk-request",
    UEr = ic(() => {
      let e = VO;
      return {
        computeNextBackoffDelay: ic(
          (n) => Math.floor(Math.min(mJ, Math.random() * 2 ** n * e)),
          "computeNextBackoffDelay",
        ),
        setDelayBase: ic((n) => {
          e = n;
        }, "setDelayBase"),
      };
    }, "getDefaultRetryBackoffStrategy"),
    W2e = ic(
      ({ retryDelay: e, retryCount: t, retryCost: r }) => ({
        getRetryCount: ic(() => t, "getRetryCount"),
        getRetryDelay: ic(() => Math.min(mJ, e), "getRetryDelay"),
        getRetryCost: ic(() => r, "getRetryCost"),
      }),
      "createDefaultRetryToken",
    ),
    hJ = class {
      constructor(e) {
        (this.maxAttempts = e),
          (this.mode = "standard"),
          (this.capacity = pJ),
          (this.retryBackoffStrategy = UEr()),
          (this.maxAttemptsProvider =
            typeof e == "function" ? e : async () => e);
      }
      static {
        ic(this, "StandardRetryStrategy");
      }
      async acquireInitialRetryToken(e) {
        return W2e({ retryDelay: VO, retryCount: 0 });
      }
      async refreshRetryTokenForRetry(e, t) {
        let r = await this.getMaxAttempts();
        if (this.shouldRetry(e, t, r)) {
          let n = t.errorType;
          this.retryBackoffStrategy.setDelayBase(n === "THROTTLING" ? Z2e : VO);
          let i = this.retryBackoffStrategy.computeNextBackoffDelay(
              e.getRetryCount(),
            ),
            o = t.retryAfterHint
              ? Math.max(t.retryAfterHint.getTime() - Date.now() || 0, i)
              : i,
            a = this.getCapacityCost(n);
          return (
            (this.capacity -= a),
            W2e({
              retryDelay: o,
              retryCount: e.getRetryCount() + 1,
              retryCost: a,
            })
          );
        }
        throw new Error("No retry token available");
      }
      recordSuccess(e) {
        this.capacity = Math.max(pJ, this.capacity + (e.getRetryCost() ?? rKe));
      }
      getCapacity() {
        return this.capacity;
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider();
        } catch {
          return (
            console.warn(
              `Max attempts provider could not resolve. Using default of ${fJ}`,
            ),
            fJ
          );
        }
      }
      shouldRetry(e, t, r) {
        return (
          e.getRetryCount() + 1 < r &&
          this.capacity >= this.getCapacityCost(t.errorType) &&
          this.isRetryableError(t.errorType)
        );
      }
      getCapacityCost(e) {
        return e === "TRANSIENT" ? tKe : eKe;
      }
      isRetryableError(e) {
        return e === "THROTTLING" || e === "TRANSIENT";
      }
    },
    HEr = class {
      constructor(e, t) {
        (this.maxAttemptsProvider = e), (this.mode = "adaptive");
        let { rateLimiter: r } = t ?? {};
        (this.rateLimiter = r ?? new X2e()),
          (this.standardRetryStrategy = new hJ(e));
      }
      static {
        ic(this, "AdaptiveRetryStrategy");
      }
      async acquireInitialRetryToken(e) {
        return (
          await this.rateLimiter.getSendToken(),
          this.standardRetryStrategy.acquireInitialRetryToken(e)
        );
      }
      async refreshRetryTokenForRetry(e, t) {
        return (
          this.rateLimiter.updateClientSendingRate(t),
          this.standardRetryStrategy.refreshRetryTokenForRetry(e, t)
        );
      }
      recordSuccess(e) {
        this.rateLimiter.updateClientSendingRate({}),
          this.standardRetryStrategy.recordSuccess(e);
      }
    },
    GEr = class extends hJ {
      static {
        ic(this, "ConfiguredRetryStrategy");
      }
      constructor(e, t = VO) {
        super(typeof e == "function" ? e : async () => e),
          typeof t == "number"
            ? (this.computeNextBackoffDelay = () => t)
            : (this.computeNextBackoffDelay = t);
      }
      async refreshRetryTokenForRetry(e, t) {
        let r = await super.refreshRetryTokenForRetry(e, t);
        return (
          (r.getRetryDelay = () =>
            this.computeNextBackoffDelay(r.getRetryCount())),
          r
        );
      }
    };
});
var iKe = g((j1) => {
  "use strict";
  c();
  Object.defineProperty(j1, "__esModule", { value: !0 });
  j1.isStreamingPayload = void 0;
  var VEr = G("stream"),
    $Er = (e) =>
      e?.body instanceof VEr.Readable ||
      (typeof ReadableStream < "u" && e?.body instanceof ReadableStream);
  j1.isStreamingPayload = $Er;
});
var Kl = g((G$n, _Ke) => {
  c();
  var F1 = Object.defineProperty,
    zEr = Object.getOwnPropertyDescriptor,
    KEr = Object.getOwnPropertyNames,
    WEr = Object.prototype.hasOwnProperty,
    xn = (e, t) => F1(e, "name", { value: t, configurable: !0 }),
    QEr = (e, t) => {
      for (var r in t) F1(e, r, { get: t[r], enumerable: !0 });
    },
    YEr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of KEr(t))
          !WEr.call(e, i) &&
            i !== r &&
            F1(e, i, {
              get: () => t[i],
              enumerable: !(n = zEr(t, i)) || n.enumerable,
            });
      return e;
    },
    XEr = (e) => YEr(F1({}, "__esModule", { value: !0 }), e),
    aKe = {};
  QEr(aKe, {
    AdaptiveRetryStrategy: () => ebr,
    CONFIG_MAX_ATTEMPTS: () => vJ,
    CONFIG_RETRY_MODE: () => pKe,
    ENV_MAX_ATTEMPTS: () => gJ,
    ENV_RETRY_MODE: () => fKe,
    NODE_MAX_ATTEMPT_CONFIG_OPTIONS: () => tbr,
    NODE_RETRY_MODE_CONFIG_OPTIONS: () => nbr,
    StandardRetryStrategy: () => dKe,
    defaultDelayDecider: () => cKe,
    defaultRetryDecider: () => uKe,
    getOmitRetryHeadersPlugin: () => ibr,
    getRetryAfterHint: () => yKe,
    getRetryPlugin: () => lbr,
    omitRetryHeadersMiddleware: () => mKe,
    omitRetryHeadersMiddlewareOptions: () => hKe,
    resolveRetryConfig: () => rbr,
    retryMiddleware: () => gKe,
    retryMiddlewareOptions: () => vKe,
  });
  _Ke.exports = XEr(aKe);
  var TE = ln(),
    sKe = (V2e(), ue(G2e)),
    en = OE(),
    JEr = xn((e, t) => {
      let r = e,
        n = t?.noRetryIncrement ?? en.NO_RETRY_INCREMENT,
        i = t?.retryCost ?? en.RETRY_COST,
        o = t?.timeoutRetryCost ?? en.TIMEOUT_RETRY_COST,
        a = e,
        s = xn((f) => (f.name === "TimeoutError" ? o : i), "getCapacityAmount"),
        u = xn((f) => s(f) <= a, "hasRetryTokens");
      return Object.freeze({
        hasRetryTokens: u,
        retrieveRetryTokens: xn((f) => {
          if (!u(f)) throw new Error("No retry token available");
          let m = s(f);
          return (a -= m), m;
        }, "retrieveRetryTokens"),
        releaseRetryTokens: xn((f) => {
          (a += f ?? n), (a = Math.min(a, r));
        }, "releaseRetryTokens"),
      });
    }, "getDefaultRetryQuota"),
    cKe = xn(
      (e, t) =>
        Math.floor(
          Math.min(en.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** t * e),
        ),
      "defaultDelayDecider",
    ),
    pp = dJ(),
    uKe = xn(
      (e) =>
        e
          ? (0, pp.isRetryableByTrait)(e) ||
            (0, pp.isClockSkewError)(e) ||
            (0, pp.isThrottlingError)(e) ||
            (0, pp.isTransientError)(e)
          : !1,
      "defaultRetryDecider",
    ),
    lKe = xn(
      (e) =>
        e instanceof Error
          ? e
          : e instanceof Object
            ? Object.assign(new Error(), e)
            : typeof e == "string"
              ? new Error(e)
              : new Error(`AWS SDK error wrapper for ${e}`),
      "asSdkError",
    ),
    dKe = class {
      constructor(e, t) {
        (this.maxAttemptsProvider = e),
          (this.mode = en.RETRY_MODES.STANDARD),
          (this.retryDecider = t?.retryDecider ?? uKe),
          (this.delayDecider = t?.delayDecider ?? cKe),
          (this.retryQuota = t?.retryQuota ?? JEr(en.INITIAL_RETRY_TOKENS));
      }
      static {
        xn(this, "StandardRetryStrategy");
      }
      shouldRetry(e, t, r) {
        return (
          t < r && this.retryDecider(e) && this.retryQuota.hasRetryTokens(e)
        );
      }
      async getMaxAttempts() {
        let e;
        try {
          e = await this.maxAttemptsProvider();
        } catch {
          e = en.DEFAULT_MAX_ATTEMPTS;
        }
        return e;
      }
      async retry(e, t, r) {
        let n,
          i = 0,
          o = 0,
          a = await this.getMaxAttempts(),
          { request: s } = t;
        for (
          TE.HttpRequest.isInstance(s) &&
          (s.headers[en.INVOCATION_ID_HEADER] = (0, sKe.v4)());
          ;

        )
          try {
            TE.HttpRequest.isInstance(s) &&
              (s.headers[en.REQUEST_HEADER] = `attempt=${i + 1}; max=${a}`),
              r?.beforeRequest && (await r.beforeRequest());
            let { response: u, output: l } = await e(t);
            return (
              r?.afterRequest && r.afterRequest(u),
              this.retryQuota.releaseRetryTokens(n),
              (l.$metadata.attempts = i + 1),
              (l.$metadata.totalRetryDelay = o),
              { response: u, output: l }
            );
          } catch (u) {
            let l = lKe(u);
            if ((i++, this.shouldRetry(l, i, a))) {
              n = this.retryQuota.retrieveRetryTokens(l);
              let d = this.delayDecider(
                  (0, pp.isThrottlingError)(l)
                    ? en.THROTTLING_RETRY_DELAY_BASE
                    : en.DEFAULT_RETRY_DELAY_BASE,
                  i,
                ),
                f = ZEr(l.$response),
                m = Math.max(f || 0, d);
              (o += m), await new Promise((h) => setTimeout(h, m));
              continue;
            }
            throw (
              (l.$metadata || (l.$metadata = {}),
              (l.$metadata.attempts = i),
              (l.$metadata.totalRetryDelay = o),
              l)
            );
          }
      }
    },
    ZEr = xn((e) => {
      if (!TE.HttpResponse.isInstance(e)) return;
      let t = Object.keys(e.headers).find(
        (o) => o.toLowerCase() === "retry-after",
      );
      if (!t) return;
      let r = e.headers[t],
        n = Number(r);
      return Number.isNaN(n) ? new Date(r).getTime() - Date.now() : n * 1e3;
    }, "getDelayFromRetryAfterHeader"),
    ebr = class extends dKe {
      static {
        xn(this, "AdaptiveRetryStrategy");
      }
      constructor(e, t) {
        let { rateLimiter: r, ...n } = t ?? {};
        super(e, n),
          (this.rateLimiter = r ?? new en.DefaultRateLimiter()),
          (this.mode = en.RETRY_MODES.ADAPTIVE);
      }
      async retry(e, t) {
        return super.retry(e, t, {
          beforeRequest: async () => this.rateLimiter.getSendToken(),
          afterRequest: (r) => {
            this.rateLimiter.updateClientSendingRate(r);
          },
        });
      }
    },
    oKe = tc(),
    gJ = "AWS_MAX_ATTEMPTS",
    vJ = "max_attempts",
    tbr = {
      environmentVariableSelector: (e) => {
        let t = e[gJ];
        if (!t) return;
        let r = parseInt(t);
        if (Number.isNaN(r))
          throw new Error(
            `Environment variable ${gJ} mast be a number, got "${t}"`,
          );
        return r;
      },
      configFileSelector: (e) => {
        let t = e[vJ];
        if (!t) return;
        let r = parseInt(t);
        if (Number.isNaN(r))
          throw new Error(
            `Shared config file entry ${vJ} mast be a number, got "${t}"`,
          );
        return r;
      },
      default: en.DEFAULT_MAX_ATTEMPTS,
    },
    rbr = xn((e) => {
      let { retryStrategy: t, retryMode: r, maxAttempts: n } = e,
        i = (0, oKe.normalizeProvider)(n ?? en.DEFAULT_MAX_ATTEMPTS);
      return Object.assign(e, {
        maxAttempts: i,
        retryStrategy: async () =>
          t ||
          ((await (0, oKe.normalizeProvider)(r)()) === en.RETRY_MODES.ADAPTIVE
            ? new en.AdaptiveRetryStrategy(i)
            : new en.StandardRetryStrategy(i)),
      });
    }, "resolveRetryConfig"),
    fKe = "AWS_RETRY_MODE",
    pKe = "retry_mode",
    nbr = {
      environmentVariableSelector: (e) => e[fKe],
      configFileSelector: (e) => e[pKe],
      default: en.DEFAULT_RETRY_MODE,
    },
    mKe = xn(
      () => (e) => async (t) => {
        let { request: r } = t;
        return (
          TE.HttpRequest.isInstance(r) &&
            (delete r.headers[en.INVOCATION_ID_HEADER],
            delete r.headers[en.REQUEST_HEADER]),
          e(t)
        );
      },
      "omitRetryHeadersMiddleware",
    ),
    hKe = {
      name: "omitRetryHeadersMiddleware",
      tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
      relation: "before",
      toMiddleware: "awsAuthMiddleware",
      override: !0,
    },
    ibr = xn(
      (e) => ({
        applyToStack: (t) => {
          t.addRelativeTo(mKe(), hKe);
        },
      }),
      "getOmitRetryHeadersPlugin",
    ),
    obr = At(),
    abr = iKe(),
    gKe = xn(
      (e) => (t, r) => async (n) => {
        let i = await e.retryStrategy(),
          o = await e.maxAttempts();
        if (sbr(i)) {
          i = i;
          let a = await i.acquireInitialRetryToken(r.partition_id),
            s = new Error(),
            u = 0,
            l = 0,
            { request: d } = n,
            f = TE.HttpRequest.isInstance(d);
          for (f && (d.headers[en.INVOCATION_ID_HEADER] = (0, sKe.v4)()); ; )
            try {
              f &&
                (d.headers[en.REQUEST_HEADER] = `attempt=${u + 1}; max=${o}`);
              let { response: m, output: h } = await t(n);
              return (
                i.recordSuccess(a),
                (h.$metadata.attempts = u + 1),
                (h.$metadata.totalRetryDelay = l),
                { response: m, output: h }
              );
            } catch (m) {
              let h = cbr(m);
              if (((s = lKe(m)), f && (0, abr.isStreamingPayload)(d)))
                throw (
                  ((r.logger instanceof obr.NoOpLogger
                    ? console
                    : r.logger
                  )?.warn(
                    "An error was encountered in a non-retryable streaming request.",
                  ),
                  s)
                );
              try {
                a = await i.refreshRetryTokenForRetry(a, h);
              } catch {
                throw (
                  (s.$metadata || (s.$metadata = {}),
                  (s.$metadata.attempts = u + 1),
                  (s.$metadata.totalRetryDelay = l),
                  s)
                );
              }
              u = a.getRetryCount();
              let y = a.getRetryDelay();
              (l += y), await new Promise((_) => setTimeout(_, y));
            }
        } else
          return (
            (i = i),
            i?.mode &&
              (r.userAgent = [
                ...(r.userAgent || []),
                ["cfg/retry-mode", i.mode],
              ]),
            i.retry(t, n)
          );
      },
      "retryMiddleware",
    ),
    sbr = xn(
      (e) =>
        typeof e.acquireInitialRetryToken < "u" &&
        typeof e.refreshRetryTokenForRetry < "u" &&
        typeof e.recordSuccess < "u",
      "isRetryStrategyV2",
    ),
    cbr = xn((e) => {
      let t = { error: e, errorType: ubr(e) },
        r = yKe(e.$response);
      return r && (t.retryAfterHint = r), t;
    }, "getRetryErrorInfo"),
    ubr = xn(
      (e) =>
        (0, pp.isThrottlingError)(e)
          ? "THROTTLING"
          : (0, pp.isTransientError)(e)
            ? "TRANSIENT"
            : (0, pp.isServerError)(e)
              ? "SERVER_ERROR"
              : "CLIENT_ERROR",
      "getRetryErrorType",
    ),
    vKe = {
      name: "retryMiddleware",
      tags: ["RETRY"],
      step: "finalizeRequest",
      priority: "high",
      override: !0,
    },
    lbr = xn(
      (e) => ({
        applyToStack: (t) => {
          t.add(gKe(e), vKe);
        },
      }),
      "getRetryPlugin",
    ),
    yKe = xn((e) => {
      if (!TE.HttpResponse.isInstance(e)) return;
      let t = Object.keys(e.headers).find(
        (o) => o.toLowerCase() === "retry-after",
      );
      if (!t) return;
      let r = e.headers[t],
        n = Number(r);
      return Number.isNaN(n) ? new Date(r) : new Date(n * 1e3);
    }, "getRetryAfterHint");
});
var yJ = g((K$n, PKe) => {
  c();
  var B1 = Object.defineProperty,
    dbr = Object.getOwnPropertyDescriptor,
    fbr = Object.getOwnPropertyNames,
    pbr = Object.prototype.hasOwnProperty,
    U1 = (e, t) => B1(e, "name", { value: t, configurable: !0 }),
    mbr = (e, t) => {
      for (var r in t) B1(e, r, { get: t[r], enumerable: !0 });
    },
    hbr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of fbr(t))
          !pbr.call(e, i) &&
            i !== r &&
            B1(e, i, {
              get: () => t[i],
              enumerable: !(n = dbr(t, i)) || n.enumerable,
            });
      return e;
    },
    gbr = (e) => hbr(B1({}, "__esModule", { value: !0 }), e),
    EKe = {};
  mbr(EKe, {
    AlgorithmId: () => wKe,
    EndpointURLScheme: () => CKe,
    FieldPosition: () => OKe,
    HttpApiKeyAuthLocation: () => SKe,
    HttpAuthLocation: () => bKe,
    IniSectionType: () => TKe,
    RequestHandlerProtocol: () => AKe,
    SMITHY_CONTEXT_KEY: () => bbr,
    getDefaultClientConfiguration: () => _br,
    resolveDefaultRuntimeConfig: () => Ebr,
  });
  PKe.exports = gbr(EKe);
  var bKe = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(bKe || {}),
    SKe = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(SKe || {}),
    CKe = ((e) => ((e.HTTP = "http"), (e.HTTPS = "https"), e))(CKe || {}),
    wKe = ((e) => (
      (e.MD5 = "md5"),
      (e.CRC32 = "crc32"),
      (e.CRC32C = "crc32c"),
      (e.SHA1 = "sha1"),
      (e.SHA256 = "sha256"),
      e
    ))(wKe || {}),
    vbr = U1((e) => {
      let t = [];
      return (
        e.sha256 !== void 0 &&
          t.push({
            algorithmId: () => "sha256",
            checksumConstructor: () => e.sha256,
          }),
        e.md5 != null &&
          t.push({
            algorithmId: () => "md5",
            checksumConstructor: () => e.md5,
          }),
        {
          addChecksumAlgorithm(r) {
            t.push(r);
          },
          checksumAlgorithms() {
            return t;
          },
        }
      );
    }, "getChecksumConfiguration"),
    ybr = U1((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    _br = U1((e) => vbr(e), "getDefaultClientConfiguration"),
    Ebr = U1((e) => ybr(e), "resolveDefaultRuntimeConfig"),
    OKe = ((e) => (
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER"), e
    ))(OKe || {}),
    bbr = "__smithy_context",
    TKe = ((e) => (
      (e.PROFILE = "profile"),
      (e.SSO_SESSION = "sso-session"),
      (e.SERVICES = "services"),
      e
    ))(TKe || {}),
    AKe = ((e) => (
      (e.HTTP_0_9 = "http/0.9"),
      (e.HTTP_1_0 = "http/1.0"),
      (e.TDS_8_0 = "tds/8.0"),
      e
    ))(AKe || {});
});
var DKe = g((Q$n, kKe) => {
  c();
  var H1 = Object.defineProperty,
    Sbr = Object.getOwnPropertyDescriptor,
    Cbr = Object.getOwnPropertyNames,
    wbr = Object.prototype.hasOwnProperty,
    mp = (e, t) => H1(e, "name", { value: t, configurable: !0 }),
    Obr = (e, t) => {
      for (var r in t) H1(e, r, { get: t[r], enumerable: !0 });
    },
    Tbr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Cbr(t))
          !wbr.call(e, i) &&
            i !== r &&
            H1(e, i, {
              get: () => t[i],
              enumerable: !(n = Sbr(t, i)) || n.enumerable,
            });
      return e;
    },
    Abr = (e) => Tbr(H1({}, "__esModule", { value: !0 }), e),
    RKe = {};
  Obr(RKe, {
    Field: () => Ibr,
    Fields: () => xbr,
    HttpRequest: () => Nbr,
    HttpResponse: () => kbr,
    IHttpRequest: () => IKe.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => Pbr,
    isValidHostname: () => NKe,
    resolveHttpHandlerRuntimeConfig: () => Rbr,
  });
  kKe.exports = Abr(RKe);
  var Pbr = mp(
      (e) => ({
        setHttpHandler(t) {
          e.httpHandler = t;
        },
        httpHandler() {
          return e.httpHandler;
        },
        updateHttpClientConfig(t, r) {
          e.httpHandler?.updateHttpClientConfig(t, r);
        },
        httpHandlerConfigs() {
          return e.httpHandler.httpHandlerConfigs();
        },
      }),
      "getHttpHandlerExtensionConfiguration",
    ),
    Rbr = mp(
      (e) => ({ httpHandler: e.httpHandler() }),
      "resolveHttpHandlerRuntimeConfig",
    ),
    IKe = yJ(),
    Ibr = class {
      static {
        mp(this, "Field");
      }
      constructor({
        name: e,
        kind: t = IKe.FieldPosition.HEADER,
        values: r = [],
      }) {
        (this.name = e), (this.kind = t), (this.values = r);
      }
      add(e) {
        this.values.push(e);
      }
      set(e) {
        this.values = e;
      }
      remove(e) {
        this.values = this.values.filter((t) => t !== e);
      }
      toString() {
        return this.values
          .map((e) => (e.includes(",") || e.includes(" ") ? `"${e}"` : e))
          .join(", ");
      }
      get() {
        return this.values;
      }
    },
    xbr = class {
      constructor({ fields: e = [], encoding: t = "utf-8" }) {
        (this.entries = {}),
          e.forEach(this.setField.bind(this)),
          (this.encoding = t);
      }
      static {
        mp(this, "Fields");
      }
      setField(e) {
        this.entries[e.name.toLowerCase()] = e;
      }
      getField(e) {
        return this.entries[e.toLowerCase()];
      }
      removeField(e) {
        delete this.entries[e.toLowerCase()];
      }
      getByType(e) {
        return Object.values(this.entries).filter((t) => t.kind === e);
      }
    },
    Nbr = class _J {
      static {
        mp(this, "HttpRequest");
      }
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new _J({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = xKe(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return _J.clone(this);
      }
    };
  function xKe(e) {
    return Object.keys(e).reduce((t, r) => {
      let n = e[r];
      return { ...t, [r]: Array.isArray(n) ? [...n] : n };
    }, {});
  }
  mp(xKe, "cloneQuery");
  var kbr = class {
    static {
      mp(this, "HttpResponse");
    }
    constructor(e) {
      (this.statusCode = e.statusCode),
        (this.reason = e.reason),
        (this.headers = e.headers || {}),
        (this.body = e.body);
    }
    static isInstance(e) {
      if (!e) return !1;
      let t = e;
      return typeof t.statusCode == "number" && typeof t.headers == "object";
    }
  };
  function NKe(e) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e);
  }
  mp(NKe, "isValidHostname");
});
var FKe = g((ezn, jKe) => {
  c();
  var G1 = Object.defineProperty,
    Dbr = Object.getOwnPropertyDescriptor,
    Lbr = Object.getOwnPropertyNames,
    Mbr = Object.prototype.hasOwnProperty,
    MKe = (e, t) => G1(e, "name", { value: t, configurable: !0 }),
    qbr = (e, t) => {
      for (var r in t) G1(e, r, { get: t[r], enumerable: !0 });
    },
    jbr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Lbr(t))
          !Mbr.call(e, i) &&
            i !== r &&
            G1(e, i, {
              get: () => t[i],
              enumerable: !(n = Dbr(t, i)) || n.enumerable,
            });
      return e;
    },
    Fbr = (e) => jbr(G1({}, "__esModule", { value: !0 }), e),
    qKe = {};
  qbr(qKe, { getSmithyContext: () => Bbr, normalizeProvider: () => Ubr });
  jKe.exports = Fbr(qKe);
  var LKe = yJ(),
    Bbr = MKe(
      (e) => e[LKe.SMITHY_CONTEXT_KEY] || (e[LKe.SMITHY_CONTEXT_KEY] = {}),
      "getSmithyContext",
    ),
    Ubr = MKe((e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    }, "normalizeProvider");
});
var GKe = g((rzn, HKe) => {
  c();
  var V1 = Object.defineProperty,
    Hbr = Object.getOwnPropertyDescriptor,
    Gbr = Object.getOwnPropertyNames,
    Vbr = Object.prototype.hasOwnProperty,
    EJ = (e, t) => V1(e, "name", { value: t, configurable: !0 }),
    $br = (e, t) => {
      for (var r in t) V1(e, r, { get: t[r], enumerable: !0 });
    },
    zbr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Gbr(t))
          !Vbr.call(e, i) &&
            i !== r &&
            V1(e, i, {
              get: () => t[i],
              enumerable: !(n = Hbr(t, i)) || n.enumerable,
            });
      return e;
    },
    Kbr = (e) => zbr(V1({}, "__esModule", { value: !0 }), e),
    BKe = {};
  $br(BKe, { escapeUri: () => UKe, escapeUriPath: () => Qbr });
  HKe.exports = Kbr(BKe);
  var UKe = EJ(
      (e) => encodeURIComponent(e).replace(/[!'()*]/g, Wbr),
      "escapeUri",
    ),
    Wbr = EJ(
      (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`,
      "hexEncode",
    ),
    Qbr = EJ((e) => e.split("/").map(UKe).join("/"), "escapeUriPath");
});
var y4e = g((izn, v4e) => {
  c();
  var X1 = Object.defineProperty,
    Ybr = Object.getOwnPropertyDescriptor,
    Xbr = Object.getOwnPropertyNames,
    Jbr = Object.prototype.hasOwnProperty,
    xi = (e, t) => X1(e, "name", { value: t, configurable: !0 }),
    Zbr = (e, t) => {
      for (var r in t) X1(e, r, { get: t[r], enumerable: !0 });
    },
    eSr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Xbr(t))
          !Jbr.call(e, i) &&
            i !== r &&
            X1(e, i, {
              get: () => t[i],
              enumerable: !(n = Ybr(t, i)) || n.enumerable,
            });
      return e;
    },
    tSr = (e) => eSr(X1({}, "__esModule", { value: !0 }), e),
    WKe = {};
  Zbr(WKe, {
    ALGORITHM_IDENTIFIER: () => $1,
    ALGORITHM_IDENTIFIER_V4A: () => oSr,
    ALGORITHM_QUERY_PARAM: () => QKe,
    ALWAYS_UNSIGNABLE_HEADERS: () => n4e,
    AMZ_DATE_HEADER: () => PJ,
    AMZ_DATE_QUERY_PARAM: () => wJ,
    AUTH_HEADER: () => AJ,
    CREDENTIAL_QUERY_PARAM: () => YKe,
    DATE_HEADER: () => ZKe,
    EVENT_ALGORITHM_IDENTIFIER: () => a4e,
    EXPIRES_QUERY_PARAM: () => JKe,
    GENERATED_HEADERS: () => e4e,
    HOST_HEADER: () => nSr,
    KEY_TYPE_IDENTIFIER: () => RJ,
    MAX_CACHE_SIZE: () => c4e,
    MAX_PRESIGNED_TTL: () => u4e,
    PROXY_HEADER_PATTERN: () => i4e,
    REGION_SET_PARAM: () => rSr,
    SEC_HEADER_PATTERN: () => o4e,
    SHA256_HEADER: () => Y1,
    SIGNATURE_HEADER: () => t4e,
    SIGNATURE_QUERY_PARAM: () => OJ,
    SIGNED_HEADERS_QUERY_PARAM: () => XKe,
    SignatureV4: () => gSr,
    SignatureV4Base: () => g4e,
    TOKEN_HEADER: () => r4e,
    TOKEN_QUERY_PARAM: () => TJ,
    UNSIGNABLE_PATTERNS: () => iSr,
    UNSIGNED_PAYLOAD: () => s4e,
    clearCredentialCache: () => sSr,
    createScope: () => K1,
    getCanonicalHeaders: () => bJ,
    getCanonicalQuery: () => h4e,
    getPayloadHash: () => W1,
    getSigningKey: () => l4e,
    hasHeader: () => f4e,
    moveHeadersToQuery: () => m4e,
    prepareRequest: () => CJ,
    signatureV4aContainer: () => vSr,
  });
  v4e.exports = tSr(WKe);
  var VKe = Fe(),
    QKe = "X-Amz-Algorithm",
    YKe = "X-Amz-Credential",
    wJ = "X-Amz-Date",
    XKe = "X-Amz-SignedHeaders",
    JKe = "X-Amz-Expires",
    OJ = "X-Amz-Signature",
    TJ = "X-Amz-Security-Token",
    rSr = "X-Amz-Region-Set",
    AJ = "authorization",
    PJ = wJ.toLowerCase(),
    ZKe = "date",
    e4e = [AJ, PJ, ZKe],
    t4e = OJ.toLowerCase(),
    Y1 = "x-amz-content-sha256",
    r4e = TJ.toLowerCase(),
    nSr = "host",
    n4e = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0,
    },
    i4e = /^proxy-/,
    o4e = /^sec-/,
    iSr = [/^proxy-/i, /^sec-/i],
    $1 = "AWS4-HMAC-SHA256",
    oSr = "AWS4-ECDSA-P256-SHA256",
    a4e = "AWS4-HMAC-SHA256-PAYLOAD",
    s4e = "UNSIGNED-PAYLOAD",
    c4e = 50,
    RJ = "aws4_request",
    u4e = 60 * 60 * 24 * 7,
    hp = zs(),
    aSr = Fe(),
    AE = {},
    z1 = [],
    K1 = xi((e, t, r) => `${e}/${t}/${r}/${RJ}`, "createScope"),
    l4e = xi(async (e, t, r, n, i) => {
      let o = await $Ke(e, t.secretAccessKey, t.accessKeyId),
        a = `${r}:${n}:${i}:${(0, hp.toHex)(o)}:${t.sessionToken}`;
      if (a in AE) return AE[a];
      for (z1.push(a); z1.length > c4e; ) delete AE[z1.shift()];
      let s = `AWS4${t.secretAccessKey}`;
      for (let u of [r, n, i, RJ]) s = await $Ke(e, s, u);
      return (AE[a] = s);
    }, "getSigningKey"),
    sSr = xi(() => {
      (z1.length = 0),
        Object.keys(AE).forEach((e) => {
          delete AE[e];
        });
    }, "clearCredentialCache"),
    $Ke = xi((e, t, r) => {
      let n = new e(t);
      return n.update((0, aSr.toUint8Array)(r)), n.digest();
    }, "hmac"),
    bJ = xi(({ headers: e }, t, r) => {
      let n = {};
      for (let i of Object.keys(e).sort()) {
        if (e[i] == null) continue;
        let o = i.toLowerCase();
        ((o in n4e || t?.has(o) || i4e.test(o) || o4e.test(o)) &&
          (!r || (r && !r.has(o)))) ||
          (n[o] = e[i].trim().replace(/\s+/g, " "));
      }
      return n;
    }, "getCanonicalHeaders"),
    cSr = hf(),
    uSr = Fe(),
    W1 = xi(async ({ headers: e, body: t }, r) => {
      for (let n of Object.keys(e)) if (n.toLowerCase() === Y1) return e[n];
      if (t == null)
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      if (
        typeof t == "string" ||
        ArrayBuffer.isView(t) ||
        (0, cSr.isArrayBuffer)(t)
      ) {
        let n = new r();
        return (
          n.update((0, uSr.toUint8Array)(t)), (0, hp.toHex)(await n.digest())
        );
      }
      return s4e;
    }, "getPayloadHash"),
    zKe = Fe(),
    lSr = class {
      static {
        xi(this, "HeaderFormatter");
      }
      format(e) {
        let t = [];
        for (let i of Object.keys(e)) {
          let o = (0, zKe.fromUtf8)(i);
          t.push(
            Uint8Array.from([o.byteLength]),
            o,
            this.formatHeaderValue(e[i]),
          );
        }
        let r = new Uint8Array(t.reduce((i, o) => i + o.byteLength, 0)),
          n = 0;
        for (let i of t) r.set(i, n), (n += i.byteLength);
        return r;
      }
      formatHeaderValue(e) {
        switch (e.type) {
          case "boolean":
            return Uint8Array.from([e.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, e.value]);
          case "short":
            let t = new DataView(new ArrayBuffer(3));
            return (
              t.setUint8(0, 3),
              t.setInt16(1, e.value, !1),
              new Uint8Array(t.buffer)
            );
          case "integer":
            let r = new DataView(new ArrayBuffer(5));
            return (
              r.setUint8(0, 4),
              r.setInt32(1, e.value, !1),
              new Uint8Array(r.buffer)
            );
          case "long":
            let n = new Uint8Array(9);
            return (n[0] = 5), n.set(e.value.bytes, 1), n;
          case "binary":
            let i = new DataView(new ArrayBuffer(3 + e.value.byteLength));
            i.setUint8(0, 6), i.setUint16(1, e.value.byteLength, !1);
            let o = new Uint8Array(i.buffer);
            return o.set(e.value, 3), o;
          case "string":
            let a = (0, zKe.fromUtf8)(e.value),
              s = new DataView(new ArrayBuffer(3 + a.byteLength));
            s.setUint8(0, 7), s.setUint16(1, a.byteLength, !1);
            let u = new Uint8Array(s.buffer);
            return u.set(a, 3), u;
          case "timestamp":
            let l = new Uint8Array(9);
            return (
              (l[0] = 8), l.set(fSr.fromNumber(e.value.valueOf()).bytes, 1), l
            );
          case "uuid":
            if (!dSr.test(e.value))
              throw new Error(`Invalid UUID received: ${e.value}`);
            let d = new Uint8Array(17);
            return (
              (d[0] = 9),
              d.set((0, hp.fromHex)(e.value.replace(/\-/g, "")), 1),
              d
            );
        }
      }
    },
    dSr = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    fSr = class d4e {
      constructor(t) {
        if (((this.bytes = t), t.byteLength !== 8))
          throw new Error("Int64 buffers must be exactly 8 bytes");
      }
      static {
        xi(this, "Int64");
      }
      static fromNumber(t) {
        if (t > 9223372036854776e3 || t < -9223372036854776e3)
          throw new Error(
            `${t} is too large (or, if negative, too small) to represent as an Int64`,
          );
        let r = new Uint8Array(8);
        for (
          let n = 7, i = Math.abs(Math.round(t));
          n > -1 && i > 0;
          n--, i /= 256
        )
          r[n] = i;
        return t < 0 && SJ(r), new d4e(r);
      }
      valueOf() {
        let t = this.bytes.slice(0),
          r = t[0] & 128;
        return r && SJ(t), parseInt((0, hp.toHex)(t), 16) * (r ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  function SJ(e) {
    for (let t = 0; t < 8; t++) e[t] ^= 255;
    for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
  }
  xi(SJ, "negate");
  var f4e = xi((e, t) => {
      e = e.toLowerCase();
      for (let r of Object.keys(t)) if (e === r.toLowerCase()) return !0;
      return !1;
    }, "hasHeader"),
    p4e = DKe(),
    m4e = xi((e, t = {}) => {
      let { headers: r, query: n = {} } = p4e.HttpRequest.clone(e);
      for (let i of Object.keys(r)) {
        let o = i.toLowerCase();
        ((o.slice(0, 6) === "x-amz-" && !t.unhoistableHeaders?.has(o)) ||
          t.hoistableHeaders?.has(o)) &&
          ((n[i] = r[i]), delete r[i]);
      }
      return { ...e, headers: r, query: n };
    }, "moveHeadersToQuery"),
    CJ = xi((e) => {
      e = p4e.HttpRequest.clone(e);
      for (let t of Object.keys(e.headers))
        e4e.indexOf(t.toLowerCase()) > -1 && delete e.headers[t];
      return e;
    }, "prepareRequest"),
    KKe = FKe(),
    pSr = Fe(),
    Q1 = GKe(),
    h4e = xi(({ query: e = {} }) => {
      let t = [],
        r = {};
      for (let n of Object.keys(e)) {
        if (n.toLowerCase() === t4e) continue;
        let i = (0, Q1.escapeUri)(n);
        t.push(i);
        let o = e[n];
        typeof o == "string"
          ? (r[i] = `${i}=${(0, Q1.escapeUri)(o)}`)
          : Array.isArray(o) &&
            (r[i] = o
              .slice(0)
              .reduce((a, s) => a.concat([`${i}=${(0, Q1.escapeUri)(s)}`]), [])
              .sort()
              .join("&"));
      }
      return t
        .sort()
        .map((n) => r[n])
        .filter((n) => n)
        .join("&");
    }, "getCanonicalQuery"),
    mSr = xi(
      (e) =>
        hSr(e)
          .toISOString()
          .replace(/\.\d{3}Z$/, "Z"),
      "iso8601",
    ),
    hSr = xi(
      (e) =>
        typeof e == "number"
          ? new Date(e * 1e3)
          : typeof e == "string"
            ? Number(e)
              ? new Date(Number(e) * 1e3)
              : new Date(e)
            : e,
      "toDate",
    ),
    g4e = class {
      static {
        xi(this, "SignatureV4Base");
      }
      constructor({
        applyChecksum: e,
        credentials: t,
        region: r,
        service: n,
        sha256: i,
        uriEscapePath: o = !0,
      }) {
        (this.service = n),
          (this.sha256 = i),
          (this.uriEscapePath = o),
          (this.applyChecksum = typeof e == "boolean" ? e : !0),
          (this.regionProvider = (0, KKe.normalizeProvider)(r)),
          (this.credentialProvider = (0, KKe.normalizeProvider)(t));
      }
      createCanonicalRequest(e, t, r) {
        let n = Object.keys(t).sort();
        return `${e.method}
${this.getCanonicalPath(e)}
${h4e(e)}
${n.map((i) => `${i}:${t[i]}`).join(`
`)}

${n.join(";")}
${r}`;
      }
      async createStringToSign(e, t, r, n) {
        let i = new this.sha256();
        i.update((0, pSr.toUint8Array)(r));
        let o = await i.digest();
        return `${n}
${e}
${t}
${(0, hp.toHex)(o)}`;
      }
      getCanonicalPath({ path: e }) {
        if (this.uriEscapePath) {
          let t = [];
          for (let i of e.split("/"))
            i?.length !== 0 && i !== "." && (i === ".." ? t.pop() : t.push(i));
          let r = `${e?.startsWith("/") ? "/" : ""}${t.join("/")}${t.length > 0 && e?.endsWith("/") ? "/" : ""}`;
          return (0, Q1.escapeUri)(r).replace(/%2F/g, "/");
        }
        return e;
      }
      validateResolvedCredentials(e) {
        if (
          typeof e != "object" ||
          typeof e.accessKeyId != "string" ||
          typeof e.secretAccessKey != "string"
        )
          throw new Error("Resolved credential object is not valid");
      }
      formatDate(e) {
        let t = mSr(e).replace(/[\-:]/g, "");
        return { longDate: t, shortDate: t.slice(0, 8) };
      }
      getCanonicalHeaderList(e) {
        return Object.keys(e).sort().join(";");
      }
    },
    gSr = class extends g4e {
      constructor({
        applyChecksum: e,
        credentials: t,
        region: r,
        service: n,
        sha256: i,
        uriEscapePath: o = !0,
      }) {
        super({
          applyChecksum: e,
          credentials: t,
          region: r,
          service: n,
          sha256: i,
          uriEscapePath: o,
        }),
          (this.headerFormatter = new lSr());
      }
      static {
        xi(this, "SignatureV4");
      }
      async presign(e, t = {}) {
        let {
            signingDate: r = new Date(),
            expiresIn: n = 3600,
            unsignableHeaders: i,
            unhoistableHeaders: o,
            signableHeaders: a,
            hoistableHeaders: s,
            signingRegion: u,
            signingService: l,
          } = t,
          d = await this.credentialProvider();
        this.validateResolvedCredentials(d);
        let f = u ?? (await this.regionProvider()),
          { longDate: m, shortDate: h } = this.formatDate(r);
        if (n > u4e)
          return Promise.reject(
            "Signature version 4 presigned URLs must have an expiration date less than one week in the future",
          );
        let y = K1(h, f, l ?? this.service),
          _ = m4e(CJ(e), { unhoistableHeaders: o, hoistableHeaders: s });
        d.sessionToken && (_.query[TJ] = d.sessionToken),
          (_.query[QKe] = $1),
          (_.query[YKe] = `${d.accessKeyId}/${y}`),
          (_.query[wJ] = m),
          (_.query[JKe] = n.toString(10));
        let E = bJ(_, i, a);
        return (
          (_.query[XKe] = this.getCanonicalHeaderList(E)),
          (_.query[OJ] = await this.getSignature(
            m,
            y,
            this.getSigningKey(d, f, h, l),
            this.createCanonicalRequest(_, E, await W1(e, this.sha256)),
          )),
          _
        );
      }
      async sign(e, t) {
        return typeof e == "string"
          ? this.signString(e, t)
          : e.headers && e.payload
            ? this.signEvent(e, t)
            : e.message
              ? this.signMessage(e, t)
              : this.signRequest(e, t);
      }
      async signEvent(
        { headers: e, payload: t },
        {
          signingDate: r = new Date(),
          priorSignature: n,
          signingRegion: i,
          signingService: o,
        },
      ) {
        let a = i ?? (await this.regionProvider()),
          { shortDate: s, longDate: u } = this.formatDate(r),
          l = K1(s, a, o ?? this.service),
          d = await W1({ headers: {}, body: t }, this.sha256),
          f = new this.sha256();
        f.update(e);
        let m = (0, hp.toHex)(await f.digest()),
          h = [a4e, u, l, n, m, d].join(`
`);
        return this.signString(h, {
          signingDate: r,
          signingRegion: a,
          signingService: o,
        });
      }
      async signMessage(
        e,
        { signingDate: t = new Date(), signingRegion: r, signingService: n },
      ) {
        return this.signEvent(
          {
            headers: this.headerFormatter.format(e.message.headers),
            payload: e.message.body,
          },
          {
            signingDate: t,
            signingRegion: r,
            signingService: n,
            priorSignature: e.priorSignature,
          },
        ).then((o) => ({ message: e.message, signature: o }));
      }
      async signString(
        e,
        {
          signingDate: t = new Date(),
          signingRegion: r,
          signingService: n,
        } = {},
      ) {
        let i = await this.credentialProvider();
        this.validateResolvedCredentials(i);
        let o = r ?? (await this.regionProvider()),
          { shortDate: a } = this.formatDate(t),
          s = new this.sha256(await this.getSigningKey(i, o, a, n));
        return (
          s.update((0, VKe.toUint8Array)(e)), (0, hp.toHex)(await s.digest())
        );
      }
      async signRequest(
        e,
        {
          signingDate: t = new Date(),
          signableHeaders: r,
          unsignableHeaders: n,
          signingRegion: i,
          signingService: o,
        } = {},
      ) {
        let a = await this.credentialProvider();
        this.validateResolvedCredentials(a);
        let s = i ?? (await this.regionProvider()),
          u = CJ(e),
          { longDate: l, shortDate: d } = this.formatDate(t),
          f = K1(d, s, o ?? this.service);
        (u.headers[PJ] = l),
          a.sessionToken && (u.headers[r4e] = a.sessionToken);
        let m = await W1(u, this.sha256);
        !f4e(Y1, u.headers) && this.applyChecksum && (u.headers[Y1] = m);
        let h = bJ(u, n, r),
          y = await this.getSignature(
            l,
            f,
            this.getSigningKey(a, s, d, o),
            this.createCanonicalRequest(u, h, m),
          );
        return (
          (u.headers[AJ] =
            `${$1} Credential=${a.accessKeyId}/${f}, SignedHeaders=${this.getCanonicalHeaderList(h)}, Signature=${y}`),
          u
        );
      }
      async getSignature(e, t, r, n) {
        let i = await this.createStringToSign(e, t, n, $1),
          o = new this.sha256(await r);
        return (
          o.update((0, VKe.toUint8Array)(i)), (0, hp.toHex)(await o.digest())
        );
      }
      getSigningKey(e, t, r, n) {
        return l4e(this.sha256, e, r, t, n || this.service);
      }
    },
    vSr = { SignatureV4a: null };
});
var IJ = g((uzn, E4e) => {
  "use strict";
  c();
  var Z1 = Object.defineProperty,
    ySr = Object.getOwnPropertyDescriptor,
    _Sr = Object.getOwnPropertyNames,
    ESr = Object.prototype.hasOwnProperty,
    bSr = (e, t) => Z1(e, "name", { value: t, configurable: !0 }),
    SSr = (e, t) => {
      for (var r in t) Z1(e, r, { get: t[r], enumerable: !0 });
    },
    CSr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of _Sr(t))
          !ESr.call(e, i) &&
            i !== r &&
            Z1(e, i, {
              get: () => t[i],
              enumerable: !(n = ySr(t, i)) || n.enumerable,
            });
      return e;
    },
    wSr = (e) => CSr(Z1({}, "__esModule", { value: !0 }), e),
    _4e = {};
  SSr(_4e, {
    SignatureV4MultiRegion: () => ASr,
    signatureV4CrtContainer: () => J1,
  });
  E4e.exports = wSr(_4e);
  var OSr = Te(),
    TSr = y4e(),
    J1 = { CrtSignerV4: null },
    ASr = class {
      static {
        bSr(this, "SignatureV4MultiRegion");
      }
      sigv4aSigner;
      sigv4Signer;
      signerOptions;
      constructor(e) {
        (this.sigv4Signer = new OSr.SignatureV4S3Express(e)),
          (this.signerOptions = e);
      }
      async sign(e, t = {}) {
        return t.signingRegion === "*"
          ? this.getSigv4aSigner().sign(e, t)
          : this.sigv4Signer.sign(e, t);
      }
      async signWithCredentials(e, t, r = {}) {
        if (r.signingRegion === "*") {
          let n = this.getSigv4aSigner(),
            i = J1.CrtSignerV4;
          if (i && n instanceof i) return n.signWithCredentials(e, t, r);
          throw new Error(
            `signWithCredentials with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`,
          );
        }
        return this.sigv4Signer.signWithCredentials(e, t, r);
      }
      async presign(e, t = {}) {
        if (t.signingRegion === "*") {
          let r = this.getSigv4aSigner(),
            n = J1.CrtSignerV4;
          if (n && r instanceof n) return r.presign(e, t);
          throw new Error(
            `presign with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`,
          );
        }
        return this.sigv4Signer.presign(e, t);
      }
      async presignWithCredentials(e, t, r = {}) {
        if (r.signingRegion === "*")
          throw new Error(
            "Method presignWithCredentials is not supported for [signingRegion=*].",
          );
        return this.sigv4Signer.presignWithCredentials(e, t, r);
      }
      getSigv4aSigner() {
        if (!this.sigv4aSigner) {
          let e = J1.CrtSignerV4,
            t = TSr.signatureV4aContainer.SignatureV4a;
          if (this.signerOptions.runtime === "node") {
            if (!e && !t)
              throw new Error(
                "Neither CRT nor JS SigV4a implementation is available. Please load either @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt",
              );
            if (e && typeof e == "function")
              this.sigv4aSigner = new e({
                ...this.signerOptions,
                signingAlgorithm: 1,
              });
            else if (t && typeof t == "function")
              this.sigv4aSigner = new t({ ...this.signerOptions });
            else
              throw new Error(
                "Available SigV4a implementation is not a valid constructor. Please ensure you've properly imported @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a.For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt",
              );
          } else {
            if (!t || typeof t != "function")
              throw new Error(
                "JS SigV4a implementation is not available or not a valid constructor. Please check whether you have installed the @aws-sdk/signature-v4a package explicitly. The CRT implementation is not available for browsers. You must also register the package by calling [require('@aws-sdk/signature-v4a');] or an ESM equivalent such as [import '@aws-sdk/signature-v4a';]. For more information please go to https://github.com/aws/aws-sdk-js-v3#using-javascript-non-crt-implementation-of-sigv4a",
              );
            this.sigv4aSigner = new t({ ...this.signerOptions });
          }
        }
        return this.sigv4aSigner;
      }
    };
});
var w4e = g((eB) => {
  "use strict";
  c();
  Object.defineProperty(eB, "__esModule", { value: !0 });
  eB.getEndpointUrlConfig = void 0;
  var b4e = No(),
    S4e = "AWS_ENDPOINT_URL",
    C4e = "endpoint_url",
    PSr = (e) => ({
      environmentVariableSelector: (t) => {
        let r = e.split(" ").map((o) => o.toUpperCase()),
          n = t[[S4e, ...r].join("_")];
        if (n) return n;
        let i = t[S4e];
        if (i) return i;
      },
      configFileSelector: (t, r) => {
        if (r && t.services) {
          let i = r[["services", t.services].join(b4e.CONFIG_PREFIX_SEPARATOR)];
          if (i) {
            let o = e.split(" ").map((s) => s.toLowerCase()),
              a = i[[o.join("_"), C4e].join(b4e.CONFIG_PREFIX_SEPARATOR)];
            if (a) return a;
          }
        }
        let n = t[C4e];
        if (n) return n;
      },
      default: void 0,
    });
  eB.getEndpointUrlConfig = PSr;
});
var xJ = g((tB) => {
  "use strict";
  c();
  Object.defineProperty(tB, "__esModule", { value: !0 });
  tB.getEndpointFromConfig = void 0;
  var RSr = ro(),
    ISr = w4e(),
    xSr = async (e) =>
      (0, RSr.loadConfig)((0, ISr.getEndpointUrlConfig)(e ?? ""))();
  tB.getEndpointFromConfig = xSr;
});
var P4e = g((gzn, A4e) => {
  c();
  var rB = Object.defineProperty,
    NSr = Object.getOwnPropertyDescriptor,
    kSr = Object.getOwnPropertyNames,
    DSr = Object.prototype.hasOwnProperty,
    LSr = (e, t) => rB(e, "name", { value: t, configurable: !0 }),
    MSr = (e, t) => {
      for (var r in t) rB(e, r, { get: t[r], enumerable: !0 });
    },
    qSr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of kSr(t))
          !DSr.call(e, i) &&
            i !== r &&
            rB(e, i, {
              get: () => t[i],
              enumerable: !(n = NSr(t, i)) || n.enumerable,
            });
      return e;
    },
    jSr = (e) => qSr(rB({}, "__esModule", { value: !0 }), e),
    O4e = {};
  MSr(O4e, { parseQueryString: () => T4e });
  A4e.exports = jSr(O4e);
  function T4e(e) {
    let t = {};
    if (((e = e.replace(/^\?/, "")), e))
      for (let r of e.split("&")) {
        let [n, i = null] = r.split("=");
        (n = decodeURIComponent(n)),
          i && (i = decodeURIComponent(i)),
          n in t
            ? Array.isArray(t[n])
              ? t[n].push(i)
              : (t[n] = [t[n], i])
            : (t[n] = i);
      }
    return t;
  }
  LSr(T4e, "parseQueryString");
});
var Hh = g((yzn, x4e) => {
  c();
  var nB = Object.defineProperty,
    FSr = Object.getOwnPropertyDescriptor,
    BSr = Object.getOwnPropertyNames,
    USr = Object.prototype.hasOwnProperty,
    HSr = (e, t) => nB(e, "name", { value: t, configurable: !0 }),
    GSr = (e, t) => {
      for (var r in t) nB(e, r, { get: t[r], enumerable: !0 });
    },
    VSr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of BSr(t))
          !USr.call(e, i) &&
            i !== r &&
            nB(e, i, {
              get: () => t[i],
              enumerable: !(n = FSr(t, i)) || n.enumerable,
            });
      return e;
    },
    $Sr = (e) => VSr(nB({}, "__esModule", { value: !0 }), e),
    R4e = {};
  GSr(R4e, { parseUrl: () => I4e });
  x4e.exports = $Sr(R4e);
  var zSr = P4e(),
    I4e = HSr((e) => {
      if (typeof e == "string") return I4e(new URL(e));
      let { hostname: t, pathname: r, port: n, protocol: i, search: o } = e,
        a;
      return (
        o && (a = (0, zSr.parseQueryString)(o)),
        {
          hostname: t,
          port: n ? parseInt(n) : void 0,
          protocol: i,
          path: r,
          query: a,
        }
      );
    }, "parseUrl");
});
var Wl = g((Ezn, j4e) => {
  c();
  var oB = Object.defineProperty,
    KSr = Object.getOwnPropertyDescriptor,
    WSr = Object.getOwnPropertyNames,
    QSr = Object.prototype.hasOwnProperty,
    oc = (e, t) => oB(e, "name", { value: t, configurable: !0 }),
    YSr = (e, t) => {
      for (var r in t) oB(e, r, { get: t[r], enumerable: !0 });
    },
    XSr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of WSr(t))
          !QSr.call(e, i) &&
            i !== r &&
            oB(e, i, {
              get: () => t[i],
              enumerable: !(n = KSr(t, i)) || n.enumerable,
            });
      return e;
    },
    JSr = (e) => XSr(oB({}, "__esModule", { value: !0 }), e),
    k4e = {};
  YSr(k4e, {
    endpointMiddleware: () => M4e,
    endpointMiddlewareOptions: () => q4e,
    getEndpointFromInstructions: () => D4e,
    getEndpointPlugin: () => u0r,
    resolveEndpointConfig: () => d0r,
    resolveParams: () => L4e,
    toEndpointV1: () => NJ,
  });
  j4e.exports = JSr(k4e);
  var ZSr = oc(async (e) => {
      let t = e?.Bucket || "";
      if (
        (typeof e.Bucket == "string" &&
          (e.Bucket = t
            .replace(/#/g, encodeURIComponent("#"))
            .replace(/\?/g, encodeURIComponent("?"))),
        i0r(t))
      ) {
        if (e.ForcePathStyle === !0)
          throw new Error(
            "Path-style addressing cannot be used with ARN buckets",
          );
      } else
        (!n0r(t) ||
          (t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:")) ||
          t.toLowerCase() !== t ||
          t.length < 3) &&
          (e.ForcePathStyle = !0);
      return (
        e.DisableMultiRegionAccessPoints &&
          ((e.disableMultiRegionAccessPoints = !0), (e.DisableMRAP = !0)),
        e
      );
    }, "resolveParamsForS3"),
    e0r = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/,
    t0r = /(\d+\.){3}\d+/,
    r0r = /\.\./,
    n0r = oc(
      (e) => e0r.test(e) && !t0r.test(e) && !r0r.test(e),
      "isDnsCompatibleBucketName",
    ),
    i0r = oc((e) => {
      let [t, r, n, , , i] = e.split(":"),
        o = t === "arn" && e.split(":").length >= 6,
        a = !!(o && r && n && i);
      if (o && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`);
      return a;
    }, "isArnBucketName"),
    o0r = oc((e, t, r) => {
      let n = oc(async () => {
        let i = r[e] ?? r[t];
        return typeof i == "function" ? i() : i;
      }, "configProvider");
      return e === "credentialScope" || t === "CredentialScope"
        ? async () => {
            let i =
              typeof r.credentials == "function"
                ? await r.credentials()
                : r.credentials;
            return i?.credentialScope ?? i?.CredentialScope;
          }
        : e === "accountId" || t === "AccountId"
          ? async () => {
              let i =
                typeof r.credentials == "function"
                  ? await r.credentials()
                  : r.credentials;
              return i?.accountId ?? i?.AccountId;
            }
          : e === "endpoint" || t === "endpoint"
            ? async () => {
                let i = await n();
                if (i && typeof i == "object") {
                  if ("url" in i) return i.url.href;
                  if ("hostname" in i) {
                    let { protocol: o, hostname: a, port: s, path: u } = i;
                    return `${o}//${a}${s ? ":" + s : ""}${u}`;
                  }
                }
                return i;
              }
            : n;
    }, "createConfigValueProvider"),
    a0r = xJ(),
    N4e = Hh(),
    NJ = oc(
      (e) =>
        typeof e == "object"
          ? "url" in e
            ? (0, N4e.parseUrl)(e.url)
            : e
          : (0, N4e.parseUrl)(e),
      "toEndpointV1",
    ),
    D4e = oc(async (e, t, r, n) => {
      if (!r.endpoint) {
        let a;
        r.serviceConfiguredEndpoint
          ? (a = await r.serviceConfiguredEndpoint())
          : (a = await (0, a0r.getEndpointFromConfig)(r.serviceId)),
          a && (r.endpoint = () => Promise.resolve(NJ(a)));
      }
      let i = await L4e(e, t, r);
      if (typeof r.endpointProvider != "function")
        throw new Error("config.endpointProvider is not set.");
      return r.endpointProvider(i, n);
    }, "getEndpointFromInstructions"),
    L4e = oc(async (e, t, r) => {
      let n = {},
        i = t?.getEndpointParameterInstructions?.() || {};
      for (let [o, a] of Object.entries(i))
        switch (a.type) {
          case "staticContextParams":
            n[o] = a.value;
            break;
          case "contextParams":
            n[o] = e[a.name];
            break;
          case "clientContextParams":
          case "builtInParams":
            n[o] = await o0r(a.name, o, r)();
            break;
          case "operationContextParams":
            n[o] = a.get(e);
            break;
          default:
            throw new Error(
              "Unrecognized endpoint parameter instruction: " +
                JSON.stringify(a),
            );
        }
      return (
        Object.keys(i).length === 0 && Object.assign(n, r),
        String(r.serviceId).toLowerCase() === "s3" && (await ZSr(n)),
        n
      );
    }, "resolveParams"),
    s0r = (Gn(), ue(rc)),
    iB = tc(),
    M4e = oc(
      ({ config: e, instructions: t }) =>
        (r, n) =>
        async (i) => {
          e.endpoint && (0, s0r.setFeature)(n, "ENDPOINT_OVERRIDE", "N");
          let o = await D4e(
            i.input,
            {
              getEndpointParameterInstructions() {
                return t;
              },
            },
            { ...e },
            n,
          );
          (n.endpointV2 = o), (n.authSchemes = o.properties?.authSchemes);
          let a = n.authSchemes?.[0];
          if (a) {
            (n.signing_region = a.signingRegion),
              (n.signing_service = a.signingName);
            let u = (0, iB.getSmithyContext)(n)?.selectedHttpAuthScheme
              ?.httpAuthOption;
            u &&
              (u.signingProperties = Object.assign(
                u.signingProperties || {},
                {
                  signing_region: a.signingRegion,
                  signingRegion: a.signingRegion,
                  signing_service: a.signingName,
                  signingName: a.signingName,
                  signingRegionSet: a.signingRegionSet,
                },
                a.properties,
              ));
          }
          return r({ ...i });
        },
      "endpointMiddleware",
    ),
    c0r = ip(),
    q4e = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: !0,
      relation: "before",
      toMiddleware: c0r.serializerMiddlewareOption.name,
    },
    u0r = oc(
      (e, t) => ({
        applyToStack: (r) => {
          r.addRelativeTo(M4e({ config: e, instructions: t }), q4e);
        },
      }),
      "getEndpointPlugin",
    ),
    l0r = xJ(),
    d0r = oc((e) => {
      let t = e.tls ?? !0,
        { endpoint: r, useDualstackEndpoint: n, useFipsEndpoint: i } = e,
        o =
          r != null
            ? async () => NJ(await (0, iB.normalizeProvider)(r)())
            : void 0,
        s = Object.assign(e, {
          endpoint: o,
          tls: t,
          isCustomEndpoint: !!r,
          useDualstackEndpoint: (0, iB.normalizeProvider)(n ?? !1),
          useFipsEndpoint: (0, iB.normalizeProvider)(i ?? !1),
        }),
        u;
      return (
        (s.serviceConfiguredEndpoint = async () => (
          e.serviceId &&
            !u &&
            (u = (0, l0r.getEndpointFromConfig)(e.serviceId)),
          u
        )),
        s
      );
    }, "resolveEndpointConfig");
});
var f6e = g((mB) => {
  "use strict";
  c();
  Object.defineProperty(mB, "__esModule", { value: !0 });
  mB.ruleSet = void 0;
  var rZ = "required",
    T = "type",
    F = "rules",
    I = "conditions",
    M = "fn",
    q = "argv",
    xe = "ref",
    tt = "assign",
    _e = "url",
    Ee = "properties",
    Vh = "backend",
    Ki = "authSchemes",
    ai = "disableDoubleEncoding",
    si = "signingName",
    so = "signingRegion",
    be = "headers",
    nZ = "signingRegionSet",
    f0r = 6,
    p0r = !1,
    bu = !0,
    ha = "isSet",
    _n = "booleanEquals",
    ye = "error",
    lB = "aws.partition",
    xt = "stringEquals",
    tn = "getAttr",
    yn = "name",
    yr = "substring",
    F4e = "bucketSuffix",
    iZ = "parseURL",
    K = "endpoint",
    U = "tree",
    dB = "aws.isVirtualHostableS3Bucket",
    fB = "{url#scheme}://{Bucket}.{url#authority}{url#path}",
    wu = "not",
    B4e = "accessPointSuffix",
    uB = "{url#scheme}://{url#authority}{url#path}",
    YWe = "hardwareType",
    XWe = "regionPrefix",
    U4e = "bucketAliasSuffix",
    eZ = "outpostId",
    $h = "isValidHostLabel",
    oZ = "sigv4a",
    WO = "s3-outposts",
    NE = "s3",
    JWe = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}",
    ZWe = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}",
    H4e = "https://{Bucket}.s3.{partitionResult#dnsSuffix}",
    e6e = "aws.parseArn",
    t6e = "bucketArn",
    r6e = "arnType",
    pB = "",
    aZ = "s3-object-lambda",
    n6e = "accesspoint",
    sZ = "accessPointName",
    G4e =
      "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}",
    V4e = "mrapPartition",
    $4e = "outpostType",
    z4e = "arnPrefix",
    i6e =
      "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}",
    K4e = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
    W4e = "https://s3.{partitionResult#dnsSuffix}",
    PE = { [rZ]: !1, [T]: "String" },
    RE = { [rZ]: !0, default: !1, [T]: "Boolean" },
    $O = { [rZ]: !1, [T]: "Boolean" },
    ss = { [M]: _n, [q]: [{ [xe]: "Accelerate" }, !0] },
    Ir = { [M]: _n, [q]: [{ [xe]: "UseFIPS" }, !0] },
    vr = { [M]: _n, [q]: [{ [xe]: "UseDualStack" }, !0] },
    vn = { [M]: ha, [q]: [{ [xe]: "Endpoint" }] },
    o6e = { [M]: lB, [q]: [{ [xe]: "Region" }], [tt]: "partitionResult" },
    Q4e = {
      [M]: xt,
      [q]: [{ [M]: tn, [q]: [{ [xe]: "partitionResult" }, yn] }, "aws-cn"],
    },
    KO = { [M]: ha, [q]: [{ [xe]: "Bucket" }] },
    Pt = { [xe]: "Bucket" },
    Y4e = {
      [I]: [vr],
      [ye]: "S3Express does not support Dual-stack.",
      [T]: ye,
    },
    X4e = {
      [I]: [ss],
      [ye]: "S3Express does not support S3 Accelerate.",
      [T]: ye,
    },
    J4e = {
      [I]: [vn, { [M]: iZ, [q]: [{ [xe]: "Endpoint" }], [tt]: "url" }],
      [F]: [
        {
          [I]: [
            { [M]: ha, [q]: [{ [xe]: "DisableS3ExpressSessionAuth" }] },
            { [M]: _n, [q]: [{ [xe]: "DisableS3ExpressSessionAuth" }, !0] },
          ],
          [F]: [
            {
              [I]: [
                {
                  [M]: _n,
                  [q]: [{ [M]: tn, [q]: [{ [xe]: "url" }, "isIp"] }, !0],
                },
              ],
              [F]: [
                {
                  [I]: [
                    { [M]: "uriEncode", [q]: [Pt], [tt]: "uri_encoded_bucket" },
                  ],
                  [F]: [
                    {
                      [K]: {
                        [_e]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}",
                        [Ee]: {
                          [Vh]: "S3Express",
                          [Ki]: [
                            {
                              [ai]: !0,
                              [yn]: "sigv4",
                              [si]: "s3express",
                              [so]: "{Region}",
                            },
                          ],
                        },
                        [be]: {},
                      },
                      [T]: K,
                    },
                  ],
                  [T]: U,
                },
              ],
              [T]: U,
            },
            {
              [I]: [{ [M]: dB, [q]: [Pt, !1] }],
              [F]: [
                {
                  [K]: {
                    [_e]: fB,
                    [Ee]: {
                      [Vh]: "S3Express",
                      [Ki]: [
                        {
                          [ai]: !0,
                          [yn]: "sigv4",
                          [si]: "s3express",
                          [so]: "{Region}",
                        },
                      ],
                    },
                    [be]: {},
                  },
                  [T]: K,
                },
              ],
              [T]: U,
            },
            {
              [ye]: "S3Express bucket name is not a valid virtual hostable name.",
              [T]: ye,
            },
          ],
          [T]: U,
        },
        {
          [I]: [
            { [M]: _n, [q]: [{ [M]: tn, [q]: [{ [xe]: "url" }, "isIp"] }, !0] },
          ],
          [F]: [
            {
              [I]: [
                { [M]: "uriEncode", [q]: [Pt], [tt]: "uri_encoded_bucket" },
              ],
              [F]: [
                {
                  [K]: {
                    [_e]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}",
                    [Ee]: {
                      [Vh]: "S3Express",
                      [Ki]: [
                        {
                          [ai]: !0,
                          [yn]: "sigv4-s3express",
                          [si]: "s3express",
                          [so]: "{Region}",
                        },
                      ],
                    },
                    [be]: {},
                  },
                  [T]: K,
                },
              ],
              [T]: U,
            },
          ],
          [T]: U,
        },
        {
          [I]: [{ [M]: dB, [q]: [Pt, !1] }],
          [F]: [
            {
              [K]: {
                [_e]: fB,
                [Ee]: {
                  [Vh]: "S3Express",
                  [Ki]: [
                    {
                      [ai]: !0,
                      [yn]: "sigv4-s3express",
                      [si]: "s3express",
                      [so]: "{Region}",
                    },
                  ],
                },
                [be]: {},
              },
              [T]: K,
            },
          ],
          [T]: U,
        },
        {
          [ye]: "S3Express bucket name is not a valid virtual hostable name.",
          [T]: ye,
        },
      ],
      [T]: U,
    },
    ao = { [M]: iZ, [q]: [{ [xe]: "Endpoint" }], [tt]: "url" },
    kJ = { [M]: _n, [q]: [{ [M]: tn, [q]: [{ [xe]: "url" }, "isIp"] }, !0] },
    a6e = { [xe]: "url" },
    s6e = { [M]: "uriEncode", [q]: [Pt], [tt]: "uri_encoded_bucket" },
    Gh = {
      [Vh]: "S3Express",
      [Ki]: [{ [ai]: !0, [yn]: "sigv4", [si]: "s3express", [so]: "{Region}" }],
    },
    We = {},
    c6e = { [M]: dB, [q]: [Pt, !1] },
    Z4e = {
      [ye]: "S3Express bucket name is not a valid virtual hostable name.",
      [T]: ye,
    },
    eWe = { [M]: ha, [q]: [{ [xe]: "UseS3ExpressControlEndpoint" }] },
    tWe = { [M]: _n, [q]: [{ [xe]: "UseS3ExpressControlEndpoint" }, !0] },
    Qe = { [M]: wu, [q]: [vn] },
    aB = { [ye]: "Unrecognized S3Express bucket name format.", [T]: ye },
    rWe = { [M]: wu, [q]: [KO] },
    nWe = { [xe]: YWe },
    iWe = {
      [I]: [Qe],
      [ye]: "Expected a endpoint to be specified but no endpoint was found",
      [T]: ye,
    },
    sB = {
      [Ki]: [
        { [ai]: !0, [yn]: oZ, [si]: WO, [nZ]: ["*"] },
        { [ai]: !0, [yn]: "sigv4", [si]: WO, [so]: "{Region}" },
      ],
    },
    DJ = { [M]: _n, [q]: [{ [xe]: "ForcePathStyle" }, !1] },
    m0r = { [xe]: "ForcePathStyle" },
    Nn = { [M]: _n, [q]: [{ [xe]: "Accelerate" }, !1] },
    Vn = { [M]: xt, [q]: [{ [xe]: "Region" }, "aws-global"] },
    ni = { [Ki]: [{ [ai]: !0, [yn]: "sigv4", [si]: NE, [so]: "us-east-1" }] },
    bt = { [M]: wu, [q]: [Vn] },
    ii = { [M]: _n, [q]: [{ [xe]: "UseGlobalEndpoint" }, !0] },
    oWe = {
      [_e]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}",
      [Ee]: { [Ki]: [{ [ai]: !0, [yn]: "sigv4", [si]: NE, [so]: "{Region}" }] },
      [be]: {},
    },
    kn = { [Ki]: [{ [ai]: !0, [yn]: "sigv4", [si]: NE, [so]: "{Region}" }] },
    oi = { [M]: _n, [q]: [{ [xe]: "UseGlobalEndpoint" }, !1] },
    yt = { [M]: _n, [q]: [{ [xe]: "UseDualStack" }, !1] },
    aWe = {
      [_e]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}",
      [Ee]: kn,
      [be]: {},
    },
    ut = { [M]: _n, [q]: [{ [xe]: "UseFIPS" }, !1] },
    sWe = {
      [_e]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}",
      [Ee]: kn,
      [be]: {},
    },
    cWe = {
      [_e]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}",
      [Ee]: kn,
      [be]: {},
    },
    LJ = { [M]: _n, [q]: [{ [M]: tn, [q]: [a6e, "isIp"] }, !1] },
    MJ = { [_e]: JWe, [Ee]: kn, [be]: {} },
    tZ = { [_e]: fB, [Ee]: kn, [be]: {} },
    uWe = { [K]: tZ, [T]: K },
    qJ = { [_e]: ZWe, [Ee]: kn, [be]: {} },
    lWe = {
      [_e]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}",
      [Ee]: kn,
      [be]: {},
    },
    cB = { [ye]: "Invalid region: region was not a valid DNS name.", [T]: ye },
    Go = { [xe]: t6e },
    u6e = { [xe]: r6e },
    jJ = { [M]: tn, [q]: [Go, "service"] },
    cZ = { [xe]: sZ },
    dWe = {
      [I]: [vr],
      [ye]: "S3 Object Lambda does not support Dual-stack",
      [T]: ye,
    },
    fWe = {
      [I]: [ss],
      [ye]: "S3 Object Lambda does not support S3 Accelerate",
      [T]: ye,
    },
    pWe = {
      [I]: [
        { [M]: ha, [q]: [{ [xe]: "DisableAccessPoints" }] },
        { [M]: _n, [q]: [{ [xe]: "DisableAccessPoints" }, !0] },
      ],
      [ye]: "Access points are not supported for this operation",
      [T]: ye,
    },
    FJ = {
      [I]: [
        { [M]: ha, [q]: [{ [xe]: "UseArnRegion" }] },
        { [M]: _n, [q]: [{ [xe]: "UseArnRegion" }, !1] },
        {
          [M]: wu,
          [q]: [
            { [M]: xt, [q]: [{ [M]: tn, [q]: [Go, "region"] }, "{Region}"] },
          ],
        },
      ],
      [ye]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`",
      [T]: ye,
    },
    l6e = { [M]: tn, [q]: [{ [xe]: "bucketPartition" }, yn] },
    d6e = { [M]: tn, [q]: [Go, "accountId"] },
    BJ = {
      [Ki]: [{ [ai]: !0, [yn]: "sigv4", [si]: aZ, [so]: "{bucketArn#region}" }],
    },
    mWe = {
      [ye]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`",
      [T]: ye,
    },
    UJ = {
      [ye]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`",
      [T]: ye,
    },
    HJ = {
      [ye]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)",
      [T]: ye,
    },
    GJ = {
      [ye]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`",
      [T]: ye,
    },
    hWe = {
      [ye]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.",
      [T]: ye,
    },
    gWe = {
      [ye]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided",
      [T]: ye,
    },
    zO = {
      [Ki]: [{ [ai]: !0, [yn]: "sigv4", [si]: NE, [so]: "{bucketArn#region}" }],
    },
    vWe = {
      [Ki]: [
        { [ai]: !0, [yn]: oZ, [si]: WO, [nZ]: ["*"] },
        { [ai]: !0, [yn]: "sigv4", [si]: WO, [so]: "{bucketArn#region}" },
      ],
    },
    yWe = { [M]: e6e, [q]: [Pt] },
    _We = {
      [_e]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
      [Ee]: kn,
      [be]: {},
    },
    EWe = {
      [_e]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
      [Ee]: kn,
      [be]: {},
    },
    bWe = {
      [_e]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
      [Ee]: kn,
      [be]: {},
    },
    VJ = { [_e]: i6e, [Ee]: kn, [be]: {} },
    SWe = {
      [_e]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
      [Ee]: kn,
      [be]: {},
    },
    CWe = { [xe]: "UseObjectLambdaEndpoint" },
    $J = { [Ki]: [{ [ai]: !0, [yn]: "sigv4", [si]: aZ, [so]: "{Region}" }] },
    wWe = {
      [_e]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}",
      [Ee]: kn,
      [be]: {},
    },
    OWe = {
      [_e]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}",
      [Ee]: kn,
      [be]: {},
    },
    TWe = {
      [_e]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}",
      [Ee]: kn,
      [be]: {},
    },
    zJ = { [_e]: uB, [Ee]: kn, [be]: {} },
    AWe = {
      [_e]: "https://s3.{Region}.{partitionResult#dnsSuffix}",
      [Ee]: kn,
      [be]: {},
    },
    KJ = [{ [xe]: "Region" }],
    h0r = [{ [xe]: "Endpoint" }],
    g0r = [Pt],
    PWe = [vr],
    WJ = [ss],
    IE = [vn, ao],
    RWe = [
      { [M]: ha, [q]: [{ [xe]: "DisableS3ExpressSessionAuth" }] },
      { [M]: _n, [q]: [{ [xe]: "DisableS3ExpressSessionAuth" }, !0] },
    ],
    v0r = [s6e],
    IWe = [c6e],
    as = [o6e],
    xE = [Ir],
    xWe = [
      { [M]: yr, [q]: [Pt, 6, 14, !0], [tt]: "s3expressAvailabilityZoneId" },
      {
        [M]: yr,
        [q]: [Pt, 14, 16, !0],
        [tt]: "s3expressAvailabilityZoneDelim",
      },
      { [M]: xt, [q]: [{ [xe]: "s3expressAvailabilityZoneDelim" }, "--"] },
    ],
    Su = [
      {
        [I]: [Ir],
        [K]: {
          [_e]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}",
          [Ee]: Gh,
          [be]: {},
        },
        [T]: K,
      },
      {
        [K]: {
          [_e]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}",
          [Ee]: Gh,
          [be]: {},
        },
        [T]: K,
      },
    ],
    NWe = [
      { [M]: yr, [q]: [Pt, 6, 15, !0], [tt]: "s3expressAvailabilityZoneId" },
      {
        [M]: yr,
        [q]: [Pt, 15, 17, !0],
        [tt]: "s3expressAvailabilityZoneDelim",
      },
      { [M]: xt, [q]: [{ [xe]: "s3expressAvailabilityZoneDelim" }, "--"] },
    ],
    kWe = [
      { [M]: yr, [q]: [Pt, 6, 19, !0], [tt]: "s3expressAvailabilityZoneId" },
      {
        [M]: yr,
        [q]: [Pt, 19, 21, !0],
        [tt]: "s3expressAvailabilityZoneDelim",
      },
      { [M]: xt, [q]: [{ [xe]: "s3expressAvailabilityZoneDelim" }, "--"] },
    ],
    DWe = [
      { [M]: yr, [q]: [Pt, 6, 20, !0], [tt]: "s3expressAvailabilityZoneId" },
      {
        [M]: yr,
        [q]: [Pt, 20, 22, !0],
        [tt]: "s3expressAvailabilityZoneDelim",
      },
      { [M]: xt, [q]: [{ [xe]: "s3expressAvailabilityZoneDelim" }, "--"] },
    ],
    LWe = [
      { [M]: yr, [q]: [Pt, 6, 26, !0], [tt]: "s3expressAvailabilityZoneId" },
      {
        [M]: yr,
        [q]: [Pt, 26, 28, !0],
        [tt]: "s3expressAvailabilityZoneDelim",
      },
      { [M]: xt, [q]: [{ [xe]: "s3expressAvailabilityZoneDelim" }, "--"] },
    ],
    Cu = [
      {
        [I]: [Ir],
        [K]: {
          [_e]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}",
          [Ee]: {
            [Vh]: "S3Express",
            [Ki]: [
              {
                [ai]: !0,
                [yn]: "sigv4-s3express",
                [si]: "s3express",
                [so]: "{Region}",
              },
            ],
          },
          [be]: {},
        },
        [T]: K,
      },
      {
        [K]: {
          [_e]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}",
          [Ee]: {
            [Vh]: "S3Express",
            [Ki]: [
              {
                [ai]: !0,
                [yn]: "sigv4-s3express",
                [si]: "s3express",
                [so]: "{Region}",
              },
            ],
          },
          [be]: {},
        },
        [T]: K,
      },
    ],
    MWe = [Pt, 0, 7, !0],
    qWe = [
      { [M]: yr, [q]: [Pt, 7, 15, !0], [tt]: "s3expressAvailabilityZoneId" },
      {
        [M]: yr,
        [q]: [Pt, 15, 17, !0],
        [tt]: "s3expressAvailabilityZoneDelim",
      },
      { [M]: xt, [q]: [{ [xe]: "s3expressAvailabilityZoneDelim" }, "--"] },
    ],
    jWe = [
      { [M]: yr, [q]: [Pt, 7, 16, !0], [tt]: "s3expressAvailabilityZoneId" },
      {
        [M]: yr,
        [q]: [Pt, 16, 18, !0],
        [tt]: "s3expressAvailabilityZoneDelim",
      },
      { [M]: xt, [q]: [{ [xe]: "s3expressAvailabilityZoneDelim" }, "--"] },
    ],
    FWe = [
      { [M]: yr, [q]: [Pt, 7, 20, !0], [tt]: "s3expressAvailabilityZoneId" },
      {
        [M]: yr,
        [q]: [Pt, 20, 22, !0],
        [tt]: "s3expressAvailabilityZoneDelim",
      },
      { [M]: xt, [q]: [{ [xe]: "s3expressAvailabilityZoneDelim" }, "--"] },
    ],
    BWe = [
      { [M]: yr, [q]: [Pt, 7, 21, !0], [tt]: "s3expressAvailabilityZoneId" },
      {
        [M]: yr,
        [q]: [Pt, 21, 23, !0],
        [tt]: "s3expressAvailabilityZoneDelim",
      },
      { [M]: xt, [q]: [{ [xe]: "s3expressAvailabilityZoneDelim" }, "--"] },
    ],
    UWe = [
      { [M]: yr, [q]: [Pt, 7, 27, !0], [tt]: "s3expressAvailabilityZoneId" },
      {
        [M]: yr,
        [q]: [Pt, 27, 29, !0],
        [tt]: "s3expressAvailabilityZoneDelim",
      },
      { [M]: xt, [q]: [{ [xe]: "s3expressAvailabilityZoneDelim" }, "--"] },
    ],
    y0r = [KO],
    HWe = [{ [M]: $h, [q]: [{ [xe]: eZ }, !1] }],
    GWe = [{ [M]: xt, [q]: [{ [xe]: XWe }, "beta"] }],
    _0r = ["*"],
    VWe = [{ [M]: $h, [q]: [{ [xe]: "Region" }, !1] }],
    gp = [{ [M]: xt, [q]: [{ [xe]: "Region" }, "us-east-1"] }],
    QJ = [{ [M]: xt, [q]: [u6e, n6e] }],
    $We = [
      { [M]: tn, [q]: [Go, "resourceId[1]"], [tt]: sZ },
      { [M]: wu, [q]: [{ [M]: xt, [q]: [cZ, pB] }] },
    ],
    E0r = [Go, "resourceId[1]"],
    YJ = [
      {
        [M]: wu,
        [q]: [{ [M]: xt, [q]: [{ [M]: tn, [q]: [Go, "region"] }, pB] }],
      },
    ],
    zWe = [
      {
        [M]: wu,
        [q]: [{ [M]: ha, [q]: [{ [M]: tn, [q]: [Go, "resourceId[2]"] }] }],
      },
    ],
    b0r = [Go, "resourceId[2]"],
    XJ = [
      {
        [M]: lB,
        [q]: [{ [M]: tn, [q]: [Go, "region"] }],
        [tt]: "bucketPartition",
      },
    ],
    KWe = [
      {
        [M]: xt,
        [q]: [l6e, { [M]: tn, [q]: [{ [xe]: "partitionResult" }, yn] }],
      },
    ],
    JJ = [{ [M]: $h, [q]: [{ [M]: tn, [q]: [Go, "region"] }, !0] }],
    ZJ = [{ [M]: $h, [q]: [d6e, !1] }],
    WWe = [{ [M]: $h, [q]: [cZ, !1] }],
    QWe = [{ [M]: $h, [q]: [{ [xe]: "Region" }, !0] }],
    S0r = {
      version: "1.0",
      parameters: {
        Bucket: PE,
        Region: PE,
        UseFIPS: RE,
        UseDualStack: RE,
        Endpoint: PE,
        ForcePathStyle: RE,
        Accelerate: RE,
        UseGlobalEndpoint: RE,
        UseObjectLambdaEndpoint: $O,
        Key: PE,
        Prefix: PE,
        CopySource: PE,
        DisableAccessPoints: $O,
        DisableMultiRegionAccessPoints: RE,
        UseArnRegion: $O,
        UseS3ExpressControlEndpoint: $O,
        DisableS3ExpressSessionAuth: $O,
      },
      [F]: [
        {
          [I]: [{ [M]: ha, [q]: KJ }],
          [F]: [
            {
              [I]: [ss, Ir],
              error: "Accelerate cannot be used with FIPS",
              [T]: ye,
            },
            {
              [I]: [vr, vn],
              error:
                "Cannot set dual-stack in combination with a custom endpoint.",
              [T]: ye,
            },
            {
              [I]: [vn, Ir],
              error: "A custom endpoint cannot be combined with FIPS",
              [T]: ye,
            },
            {
              [I]: [vn, ss],
              error: "A custom endpoint cannot be combined with S3 Accelerate",
              [T]: ye,
            },
            {
              [I]: [Ir, o6e, Q4e],
              error: "Partition does not support FIPS",
              [T]: ye,
            },
            {
              [I]: [
                KO,
                { [M]: yr, [q]: [Pt, 0, f0r, bu], [tt]: F4e },
                { [M]: xt, [q]: [{ [xe]: F4e }, "--x-s3"] },
              ],
              [F]: [
                Y4e,
                X4e,
                J4e,
                {
                  [I]: [eWe, tWe],
                  [F]: [
                    {
                      [I]: as,
                      [F]: [
                        {
                          [I]: [s6e, Qe],
                          [F]: [
                            {
                              [I]: xE,
                              endpoint: {
                                [_e]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                [Ee]: Gh,
                                [be]: We,
                              },
                              [T]: K,
                            },
                            {
                              endpoint: {
                                [_e]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                [Ee]: Gh,
                                [be]: We,
                              },
                              [T]: K,
                            },
                          ],
                          [T]: U,
                        },
                      ],
                      [T]: U,
                    },
                  ],
                  [T]: U,
                },
                {
                  [I]: IWe,
                  [F]: [
                    {
                      [I]: as,
                      [F]: [
                        {
                          [I]: RWe,
                          [F]: [
                            { [I]: xWe, [F]: Su, [T]: U },
                            { [I]: NWe, [F]: Su, [T]: U },
                            { [I]: kWe, [F]: Su, [T]: U },
                            { [I]: DWe, [F]: Su, [T]: U },
                            { [I]: LWe, [F]: Su, [T]: U },
                            aB,
                          ],
                          [T]: U,
                        },
                        { [I]: xWe, [F]: Cu, [T]: U },
                        { [I]: NWe, [F]: Cu, [T]: U },
                        { [I]: kWe, [F]: Cu, [T]: U },
                        { [I]: DWe, [F]: Cu, [T]: U },
                        { [I]: LWe, [F]: Cu, [T]: U },
                        aB,
                      ],
                      [T]: U,
                    },
                  ],
                  [T]: U,
                },
                Z4e,
              ],
              [T]: U,
            },
            {
              [I]: [
                KO,
                { [M]: yr, [q]: MWe, [tt]: B4e },
                { [M]: xt, [q]: [{ [xe]: B4e }, "--xa-s3"] },
              ],
              [F]: [
                Y4e,
                X4e,
                J4e,
                {
                  [I]: IWe,
                  [F]: [
                    {
                      [I]: as,
                      [F]: [
                        {
                          [I]: RWe,
                          [F]: [
                            { [I]: qWe, [F]: Su, [T]: U },
                            { [I]: jWe, [F]: Su, [T]: U },
                            { [I]: FWe, [F]: Su, [T]: U },
                            { [I]: BWe, [F]: Su, [T]: U },
                            { [I]: UWe, [F]: Su, [T]: U },
                            aB,
                          ],
                          [T]: U,
                        },
                        { [I]: qWe, [F]: Cu, [T]: U },
                        { [I]: jWe, [F]: Cu, [T]: U },
                        { [I]: FWe, [F]: Cu, [T]: U },
                        { [I]: BWe, [F]: Cu, [T]: U },
                        { [I]: UWe, [F]: Cu, [T]: U },
                        aB,
                      ],
                      [T]: U,
                    },
                  ],
                  [T]: U,
                },
                Z4e,
              ],
              [T]: U,
            },
            {
              [I]: [rWe, eWe, tWe],
              [F]: [
                {
                  [I]: as,
                  [F]: [
                    {
                      [I]: IE,
                      endpoint: { [_e]: uB, [Ee]: Gh, [be]: We },
                      [T]: K,
                    },
                    {
                      [I]: xE,
                      endpoint: {
                        [_e]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}",
                        [Ee]: Gh,
                        [be]: We,
                      },
                      [T]: K,
                    },
                    {
                      endpoint: {
                        [_e]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}",
                        [Ee]: Gh,
                        [be]: We,
                      },
                      [T]: K,
                    },
                  ],
                  [T]: U,
                },
              ],
              [T]: U,
            },
            {
              [I]: [
                KO,
                { [M]: yr, [q]: [Pt, 49, 50, bu], [tt]: YWe },
                { [M]: yr, [q]: [Pt, 8, 12, bu], [tt]: XWe },
                { [M]: yr, [q]: MWe, [tt]: U4e },
                { [M]: yr, [q]: [Pt, 32, 49, bu], [tt]: eZ },
                { [M]: lB, [q]: KJ, [tt]: "regionPartition" },
                { [M]: xt, [q]: [{ [xe]: U4e }, "--op-s3"] },
              ],
              [F]: [
                {
                  [I]: HWe,
                  [F]: [
                    {
                      [I]: [{ [M]: xt, [q]: [nWe, "e"] }],
                      [F]: [
                        {
                          [I]: GWe,
                          [F]: [
                            iWe,
                            {
                              [I]: IE,
                              endpoint: {
                                [_e]: "https://{Bucket}.ec2.{url#authority}",
                                [Ee]: sB,
                                [be]: We,
                              },
                              [T]: K,
                            },
                          ],
                          [T]: U,
                        },
                        {
                          endpoint: {
                            [_e]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}",
                            [Ee]: sB,
                            [be]: We,
                          },
                          [T]: K,
                        },
                      ],
                      [T]: U,
                    },
                    {
                      [I]: [{ [M]: xt, [q]: [nWe, "o"] }],
                      [F]: [
                        {
                          [I]: GWe,
                          [F]: [
                            iWe,
                            {
                              [I]: IE,
                              endpoint: {
                                [_e]: "https://{Bucket}.op-{outpostId}.{url#authority}",
                                [Ee]: sB,
                                [be]: We,
                              },
                              [T]: K,
                            },
                          ],
                          [T]: U,
                        },
                        {
                          endpoint: {
                            [_e]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}",
                            [Ee]: sB,
                            [be]: We,
                          },
                          [T]: K,
                        },
                      ],
                      [T]: U,
                    },
                    {
                      error:
                        'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"',
                      [T]: ye,
                    },
                  ],
                  [T]: U,
                },
                {
                  error:
                    "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.",
                  [T]: ye,
                },
              ],
              [T]: U,
            },
            {
              [I]: y0r,
              [F]: [
                {
                  [I]: [
                    vn,
                    {
                      [M]: wu,
                      [q]: [{ [M]: ha, [q]: [{ [M]: iZ, [q]: h0r }] }],
                    },
                  ],
                  error: "Custom endpoint `{Endpoint}` was not a valid URI",
                  [T]: ye,
                },
                {
                  [I]: [DJ, c6e],
                  [F]: [
                    {
                      [I]: as,
                      [F]: [
                        {
                          [I]: VWe,
                          [F]: [
                            {
                              [I]: [ss, Q4e],
                              error:
                                "S3 Accelerate cannot be used in this region",
                              [T]: ye,
                            },
                            {
                              [I]: [vr, Ir, Nn, Qe, Vn],
                              endpoint: {
                                [_e]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                                [Ee]: ni,
                                [be]: We,
                              },
                              [T]: K,
                            },
                            {
                              [I]: [vr, Ir, Nn, Qe, bt, ii],
                              [F]: [{ endpoint: oWe, [T]: K }],
                              [T]: U,
                            },
                            {
                              [I]: [vr, Ir, Nn, Qe, bt, oi],
                              endpoint: oWe,
                              [T]: K,
                            },
                            {
                              [I]: [yt, Ir, Nn, Qe, Vn],
                              endpoint: {
                                [_e]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}",
                                [Ee]: ni,
                                [be]: We,
                              },
                              [T]: K,
                            },
                            {
                              [I]: [yt, Ir, Nn, Qe, bt, ii],
                              [F]: [{ endpoint: aWe, [T]: K }],
                              [T]: U,
                            },
                            {
                              [I]: [yt, Ir, Nn, Qe, bt, oi],
                              endpoint: aWe,
                              [T]: K,
                            },
                            {
                              [I]: [vr, ut, ss, Qe, Vn],
                              endpoint: {
                                [_e]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                                [Ee]: ni,
                                [be]: We,
                              },
                              [T]: K,
                            },
                            {
                              [I]: [vr, ut, ss, Qe, bt, ii],
                              [F]: [{ endpoint: sWe, [T]: K }],
                              [T]: U,
                            },
                            {
                              [I]: [vr, ut, ss, Qe, bt, oi],
                              endpoint: sWe,
                              [T]: K,
                            },
                            {
                              [I]: [vr, ut, Nn, Qe, Vn],
                              endpoint: {
                                [_e]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                                [Ee]: ni,
                                [be]: We,
                              },
                              [T]: K,
                            },
                            {
                              [I]: [vr, ut, Nn, Qe, bt, ii],
                              [F]: [{ endpoint: cWe, [T]: K }],
                              [T]: U,
                            },
                            {
                              [I]: [vr, ut, Nn, Qe, bt, oi],
                              endpoint: cWe,
                              [T]: K,
                            },
                            {
                              [I]: [yt, ut, Nn, vn, ao, kJ, Vn],
                              endpoint: { [_e]: JWe, [Ee]: ni, [be]: We },
                              [T]: K,
                            },
                            {
                              [I]: [yt, ut, Nn, vn, ao, LJ, Vn],
                              endpoint: { [_e]: fB, [Ee]: ni, [be]: We },
                              [T]: K,
                            },
                            {
                              [I]: [yt, ut, Nn, vn, ao, kJ, bt, ii],
                              [F]: [
                                { [I]: gp, endpoint: MJ, [T]: K },
                                { endpoint: MJ, [T]: K },
                              ],
                              [T]: U,
                            },
                            {
                              [I]: [yt, ut, Nn, vn, ao, LJ, bt, ii],
                              [F]: [{ [I]: gp, endpoint: tZ, [T]: K }, uWe],
                              [T]: U,
                            },
                            {
                              [I]: [yt, ut, Nn, vn, ao, kJ, bt, oi],
                              endpoint: MJ,
                              [T]: K,
                            },
                            {
                              [I]: [yt, ut, Nn, vn, ao, LJ, bt, oi],
                              endpoint: tZ,
                              [T]: K,
                            },
                            {
                              [I]: [yt, ut, ss, Qe, Vn],
                              endpoint: { [_e]: ZWe, [Ee]: ni, [be]: We },
                              [T]: K,
                            },
                            {
                              [I]: [yt, ut, ss, Qe, bt, ii],
                              [F]: [
                                { [I]: gp, endpoint: qJ, [T]: K },
                                { endpoint: qJ, [T]: K },
                              ],
                              [T]: U,
                            },
                            {
                              [I]: [yt, ut, ss, Qe, bt, oi],
                              endpoint: qJ,
                              [T]: K,
                            },
                            {
                              [I]: [yt, ut, Nn, Qe, Vn],
                              endpoint: { [_e]: H4e, [Ee]: ni, [be]: We },
                              [T]: K,
                            },
                            {
                              [I]: [yt, ut, Nn, Qe, bt, ii],
                              [F]: [
                                {
                                  [I]: gp,
                                  endpoint: { [_e]: H4e, [Ee]: kn, [be]: We },
                                  [T]: K,
                                },
                                { endpoint: lWe, [T]: K },
                              ],
                              [T]: U,
                            },
                            {
                              [I]: [yt, ut, Nn, Qe, bt, oi],
                              endpoint: lWe,
                              [T]: K,
                            },
                          ],
                          [T]: U,
                        },
                        cB,
                      ],
                      [T]: U,
                    },
                  ],
                  [T]: U,
                },
                {
                  [I]: [
                    vn,
                    ao,
                    {
                      [M]: xt,
                      [q]: [{ [M]: tn, [q]: [a6e, "scheme"] }, "http"],
                    },
                    { [M]: dB, [q]: [Pt, bu] },
                    DJ,
                    ut,
                    yt,
                    Nn,
                  ],
                  [F]: [
                    {
                      [I]: as,
                      [F]: [{ [I]: VWe, [F]: [uWe], [T]: U }, cB],
                      [T]: U,
                    },
                  ],
                  [T]: U,
                },
                {
                  [I]: [DJ, { [M]: e6e, [q]: g0r, [tt]: t6e }],
                  [F]: [
                    {
                      [I]: [
                        { [M]: tn, [q]: [Go, "resourceId[0]"], [tt]: r6e },
                        { [M]: wu, [q]: [{ [M]: xt, [q]: [u6e, pB] }] },
                      ],
                      [F]: [
                        {
                          [I]: [{ [M]: xt, [q]: [jJ, aZ] }],
                          [F]: [
                            {
                              [I]: QJ,
                              [F]: [
                                {
                                  [I]: $We,
                                  [F]: [
                                    dWe,
                                    fWe,
                                    {
                                      [I]: YJ,
                                      [F]: [
                                        pWe,
                                        {
                                          [I]: zWe,
                                          [F]: [
                                            FJ,
                                            {
                                              [I]: XJ,
                                              [F]: [
                                                {
                                                  [I]: as,
                                                  [F]: [
                                                    {
                                                      [I]: KWe,
                                                      [F]: [
                                                        {
                                                          [I]: JJ,
                                                          [F]: [
                                                            {
                                                              [I]: [
                                                                {
                                                                  [M]: xt,
                                                                  [q]: [
                                                                    d6e,
                                                                    pB,
                                                                  ],
                                                                },
                                                              ],
                                                              error:
                                                                "Invalid ARN: Missing account id",
                                                              [T]: ye,
                                                            },
                                                            {
                                                              [I]: ZJ,
                                                              [F]: [
                                                                {
                                                                  [I]: WWe,
                                                                  [F]: [
                                                                    {
                                                                      [I]: IE,
                                                                      endpoint:
                                                                        {
                                                                          [_e]: G4e,
                                                                          [Ee]: BJ,
                                                                          [be]: We,
                                                                        },
                                                                      [T]: K,
                                                                    },
                                                                    {
                                                                      [I]: xE,
                                                                      endpoint:
                                                                        {
                                                                          [_e]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                          [Ee]: BJ,
                                                                          [be]: We,
                                                                        },
                                                                      [T]: K,
                                                                    },
                                                                    {
                                                                      endpoint:
                                                                        {
                                                                          [_e]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                          [Ee]: BJ,
                                                                          [be]: We,
                                                                        },
                                                                      [T]: K,
                                                                    },
                                                                  ],
                                                                  [T]: U,
                                                                },
                                                                mWe,
                                                              ],
                                                              [T]: U,
                                                            },
                                                            UJ,
                                                          ],
                                                          [T]: U,
                                                        },
                                                        HJ,
                                                      ],
                                                      [T]: U,
                                                    },
                                                    GJ,
                                                  ],
                                                  [T]: U,
                                                },
                                              ],
                                              [T]: U,
                                            },
                                          ],
                                          [T]: U,
                                        },
                                        hWe,
                                      ],
                                      [T]: U,
                                    },
                                    {
                                      error:
                                        "Invalid ARN: bucket ARN is missing a region",
                                      [T]: ye,
                                    },
                                  ],
                                  [T]: U,
                                },
                                gWe,
                              ],
                              [T]: U,
                            },
                            {
                              error:
                                "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`",
                              [T]: ye,
                            },
                          ],
                          [T]: U,
                        },
                        {
                          [I]: QJ,
                          [F]: [
                            {
                              [I]: $We,
                              [F]: [
                                {
                                  [I]: YJ,
                                  [F]: [
                                    {
                                      [I]: QJ,
                                      [F]: [
                                        {
                                          [I]: YJ,
                                          [F]: [
                                            pWe,
                                            {
                                              [I]: zWe,
                                              [F]: [
                                                FJ,
                                                {
                                                  [I]: XJ,
                                                  [F]: [
                                                    {
                                                      [I]: as,
                                                      [F]: [
                                                        {
                                                          [I]: [
                                                            {
                                                              [M]: xt,
                                                              [q]: [
                                                                l6e,
                                                                "{partitionResult#name}",
                                                              ],
                                                            },
                                                          ],
                                                          [F]: [
                                                            {
                                                              [I]: JJ,
                                                              [F]: [
                                                                {
                                                                  [I]: [
                                                                    {
                                                                      [M]: xt,
                                                                      [q]: [
                                                                        jJ,
                                                                        NE,
                                                                      ],
                                                                    },
                                                                  ],
                                                                  [F]: [
                                                                    {
                                                                      [I]: ZJ,
                                                                      [F]: [
                                                                        {
                                                                          [I]: WWe,
                                                                          [F]: [
                                                                            {
                                                                              [I]: WJ,
                                                                              error:
                                                                                "Access Points do not support S3 Accelerate",
                                                                              [T]: ye,
                                                                            },
                                                                            {
                                                                              [I]: [
                                                                                Ir,
                                                                                vr,
                                                                              ],
                                                                              endpoint:
                                                                                {
                                                                                  [_e]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                  [Ee]: zO,
                                                                                  [be]: We,
                                                                                },
                                                                              [T]: K,
                                                                            },
                                                                            {
                                                                              [I]: [
                                                                                Ir,
                                                                                yt,
                                                                              ],
                                                                              endpoint:
                                                                                {
                                                                                  [_e]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                  [Ee]: zO,
                                                                                  [be]: We,
                                                                                },
                                                                              [T]: K,
                                                                            },
                                                                            {
                                                                              [I]: [
                                                                                ut,
                                                                                vr,
                                                                              ],
                                                                              endpoint:
                                                                                {
                                                                                  [_e]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                  [Ee]: zO,
                                                                                  [be]: We,
                                                                                },
                                                                              [T]: K,
                                                                            },
                                                                            {
                                                                              [I]: [
                                                                                ut,
                                                                                yt,
                                                                                vn,
                                                                                ao,
                                                                              ],
                                                                              endpoint:
                                                                                {
                                                                                  [_e]: G4e,
                                                                                  [Ee]: zO,
                                                                                  [be]: We,
                                                                                },
                                                                              [T]: K,
                                                                            },
                                                                            {
                                                                              [I]: [
                                                                                ut,
                                                                                yt,
                                                                              ],
                                                                              endpoint:
                                                                                {
                                                                                  [_e]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                  [Ee]: zO,
                                                                                  [be]: We,
                                                                                },
                                                                              [T]: K,
                                                                            },
                                                                          ],
                                                                          [T]: U,
                                                                        },
                                                                        mWe,
                                                                      ],
                                                                      [T]: U,
                                                                    },
                                                                    UJ,
                                                                  ],
                                                                  [T]: U,
                                                                },
                                                                {
                                                                  error:
                                                                    "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}",
                                                                  [T]: ye,
                                                                },
                                                              ],
                                                              [T]: U,
                                                            },
                                                            HJ,
                                                          ],
                                                          [T]: U,
                                                        },
                                                        GJ,
                                                      ],
                                                      [T]: U,
                                                    },
                                                  ],
                                                  [T]: U,
                                                },
                                              ],
                                              [T]: U,
                                            },
                                            hWe,
                                          ],
                                          [T]: U,
                                        },
                                      ],
                                      [T]: U,
                                    },
                                  ],
                                  [T]: U,
                                },
                                {
                                  [I]: [{ [M]: $h, [q]: [cZ, bu] }],
                                  [F]: [
                                    {
                                      [I]: PWe,
                                      error:
                                        "S3 MRAP does not support dual-stack",
                                      [T]: ye,
                                    },
                                    {
                                      [I]: xE,
                                      error: "S3 MRAP does not support FIPS",
                                      [T]: ye,
                                    },
                                    {
                                      [I]: WJ,
                                      error:
                                        "S3 MRAP does not support S3 Accelerate",
                                      [T]: ye,
                                    },
                                    {
                                      [I]: [
                                        {
                                          [M]: _n,
                                          [q]: [
                                            {
                                              [xe]: "DisableMultiRegionAccessPoints",
                                            },
                                            bu,
                                          ],
                                        },
                                      ],
                                      error:
                                        "Invalid configuration: Multi-Region Access Point ARNs are disabled.",
                                      [T]: ye,
                                    },
                                    {
                                      [I]: [{ [M]: lB, [q]: KJ, [tt]: V4e }],
                                      [F]: [
                                        {
                                          [I]: [
                                            {
                                              [M]: xt,
                                              [q]: [
                                                {
                                                  [M]: tn,
                                                  [q]: [{ [xe]: V4e }, yn],
                                                },
                                                {
                                                  [M]: tn,
                                                  [q]: [Go, "partition"],
                                                },
                                              ],
                                            },
                                          ],
                                          [F]: [
                                            {
                                              endpoint: {
                                                [_e]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}",
                                                [Ee]: {
                                                  [Ki]: [
                                                    {
                                                      [ai]: bu,
                                                      name: oZ,
                                                      [si]: NE,
                                                      [nZ]: _0r,
                                                    },
                                                  ],
                                                },
                                                [be]: We,
                                              },
                                              [T]: K,
                                            },
                                          ],
                                          [T]: U,
                                        },
                                        {
                                          error:
                                            "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`",
                                          [T]: ye,
                                        },
                                      ],
                                      [T]: U,
                                    },
                                  ],
                                  [T]: U,
                                },
                                { error: "Invalid Access Point Name", [T]: ye },
                              ],
                              [T]: U,
                            },
                            gWe,
                          ],
                          [T]: U,
                        },
                        {
                          [I]: [{ [M]: xt, [q]: [jJ, WO] }],
                          [F]: [
                            {
                              [I]: PWe,
                              error: "S3 Outposts does not support Dual-stack",
                              [T]: ye,
                            },
                            {
                              [I]: xE,
                              error: "S3 Outposts does not support FIPS",
                              [T]: ye,
                            },
                            {
                              [I]: WJ,
                              error:
                                "S3 Outposts does not support S3 Accelerate",
                              [T]: ye,
                            },
                            {
                              [I]: [
                                {
                                  [M]: ha,
                                  [q]: [
                                    { [M]: tn, [q]: [Go, "resourceId[4]"] },
                                  ],
                                },
                              ],
                              error:
                                "Invalid Arn: Outpost Access Point ARN contains sub resources",
                              [T]: ye,
                            },
                            {
                              [I]: [{ [M]: tn, [q]: E0r, [tt]: eZ }],
                              [F]: [
                                {
                                  [I]: HWe,
                                  [F]: [
                                    FJ,
                                    {
                                      [I]: XJ,
                                      [F]: [
                                        {
                                          [I]: as,
                                          [F]: [
                                            {
                                              [I]: KWe,
                                              [F]: [
                                                {
                                                  [I]: JJ,
                                                  [F]: [
                                                    {
                                                      [I]: ZJ,
                                                      [F]: [
                                                        {
                                                          [I]: [
                                                            {
                                                              [M]: tn,
                                                              [q]: b0r,
                                                              [tt]: $4e,
                                                            },
                                                          ],
                                                          [F]: [
                                                            {
                                                              [I]: [
                                                                {
                                                                  [M]: tn,
                                                                  [q]: [
                                                                    Go,
                                                                    "resourceId[3]",
                                                                  ],
                                                                  [tt]: sZ,
                                                                },
                                                              ],
                                                              [F]: [
                                                                {
                                                                  [I]: [
                                                                    {
                                                                      [M]: xt,
                                                                      [q]: [
                                                                        {
                                                                          [xe]: $4e,
                                                                        },
                                                                        n6e,
                                                                      ],
                                                                    },
                                                                  ],
                                                                  [F]: [
                                                                    {
                                                                      [I]: IE,
                                                                      endpoint:
                                                                        {
                                                                          [_e]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}",
                                                                          [Ee]: vWe,
                                                                          [be]: We,
                                                                        },
                                                                      [T]: K,
                                                                    },
                                                                    {
                                                                      endpoint:
                                                                        {
                                                                          [_e]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                          [Ee]: vWe,
                                                                          [be]: We,
                                                                        },
                                                                      [T]: K,
                                                                    },
                                                                  ],
                                                                  [T]: U,
                                                                },
                                                                {
                                                                  error:
                                                                    "Expected an outpost type `accesspoint`, found {outpostType}",
                                                                  [T]: ye,
                                                                },
                                                              ],
                                                              [T]: U,
                                                            },
                                                            {
                                                              error:
                                                                "Invalid ARN: expected an access point name",
                                                              [T]: ye,
                                                            },
                                                          ],
                                                          [T]: U,
                                                        },
                                                        {
                                                          error:
                                                            "Invalid ARN: Expected a 4-component resource",
                                                          [T]: ye,
                                                        },
                                                      ],
                                                      [T]: U,
                                                    },
                                                    UJ,
                                                  ],
                                                  [T]: U,
                                                },
                                                HJ,
                                              ],
                                              [T]: U,
                                            },
                                            GJ,
                                          ],
                                          [T]: U,
                                        },
                                      ],
                                      [T]: U,
                                    },
                                  ],
                                  [T]: U,
                                },
                                {
                                  error:
                                    "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`",
                                  [T]: ye,
                                },
                              ],
                              [T]: U,
                            },
                            {
                              error: "Invalid ARN: The Outpost Id was not set",
                              [T]: ye,
                            },
                          ],
                          [T]: U,
                        },
                        {
                          error:
                            "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})",
                          [T]: ye,
                        },
                      ],
                      [T]: U,
                    },
                    { error: "Invalid ARN: No ARN type specified", [T]: ye },
                  ],
                  [T]: U,
                },
                {
                  [I]: [
                    { [M]: yr, [q]: [Pt, 0, 4, p0r], [tt]: z4e },
                    { [M]: xt, [q]: [{ [xe]: z4e }, "arn:"] },
                    { [M]: wu, [q]: [{ [M]: ha, [q]: [yWe] }] },
                  ],
                  error: "Invalid ARN: `{Bucket}` was not a valid ARN",
                  [T]: ye,
                },
                {
                  [I]: [{ [M]: _n, [q]: [m0r, bu] }, yWe],
                  error:
                    "Path-style addressing cannot be used with ARN buckets",
                  [T]: ye,
                },
                {
                  [I]: v0r,
                  [F]: [
                    {
                      [I]: as,
                      [F]: [
                        {
                          [I]: [Nn],
                          [F]: [
                            {
                              [I]: [vr, Qe, Ir, Vn],
                              endpoint: {
                                [_e]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                [Ee]: ni,
                                [be]: We,
                              },
                              [T]: K,
                            },
                            {
                              [I]: [vr, Qe, Ir, bt, ii],
                              [F]: [{ endpoint: _We, [T]: K }],
                              [T]: U,
                            },
                            {
                              [I]: [vr, Qe, Ir, bt, oi],
                              endpoint: _We,
                              [T]: K,
                            },
                            {
                              [I]: [yt, Qe, Ir, Vn],
                              endpoint: {
                                [_e]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                [Ee]: ni,
                                [be]: We,
                              },
                              [T]: K,
                            },
                            {
                              [I]: [yt, Qe, Ir, bt, ii],
                              [F]: [{ endpoint: EWe, [T]: K }],
                              [T]: U,
                            },
                            {
                              [I]: [yt, Qe, Ir, bt, oi],
                              endpoint: EWe,
                              [T]: K,
                            },
                            {
                              [I]: [vr, Qe, ut, Vn],
                              endpoint: {
                                [_e]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                [Ee]: ni,
                                [be]: We,
                              },
                              [T]: K,
                            },
                            {
                              [I]: [vr, Qe, ut, bt, ii],
                              [F]: [{ endpoint: bWe, [T]: K }],
                              [T]: U,
                            },
                            {
                              [I]: [vr, Qe, ut, bt, oi],
                              endpoint: bWe,
                              [T]: K,
                            },
                            {
                              [I]: [yt, vn, ao, ut, Vn],
                              endpoint: { [_e]: i6e, [Ee]: ni, [be]: We },
                              [T]: K,
                            },
                            {
                              [I]: [yt, vn, ao, ut, bt, ii],
                              [F]: [
                                { [I]: gp, endpoint: VJ, [T]: K },
                                { endpoint: VJ, [T]: K },
                              ],
                              [T]: U,
                            },
                            {
                              [I]: [yt, vn, ao, ut, bt, oi],
                              endpoint: VJ,
                              [T]: K,
                            },
                            {
                              [I]: [yt, Qe, ut, Vn],
                              endpoint: { [_e]: K4e, [Ee]: ni, [be]: We },
                              [T]: K,
                            },
                            {
                              [I]: [yt, Qe, ut, bt, ii],
                              [F]: [
                                {
                                  [I]: gp,
                                  endpoint: { [_e]: K4e, [Ee]: kn, [be]: We },
                                  [T]: K,
                                },
                                { endpoint: SWe, [T]: K },
                              ],
                              [T]: U,
                            },
                            {
                              [I]: [yt, Qe, ut, bt, oi],
                              endpoint: SWe,
                              [T]: K,
                            },
                          ],
                          [T]: U,
                        },
                        {
                          error:
                            "Path-style addressing cannot be used with S3 Accelerate",
                          [T]: ye,
                        },
                      ],
                      [T]: U,
                    },
                  ],
                  [T]: U,
                },
              ],
              [T]: U,
            },
            {
              [I]: [
                { [M]: ha, [q]: [CWe] },
                { [M]: _n, [q]: [CWe, bu] },
              ],
              [F]: [
                {
                  [I]: as,
                  [F]: [
                    {
                      [I]: QWe,
                      [F]: [
                        dWe,
                        fWe,
                        {
                          [I]: IE,
                          endpoint: { [_e]: uB, [Ee]: $J, [be]: We },
                          [T]: K,
                        },
                        {
                          [I]: xE,
                          endpoint: {
                            [_e]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}",
                            [Ee]: $J,
                            [be]: We,
                          },
                          [T]: K,
                        },
                        {
                          endpoint: {
                            [_e]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}",
                            [Ee]: $J,
                            [be]: We,
                          },
                          [T]: K,
                        },
                      ],
                      [T]: U,
                    },
                    cB,
                  ],
                  [T]: U,
                },
              ],
              [T]: U,
            },
            {
              [I]: [rWe],
              [F]: [
                {
                  [I]: as,
                  [F]: [
                    {
                      [I]: QWe,
                      [F]: [
                        {
                          [I]: [Ir, vr, Qe, Vn],
                          endpoint: {
                            [_e]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                            [Ee]: ni,
                            [be]: We,
                          },
                          [T]: K,
                        },
                        {
                          [I]: [Ir, vr, Qe, bt, ii],
                          [F]: [{ endpoint: wWe, [T]: K }],
                          [T]: U,
                        },
                        { [I]: [Ir, vr, Qe, bt, oi], endpoint: wWe, [T]: K },
                        {
                          [I]: [Ir, yt, Qe, Vn],
                          endpoint: {
                            [_e]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}",
                            [Ee]: ni,
                            [be]: We,
                          },
                          [T]: K,
                        },
                        {
                          [I]: [Ir, yt, Qe, bt, ii],
                          [F]: [{ endpoint: OWe, [T]: K }],
                          [T]: U,
                        },
                        { [I]: [Ir, yt, Qe, bt, oi], endpoint: OWe, [T]: K },
                        {
                          [I]: [ut, vr, Qe, Vn],
                          endpoint: {
                            [_e]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                            [Ee]: ni,
                            [be]: We,
                          },
                          [T]: K,
                        },
                        {
                          [I]: [ut, vr, Qe, bt, ii],
                          [F]: [{ endpoint: TWe, [T]: K }],
                          [T]: U,
                        },
                        { [I]: [ut, vr, Qe, bt, oi], endpoint: TWe, [T]: K },
                        {
                          [I]: [ut, yt, vn, ao, Vn],
                          endpoint: { [_e]: uB, [Ee]: ni, [be]: We },
                          [T]: K,
                        },
                        {
                          [I]: [ut, yt, vn, ao, bt, ii],
                          [F]: [
                            { [I]: gp, endpoint: zJ, [T]: K },
                            { endpoint: zJ, [T]: K },
                          ],
                          [T]: U,
                        },
                        { [I]: [ut, yt, vn, ao, bt, oi], endpoint: zJ, [T]: K },
                        {
                          [I]: [ut, yt, Qe, Vn],
                          endpoint: { [_e]: W4e, [Ee]: ni, [be]: We },
                          [T]: K,
                        },
                        {
                          [I]: [ut, yt, Qe, bt, ii],
                          [F]: [
                            {
                              [I]: gp,
                              endpoint: { [_e]: W4e, [Ee]: kn, [be]: We },
                              [T]: K,
                            },
                            { endpoint: AWe, [T]: K },
                          ],
                          [T]: U,
                        },
                        { [I]: [ut, yt, Qe, bt, oi], endpoint: AWe, [T]: K },
                      ],
                      [T]: U,
                    },
                    cB,
                  ],
                  [T]: U,
                },
              ],
              [T]: U,
            },
          ],
          [T]: U,
        },
        { error: "A region must be set when sending requests to S3.", [T]: ye },
      ],
    };
  mB.ruleSet = S0r;
});
var lZ = g((hB) => {
  "use strict";
  c();
  Object.defineProperty(hB, "__esModule", { value: !0 });
  hB.defaultEndpointResolver = void 0;
  var C0r = hE(),
    uZ = pE(),
    w0r = f6e(),
    O0r = new uZ.EndpointCache({
      size: 50,
      params: [
        "Accelerate",
        "Bucket",
        "DisableAccessPoints",
        "DisableMultiRegionAccessPoints",
        "DisableS3ExpressSessionAuth",
        "Endpoint",
        "ForcePathStyle",
        "Region",
        "UseArnRegion",
        "UseDualStack",
        "UseFIPS",
        "UseGlobalEndpoint",
        "UseObjectLambdaEndpoint",
        "UseS3ExpressControlEndpoint",
      ],
    }),
    T0r = (e, t = {}) =>
      O0r.get(e, () =>
        (0, uZ.resolveEndpoint)(w0r.ruleSet, {
          endpointParams: e,
          logger: t.logger,
        }),
      );
  hB.defaultEndpointResolver = T0r;
  uZ.customEndpointFunctions.aws = C0r.awsEndpointFunctions;
});
var dZ = g((vp) => {
  "use strict";
  c();
  Object.defineProperty(vp, "__esModule", { value: !0 });
  vp.resolveHttpAuthSchemeConfig =
    vp.defaultS3HttpAuthSchemeProvider =
    vp.defaultS3HttpAuthSchemeParametersProvider =
      void 0;
  var p6e = (ri(), ue(yu)),
    A0r = IJ(),
    P0r = Wl(),
    gB = tc(),
    R0r = lZ(),
    I0r = (e) => async (t, r, n) => {
      if (!n)
        throw new Error(
          "Could not find `input` for `defaultEndpointRuleSetHttpAuthSchemeParametersProvider`",
        );
      let i = await e(t, r, n),
        o = (0, gB.getSmithyContext)(r)?.commandInstance?.constructor
          ?.getEndpointParameterInstructions;
      if (!o)
        throw new Error(
          `getEndpointParameterInstructions() is not defined on \`${r.commandName}\``,
        );
      let a = await (0, P0r.resolveParams)(
        n,
        { getEndpointParameterInstructions: o },
        t,
      );
      return Object.assign(i, a);
    },
    x0r = async (e, t, r) => ({
      operation: (0, gB.getSmithyContext)(t).operation,
      region:
        (await (0, gB.normalizeProvider)(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`",
          );
        })(),
    });
  vp.defaultS3HttpAuthSchemeParametersProvider = I0r(x0r);
  function m6e(e) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: { name: "s3", region: e.region },
      propertiesExtractor: (t, r) => ({
        signingProperties: { config: t, context: r },
      }),
    };
  }
  function h6e(e) {
    return {
      schemeId: "aws.auth#sigv4a",
      signingProperties: { name: "s3", region: e.region },
      propertiesExtractor: (t, r) => ({
        signingProperties: { config: t, context: r },
      }),
    };
  }
  var N0r = (e, t, r) => (i) => {
      let a = e(i).properties?.authSchemes;
      if (!a) return t(i);
      let s = [];
      for (let u of a) {
        let { name: l, properties: d = {}, ...f } = u,
          m = l.toLowerCase();
        l !== m &&
          console.warn(
            `HttpAuthScheme has been normalized with lowercasing: \`${l}\` to \`${m}\``,
          );
        let h;
        if (m === "sigv4a") {
          h = "aws.auth#sigv4a";
          let E = a.find((b) => {
            let O = b.name.toLowerCase();
            return O !== "sigv4a" && O.startsWith("sigv4");
          });
          if (!A0r.signatureV4CrtContainer.CrtSignerV4 && E) continue;
        } else if (m.startsWith("sigv4")) h = "aws.auth#sigv4";
        else
          throw new Error(
            `Unknown HttpAuthScheme found in \`@smithy.rules#endpointRuleSet\`: \`${m}\``,
          );
        let y = r[h];
        if (!y)
          throw new Error(
            `Could not find HttpAuthOption create function for \`${h}\``,
          );
        let _ = y(i);
        (_.schemeId = h),
          (_.signingProperties = {
            ...(_.signingProperties || {}),
            ...f,
            ...d,
          }),
          s.push(_);
      }
      return s;
    },
    k0r = (e) => {
      let t = [];
      switch (e.operation) {
        default:
          t.push(m6e(e)), t.push(h6e(e));
      }
      return t;
    };
  vp.defaultS3HttpAuthSchemeProvider = N0r(R0r.defaultEndpointResolver, k0r, {
    "aws.auth#sigv4": m6e,
    "aws.auth#sigv4a": h6e,
  });
  var D0r = (e) => {
    let t = (0, p6e.resolveAwsSdkSigV4Config)(e),
      r = (0, p6e.resolveAwsSdkSigV4AConfig)(t);
    return Object.assign(r, {
      authSchemePreference: (0, gB.normalizeProvider)(
        e.authSchemePreference ?? [],
      ),
    });
  };
  vp.resolveHttpAuthSchemeConfig = D0r;
});
var b6e = g((Pzn, E6e) => {
  "use strict";
  c();
  var yB = Object.defineProperty,
    L0r = Object.getOwnPropertyDescriptor,
    M0r = Object.getOwnPropertyNames,
    q0r = Object.prototype.hasOwnProperty,
    _B = (e, t) => yB(e, "name", { value: t, configurable: !0 }),
    j0r = (e, t) => {
      for (var r in t) yB(e, r, { get: t[r], enumerable: !0 });
    },
    F0r = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of M0r(t))
          !q0r.call(e, i) &&
            i !== r &&
            yB(e, i, {
              get: () => t[i],
              enumerable: !(n = L0r(t, i)) || n.enumerable,
            });
      return e;
    },
    B0r = (e) => F0r(yB({}, "__esModule", { value: !0 }), e),
    g6e = {};
  j0r(g6e, { XmlNode: () => U0r, XmlText: () => _6e });
  E6e.exports = B0r(g6e);
  function v6e(e) {
    return e
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;");
  }
  _B(v6e, "escapeAttribute");
  function y6e(e) {
    return e
      .replace(/&/g, "&amp;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&apos;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\r/g, "&#x0D;")
      .replace(/\n/g, "&#x0A;")
      .replace(/\u0085/g, "&#x85;")
      .replace(/\u2028/, "&#x2028;");
  }
  _B(y6e, "escapeElement");
  var _6e = class {
      constructor(e) {
        this.value = e;
      }
      static {
        _B(this, "XmlText");
      }
      toString() {
        return y6e("" + this.value);
      }
    },
    U0r = class vB {
      constructor(t, r = []) {
        (this.name = t), (this.children = r);
      }
      static {
        _B(this, "XmlNode");
      }
      attributes = {};
      static of(t, r, n) {
        let i = new vB(t);
        return (
          r !== void 0 && i.addChildNode(new _6e(r)),
          n !== void 0 && i.withName(n),
          i
        );
      }
      withName(t) {
        return (this.name = t), this;
      }
      addAttribute(t, r) {
        return (this.attributes[t] = r), this;
      }
      addChildNode(t) {
        return this.children.push(t), this;
      }
      removeAttribute(t) {
        return delete this.attributes[t], this;
      }
      n(t) {
        return (this.name = t), this;
      }
      c(t) {
        return this.children.push(t), this;
      }
      a(t, r) {
        return r != null && (this.attributes[t] = r), this;
      }
      cc(t, r, n = r) {
        if (t[r] != null) {
          let i = vB.of(r, t[r]).withName(n);
          this.c(i);
        }
      }
      l(t, r, n, i) {
        t[r] != null &&
          i().map((a) => {
            a.withName(n), this.c(a);
          });
      }
      lc(t, r, n, i) {
        if (t[r] != null) {
          let o = i(),
            a = new vB(n);
          o.map((s) => {
            a.c(s);
          }),
            this.c(a);
        }
      }
      toString() {
        let t = !!this.children.length,
          r = `<${this.name}`,
          n = this.attributes;
        for (let i of Object.keys(n)) {
          let o = n[i];
          o != null && (r += ` ${i}="${v6e("" + o)}"`);
        }
        return (r += t
          ? `>${this.children.map((i) => i.toString()).join("")}</${this.name}>`
          : "/>");
      }
    };
});
var S6e = g((xzn, H0r) => {
  H0r.exports = {
    name: "@aws-sdk/client-s3",
    description:
      "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
    version: "3.800.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-s3",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps":
        "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client":
        "node ../../scripts/generate-clients/single-service --solo s3",
      test: "yarn g:vitest run",
      "test:browser":
        "node ./test/browser-build/esbuild && yarn g:vitest run -c vitest.config.browser.ts",
      "test:browser:watch":
        "node ./test/browser-build/esbuild && yarn g:vitest watch -c vitest.config.browser.ts",
      "test:e2e":
        "yarn g:vitest run -c vitest.config.e2e.ts && yarn test:browser",
      "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.ts",
      "test:watch": "yarn g:vitest watch",
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha1-browser": "5.2.0",
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.799.0",
      "@aws-sdk/credential-provider-node": "3.799.0",
      "@aws-sdk/middleware-bucket-endpoint": "3.775.0",
      "@aws-sdk/middleware-expect-continue": "3.775.0",
      "@aws-sdk/middleware-flexible-checksums": "3.799.0",
      "@aws-sdk/middleware-host-header": "3.775.0",
      "@aws-sdk/middleware-location-constraint": "3.775.0",
      "@aws-sdk/middleware-logger": "3.775.0",
      "@aws-sdk/middleware-recursion-detection": "3.775.0",
      "@aws-sdk/middleware-sdk-s3": "3.799.0",
      "@aws-sdk/middleware-ssec": "3.775.0",
      "@aws-sdk/middleware-user-agent": "3.799.0",
      "@aws-sdk/region-config-resolver": "3.775.0",
      "@aws-sdk/signature-v4-multi-region": "3.800.0",
      "@aws-sdk/types": "3.775.0",
      "@aws-sdk/util-endpoints": "3.787.0",
      "@aws-sdk/util-user-agent-browser": "3.775.0",
      "@aws-sdk/util-user-agent-node": "3.799.0",
      "@aws-sdk/xml-builder": "3.775.0",
      "@smithy/config-resolver": "^4.1.0",
      "@smithy/core": "^3.3.0",
      "@smithy/eventstream-serde-browser": "^4.0.2",
      "@smithy/eventstream-serde-config-resolver": "^4.1.0",
      "@smithy/eventstream-serde-node": "^4.0.2",
      "@smithy/fetch-http-handler": "^5.0.2",
      "@smithy/hash-blob-browser": "^4.0.2",
      "@smithy/hash-node": "^4.0.2",
      "@smithy/hash-stream-node": "^4.0.2",
      "@smithy/invalid-dependency": "^4.0.2",
      "@smithy/md5-js": "^4.0.2",
      "@smithy/middleware-content-length": "^4.0.2",
      "@smithy/middleware-endpoint": "^4.1.1",
      "@smithy/middleware-retry": "^4.1.1",
      "@smithy/middleware-serde": "^4.0.3",
      "@smithy/middleware-stack": "^4.0.2",
      "@smithy/node-config-provider": "^4.0.2",
      "@smithy/node-http-handler": "^4.0.4",
      "@smithy/protocol-http": "^5.1.0",
      "@smithy/smithy-client": "^4.2.1",
      "@smithy/types": "^4.2.0",
      "@smithy/url-parser": "^4.0.2",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.9",
      "@smithy/util-defaults-mode-node": "^4.0.9",
      "@smithy/util-endpoints": "^3.0.2",
      "@smithy/util-middleware": "^4.0.2",
      "@smithy/util-retry": "^4.0.2",
      "@smithy/util-stream": "^4.2.0",
      "@smithy/util-utf8": "^4.0.0",
      "@smithy/util-waiter": "^4.0.3",
      tslib: "^2.6.2",
    },
    devDependencies: {
      "@aws-sdk/signature-v4-crt": "3.800.0",
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.2.2",
    },
    engines: { node: ">=18.0.0" },
    typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/",
    },
    license: "Apache-2.0",
    browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native",
    },
    homepage:
      "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-s3",
    },
  };
});
var fZ = g((Nzn, I6e) => {
  "use strict";
  c();
  var EB = Object.defineProperty,
    G0r = Object.getOwnPropertyDescriptor,
    V0r = Object.getOwnPropertyNames,
    $0r = Object.prototype.hasOwnProperty,
    z0r = (e, t) => EB(e, "name", { value: t, configurable: !0 }),
    K0r = (e, t) => {
      for (var r in t) EB(e, r, { get: t[r], enumerable: !0 });
    },
    W0r = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of V0r(t))
          !$0r.call(e, i) &&
            i !== r &&
            EB(e, i, {
              get: () => t[i],
              enumerable: !(n = G0r(t, i)) || n.enumerable,
            });
      return e;
    },
    Q0r = (e) => W0r(EB({}, "__esModule", { value: !0 }), e),
    C6e = {};
  K0r(C6e, {
    ENV_ACCOUNT_ID: () => R6e,
    ENV_CREDENTIAL_SCOPE: () => P6e,
    ENV_EXPIRATION: () => A6e,
    ENV_KEY: () => w6e,
    ENV_SECRET: () => O6e,
    ENV_SESSION: () => T6e,
    fromEnv: () => J0r,
  });
  I6e.exports = Q0r(C6e);
  var Y0r = (gu(), ue(qh)),
    X0r = Ho(),
    w6e = "AWS_ACCESS_KEY_ID",
    O6e = "AWS_SECRET_ACCESS_KEY",
    T6e = "AWS_SESSION_TOKEN",
    A6e = "AWS_CREDENTIAL_EXPIRATION",
    P6e = "AWS_CREDENTIAL_SCOPE",
    R6e = "AWS_ACCOUNT_ID",
    J0r = z0r(
      (e) => async () => {
        e?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
        let t = process.env[w6e],
          r = process.env[O6e],
          n = process.env[T6e],
          i = process.env[A6e],
          o = process.env[P6e],
          a = process.env[R6e];
        if (t && r) {
          let s = {
            accessKeyId: t,
            secretAccessKey: r,
            ...(n && { sessionToken: n }),
            ...(i && { expiration: new Date(i) }),
            ...(o && { credentialScope: o }),
            ...(a && { accountId: a }),
          };
          return (
            (0, Y0r.setCredentialFeature)(s, "CREDENTIALS_ENV_VARS", "g"), s
          );
        }
        throw new X0r.CredentialsProviderError(
          "Unable to find environment variable credentials.",
          { logger: e?.logger },
        );
      },
      "fromEnv",
    );
});
var QO = g((Dzn, V6e) => {
  c();
  var CB = Object.defineProperty,
    Z0r = Object.getOwnPropertyDescriptor,
    eCr = Object.getOwnPropertyNames,
    tCr = Object.prototype.hasOwnProperty,
    Dn = (e, t) => CB(e, "name", { value: t, configurable: !0 }),
    rCr = (e, t) => {
      for (var r in t) CB(e, r, { get: t[r], enumerable: !0 });
    },
    nCr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of eCr(t))
          !tCr.call(e, i) &&
            i !== r &&
            CB(e, i, {
              get: () => t[i],
              enumerable: !(n = Z0r(t, i)) || n.enumerable,
            });
      return e;
    },
    iCr = (e) => nCr(CB({}, "__esModule", { value: !0 }), e),
    D6e = {};
  rCr(D6e, {
    DEFAULT_MAX_RETRIES: () => j6e,
    DEFAULT_TIMEOUT: () => q6e,
    ENV_CMDS_AUTH_TOKEN: () => hZ,
    ENV_CMDS_FULL_URI: () => bB,
    ENV_CMDS_RELATIVE_URI: () => SB,
    Endpoint: () => B6e,
    fromContainerMetadata: () => cCr,
    fromInstanceMetadata: () => RCr,
    getInstanceMetadataEndpoint: () => H6e,
    httpRequest: () => kE,
    providerConfigFromInit: () => gZ,
  });
  V6e.exports = iCr(D6e);
  var oCr = G("url"),
    Ou = Ho(),
    aCr = G("buffer"),
    sCr = G("http");
  function kE(e) {
    return new Promise((t, r) => {
      let n = (0, sCr.request)({
        method: "GET",
        ...e,
        hostname: e.hostname?.replace(/^\[(.+)\]$/, "$1"),
      });
      n.on("error", (i) => {
        r(
          Object.assign(
            new Ou.ProviderError(
              "Unable to connect to instance metadata service",
            ),
            i,
          ),
        ),
          n.destroy();
      }),
        n.on("timeout", () => {
          r(
            new Ou.ProviderError("TimeoutError from instance metadata service"),
          ),
            n.destroy();
        }),
        n.on("response", (i) => {
          let { statusCode: o = 400 } = i;
          (o < 200 || 300 <= o) &&
            (r(
              Object.assign(
                new Ou.ProviderError(
                  "Error response received from instance metadata service",
                ),
                { statusCode: o },
              ),
            ),
            n.destroy());
          let a = [];
          i.on("data", (s) => {
            a.push(s);
          }),
            i.on("end", () => {
              t(aCr.Buffer.concat(a)), n.destroy();
            });
        }),
        n.end();
    });
  }
  Dn(kE, "httpRequest");
  var L6e = Dn(
      (e) =>
        !!e &&
        typeof e == "object" &&
        typeof e.AccessKeyId == "string" &&
        typeof e.SecretAccessKey == "string" &&
        typeof e.Token == "string" &&
        typeof e.Expiration == "string",
      "isImdsCredentials",
    ),
    M6e = Dn(
      (e) => ({
        accessKeyId: e.AccessKeyId,
        secretAccessKey: e.SecretAccessKey,
        sessionToken: e.Token,
        expiration: new Date(e.Expiration),
        ...(e.AccountId && { accountId: e.AccountId }),
      }),
      "fromImdsCredentials",
    ),
    q6e = 1e3,
    j6e = 0,
    gZ = Dn(
      ({ maxRetries: e = j6e, timeout: t = q6e }) => ({
        maxRetries: e,
        timeout: t,
      }),
      "providerConfigFromInit",
    ),
    mZ = Dn((e, t) => {
      let r = e();
      for (let n = 0; n < t; n++) r = r.catch(e);
      return r;
    }, "retry"),
    bB = "AWS_CONTAINER_CREDENTIALS_FULL_URI",
    SB = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",
    hZ = "AWS_CONTAINER_AUTHORIZATION_TOKEN",
    cCr = Dn((e = {}) => {
      let { timeout: t, maxRetries: r } = gZ(e);
      return () =>
        mZ(async () => {
          let n = await pCr({ logger: e.logger }),
            i = JSON.parse(await uCr(t, n));
          if (!L6e(i))
            throw new Ou.CredentialsProviderError(
              "Invalid response received from instance metadata service.",
              { logger: e.logger },
            );
          return M6e(i);
        }, r);
    }, "fromContainerMetadata"),
    uCr = Dn(
      async (e, t) => (
        process.env[hZ] &&
          (t.headers = { ...t.headers, Authorization: process.env[hZ] }),
        (await kE({ ...t, timeout: e })).toString()
      ),
      "requestFromEcsImds",
    ),
    lCr = "169.254.170.2",
    dCr = { localhost: !0, "127.0.0.1": !0 },
    fCr = { "http:": !0, "https:": !0 },
    pCr = Dn(async ({ logger: e }) => {
      if (process.env[SB]) return { hostname: lCr, path: process.env[SB] };
      if (process.env[bB]) {
        let t = (0, oCr.parse)(process.env[bB]);
        if (!t.hostname || !(t.hostname in dCr))
          throw new Ou.CredentialsProviderError(
            `${t.hostname} is not a valid container metadata service hostname`,
            { tryNextLink: !1, logger: e },
          );
        if (!t.protocol || !(t.protocol in fCr))
          throw new Ou.CredentialsProviderError(
            `${t.protocol} is not a valid container metadata service protocol`,
            { tryNextLink: !1, logger: e },
          );
        return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 };
      }
      throw new Ou.CredentialsProviderError(
        `The container metadata credential provider cannot be used unless the ${SB} or ${bB} environment variable is set`,
        { tryNextLink: !1, logger: e },
      );
    }, "getCmdsUri"),
    mCr = class F6e extends Ou.CredentialsProviderError {
      constructor(t, r = !0) {
        super(t, r),
          (this.tryNextLink = r),
          (this.name = "InstanceMetadataV1FallbackError"),
          Object.setPrototypeOf(this, F6e.prototype);
      }
      static {
        Dn(this, "InstanceMetadataV1FallbackError");
      }
    },
    vZ = ro(),
    hCr = Hh(),
    B6e = ((e) => (
      (e.IPv4 = "http://169.254.169.254"),
      (e.IPv6 = "http://[fd00:ec2::254]"),
      e
    ))(B6e || {}),
    gCr = "AWS_EC2_METADATA_SERVICE_ENDPOINT",
    vCr = "ec2_metadata_service_endpoint",
    yCr = {
      environmentVariableSelector: (e) => e[gCr],
      configFileSelector: (e) => e[vCr],
      default: void 0,
    },
    U6e = ((e) => ((e.IPv4 = "IPv4"), (e.IPv6 = "IPv6"), e))(U6e || {}),
    _Cr = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE",
    ECr = "ec2_metadata_service_endpoint_mode",
    bCr = {
      environmentVariableSelector: (e) => e[_Cr],
      configFileSelector: (e) => e[ECr],
      default: "IPv4",
    },
    H6e = Dn(
      async () => (0, hCr.parseUrl)((await SCr()) || (await CCr())),
      "getInstanceMetadataEndpoint",
    ),
    SCr = Dn(async () => (0, vZ.loadConfig)(yCr)(), "getFromEndpointConfig"),
    CCr = Dn(async () => {
      let e = await (0, vZ.loadConfig)(bCr)();
      switch (e) {
        case "IPv4":
          return "http://169.254.169.254";
        case "IPv6":
          return "http://[fd00:ec2::254]";
        default:
          throw new Error(
            `Unsupported endpoint mode: ${e}. Select from ${Object.values(U6e)}`,
          );
      }
    }, "getFromEndpointModeConfig"),
    wCr = 5 * 60,
    OCr = 5 * 60,
    TCr =
      "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html",
    x6e = Dn((e, t) => {
      let r = wCr + Math.floor(Math.random() * OCr),
        n = new Date(Date.now() + r * 1e3);
      t.warn(
        `Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(n)}.
For more information, please visit: ` + TCr,
      );
      let i = e.originalExpiration ?? e.expiration;
      return { ...e, ...(i ? { originalExpiration: i } : {}), expiration: n };
    }, "getExtendedInstanceMetadataCredentials"),
    ACr = Dn((e, t = {}) => {
      let r = t?.logger || console,
        n;
      return async () => {
        let i;
        try {
          (i = await e()),
            i.expiration &&
              i.expiration.getTime() < Date.now() &&
              (i = x6e(i, r));
        } catch (o) {
          if (n) r.warn("Credential renew failed: ", o), (i = x6e(n, r));
          else throw o;
        }
        return (n = i), i;
      };
    }, "staticStabilityProvider"),
    G6e = "/latest/meta-data/iam/security-credentials/",
    PCr = "/latest/api/token",
    pZ = "AWS_EC2_METADATA_V1_DISABLED",
    N6e = "ec2_metadata_v1_disabled",
    k6e = "x-aws-ec2-metadata-token",
    RCr = Dn(
      (e = {}) => ACr(ICr(e), { logger: e.logger }),
      "fromInstanceMetadata",
    ),
    ICr = Dn((e = {}) => {
      let t = !1,
        { logger: r, profile: n } = e,
        { timeout: i, maxRetries: o } = gZ(e),
        a = Dn(async (s, u) => {
          if (t || u.headers?.[k6e] == null) {
            let f = !1,
              m = !1,
              h = await (0, vZ.loadConfig)(
                {
                  environmentVariableSelector: (y) => {
                    let _ = y[pZ];
                    if (((m = !!_ && _ !== "false"), _ === void 0))
                      throw new Ou.CredentialsProviderError(
                        `${pZ} not set in env, checking config file next.`,
                        { logger: e.logger },
                      );
                    return m;
                  },
                  configFileSelector: (y) => {
                    let _ = y[N6e];
                    return (f = !!_ && _ !== "false"), f;
                  },
                  default: !1,
                },
                { profile: n },
              )();
            if (e.ec2MetadataV1Disabled || h) {
              let y = [];
              throw (
                (e.ec2MetadataV1Disabled &&
                  y.push(
                    "credential provider initialization (runtime option ec2MetadataV1Disabled)",
                  ),
                f && y.push(`config file profile (${N6e})`),
                m && y.push(`process environment variable (${pZ})`),
                new mCr(
                  `AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${y.join(", ")}].`,
                ))
              );
            }
          }
          let d = (
            await mZ(async () => {
              let f;
              try {
                f = await NCr(u);
              } catch (m) {
                throw (m.statusCode === 401 && (t = !1), m);
              }
              return f;
            }, s)
          ).trim();
          return mZ(async () => {
            let f;
            try {
              f = await kCr(d, u, e);
            } catch (m) {
              throw (m.statusCode === 401 && (t = !1), m);
            }
            return f;
          }, s);
        }, "getCredentials");
      return async () => {
        let s = await H6e();
        if (t)
          return (
            r?.debug(
              "AWS SDK Instance Metadata",
              "using v1 fallback (no token fetch)",
            ),
            a(o, { ...s, timeout: i })
          );
        {
          let u;
          try {
            u = (await xCr({ ...s, timeout: i })).toString();
          } catch (l) {
            if (l?.statusCode === 400)
              throw Object.assign(l, {
                message: "EC2 Metadata token request returned error",
              });
            return (
              (l.message === "TimeoutError" ||
                [403, 404, 405].includes(l.statusCode)) &&
                (t = !0),
              r?.debug(
                "AWS SDK Instance Metadata",
                "using v1 fallback (initial)",
              ),
              a(o, { ...s, timeout: i })
            );
          }
          return a(o, { ...s, headers: { [k6e]: u }, timeout: i });
        }
      };
    }, "getInstanceMetadataProvider"),
    xCr = Dn(
      async (e) =>
        kE({
          ...e,
          path: PCr,
          method: "PUT",
          headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" },
        }),
      "getMetadataToken",
    ),
    NCr = Dn(
      async (e) => (await kE({ ...e, path: G6e })).toString(),
      "getProfile",
    ),
    kCr = Dn(async (e, t, r) => {
      let n = JSON.parse((await kE({ ...t, path: G6e + e })).toString());
      if (!L6e(n))
        throw new Ou.CredentialsProviderError(
          "Invalid response received from instance metadata service.",
          { logger: r.logger },
        );
      return M6e(n);
    }, "getCredentialsFromProfile");
});
var $6e = g((wB) => {
  "use strict";
  c();
  Object.defineProperty(wB, "__esModule", { value: !0 });
  wB.checkUrl = void 0;
  var DCr = Ho(),
    LCr = "169.254.170.2",
    MCr = "169.254.170.23",
    qCr = "[fd00:ec2::23]",
    jCr = (e, t) => {
      if (
        e.protocol !== "https:" &&
        !(e.hostname === LCr || e.hostname === MCr || e.hostname === qCr)
      ) {
        if (e.hostname.includes("[")) {
          if (
            e.hostname === "[::1]" ||
            e.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]"
          )
            return;
        } else {
          if (e.hostname === "localhost") return;
          let r = e.hostname.split("."),
            n = (i) => {
              let o = parseInt(i, 10);
              return 0 <= o && o <= 255;
            };
          if (r[0] === "127" && n(r[1]) && n(r[2]) && n(r[3]) && r.length === 4)
            return;
        }
        throw new DCr.CredentialsProviderError(
          `URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`,
          { logger: t },
        );
      }
    };
  wB.checkUrl = jCr;
});
var z6e = g((DE) => {
  "use strict";
  c();
  Object.defineProperty(DE, "__esModule", { value: !0 });
  DE.getCredentials = DE.createGetRequest = void 0;
  var yZ = Ho(),
    FCr = ln(),
    BCr = At(),
    UCr = r1();
  function HCr(e) {
    return new FCr.HttpRequest({
      protocol: e.protocol,
      hostname: e.hostname,
      port: Number(e.port),
      path: e.pathname,
      query: Array.from(e.searchParams.entries()).reduce(
        (t, [r, n]) => ((t[r] = n), t),
        {},
      ),
      fragment: e.hash,
    });
  }
  DE.createGetRequest = HCr;
  async function GCr(e, t) {
    let n = await (0, UCr.sdkStreamMixin)(e.body).transformToString();
    if (e.statusCode === 200) {
      let i = JSON.parse(n);
      if (
        typeof i.AccessKeyId != "string" ||
        typeof i.SecretAccessKey != "string" ||
        typeof i.Token != "string" ||
        typeof i.Expiration != "string"
      )
        throw new yZ.CredentialsProviderError(
          "HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }",
          { logger: t },
        );
      return {
        accessKeyId: i.AccessKeyId,
        secretAccessKey: i.SecretAccessKey,
        sessionToken: i.Token,
        expiration: (0, BCr.parseRfc3339DateTime)(i.Expiration),
      };
    }
    if (e.statusCode >= 400 && e.statusCode < 500) {
      let i = {};
      try {
        i = JSON.parse(n);
      } catch {}
      throw Object.assign(
        new yZ.CredentialsProviderError(
          `Server responded with status: ${e.statusCode}`,
          { logger: t },
        ),
        { Code: i.Code, Message: i.Message },
      );
    }
    throw new yZ.CredentialsProviderError(
      `Server responded with status: ${e.statusCode}`,
      { logger: t },
    );
  }
  DE.getCredentials = GCr;
});
var K6e = g((OB) => {
  "use strict";
  c();
  Object.defineProperty(OB, "__esModule", { value: !0 });
  OB.retryWrapper = void 0;
  var VCr = (e, t, r) => async () => {
    for (let n = 0; n < t; ++n)
      try {
        return await e();
      } catch {
        await new Promise((o) => setTimeout(o, r));
      }
    return await e();
  };
  OB.retryWrapper = VCr;
});
var Y6e = g((TB) => {
  "use strict";
  c();
  Object.defineProperty(TB, "__esModule", { value: !0 });
  TB.fromHttp = void 0;
  var $Cr = (go(), ue(ho)),
    zCr = (gu(), ue(qh)),
    KCr = Lh(),
    W6e = Ho(),
    WCr = $Cr.__importDefault(G("fs/promises")),
    QCr = $6e(),
    Q6e = z6e(),
    YCr = K6e(),
    XCr = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",
    JCr = "http://169.254.170.2",
    ZCr = "AWS_CONTAINER_CREDENTIALS_FULL_URI",
    ewr = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE",
    twr = "AWS_CONTAINER_AUTHORIZATION_TOKEN",
    rwr = (e = {}) => {
      e.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
      let t,
        r = e.awsContainerCredentialsRelativeUri ?? process.env[XCr],
        n = e.awsContainerCredentialsFullUri ?? process.env[ZCr],
        i = e.awsContainerAuthorizationToken ?? process.env[twr],
        o = e.awsContainerAuthorizationTokenFile ?? process.env[ewr],
        a =
          e.logger?.constructor?.name === "NoOpLogger" || !e.logger
            ? console.warn
            : e.logger.warn;
      if (
        (r &&
          n &&
          (a(
            "@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.",
          ),
          a("awsContainerCredentialsFullUri will take precedence.")),
        i &&
          o &&
          (a(
            "@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.",
          ),
          a("awsContainerAuthorizationToken will take precedence.")),
        n)
      )
        t = n;
      else if (r) t = `${JCr}${r}`;
      else
        throw new W6e.CredentialsProviderError(
          `No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`,
          { logger: e.logger },
        );
      let s = new URL(t);
      (0, QCr.checkUrl)(s, e.logger);
      let u = new KCr.NodeHttpHandler({
        requestTimeout: e.timeout ?? 1e3,
        connectionTimeout: e.timeout ?? 1e3,
      });
      return (0, YCr.retryWrapper)(
        async () => {
          let l = (0, Q6e.createGetRequest)(s);
          i
            ? (l.headers.Authorization = i)
            : o &&
              (l.headers.Authorization = (
                await WCr.default.readFile(o)
              ).toString());
          try {
            let d = await u.handle(l);
            return (0, Q6e.getCredentials)(d.response).then((f) =>
              (0, zCr.setCredentialFeature)(f, "CREDENTIALS_HTTP", "z"),
            );
          } catch (d) {
            throw new W6e.CredentialsProviderError(String(d), {
              logger: e.logger,
            });
          }
        },
        e.maxRetries ?? 3,
        e.timeout ?? 1e3,
      );
    };
  TB.fromHttp = rwr;
});
var _Z = g((AB) => {
  "use strict";
  c();
  Object.defineProperty(AB, "__esModule", { value: !0 });
  AB.fromHttp = void 0;
  var nwr = Y6e();
  Object.defineProperty(AB, "fromHttp", {
    enumerable: !0,
    get: function () {
      return nwr.fromHttp;
    },
  });
});
var bZ = g((yp) => {
  "use strict";
  c();
  Object.defineProperty(yp, "__esModule", { value: !0 });
  yp.resolveHttpAuthSchemeConfig =
    yp.defaultSSOHttpAuthSchemeProvider =
    yp.defaultSSOHttpAuthSchemeParametersProvider =
      void 0;
  var iwr = (ri(), ue(yu)),
    EZ = tc(),
    owr = async (e, t, r) => ({
      operation: (0, EZ.getSmithyContext)(t).operation,
      region:
        (await (0, EZ.normalizeProvider)(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`",
          );
        })(),
    });
  yp.defaultSSOHttpAuthSchemeParametersProvider = owr;
  function awr(e) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: { name: "awsssoportal", region: e.region },
      propertiesExtractor: (t, r) => ({
        signingProperties: { config: t, context: r },
      }),
    };
  }
  function PB(e) {
    return { schemeId: "smithy.api#noAuth" };
  }
  var swr = (e) => {
    let t = [];
    switch (e.operation) {
      case "GetRoleCredentials": {
        t.push(PB(e));
        break;
      }
      case "ListAccountRoles": {
        t.push(PB(e));
        break;
      }
      case "ListAccounts": {
        t.push(PB(e));
        break;
      }
      case "Logout": {
        t.push(PB(e));
        break;
      }
      default:
        t.push(awr(e));
    }
    return t;
  };
  yp.defaultSSOHttpAuthSchemeProvider = swr;
  var cwr = (e) => {
    let t = (0, iwr.resolveAwsSdkSigV4Config)(e);
    return Object.assign(t, {
      authSchemePreference: (0, EZ.normalizeProvider)(
        e.authSchemePreference ?? [],
      ),
    });
  };
  yp.resolveHttpAuthSchemeConfig = cwr;
});
var X6e = g((Wzn, uwr) => {
  uwr.exports = {
    name: "@aws-sdk/client-sso",
    description:
      "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.799.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps":
        "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client":
        "node ../../scripts/generate-clients/single-service --solo sso",
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.799.0",
      "@aws-sdk/middleware-host-header": "3.775.0",
      "@aws-sdk/middleware-logger": "3.775.0",
      "@aws-sdk/middleware-recursion-detection": "3.775.0",
      "@aws-sdk/middleware-user-agent": "3.799.0",
      "@aws-sdk/region-config-resolver": "3.775.0",
      "@aws-sdk/types": "3.775.0",
      "@aws-sdk/util-endpoints": "3.787.0",
      "@aws-sdk/util-user-agent-browser": "3.775.0",
      "@aws-sdk/util-user-agent-node": "3.799.0",
      "@smithy/config-resolver": "^4.1.0",
      "@smithy/core": "^3.3.0",
      "@smithy/fetch-http-handler": "^5.0.2",
      "@smithy/hash-node": "^4.0.2",
      "@smithy/invalid-dependency": "^4.0.2",
      "@smithy/middleware-content-length": "^4.0.2",
      "@smithy/middleware-endpoint": "^4.1.1",
      "@smithy/middleware-retry": "^4.1.1",
      "@smithy/middleware-serde": "^4.0.3",
      "@smithy/middleware-stack": "^4.0.2",
      "@smithy/node-config-provider": "^4.0.2",
      "@smithy/node-http-handler": "^4.0.4",
      "@smithy/protocol-http": "^5.1.0",
      "@smithy/smithy-client": "^4.2.1",
      "@smithy/types": "^4.2.0",
      "@smithy/url-parser": "^4.0.2",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.9",
      "@smithy/util-defaults-mode-node": "^4.0.9",
      "@smithy/util-endpoints": "^3.0.2",
      "@smithy/util-middleware": "^4.0.2",
      "@smithy/util-retry": "^4.0.2",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2",
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.2.2",
    },
    engines: { node: ">=18.0.0" },
    typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/",
    },
    license: "Apache-2.0",
    browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native",
    },
    homepage:
      "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso",
    },
  };
});
var YO = g((Qzn, i8e) => {
  "use strict";
  c();
  var IB = Object.defineProperty,
    lwr = Object.getOwnPropertyDescriptor,
    dwr = Object.getOwnPropertyNames,
    fwr = Object.prototype.hasOwnProperty,
    RB = (e, t) => IB(e, "name", { value: t, configurable: !0 }),
    pwr = (e, t) => {
      for (var r in t) IB(e, r, { get: t[r], enumerable: !0 });
    },
    mwr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of dwr(t))
          !fwr.call(e, i) &&
            i !== r &&
            IB(e, i, {
              get: () => t[i],
              enumerable: !(n = lwr(t, i)) || n.enumerable,
            });
      return e;
    },
    hwr = (e) => mwr(IB({}, "__esModule", { value: !0 }), e),
    Z6e = {};
  pwr(Z6e, {
    NODE_APP_ID_CONFIG_OPTIONS: () => Ewr,
    UA_APP_ID_ENV_NAME: () => r8e,
    UA_APP_ID_INI_NAME: () => n8e,
    createDefaultUserAgentProvider: () => t8e,
    crtAvailability: () => e8e,
    defaultUserAgent: () => vwr,
  });
  i8e.exports = hwr(Z6e);
  var J6e = G("os"),
    SZ = G("process"),
    e8e = { isCrtAvailable: !1 },
    gwr = RB(
      () => (e8e.isCrtAvailable ? ["md/crt-avail"] : null),
      "isCrtAvailable",
    ),
    t8e = RB(
      ({ serviceId: e, clientVersion: t }) =>
        async (r) => {
          let n = [
              ["aws-sdk-js", t],
              ["ua", "2.1"],
              [`os/${(0, J6e.platform)()}`, (0, J6e.release)()],
              ["lang/js"],
              ["md/nodejs", `${SZ.versions.node}`],
            ],
            i = gwr();
          i && n.push(i),
            e && n.push([`api/${e}`, t]),
            SZ.env.AWS_EXECUTION_ENV &&
              n.push([`exec-env/${SZ.env.AWS_EXECUTION_ENV}`]);
          let o = await r?.userAgentAppId?.();
          return o ? [...n, [`app/${o}`]] : [...n];
        },
      "createDefaultUserAgentProvider",
    ),
    vwr = t8e,
    ywr = CE(),
    r8e = "AWS_SDK_UA_APP_ID",
    n8e = "sdk_ua_app_id",
    _wr = "sdk-ua-app-id",
    Ewr = {
      environmentVariableSelector: RB(
        (e) => e[r8e],
        "environmentVariableSelector",
      ),
      configFileSelector: RB((e) => e[n8e] ?? e[_wr], "configFileSelector"),
      default: ywr.DEFAULT_UA_APP_ID,
    };
});
var XO = g((Xzn, c8e) => {
  c();
  var xB = Object.defineProperty,
    bwr = Object.getOwnPropertyDescriptor,
    Swr = Object.getOwnPropertyNames,
    Cwr = Object.prototype.hasOwnProperty,
    a8e = (e, t) => xB(e, "name", { value: t, configurable: !0 }),
    wwr = (e, t) => {
      for (var r in t) xB(e, r, { get: t[r], enumerable: !0 });
    },
    Owr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Swr(t))
          !Cwr.call(e, i) &&
            i !== r &&
            xB(e, i, {
              get: () => t[i],
              enumerable: !(n = bwr(t, i)) || n.enumerable,
            });
      return e;
    },
    Twr = (e) => Owr(xB({}, "__esModule", { value: !0 }), e),
    s8e = {};
  wwr(s8e, { Hash: () => Rwr });
  c8e.exports = Twr(s8e);
  var CZ = Hi(),
    Awr = Fe(),
    Pwr = G("buffer"),
    o8e = G("crypto"),
    Rwr = class {
      static {
        a8e(this, "Hash");
      }
      constructor(e, t) {
        (this.algorithmIdentifier = e), (this.secret = t), this.reset();
      }
      update(e, t) {
        this.hash.update((0, Awr.toUint8Array)(wZ(e, t)));
      }
      digest() {
        return Promise.resolve(this.hash.digest());
      }
      reset() {
        this.hash = this.secret
          ? (0, o8e.createHmac)(this.algorithmIdentifier, wZ(this.secret))
          : (0, o8e.createHash)(this.algorithmIdentifier);
      }
    };
  function wZ(e, t) {
    return Pwr.Buffer.isBuffer(e)
      ? e
      : typeof e == "string"
        ? (0, CZ.fromString)(e, t)
        : ArrayBuffer.isView(e)
          ? (0, CZ.fromArrayBuffer)(e.buffer, e.byteOffset, e.byteLength)
          : (0, CZ.fromArrayBuffer)(e);
  }
  a8e(wZ, "castSourceData");
});
var C8e = g((NB) => {
  "use strict";
  c();
  Object.defineProperty(NB, "__esModule", { value: !0 });
  NB.ruleSet = void 0;
  var _8e = "required",
    us = "fn",
    ls = "argv",
    qE = "ref",
    u8e = !0,
    l8e = "isSet",
    JO = "booleanEquals",
    LE = "error",
    ME = "endpoint",
    Ql = "tree",
    OZ = "PartitionResult",
    TZ = "getAttr",
    d8e = { [_8e]: !1, type: "String" },
    f8e = { [_8e]: !0, default: !1, type: "Boolean" },
    p8e = { [qE]: "Endpoint" },
    E8e = { [us]: JO, [ls]: [{ [qE]: "UseFIPS" }, !0] },
    b8e = { [us]: JO, [ls]: [{ [qE]: "UseDualStack" }, !0] },
    cs = {},
    m8e = { [us]: TZ, [ls]: [{ [qE]: OZ }, "supportsFIPS"] },
    S8e = { [qE]: OZ },
    h8e = {
      [us]: JO,
      [ls]: [!0, { [us]: TZ, [ls]: [S8e, "supportsDualStack"] }],
    },
    g8e = [E8e],
    v8e = [b8e],
    y8e = [{ [qE]: "Region" }],
    Iwr = {
      version: "1.0",
      parameters: {
        Region: d8e,
        UseDualStack: f8e,
        UseFIPS: f8e,
        Endpoint: d8e,
      },
      rules: [
        {
          conditions: [{ [us]: l8e, [ls]: [p8e] }],
          rules: [
            {
              conditions: g8e,
              error:
                "Invalid Configuration: FIPS and custom endpoint are not supported",
              type: LE,
            },
            {
              conditions: v8e,
              error:
                "Invalid Configuration: Dualstack and custom endpoint are not supported",
              type: LE,
            },
            { endpoint: { url: p8e, properties: cs, headers: cs }, type: ME },
          ],
          type: Ql,
        },
        {
          conditions: [{ [us]: l8e, [ls]: y8e }],
          rules: [
            {
              conditions: [{ [us]: "aws.partition", [ls]: y8e, assign: OZ }],
              rules: [
                {
                  conditions: [E8e, b8e],
                  rules: [
                    {
                      conditions: [{ [us]: JO, [ls]: [u8e, m8e] }, h8e],
                      rules: [
                        {
                          endpoint: {
                            url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                            properties: cs,
                            headers: cs,
                          },
                          type: ME,
                        },
                      ],
                      type: Ql,
                    },
                    {
                      error:
                        "FIPS and DualStack are enabled, but this partition does not support one or both",
                      type: LE,
                    },
                  ],
                  type: Ql,
                },
                {
                  conditions: g8e,
                  rules: [
                    {
                      conditions: [{ [us]: JO, [ls]: [m8e, u8e] }],
                      rules: [
                        {
                          conditions: [
                            {
                              [us]: "stringEquals",
                              [ls]: [
                                { [us]: TZ, [ls]: [S8e, "name"] },
                                "aws-us-gov",
                              ],
                            },
                          ],
                          endpoint: {
                            url: "https://portal.sso.{Region}.amazonaws.com",
                            properties: cs,
                            headers: cs,
                          },
                          type: ME,
                        },
                        {
                          endpoint: {
                            url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                            properties: cs,
                            headers: cs,
                          },
                          type: ME,
                        },
                      ],
                      type: Ql,
                    },
                    {
                      error:
                        "FIPS is enabled but this partition does not support FIPS",
                      type: LE,
                    },
                  ],
                  type: Ql,
                },
                {
                  conditions: v8e,
                  rules: [
                    {
                      conditions: [h8e],
                      rules: [
                        {
                          endpoint: {
                            url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                            properties: cs,
                            headers: cs,
                          },
                          type: ME,
                        },
                      ],
                      type: Ql,
                    },
                    {
                      error:
                        "DualStack is enabled but this partition does not support DualStack",
                      type: LE,
                    },
                  ],
                  type: Ql,
                },
                {
                  endpoint: {
                    url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
                    properties: cs,
                    headers: cs,
                  },
                  type: ME,
                },
              ],
              type: Ql,
            },
          ],
          type: Ql,
        },
        { error: "Invalid Configuration: Missing Region", type: LE },
      ],
    };
  NB.ruleSet = Iwr;
});
var w8e = g((kB) => {
  "use strict";
  c();
  Object.defineProperty(kB, "__esModule", { value: !0 });
  kB.defaultEndpointResolver = void 0;
  var xwr = hE(),
    AZ = pE(),
    Nwr = C8e(),
    kwr = new AZ.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
    }),
    Dwr = (e, t = {}) =>
      kwr.get(e, () =>
        (0, AZ.resolveEndpoint)(Nwr.ruleSet, {
          endpointParams: e,
          logger: t.logger,
        }),
      );
  kB.defaultEndpointResolver = Dwr;
  AZ.customEndpointFunctions.aws = xwr.awsEndpointFunctions;
});
var A8e = g((DB) => {
  "use strict";
  c();
  Object.defineProperty(DB, "__esModule", { value: !0 });
  DB.getRuntimeConfig = void 0;
  var Lwr = (ri(), ue(yu)),
    Mwr = (Gn(), ue(rc)),
    qwr = At(),
    jwr = Hh(),
    O8e = fu(),
    T8e = Fe(),
    Fwr = bZ(),
    Bwr = w8e(),
    Uwr = (e) => ({
      apiVersion: "2019-06-10",
      base64Decoder: e?.base64Decoder ?? O8e.fromBase64,
      base64Encoder: e?.base64Encoder ?? O8e.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? Bwr.defaultEndpointResolver,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider:
        e?.httpAuthSchemeProvider ?? Fwr.defaultSSOHttpAuthSchemeProvider,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new Lwr.AwsSdkSigV4Signer(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Mwr.NoAuthSigner(),
        },
      ],
      logger: e?.logger ?? new qwr.NoOpLogger(),
      serviceId: e?.serviceId ?? "SSO",
      urlParser: e?.urlParser ?? jwr.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? T8e.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? T8e.toUtf8,
    });
  DB.getRuntimeConfig = Uwr;
});
var eT = g((a2n, k8e) => {
  c();
  var Hwr = Object.create,
    ZO = Object.defineProperty,
    Gwr = Object.getOwnPropertyDescriptor,
    Vwr = Object.getOwnPropertyNames,
    $wr = Object.getPrototypeOf,
    zwr = Object.prototype.hasOwnProperty,
    PZ = (e, t) => ZO(e, "name", { value: t, configurable: !0 }),
    Kwr = (e, t) => {
      for (var r in t) ZO(e, r, { get: t[r], enumerable: !0 });
    },
    x8e = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Vwr(t))
          !zwr.call(e, i) &&
            i !== r &&
            ZO(e, i, {
              get: () => t[i],
              enumerable: !(n = Gwr(t, i)) || n.enumerable,
            });
      return e;
    },
    Wwr = (e, t, r) => (
      (r = e != null ? Hwr($wr(e)) : {}),
      x8e(
        t || !e || !e.__esModule
          ? ZO(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    Qwr = (e) => x8e(ZO({}, "__esModule", { value: !0 }), e),
    N8e = {};
  Kwr(N8e, { resolveDefaultsModeConfig: () => oOr });
  k8e.exports = Qwr(N8e);
  var Ywr = Eu(),
    P8e = ro(),
    Xwr = Ho(),
    Jwr = "AWS_EXECUTION_ENV",
    R8e = "AWS_REGION",
    I8e = "AWS_DEFAULT_REGION",
    Zwr = "AWS_EC2_METADATA_DISABLED",
    eOr = ["in-region", "cross-region", "mobile", "standard", "legacy"],
    tOr = "/latest/meta-data/placement/region",
    rOr = "AWS_DEFAULTS_MODE",
    nOr = "defaults_mode",
    iOr = {
      environmentVariableSelector: (e) => e[rOr],
      configFileSelector: (e) => e[nOr],
      default: "legacy",
    },
    oOr = PZ(
      ({
        region: e = (0, P8e.loadConfig)(Ywr.NODE_REGION_CONFIG_OPTIONS),
        defaultsMode: t = (0, P8e.loadConfig)(iOr),
      } = {}) =>
        (0, Xwr.memoize)(async () => {
          let r = typeof t == "function" ? await t() : t;
          switch (r?.toLowerCase()) {
            case "auto":
              return aOr(e);
            case "in-region":
            case "cross-region":
            case "mobile":
            case "standard":
            case "legacy":
              return Promise.resolve(r?.toLocaleLowerCase());
            case void 0:
              return Promise.resolve("legacy");
            default:
              throw new Error(
                `Invalid parameter for "defaultsMode", expect ${eOr.join(", ")}, got ${r}`,
              );
          }
        }),
      "resolveDefaultsModeConfig",
    ),
    aOr = PZ(async (e) => {
      if (e) {
        let t = typeof e == "function" ? await e() : e,
          r = await sOr();
        return r ? (t === r ? "in-region" : "cross-region") : "standard";
      }
      return "standard";
    }, "resolveNodeDefaultsModeAuto"),
    sOr = PZ(async () => {
      if (process.env[Jwr] && (process.env[R8e] || process.env[I8e]))
        return process.env[R8e] ?? process.env[I8e];
      if (!process.env[Zwr])
        try {
          let { getInstanceMetadataEndpoint: e, httpRequest: t } =
              await Promise.resolve().then(() => Wwr(QO())),
            r = await e();
          return (await t({ ...r, path: tOr })).toString();
        } catch {}
    }, "inferPhysicalRegion");
});
var j8e = g((MB) => {
  "use strict";
  c();
  Object.defineProperty(MB, "__esModule", { value: !0 });
  MB.getRuntimeConfig = void 0;
  var cOr = (go(), ue(ho)),
    uOr = cOr.__importDefault(X6e()),
    D8e = (ri(), ue(yu)),
    L8e = YO(),
    LB = Eu(),
    lOr = XO(),
    M8e = Kl(),
    zh = ro(),
    q8e = Lh(),
    dOr = yl(),
    fOr = OE(),
    pOr = A8e(),
    mOr = At(),
    hOr = eT(),
    gOr = At(),
    vOr = (e) => {
      (0, gOr.emitWarningIfUnsupportedVersion)(process.version);
      let t = (0, hOr.resolveDefaultsModeConfig)(e),
        r = () => t().then(mOr.loadConfigsForDefaultMode),
        n = (0, pOr.getRuntimeConfig)(e);
      (0, D8e.emitWarningIfUnsupportedVersion)(process.version);
      let i = { profile: e?.profile };
      return {
        ...n,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference:
          e?.authSchemePreference ??
          (0, zh.loadConfig)(D8e.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, i),
        bodyLengthChecker: e?.bodyLengthChecker ?? dOr.calculateBodyLength,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          (0, L8e.createDefaultUserAgentProvider)({
            serviceId: n.serviceId,
            clientVersion: uOr.default.version,
          }),
        maxAttempts:
          e?.maxAttempts ??
          (0, zh.loadConfig)(M8e.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, e),
        region:
          e?.region ??
          (0, zh.loadConfig)(LB.NODE_REGION_CONFIG_OPTIONS, {
            ...LB.NODE_REGION_CONFIG_FILE_OPTIONS,
            ...i,
          }),
        requestHandler: q8e.NodeHttpHandler.create(e?.requestHandler ?? r),
        retryMode:
          e?.retryMode ??
          (0, zh.loadConfig)(
            {
              ...M8e.NODE_RETRY_MODE_CONFIG_OPTIONS,
              default: async () =>
                (await r()).retryMode || fOr.DEFAULT_RETRY_MODE,
            },
            e,
          ),
        sha256: e?.sha256 ?? lOr.Hash.bind(null, "sha256"),
        streamCollector: e?.streamCollector ?? q8e.streamCollector,
        useDualstackEndpoint:
          e?.useDualstackEndpoint ??
          (0, zh.loadConfig)(LB.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, i),
        useFipsEndpoint:
          e?.useFipsEndpoint ??
          (0, zh.loadConfig)(LB.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, i),
        userAgentAppId:
          e?.userAgentAppId ??
          (0, zh.loadConfig)(L8e.NODE_APP_ID_CONFIG_OPTIONS, i),
      };
    };
  MB.getRuntimeConfig = vOr;
});
var tT = g((l2n, V8e) => {
  "use strict";
  c();
  var qB = Object.defineProperty,
    yOr = Object.getOwnPropertyDescriptor,
    _Or = Object.getOwnPropertyNames,
    EOr = Object.prototype.hasOwnProperty,
    Tu = (e, t) => qB(e, "name", { value: t, configurable: !0 }),
    bOr = (e, t) => {
      for (var r in t) qB(e, r, { get: t[r], enumerable: !0 });
    },
    SOr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of _Or(t))
          !EOr.call(e, i) &&
            i !== r &&
            qB(e, i, {
              get: () => t[i],
              enumerable: !(n = yOr(t, i)) || n.enumerable,
            });
      return e;
    },
    COr = (e) => SOr(qB({}, "__esModule", { value: !0 }), e),
    B8e = {};
  bOr(B8e, {
    NODE_REGION_CONFIG_FILE_OPTIONS: () => AOr,
    NODE_REGION_CONFIG_OPTIONS: () => TOr,
    REGION_ENV_NAME: () => U8e,
    REGION_INI_NAME: () => H8e,
    getAwsRegionExtensionConfiguration: () => wOr,
    resolveAwsRegionExtensionConfiguration: () => OOr,
    resolveRegionConfig: () => POr,
  });
  V8e.exports = COr(B8e);
  var wOr = Tu(
      (e) => ({
        setRegion(t) {
          e.region = t;
        },
        region() {
          return e.region;
        },
      }),
      "getAwsRegionExtensionConfiguration",
    ),
    OOr = Tu(
      (e) => ({ region: e.region() }),
      "resolveAwsRegionExtensionConfiguration",
    ),
    U8e = "AWS_REGION",
    H8e = "region",
    TOr = {
      environmentVariableSelector: Tu(
        (e) => e[U8e],
        "environmentVariableSelector",
      ),
      configFileSelector: Tu((e) => e[H8e], "configFileSelector"),
      default: Tu(() => {
        throw new Error("Region is missing");
      }, "default"),
    },
    AOr = { preferredFile: "credentials" },
    G8e = Tu(
      (e) =>
        typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips")),
      "isFipsRegion",
    ),
    F8e = Tu(
      (e) =>
        G8e(e)
          ? ["fips-aws-global", "aws-fips"].includes(e)
            ? "us-east-1"
            : e.replace(/fips-(dkr-|prod-)?|-fips/, "")
          : e,
      "getRealRegion",
    ),
    POr = Tu((e) => {
      let { region: t, useFipsEndpoint: r } = e;
      if (!t) throw new Error("Region is missing");
      return Object.assign(e, {
        region: Tu(async () => {
          if (typeof t == "string") return F8e(t);
          let n = await t();
          return F8e(n);
        }, "region"),
        useFipsEndpoint: Tu(async () => {
          let n = typeof t == "string" ? t : await t();
          return G8e(n)
            ? !0
            : typeof r != "function"
              ? Promise.resolve(!!r)
              : r();
        }, "useFipsEndpoint"),
      });
    }, "resolveRegionConfig");
});
var C5e = g((f2n, S5e) => {
  "use strict";
  c();
  var jB = Object.defineProperty,
    ROr = Object.getOwnPropertyDescriptor,
    IOr = Object.getOwnPropertyNames,
    xOr = Object.prototype.hasOwnProperty,
    St = (e, t) => jB(e, "name", { value: t, configurable: !0 }),
    NOr = (e, t) => {
      for (var r in t) jB(e, r, { get: t[r], enumerable: !0 });
    },
    kOr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of IOr(t))
          !xOr.call(e, i) &&
            i !== r &&
            jB(e, i, {
              get: () => t[i],
              enumerable: !(n = ROr(t, i)) || n.enumerable,
            });
      return e;
    },
    DOr = (e) => kOr(jB({}, "__esModule", { value: !0 }), e),
    X8e = {};
  NOr(X8e, {
    GetRoleCredentialsCommand: () => _5e,
    GetRoleCredentialsRequestFilterSensitiveLog: () => s5e,
    GetRoleCredentialsResponseFilterSensitiveLog: () => u5e,
    InvalidRequestException: () => Z8e,
    ListAccountRolesCommand: () => RZ,
    ListAccountRolesRequestFilterSensitiveLog: () => l5e,
    ListAccountsCommand: () => IZ,
    ListAccountsRequestFilterSensitiveLog: () => d5e,
    LogoutCommand: () => E5e,
    LogoutRequestFilterSensitiveLog: () => f5e,
    ResourceNotFoundException: () => t5e,
    RoleCredentialsFilterSensitiveLog: () => c5e,
    SSO: () => b5e,
    SSOClient: () => BB,
    SSOServiceException: () => jE,
    TooManyRequestsException: () => n5e,
    UnauthorizedException: () => o5e,
    __Client: () => Ae.Client,
    paginateListAccountRoles: () => aTr,
    paginateListAccounts: () => sTr,
  });
  S5e.exports = DOr(X8e);
  var $8e = uO(),
    LOr = lO(),
    MOr = dO(),
    z8e = CE(),
    qOr = Eu(),
    Yl = (Gn(), ue(rc)),
    jOr = FO(),
    nT = Wl(),
    K8e = Kl(),
    W8e = bZ(),
    FOr = St(
      (e) =>
        Object.assign(e, {
          useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
          useFipsEndpoint: e.useFipsEndpoint ?? !1,
          defaultSigningName: "awsssoportal",
        }),
      "resolveClientEndpointParameters",
    ),
    FB = {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
    },
    BOr = j8e(),
    Q8e = tT(),
    Y8e = ln(),
    Ae = At(),
    UOr = St((e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        n = e.credentials;
      return {
        setHttpAuthScheme(i) {
          let o = t.findIndex((a) => a.schemeId === i.schemeId);
          o === -1 ? t.push(i) : t.splice(o, 1, i);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(i) {
          r = i;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(i) {
          n = i;
        },
        credentials() {
          return n;
        },
      };
    }, "getHttpAuthExtensionConfiguration"),
    HOr = St(
      (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }),
      "resolveHttpAuthRuntimeConfig",
    ),
    GOr = St((e, t) => {
      let r = Object.assign(
        (0, Q8e.getAwsRegionExtensionConfiguration)(e),
        (0, Ae.getDefaultExtensionConfiguration)(e),
        (0, Y8e.getHttpHandlerExtensionConfiguration)(e),
        UOr(e),
      );
      return (
        t.forEach((n) => n.configure(r)),
        Object.assign(
          e,
          (0, Q8e.resolveAwsRegionExtensionConfiguration)(r),
          (0, Ae.resolveDefaultRuntimeConfig)(r),
          (0, Y8e.resolveHttpHandlerRuntimeConfig)(r),
          HOr(r),
        )
      );
    }, "resolveRuntimeExtensions"),
    BB = class extends Ae.Client {
      static {
        St(this, "SSOClient");
      }
      config;
      constructor(...[e]) {
        let t = (0, BOr.getRuntimeConfig)(e || {});
        super(t), (this.initConfig = t);
        let r = FOr(t),
          n = (0, z8e.resolveUserAgentConfig)(r),
          i = (0, K8e.resolveRetryConfig)(n),
          o = (0, qOr.resolveRegionConfig)(i),
          a = (0, $8e.resolveHostHeaderConfig)(o),
          s = (0, nT.resolveEndpointConfig)(a),
          u = (0, W8e.resolveHttpAuthSchemeConfig)(s),
          l = GOr(u, e?.extensions || []);
        (this.config = l),
          this.middlewareStack.use((0, z8e.getUserAgentPlugin)(this.config)),
          this.middlewareStack.use((0, K8e.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, jOr.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, $8e.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, LOr.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, MOr.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use(
            (0, Yl.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
              httpAuthSchemeParametersProvider:
                W8e.defaultSSOHttpAuthSchemeParametersProvider,
              identityProviderConfigProvider: St(
                async (d) =>
                  new Yl.DefaultIdentityProviderConfig({
                    "aws.auth#sigv4": d.credentials,
                  }),
                "identityProviderConfigProvider",
              ),
            }),
          ),
          this.middlewareStack.use((0, Yl.getHttpSigningPlugin)(this.config));
      }
      destroy() {
        super.destroy();
      }
    },
    UB = ip(),
    jE = class J8e extends Ae.ServiceException {
      static {
        St(this, "SSOServiceException");
      }
      constructor(t) {
        super(t), Object.setPrototypeOf(this, J8e.prototype);
      }
    },
    Z8e = class e5e extends jE {
      static {
        St(this, "InvalidRequestException");
      }
      name = "InvalidRequestException";
      $fault = "client";
      constructor(t) {
        super({ name: "InvalidRequestException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e5e.prototype);
      }
    },
    t5e = class r5e extends jE {
      static {
        St(this, "ResourceNotFoundException");
      }
      name = "ResourceNotFoundException";
      $fault = "client";
      constructor(t) {
        super({ name: "ResourceNotFoundException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, r5e.prototype);
      }
    },
    n5e = class i5e extends jE {
      static {
        St(this, "TooManyRequestsException");
      }
      name = "TooManyRequestsException";
      $fault = "client";
      constructor(t) {
        super({ name: "TooManyRequestsException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, i5e.prototype);
      }
    },
    o5e = class a5e extends jE {
      static {
        St(this, "UnauthorizedException");
      }
      name = "UnauthorizedException";
      $fault = "client";
      constructor(t) {
        super({ name: "UnauthorizedException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, a5e.prototype);
      }
    },
    s5e = St(
      (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: Ae.SENSITIVE_STRING }),
      }),
      "GetRoleCredentialsRequestFilterSensitiveLog",
    ),
    c5e = St(
      (e) => ({
        ...e,
        ...(e.secretAccessKey && { secretAccessKey: Ae.SENSITIVE_STRING }),
        ...(e.sessionToken && { sessionToken: Ae.SENSITIVE_STRING }),
      }),
      "RoleCredentialsFilterSensitiveLog",
    ),
    u5e = St(
      (e) => ({
        ...e,
        ...(e.roleCredentials && { roleCredentials: c5e(e.roleCredentials) }),
      }),
      "GetRoleCredentialsResponseFilterSensitiveLog",
    ),
    l5e = St(
      (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: Ae.SENSITIVE_STRING }),
      }),
      "ListAccountRolesRequestFilterSensitiveLog",
    ),
    d5e = St(
      (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: Ae.SENSITIVE_STRING }),
      }),
      "ListAccountsRequestFilterSensitiveLog",
    ),
    f5e = St(
      (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: Ae.SENSITIVE_STRING }),
      }),
      "LogoutRequestFilterSensitiveLog",
    ),
    rT = (ri(), ue(yu)),
    VOr = St(async (e, t) => {
      let r = (0, Yl.requestBuilder)(e, t),
        n = (0, Ae.map)({}, Ae.isSerializableHeaderValue, { [VB]: e[GB] });
      r.bp("/federation/credentials");
      let i = (0, Ae.map)({
        [iTr]: [, (0, Ae.expectNonNull)(e[nTr], "roleName")],
        [m5e]: [, (0, Ae.expectNonNull)(e[p5e], "accountId")],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetRoleCredentialsCommand"),
    $Or = St(async (e, t) => {
      let r = (0, Yl.requestBuilder)(e, t),
        n = (0, Ae.map)({}, Ae.isSerializableHeaderValue, { [VB]: e[GB] });
      r.bp("/assignment/roles");
      let i = (0, Ae.map)({
        [y5e]: [, e[v5e]],
        [g5e]: [() => e.maxResults !== void 0, () => e[h5e].toString()],
        [m5e]: [, (0, Ae.expectNonNull)(e[p5e], "accountId")],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListAccountRolesCommand"),
    zOr = St(async (e, t) => {
      let r = (0, Yl.requestBuilder)(e, t),
        n = (0, Ae.map)({}, Ae.isSerializableHeaderValue, { [VB]: e[GB] });
      r.bp("/assignment/accounts");
      let i = (0, Ae.map)({
        [y5e]: [, e[v5e]],
        [g5e]: [() => e.maxResults !== void 0, () => e[h5e].toString()],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListAccountsCommand"),
    KOr = St(async (e, t) => {
      let r = (0, Yl.requestBuilder)(e, t),
        n = (0, Ae.map)({}, Ae.isSerializableHeaderValue, { [VB]: e[GB] });
      return (
        r.bp("/logout"),
        r
          .m("POST")
          .h(n)
          .b(void 0),
        r.build()
      );
    }, "se_LogoutCommand"),
    WOr = St(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return HB(e, t);
      let r = (0, Ae.map)({ $metadata: _p(e) }),
        n = (0, Ae.expectNonNull)(
          (0, Ae.expectObject)(await (0, rT.parseJsonBody)(e.body, t)),
          "body",
        ),
        i = (0, Ae.take)(n, { roleCredentials: Ae._json });
      return Object.assign(r, i), r;
    }, "de_GetRoleCredentialsCommand"),
    QOr = St(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return HB(e, t);
      let r = (0, Ae.map)({ $metadata: _p(e) }),
        n = (0, Ae.expectNonNull)(
          (0, Ae.expectObject)(await (0, rT.parseJsonBody)(e.body, t)),
          "body",
        ),
        i = (0, Ae.take)(n, { nextToken: Ae.expectString, roleList: Ae._json });
      return Object.assign(r, i), r;
    }, "de_ListAccountRolesCommand"),
    YOr = St(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return HB(e, t);
      let r = (0, Ae.map)({ $metadata: _p(e) }),
        n = (0, Ae.expectNonNull)(
          (0, Ae.expectObject)(await (0, rT.parseJsonBody)(e.body, t)),
          "body",
        ),
        i = (0, Ae.take)(n, {
          accountList: Ae._json,
          nextToken: Ae.expectString,
        });
      return Object.assign(r, i), r;
    }, "de_ListAccountsCommand"),
    XOr = St(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return HB(e, t);
      let r = (0, Ae.map)({ $metadata: _p(e) });
      return await (0, Ae.collectBody)(e.body, t), r;
    }, "de_LogoutCommand"),
    HB = St(async (e, t) => {
      let r = { ...e, body: await (0, rT.parseJsonErrorBody)(e.body, t) },
        n = (0, rT.loadRestJsonErrorCode)(e, r.body);
      switch (n) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
          throw await ZOr(r, t);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
          throw await eTr(r, t);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
          throw await tTr(r, t);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
          throw await rTr(r, t);
        default:
          let i = r.body;
          return JOr({ output: e, parsedBody: i, errorCode: n });
      }
    }, "de_CommandError"),
    JOr = (0, Ae.withBaseException)(jE),
    ZOr = St(async (e, t) => {
      let r = (0, Ae.map)({}),
        n = e.body,
        i = (0, Ae.take)(n, { message: Ae.expectString });
      Object.assign(r, i);
      let o = new Z8e({ $metadata: _p(e), ...r });
      return (0, Ae.decorateServiceException)(o, e.body);
    }, "de_InvalidRequestExceptionRes"),
    eTr = St(async (e, t) => {
      let r = (0, Ae.map)({}),
        n = e.body,
        i = (0, Ae.take)(n, { message: Ae.expectString });
      Object.assign(r, i);
      let o = new t5e({ $metadata: _p(e), ...r });
      return (0, Ae.decorateServiceException)(o, e.body);
    }, "de_ResourceNotFoundExceptionRes"),
    tTr = St(async (e, t) => {
      let r = (0, Ae.map)({}),
        n = e.body,
        i = (0, Ae.take)(n, { message: Ae.expectString });
      Object.assign(r, i);
      let o = new n5e({ $metadata: _p(e), ...r });
      return (0, Ae.decorateServiceException)(o, e.body);
    }, "de_TooManyRequestsExceptionRes"),
    rTr = St(async (e, t) => {
      let r = (0, Ae.map)({}),
        n = e.body,
        i = (0, Ae.take)(n, { message: Ae.expectString });
      Object.assign(r, i);
      let o = new o5e({ $metadata: _p(e), ...r });
      return (0, Ae.decorateServiceException)(o, e.body);
    }, "de_UnauthorizedExceptionRes"),
    _p = St(
      (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }),
      "deserializeMetadata",
    ),
    p5e = "accountId",
    GB = "accessToken",
    m5e = "account_id",
    h5e = "maxResults",
    g5e = "max_result",
    v5e = "nextToken",
    y5e = "next_token",
    nTr = "roleName",
    iTr = "role_name",
    VB = "x-amz-sso_bearer_token",
    _5e = class extends Ae.Command.classBuilder()
      .ep(FB)
      .m(function (e, t, r, n) {
        return [
          (0, UB.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, nT.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("SWBPortalService", "GetRoleCredentials", {})
      .n("SSOClient", "GetRoleCredentialsCommand")
      .f(s5e, u5e)
      .ser(VOr)
      .de(WOr)
      .build() {
      static {
        St(this, "GetRoleCredentialsCommand");
      }
    },
    RZ = class extends Ae.Command.classBuilder()
      .ep(FB)
      .m(function (e, t, r, n) {
        return [
          (0, UB.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, nT.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("SWBPortalService", "ListAccountRoles", {})
      .n("SSOClient", "ListAccountRolesCommand")
      .f(l5e, void 0)
      .ser($Or)
      .de(QOr)
      .build() {
      static {
        St(this, "ListAccountRolesCommand");
      }
    },
    IZ = class extends Ae.Command.classBuilder()
      .ep(FB)
      .m(function (e, t, r, n) {
        return [
          (0, UB.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, nT.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("SWBPortalService", "ListAccounts", {})
      .n("SSOClient", "ListAccountsCommand")
      .f(d5e, void 0)
      .ser(zOr)
      .de(YOr)
      .build() {
      static {
        St(this, "ListAccountsCommand");
      }
    },
    E5e = class extends Ae.Command.classBuilder()
      .ep(FB)
      .m(function (e, t, r, n) {
        return [
          (0, UB.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, nT.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("SWBPortalService", "Logout", {})
      .n("SSOClient", "LogoutCommand")
      .f(f5e, void 0)
      .ser(KOr)
      .de(XOr)
      .build() {
      static {
        St(this, "LogoutCommand");
      }
    },
    oTr = {
      GetRoleCredentialsCommand: _5e,
      ListAccountRolesCommand: RZ,
      ListAccountsCommand: IZ,
      LogoutCommand: E5e,
    },
    b5e = class extends BB {
      static {
        St(this, "SSO");
      }
    };
  (0, Ae.createAggregatedClient)(oTr, b5e);
  var aTr = (0, Yl.createPaginator)(
      BB,
      RZ,
      "nextToken",
      "nextToken",
      "maxResults",
    ),
    sTr = (0, Yl.createPaginator)(
      BB,
      IZ,
      "nextToken",
      "nextToken",
      "maxResults",
    );
});
function cTr(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "sso-oauth", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
function uTr(e) {
  return { schemeId: "smithy.api#noAuth" };
}
var iT,
  w5e,
  O5e,
  T5e,
  xZ = w(() => {
    c();
    ri();
    (iT = A(tc())),
      (w5e = async (e, t, r) => ({
        operation: (0, iT.getSmithyContext)(t).operation,
        region:
          (await (0, iT.normalizeProvider)(e.region)()) ||
          (() => {
            throw new Error(
              "expected `region` to be configured for `aws.auth#sigv4`",
            );
          })(),
      }));
    (O5e = (e) => {
      let t = [];
      switch (e.operation) {
        case "CreateToken": {
          t.push(uTr(e));
          break;
        }
        default:
          t.push(cTr(e));
      }
      return t;
    }),
      (T5e = (e) => {
        let t = _E(e);
        return Object.assign(t, {
          authSchemePreference: (0, iT.normalizeProvider)(
            e.authSchemePreference ?? [],
          ),
        });
      });
  });
var A5e,
  P5e,
  NZ = w(() => {
    c();
    (A5e = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        defaultSigningName: "sso-oauth",
      })),
      (P5e = {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var $B,
  kZ = w(() => {
    $B = {
      name: "@aws-sdk/nested-clients",
      version: "3.799.0",
      description: "Nested clients for AWS SDK packages.",
      main: "./dist-cjs/index.js",
      module: "./dist-es/index.js",
      types: "./dist-types/index.d.ts",
      scripts: {
        build:
          "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline nested-clients",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps":
          "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
        test: "yarn g:vitest run",
        "test:watch": "yarn g:vitest watch",
      },
      engines: { node: ">=18.0.0" },
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/",
      },
      license: "Apache-2.0",
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.799.0",
        "@aws-sdk/middleware-host-header": "3.775.0",
        "@aws-sdk/middleware-logger": "3.775.0",
        "@aws-sdk/middleware-recursion-detection": "3.775.0",
        "@aws-sdk/middleware-user-agent": "3.799.0",
        "@aws-sdk/region-config-resolver": "3.775.0",
        "@aws-sdk/types": "3.775.0",
        "@aws-sdk/util-endpoints": "3.787.0",
        "@aws-sdk/util-user-agent-browser": "3.775.0",
        "@aws-sdk/util-user-agent-node": "3.799.0",
        "@smithy/config-resolver": "^4.1.0",
        "@smithy/core": "^3.3.0",
        "@smithy/fetch-http-handler": "^5.0.2",
        "@smithy/hash-node": "^4.0.2",
        "@smithy/invalid-dependency": "^4.0.2",
        "@smithy/middleware-content-length": "^4.0.2",
        "@smithy/middleware-endpoint": "^4.1.1",
        "@smithy/middleware-retry": "^4.1.1",
        "@smithy/middleware-serde": "^4.0.3",
        "@smithy/middleware-stack": "^4.0.2",
        "@smithy/node-config-provider": "^4.0.2",
        "@smithy/node-http-handler": "^4.0.4",
        "@smithy/protocol-http": "^5.1.0",
        "@smithy/smithy-client": "^4.2.1",
        "@smithy/types": "^4.2.0",
        "@smithy/url-parser": "^4.0.2",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.9",
        "@smithy/util-defaults-mode-node": "^4.0.9",
        "@smithy/util-endpoints": "^3.0.2",
        "@smithy/util-middleware": "^4.0.2",
        "@smithy/util-retry": "^4.0.2",
        "@smithy/util-utf8": "^4.0.0",
        tslib: "^2.6.2",
      },
      devDependencies: {
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.2.2",
      },
      typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
      files: [
        "./sso-oidc.d.ts",
        "./sso-oidc.js",
        "./sts.d.ts",
        "./sts.js",
        "dist-*/**",
      ],
      browser: {
        "./dist-es/submodules/sso-oidc/runtimeConfig":
          "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
        "./dist-es/submodules/sts/runtimeConfig":
          "./dist-es/submodules/sts/runtimeConfig.browser",
      },
      "react-native": {},
      homepage:
        "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "packages/nested-clients",
      },
      exports: {
        "./sso-oidc": {
          types: "./dist-types/submodules/sso-oidc/index.d.ts",
          module: "./dist-es/submodules/sso-oidc/index.js",
          node: "./dist-cjs/submodules/sso-oidc/index.js",
          import: "./dist-es/submodules/sso-oidc/index.js",
          require: "./dist-cjs/submodules/sso-oidc/index.js",
        },
        "./sts": {
          types: "./dist-types/submodules/sts/index.d.ts",
          module: "./dist-es/submodules/sts/index.js",
          node: "./dist-cjs/submodules/sts/index.js",
          import: "./dist-es/submodules/sts/index.js",
          require: "./dist-cjs/submodules/sts/index.js",
        },
      },
    };
  });
var j5e,
  fs,
  ps,
  UE,
  R5e,
  oT,
  FE,
  BE,
  Xl,
  DZ,
  LZ,
  I5e,
  x5e,
  N5e,
  F5e,
  B5e,
  ds,
  k5e,
  U5e,
  D5e,
  L5e,
  M5e,
  q5e,
  dTr,
  H5e,
  G5e = w(() => {
    c();
    (j5e = "required"),
      (fs = "fn"),
      (ps = "argv"),
      (UE = "ref"),
      (R5e = "isSet"),
      (oT = "booleanEquals"),
      (FE = "error"),
      (BE = "endpoint"),
      (Xl = "tree"),
      (DZ = "PartitionResult"),
      (LZ = "getAttr"),
      (I5e = { [j5e]: !1, type: "String" }),
      (x5e = { [j5e]: !0, default: !1, type: "Boolean" }),
      (N5e = { [UE]: "Endpoint" }),
      (F5e = { [fs]: oT, [ps]: [{ [UE]: "UseFIPS" }, !0] }),
      (B5e = { [fs]: oT, [ps]: [{ [UE]: "UseDualStack" }, !0] }),
      (ds = {}),
      (k5e = { [fs]: LZ, [ps]: [{ [UE]: DZ }, "supportsFIPS"] }),
      (U5e = { [UE]: DZ }),
      (D5e = {
        [fs]: oT,
        [ps]: [!0, { [fs]: LZ, [ps]: [U5e, "supportsDualStack"] }],
      }),
      (L5e = [F5e]),
      (M5e = [B5e]),
      (q5e = [{ [UE]: "Region" }]),
      (dTr = {
        version: "1.0",
        parameters: {
          Region: I5e,
          UseDualStack: x5e,
          UseFIPS: x5e,
          Endpoint: I5e,
        },
        rules: [
          {
            conditions: [{ [fs]: R5e, [ps]: [N5e] }],
            rules: [
              {
                conditions: L5e,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                type: FE,
              },
              {
                conditions: M5e,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                type: FE,
              },
              { endpoint: { url: N5e, properties: ds, headers: ds }, type: BE },
            ],
            type: Xl,
          },
          {
            conditions: [{ [fs]: R5e, [ps]: q5e }],
            rules: [
              {
                conditions: [{ [fs]: "aws.partition", [ps]: q5e, assign: DZ }],
                rules: [
                  {
                    conditions: [F5e, B5e],
                    rules: [
                      {
                        conditions: [{ [fs]: oT, [ps]: [!0, k5e] }, D5e],
                        rules: [
                          {
                            endpoint: {
                              url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: ds,
                              headers: ds,
                            },
                            type: BE,
                          },
                        ],
                        type: Xl,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        type: FE,
                      },
                    ],
                    type: Xl,
                  },
                  {
                    conditions: L5e,
                    rules: [
                      {
                        conditions: [{ [fs]: oT, [ps]: [k5e, !0] }],
                        rules: [
                          {
                            conditions: [
                              {
                                [fs]: "stringEquals",
                                [ps]: [
                                  { [fs]: LZ, [ps]: [U5e, "name"] },
                                  "aws-us-gov",
                                ],
                              },
                            ],
                            endpoint: {
                              url: "https://oidc.{Region}.amazonaws.com",
                              properties: ds,
                              headers: ds,
                            },
                            type: BE,
                          },
                          {
                            endpoint: {
                              url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: ds,
                              headers: ds,
                            },
                            type: BE,
                          },
                        ],
                        type: Xl,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        type: FE,
                      },
                    ],
                    type: Xl,
                  },
                  {
                    conditions: M5e,
                    rules: [
                      {
                        conditions: [D5e],
                        rules: [
                          {
                            endpoint: {
                              url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: ds,
                              headers: ds,
                            },
                            type: BE,
                          },
                        ],
                        type: Xl,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        type: FE,
                      },
                    ],
                    type: Xl,
                  },
                  {
                    endpoint: {
                      url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}",
                      properties: ds,
                      headers: ds,
                    },
                    type: BE,
                  },
                ],
                type: Xl,
              },
            ],
            type: Xl,
          },
          { error: "Invalid Configuration: Missing Region", type: FE },
        ],
      }),
      (H5e = dTr);
  });
var V5e,
  HE,
  fTr,
  $5e,
  z5e = w(() => {
    c();
    (V5e = A(hE())), (HE = A(pE()));
    G5e();
    (fTr = new HE.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
    })),
      ($5e = (e, t = {}) =>
        fTr.get(e, () =>
          (0, HE.resolveEndpoint)(H5e, { endpointParams: e, logger: t.logger }),
        ));
    HE.customEndpointFunctions.aws = V5e.awsEndpointFunctions;
  });
var K5e,
  W5e,
  zB,
  KB,
  Q5e,
  Y5e = w(() => {
    c();
    ri();
    Gn();
    (K5e = A(At())), (W5e = A(Hh())), (zB = A(fu())), (KB = A(Fe()));
    xZ();
    z5e();
    Q5e = (e) => ({
      apiVersion: "2019-06-10",
      base64Decoder: e?.base64Decoder ?? zB.fromBase64,
      base64Encoder: e?.base64Encoder ?? zB.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? $5e,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? O5e,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new ma(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Vl(),
        },
      ],
      logger: e?.logger ?? new K5e.NoOpLogger(),
      serviceId: e?.serviceId ?? "SSO OIDC",
      urlParser: e?.urlParser ?? W5e.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? KB.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? KB.toUtf8,
    });
  });
var WB,
  bp,
  X5e,
  QB,
  Ep,
  YB,
  J5e,
  Z5e,
  eQe,
  tQe,
  rQe,
  nQe,
  iQe = w(() => {
    c();
    kZ();
    ri();
    (WB = A(YO())),
      (bp = A(Eu())),
      (X5e = A(XO())),
      (QB = A(Kl())),
      (Ep = A(ro())),
      (YB = A(Lh())),
      (J5e = A(yl())),
      (Z5e = A(OE()));
    Y5e();
    (eQe = A(At())),
      (tQe = A(eT())),
      (rQe = A(At())),
      (nQe = (e) => {
        (0, rQe.emitWarningIfUnsupportedVersion)(process.version);
        let t = (0, tQe.resolveDefaultsModeConfig)(e),
          r = () => t().then(eQe.loadConfigsForDefaultMode),
          n = Q5e(e);
        gE(process.version);
        let i = { profile: e?.profile };
        return {
          ...n,
          ...e,
          runtime: "node",
          defaultsMode: t,
          authSchemePreference:
            e?.authSchemePreference ?? (0, Ep.loadConfig)(NO, i),
          bodyLengthChecker: e?.bodyLengthChecker ?? J5e.calculateBodyLength,
          defaultUserAgentProvider:
            e?.defaultUserAgentProvider ??
            (0, WB.createDefaultUserAgentProvider)({
              serviceId: n.serviceId,
              clientVersion: $B.version,
            }),
          maxAttempts:
            e?.maxAttempts ??
            (0, Ep.loadConfig)(QB.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, e),
          region:
            e?.region ??
            (0, Ep.loadConfig)(bp.NODE_REGION_CONFIG_OPTIONS, {
              ...bp.NODE_REGION_CONFIG_FILE_OPTIONS,
              ...i,
            }),
          requestHandler: YB.NodeHttpHandler.create(e?.requestHandler ?? r),
          retryMode:
            e?.retryMode ??
            (0, Ep.loadConfig)(
              {
                ...QB.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () =>
                  (await r()).retryMode || Z5e.DEFAULT_RETRY_MODE,
              },
              e,
            ),
          sha256: e?.sha256 ?? X5e.Hash.bind(null, "sha256"),
          streamCollector: e?.streamCollector ?? YB.streamCollector,
          useDualstackEndpoint:
            e?.useDualstackEndpoint ??
            (0, Ep.loadConfig)(
              bp.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS,
              i,
            ),
          useFipsEndpoint:
            e?.useFipsEndpoint ??
            (0, Ep.loadConfig)(bp.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, i),
          userAgentAppId:
            e?.userAgentAppId ??
            (0, Ep.loadConfig)(WB.NODE_APP_ID_CONFIG_OPTIONS, i),
        };
      });
  });
var oQe,
  aQe,
  sQe = w(() => {
    c();
    (oQe = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        n = e.credentials;
      return {
        setHttpAuthScheme(i) {
          let o = t.findIndex((a) => a.schemeId === i.schemeId);
          o === -1 ? t.push(i) : t.splice(o, 1, i);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(i) {
          r = i;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(i) {
          n = i;
        },
        credentials() {
          return n;
        },
      };
    }),
      (aQe = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var XB,
  JB,
  ZB,
  cQe,
  uQe = w(() => {
    c();
    (XB = A(tT())), (JB = A(ln())), (ZB = A(At()));
    sQe();
    cQe = (e, t) => {
      let r = Object.assign(
        (0, XB.getAwsRegionExtensionConfiguration)(e),
        (0, ZB.getDefaultExtensionConfiguration)(e),
        (0, JB.getHttpHandlerExtensionConfiguration)(e),
        oQe(e),
      );
      return (
        t.forEach((n) => n.configure(r)),
        Object.assign(
          e,
          (0, XB.resolveAwsRegionExtensionConfiguration)(r),
          (0, ZB.resolveDefaultRuntimeConfig)(r),
          (0, JB.resolveHttpHandlerRuntimeConfig)(r),
          aQe(r),
        )
      );
    };
  });
var eU,
  lQe,
  dQe,
  tU,
  fQe,
  pQe,
  mQe,
  rU,
  MZ,
  aT,
  qZ = w(() => {
    c();
    (eU = A(uO())),
      (lQe = A(lO())),
      (dQe = A(dO())),
      (tU = A(CE())),
      (fQe = A(Eu()));
    Gn();
    (pQe = A(FO())), (mQe = A(Wl())), (rU = A(Kl())), (MZ = A(At()));
    xZ();
    NZ();
    iQe();
    uQe();
    aT = class extends MZ.Client {
      config;
      constructor(...[t]) {
        let r = nQe(t || {});
        super(r), (this.initConfig = r);
        let n = A5e(r),
          i = (0, tU.resolveUserAgentConfig)(n),
          o = (0, rU.resolveRetryConfig)(i),
          a = (0, fQe.resolveRegionConfig)(o),
          s = (0, eU.resolveHostHeaderConfig)(a),
          u = (0, mQe.resolveEndpointConfig)(s),
          l = T5e(u),
          d = cQe(l, t?.extensions || []);
        (this.config = d),
          this.middlewareStack.use((0, tU.getUserAgentPlugin)(this.config)),
          this.middlewareStack.use((0, rU.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, pQe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, eU.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, lQe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, dQe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use(
            OO(this.config, {
              httpAuthSchemeParametersProvider: w5e,
              identityProviderConfigProvider: async (f) =>
                new Mh({ "aws.auth#sigv4": f.credentials }),
            }),
          ),
          this.middlewareStack.use(TO(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var hQe,
  ci,
  nU = w(() => {
    c();
    (hQe = A(At())),
      (ci = class e extends hQe.ServiceException {
        constructor(t) {
          super(t), Object.setPrototypeOf(this, e.prototype);
        }
      });
  });
var Kh,
  sT,
  cT,
  jZ,
  FZ,
  uT,
  lT,
  dT,
  fT,
  pT,
  mT,
  hT,
  gT,
  vT,
  iU = w(() => {
    c();
    Kh = A(At());
    nU();
    (sT = class e extends ci {
      name = "AccessDeniedException";
      $fault = "client";
      error;
      error_description;
      constructor(t) {
        super({ name: "AccessDeniedException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description);
      }
    }),
      (cT = class e extends ci {
        name = "AuthorizationPendingException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({
            name: "AuthorizationPendingException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (jZ = (e) => ({
        ...e,
        ...(e.clientSecret && { clientSecret: Kh.SENSITIVE_STRING }),
        ...(e.refreshToken && { refreshToken: Kh.SENSITIVE_STRING }),
        ...(e.codeVerifier && { codeVerifier: Kh.SENSITIVE_STRING }),
      })),
      (FZ = (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: Kh.SENSITIVE_STRING }),
        ...(e.refreshToken && { refreshToken: Kh.SENSITIVE_STRING }),
        ...(e.idToken && { idToken: Kh.SENSITIVE_STRING }),
      })),
      (uT = class e extends ci {
        name = "ExpiredTokenException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "ExpiredTokenException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (lT = class e extends ci {
        name = "InternalServerException";
        $fault = "server";
        error;
        error_description;
        constructor(t) {
          super({ name: "InternalServerException", $fault: "server", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (dT = class e extends ci {
        name = "InvalidClientException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidClientException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (fT = class e extends ci {
        name = "InvalidGrantException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidGrantException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (pT = class e extends ci {
        name = "InvalidRequestException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidRequestException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (mT = class e extends ci {
        name = "InvalidScopeException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidScopeException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (hT = class e extends ci {
        name = "SlowDownException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "SlowDownException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (gT = class e extends ci {
        name = "UnauthorizedClientException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({
            name: "UnauthorizedClientException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (vT = class e extends ci {
        name = "UnsupportedGrantTypeException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({
            name: "UnsupportedGrantTypeException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      });
  });
var he,
  gQe,
  vQe,
  pTr,
  mTr,
  hTr,
  gTr,
  vTr,
  yTr,
  _Tr,
  ETr,
  bTr,
  STr,
  CTr,
  wTr,
  OTr,
  ms,
  yQe = w(() => {
    c();
    ri();
    Gn();
    he = A(At());
    iU();
    nU();
    (gQe = async (e, t) => {
      let r = PO(e, t),
        n = { "content-type": "application/json" };
      r.bp("/token");
      let i;
      return (
        (i = JSON.stringify(
          (0, he.take)(e, {
            clientId: [],
            clientSecret: [],
            code: [],
            codeVerifier: [],
            deviceCode: [],
            grantType: [],
            redirectUri: [],
            refreshToken: [],
            scope: (o) => (0, he._json)(o),
          }),
        )),
        r.m("POST").h(n).b(i),
        r.build()
      );
    }),
      (vQe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return pTr(e, t);
        let r = (0, he.map)({ $metadata: ms(e) }),
          n = (0, he.expectNonNull)(
            (0, he.expectObject)(await T1(e.body, t)),
            "body",
          ),
          i = (0, he.take)(n, {
            accessToken: he.expectString,
            expiresIn: he.expectInt32,
            idToken: he.expectString,
            refreshToken: he.expectString,
            tokenType: he.expectString,
          });
        return Object.assign(r, i), r;
      }),
      (pTr = async (e, t) => {
        let r = { ...e, body: await X7(e.body, t) },
          n = J7(e, r.body);
        switch (n) {
          case "AccessDeniedException":
          case "com.amazonaws.ssooidc#AccessDeniedException":
            throw await hTr(r, t);
          case "AuthorizationPendingException":
          case "com.amazonaws.ssooidc#AuthorizationPendingException":
            throw await gTr(r, t);
          case "ExpiredTokenException":
          case "com.amazonaws.ssooidc#ExpiredTokenException":
            throw await vTr(r, t);
          case "InternalServerException":
          case "com.amazonaws.ssooidc#InternalServerException":
            throw await yTr(r, t);
          case "InvalidClientException":
          case "com.amazonaws.ssooidc#InvalidClientException":
            throw await _Tr(r, t);
          case "InvalidGrantException":
          case "com.amazonaws.ssooidc#InvalidGrantException":
            throw await ETr(r, t);
          case "InvalidRequestException":
          case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await bTr(r, t);
          case "InvalidScopeException":
          case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await STr(r, t);
          case "SlowDownException":
          case "com.amazonaws.ssooidc#SlowDownException":
            throw await CTr(r, t);
          case "UnauthorizedClientException":
          case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await wTr(r, t);
          case "UnsupportedGrantTypeException":
          case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
            throw await OTr(r, t);
          default:
            let i = r.body;
            return mTr({ output: e, parsedBody: i, errorCode: n });
        }
      }),
      (mTr = (0, he.withBaseException)(ci)),
      (hTr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new sT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (gTr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new cT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (vTr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new uT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (yTr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new lT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (_Tr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new dT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (ETr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new fT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (bTr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new pT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (STr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new mT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (CTr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new hT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (wTr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new gT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (OTr = async (e, t) => {
        let r = (0, he.map)({}),
          n = e.body,
          i = (0, he.take)(n, {
            error: he.expectString,
            error_description: he.expectString,
          });
        Object.assign(r, i);
        let o = new vT({ $metadata: ms(e), ...r });
        return (0, he.decorateServiceException)(o, e.body);
      }),
      (ms = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }));
  });
var _Qe,
  EQe,
  BZ,
  yT,
  UZ = w(() => {
    c();
    (_Qe = A(Wl())), (EQe = A(ip())), (BZ = A(At()));
    NZ();
    iU();
    yQe();
    yT = class extends (
      BZ.Command.classBuilder()
        .ep(P5e)
        .m(function (t, r, n, i) {
          return [
            (0, EQe.getSerdePlugin)(n, this.serialize, this.deserialize),
            (0, _Qe.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AWSSSOOIDCService", "CreateToken", {})
        .n("SSOOIDCClient", "CreateTokenCommand")
        .f(jZ, FZ)
        .ser(gQe)
        .de(vQe)
        .build()
    ) {};
  });
var bQe,
  TTr,
  oU,
  SQe = w(() => {
    c();
    bQe = A(At());
    UZ();
    qZ();
    (TTr = { CreateTokenCommand: yT }), (oU = class extends aT {});
    (0, bQe.createAggregatedClient)(TTr, oU);
  });
var CQe = w(() => {
  c();
  UZ();
});
var wQe = w(() => {
  c();
  iU();
});
var HZ = {};
bn(HZ, {
  $Command: () => BZ.Command,
  AccessDeniedException: () => sT,
  AuthorizationPendingException: () => cT,
  CreateTokenCommand: () => yT,
  CreateTokenRequestFilterSensitiveLog: () => jZ,
  CreateTokenResponseFilterSensitiveLog: () => FZ,
  ExpiredTokenException: () => uT,
  InternalServerException: () => lT,
  InvalidClientException: () => dT,
  InvalidGrantException: () => fT,
  InvalidRequestException: () => pT,
  InvalidScopeException: () => mT,
  SSOOIDC: () => oU,
  SSOOIDCClient: () => aT,
  SSOOIDCServiceException: () => ci,
  SlowDownException: () => hT,
  UnauthorizedClientException: () => gT,
  UnsupportedGrantTypeException: () => vT,
  __Client: () => MZ.Client,
});
var GZ = w(() => {
  c();
  qZ();
  SQe();
  CQe();
  wQe();
  nU();
});
var NQe = g((NKn, xQe) => {
  "use strict";
  c();
  var ATr = Object.create,
    ET = Object.defineProperty,
    PTr = Object.getOwnPropertyDescriptor,
    RTr = Object.getOwnPropertyNames,
    ITr = Object.getPrototypeOf,
    xTr = Object.prototype.hasOwnProperty,
    Sp = (e, t) => ET(e, "name", { value: t, configurable: !0 }),
    NTr = (e, t) => {
      for (var r in t) ET(e, r, { get: t[r], enumerable: !0 });
    },
    AQe = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of RTr(t))
          !xTr.call(e, i) &&
            i !== r &&
            ET(e, i, {
              get: () => t[i],
              enumerable: !(n = PTr(t, i)) || n.enumerable,
            });
      return e;
    },
    PQe = (e, t, r) => (
      (r = e != null ? ATr(ITr(e)) : {}),
      AQe(
        t || !e || !e.__esModule
          ? ET(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    kTr = (e) => AQe(ET({}, "__esModule", { value: !0 }), e),
    RQe = {};
  NTr(RQe, {
    fromSso: () => IQe,
    fromStatic: () => BTr,
    nodeProvider: () => UTr,
  });
  xQe.exports = kTr(RQe);
  var DTr = 5 * 60 * 1e3,
    VZ =
      "To refresh this SSO session run 'aws sso login' with the corresponding profile.",
    LTr = Sp(async (e, t = {}) => {
      let { SSOOIDCClient: r } = await Promise.resolve().then(() =>
        PQe((GZ(), ue(HZ))),
      );
      return new r(
        Object.assign({}, t.clientConfig ?? {}, {
          region: e ?? t.clientConfig?.region,
          logger: t.clientConfig?.logger ?? t.parentClientConfig?.logger,
        }),
      );
    }, "getSsoOidcClient"),
    MTr = Sp(async (e, t, r = {}) => {
      let { CreateTokenCommand: n } = await Promise.resolve().then(() =>
        PQe((GZ(), ue(HZ))),
      );
      return (await LTr(t, r)).send(
        new n({
          clientId: e.clientId,
          clientSecret: e.clientSecret,
          refreshToken: e.refreshToken,
          grantType: "refresh_token",
        }),
      );
    }, "getNewSsoOidcToken"),
    ac = Ho(),
    OQe = Sp((e) => {
      if (e.expiration && e.expiration.getTime() < Date.now())
        throw new ac.TokenProviderError(`Token is expired. ${VZ}`, !1);
    }, "validateTokenExpiry"),
    Wh = Sp((e, t, r = !1) => {
      if (typeof t > "u")
        throw new ac.TokenProviderError(
          `Value not present for '${e}' in SSO Token${r ? ". Cannot refresh" : ""}. ${VZ}`,
          !1,
        );
    }, "validateTokenKey"),
    _T = No(),
    qTr = G("fs"),
    { writeFile: jTr } = qTr.promises,
    FTr = Sp((e, t) => {
      let r = (0, _T.getSSOTokenFilepath)(e),
        n = JSON.stringify(t, null, 2);
      return jTr(r, n);
    }, "writeSSOTokenToFile"),
    TQe = new Date(0),
    IQe = Sp(
      (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          let r = {
            ...e,
            parentClientConfig: { ...t, ...e.parentClientConfig },
          };
          r.logger?.debug("@aws-sdk/token-providers - fromSso");
          let n = await (0, _T.parseKnownFiles)(r),
            i = (0, _T.getProfileName)({ profile: r.profile ?? t?.profile }),
            o = n[i];
          if (o) {
            if (!o.sso_session)
              throw new ac.TokenProviderError(
                `Profile '${i}' is missing required property 'sso_session'.`,
              );
          } else
            throw new ac.TokenProviderError(
              `Profile '${i}' could not be found in shared credentials file.`,
              !1,
            );
          let a = o.sso_session,
            u = (await (0, _T.loadSsoSessionData)(r))[a];
          if (!u)
            throw new ac.TokenProviderError(
              `Sso session '${a}' could not be found in shared credentials file.`,
              !1,
            );
          for (let _ of ["sso_start_url", "sso_region"])
            if (!u[_])
              throw new ac.TokenProviderError(
                `Sso session '${a}' is missing required property '${_}'.`,
                !1,
              );
          let l = u.sso_start_url,
            d = u.sso_region,
            f;
          try {
            f = await (0, _T.getSSOTokenFromFile)(a);
          } catch {
            throw new ac.TokenProviderError(
              `The SSO session token associated with profile=${i} was not found or is invalid. ${VZ}`,
              !1,
            );
          }
          Wh("accessToken", f.accessToken), Wh("expiresAt", f.expiresAt);
          let { accessToken: m, expiresAt: h } = f,
            y = { token: m, expiration: new Date(h) };
          if (y.expiration.getTime() - Date.now() > DTr) return y;
          if (Date.now() - TQe.getTime() < 30 * 1e3) return OQe(y), y;
          Wh("clientId", f.clientId, !0),
            Wh("clientSecret", f.clientSecret, !0),
            Wh("refreshToken", f.refreshToken, !0);
          try {
            TQe.setTime(Date.now());
            let _ = await MTr(f, d, r);
            Wh("accessToken", _.accessToken), Wh("expiresIn", _.expiresIn);
            let E = new Date(Date.now() + _.expiresIn * 1e3);
            try {
              await FTr(a, {
                ...f,
                accessToken: _.accessToken,
                expiresAt: E.toISOString(),
                refreshToken: _.refreshToken,
              });
            } catch {}
            return { token: _.accessToken, expiration: E };
          } catch {
            return OQe(y), y;
          }
        },
      "fromSso",
    ),
    BTr = Sp(
      ({ token: e, logger: t }) =>
        async () => {
          if (
            (t?.debug("@aws-sdk/token-providers - fromStatic"), !e || !e.token)
          )
            throw new ac.TokenProviderError(
              "Please pass a valid token to fromStatic",
              !1,
            );
          return e;
        },
      "fromStatic",
    ),
    UTr = Sp(
      (e = {}) =>
        (0, ac.memoize)(
          (0, ac.chain)(IQe(e), async () => {
            throw new ac.TokenProviderError(
              "Could not load token from any providers",
              !1,
            );
          }),
          (t) =>
            t.expiration !== void 0 &&
            t.expiration.getTime() - Date.now() < 3e5,
          (t) => t.expiration !== void 0,
        ),
      "nodeProvider",
    );
});
var zZ = g((DKn, UQe) => {
  "use strict";
  c();
  var sU = Object.defineProperty,
    HTr = Object.getOwnPropertyDescriptor,
    LQe = Object.getOwnPropertyNames,
    GTr = Object.prototype.hasOwnProperty,
    cU = (e, t) => sU(e, "name", { value: t, configurable: !0 }),
    VTr = (e, t) =>
      function () {
        return e && (t = (0, e[LQe(e)[0]])((e = 0))), t;
      },
    MQe = (e, t) => {
      for (var r in t) sU(e, r, { get: t[r], enumerable: !0 });
    },
    $Tr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of LQe(t))
          !GTr.call(e, i) &&
            i !== r &&
            sU(e, i, {
              get: () => t[i],
              enumerable: !(n = HTr(t, i)) || n.enumerable,
            });
      return e;
    },
    zTr = (e) => $Tr(sU({}, "__esModule", { value: !0 }), e),
    qQe = {};
  MQe(qQe, {
    GetRoleCredentialsCommand: () => $Z.GetRoleCredentialsCommand,
    SSOClient: () => $Z.SSOClient,
  });
  var $Z,
    KTr = VTr({
      "src/loadSso.ts"() {
        "use strict";
        $Z = C5e();
      },
    }),
    jQe = {};
  MQe(jQe, {
    fromSSO: () => QTr,
    isSsoProfile: () => FQe,
    validateSsoProfile: () => BQe,
  });
  UQe.exports = zTr(jQe);
  var FQe = cU(
      (e) =>
        e &&
        (typeof e.sso_start_url == "string" ||
          typeof e.sso_account_id == "string" ||
          typeof e.sso_session == "string" ||
          typeof e.sso_region == "string" ||
          typeof e.sso_role_name == "string"),
      "isSsoProfile",
    ),
    kQe = (gu(), ue(qh)),
    WTr = NQe(),
    sc = Ho(),
    aU = No(),
    bT = !1,
    DQe = cU(
      async ({
        ssoStartUrl: e,
        ssoSession: t,
        ssoAccountId: r,
        ssoRegion: n,
        ssoRoleName: i,
        ssoClient: o,
        clientConfig: a,
        parentClientConfig: s,
        profile: u,
        logger: l,
      }) => {
        let d,
          f =
            "To refresh this SSO session run aws sso login with the corresponding profile.";
        if (t)
          try {
            let L = await (0, WTr.fromSso)({ profile: u })();
            d = {
              accessToken: L.token,
              expiresAt: new Date(L.expiration).toISOString(),
            };
          } catch (L) {
            throw new sc.CredentialsProviderError(L.message, {
              tryNextLink: bT,
              logger: l,
            });
          }
        else
          try {
            d = await (0, aU.getSSOTokenFromFile)(e);
          } catch {
            throw new sc.CredentialsProviderError(
              `The SSO session associated with this profile is invalid. ${f}`,
              { tryNextLink: bT, logger: l },
            );
          }
        if (new Date(d.expiresAt).getTime() - Date.now() <= 0)
          throw new sc.CredentialsProviderError(
            `The SSO session associated with this profile has expired. ${f}`,
            { tryNextLink: bT, logger: l },
          );
        let { accessToken: m } = d,
          { SSOClient: h, GetRoleCredentialsCommand: y } =
            await Promise.resolve().then(() => (KTr(), qQe)),
          _ =
            o ||
            new h(
              Object.assign({}, a ?? {}, {
                logger: a?.logger ?? s?.logger,
                region: a?.region ?? n,
              }),
            ),
          E;
        try {
          E = await _.send(
            new y({ accountId: r, roleName: i, accessToken: m }),
          );
        } catch (L) {
          throw new sc.CredentialsProviderError(L, {
            tryNextLink: bT,
            logger: l,
          });
        }
        let {
          roleCredentials: {
            accessKeyId: b,
            secretAccessKey: O,
            sessionToken: C,
            expiration: P,
            credentialScope: k,
            accountId: H,
          } = {},
        } = E;
        if (!b || !O || !C || !P)
          throw new sc.CredentialsProviderError(
            "SSO returns an invalid temporary credential.",
            { tryNextLink: bT, logger: l },
          );
        let B = {
          accessKeyId: b,
          secretAccessKey: O,
          sessionToken: C,
          expiration: new Date(P),
          ...(k && { credentialScope: k }),
          ...(H && { accountId: H }),
        };
        return (
          t
            ? (0, kQe.setCredentialFeature)(B, "CREDENTIALS_SSO", "s")
            : (0, kQe.setCredentialFeature)(B, "CREDENTIALS_SSO_LEGACY", "u"),
          B
        );
      },
      "resolveSSOCredentials",
    ),
    BQe = cU((e, t) => {
      let {
        sso_start_url: r,
        sso_account_id: n,
        sso_region: i,
        sso_role_name: o,
      } = e;
      if (!r || !n || !i || !o)
        throw new sc.CredentialsProviderError(
          `Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(e).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`,
          { tryNextLink: !1, logger: t },
        );
      return e;
    }, "validateSsoProfile"),
    QTr = cU(
      (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          e.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
          let {
              ssoStartUrl: r,
              ssoAccountId: n,
              ssoRegion: i,
              ssoRoleName: o,
              ssoSession: a,
            } = e,
            { ssoClient: s } = e,
            u = (0, aU.getProfileName)({ profile: e.profile ?? t?.profile });
          if (!r && !n && !i && !o && !a) {
            let d = (await (0, aU.parseKnownFiles)(e))[u];
            if (!d)
              throw new sc.CredentialsProviderError(
                `Profile ${u} was not found.`,
                { logger: e.logger },
              );
            if (!FQe(d))
              throw new sc.CredentialsProviderError(
                `Profile ${u} is not configured with SSO credentials.`,
                { logger: e.logger },
              );
            if (d?.sso_session) {
              let b = (await (0, aU.loadSsoSessionData)(e))[d.sso_session],
                O = ` configurations in profile ${u} and sso-session ${d.sso_session}`;
              if (i && i !== b.sso_region)
                throw new sc.CredentialsProviderError(
                  "Conflicting SSO region" + O,
                  { tryNextLink: !1, logger: e.logger },
                );
              if (r && r !== b.sso_start_url)
                throw new sc.CredentialsProviderError(
                  "Conflicting SSO start_url" + O,
                  { tryNextLink: !1, logger: e.logger },
                );
              (d.sso_region = b.sso_region),
                (d.sso_start_url = b.sso_start_url);
            }
            let {
              sso_start_url: f,
              sso_account_id: m,
              sso_region: h,
              sso_role_name: y,
              sso_session: _,
            } = BQe(d, e.logger);
            return DQe({
              ssoStartUrl: f,
              ssoSession: _,
              ssoAccountId: m,
              ssoRegion: h,
              ssoRoleName: y,
              ssoClient: s,
              clientConfig: e.clientConfig,
              parentClientConfig: e.parentClientConfig,
              profile: u,
            });
          } else {
            if (!r || !n || !i || !o)
              throw new sc.CredentialsProviderError(
                'Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"',
                { tryNextLink: !1, logger: e.logger },
              );
            return DQe({
              ssoStartUrl: r,
              ssoSession: a,
              ssoAccountId: n,
              ssoRegion: i,
              ssoRoleName: o,
              ssoClient: s,
              clientConfig: e.clientConfig,
              parentClientConfig: e.parentClientConfig,
              profile: u,
            });
          }
        },
      "fromSSO",
    );
});
function YTr(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "sts", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
function XTr(e) {
  return { schemeId: "smithy.api#noAuth" };
}
var ST,
  HQe,
  GQe,
  JTr,
  VQe,
  KZ = w(() => {
    c();
    ri();
    ST = A(tc());
    CT();
    HQe = async (e, t, r) => ({
      operation: (0, ST.getSmithyContext)(t).operation,
      region:
        (await (0, ST.normalizeProvider)(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`",
          );
        })(),
    });
    (GQe = (e) => {
      let t = [];
      switch (e.operation) {
        case "AssumeRoleWithWebIdentity": {
          t.push(XTr(e));
          break;
        }
        default:
          t.push(YTr(e));
      }
      return t;
    }),
      (JTr = (e) => Object.assign(e, { stsClientCtor: Au })),
      (VQe = (e) => {
        let t = JTr(e),
          r = _E(t);
        return Object.assign(r, {
          authSchemePreference: (0, ST.normalizeProvider)(
            e.authSchemePreference ?? [],
          ),
        });
      });
  });
var $Qe,
  uU,
  lU = w(() => {
    c();
    ($Qe = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
        defaultSigningName: "sts",
      })),
      (uU = {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var r9e,
  at,
  Gt,
  Vt,
  wp,
  Cp,
  Ni,
  n9e,
  i9e,
  o9e,
  Wr,
  zQe,
  Pu,
  GE,
  QZ,
  KQe,
  WZ,
  a9e,
  WQe,
  ki,
  QQe,
  s9e,
  c9e,
  Wi,
  ga,
  YQe,
  u9e,
  l9e,
  XQe,
  d9e,
  JQe,
  ZQe,
  e9e,
  t9e,
  ZTr,
  f9e,
  p9e = w(() => {
    c();
    (r9e = "required"),
      (at = "type"),
      (Gt = "fn"),
      (Vt = "argv"),
      (wp = "ref"),
      (Cp = "booleanEquals"),
      (Ni = "stringEquals"),
      (n9e = "sigv4"),
      (i9e = "sts"),
      (o9e = "us-east-1"),
      (Wr = "endpoint"),
      (zQe = "https://sts.{Region}.{PartitionResult#dnsSuffix}"),
      (Pu = "tree"),
      (GE = "error"),
      (QZ = "getAttr"),
      (KQe = { [r9e]: !1, [at]: "String" }),
      (WZ = { [r9e]: !0, default: !1, [at]: "Boolean" }),
      (a9e = { [wp]: "Endpoint" }),
      (WQe = { [Gt]: "isSet", [Vt]: [{ [wp]: "Region" }] }),
      (ki = { [wp]: "Region" }),
      (QQe = { [Gt]: "aws.partition", [Vt]: [ki], assign: "PartitionResult" }),
      (s9e = { [wp]: "UseFIPS" }),
      (c9e = { [wp]: "UseDualStack" }),
      (Wi = {
        url: "https://sts.amazonaws.com",
        properties: {
          authSchemes: [{ name: n9e, signingName: i9e, signingRegion: o9e }],
        },
        headers: {},
      }),
      (ga = {}),
      (YQe = {
        conditions: [{ [Gt]: Ni, [Vt]: [ki, "aws-global"] }],
        [Wr]: Wi,
        [at]: Wr,
      }),
      (u9e = { [Gt]: Cp, [Vt]: [s9e, !0] }),
      (l9e = { [Gt]: Cp, [Vt]: [c9e, !0] }),
      (XQe = { [Gt]: QZ, [Vt]: [{ [wp]: "PartitionResult" }, "supportsFIPS"] }),
      (d9e = { [wp]: "PartitionResult" }),
      (JQe = {
        [Gt]: Cp,
        [Vt]: [!0, { [Gt]: QZ, [Vt]: [d9e, "supportsDualStack"] }],
      }),
      (ZQe = [{ [Gt]: "isSet", [Vt]: [a9e] }]),
      (e9e = [u9e]),
      (t9e = [l9e]),
      (ZTr = {
        version: "1.0",
        parameters: {
          Region: KQe,
          UseDualStack: WZ,
          UseFIPS: WZ,
          Endpoint: KQe,
          UseGlobalEndpoint: WZ,
        },
        rules: [
          {
            conditions: [
              { [Gt]: Cp, [Vt]: [{ [wp]: "UseGlobalEndpoint" }, !0] },
              { [Gt]: "not", [Vt]: ZQe },
              WQe,
              QQe,
              { [Gt]: Cp, [Vt]: [s9e, !1] },
              { [Gt]: Cp, [Vt]: [c9e, !1] },
            ],
            rules: [
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "ap-northeast-1"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "ap-south-1"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "ap-southeast-1"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "ap-southeast-2"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              YQe,
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "ca-central-1"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "eu-central-1"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "eu-north-1"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "eu-west-1"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "eu-west-2"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "eu-west-3"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "sa-east-1"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, o9e] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "us-east-2"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "us-west-1"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                conditions: [{ [Gt]: Ni, [Vt]: [ki, "us-west-2"] }],
                endpoint: Wi,
                [at]: Wr,
              },
              {
                endpoint: {
                  url: zQe,
                  properties: {
                    authSchemes: [
                      {
                        name: n9e,
                        signingName: i9e,
                        signingRegion: "{Region}",
                      },
                    ],
                  },
                  headers: ga,
                },
                [at]: Wr,
              },
            ],
            [at]: Pu,
          },
          {
            conditions: ZQe,
            rules: [
              {
                conditions: e9e,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                [at]: GE,
              },
              {
                conditions: t9e,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                [at]: GE,
              },
              { endpoint: { url: a9e, properties: ga, headers: ga }, [at]: Wr },
            ],
            [at]: Pu,
          },
          {
            conditions: [WQe],
            rules: [
              {
                conditions: [QQe],
                rules: [
                  {
                    conditions: [u9e, l9e],
                    rules: [
                      {
                        conditions: [{ [Gt]: Cp, [Vt]: [!0, XQe] }, JQe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: ga,
                              headers: ga,
                            },
                            [at]: Wr,
                          },
                        ],
                        [at]: Pu,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        [at]: GE,
                      },
                    ],
                    [at]: Pu,
                  },
                  {
                    conditions: e9e,
                    rules: [
                      {
                        conditions: [{ [Gt]: Cp, [Vt]: [XQe, !0] }],
                        rules: [
                          {
                            conditions: [
                              {
                                [Gt]: Ni,
                                [Vt]: [
                                  { [Gt]: QZ, [Vt]: [d9e, "name"] },
                                  "aws-us-gov",
                                ],
                              },
                            ],
                            endpoint: {
                              url: "https://sts.{Region}.amazonaws.com",
                              properties: ga,
                              headers: ga,
                            },
                            [at]: Wr,
                          },
                          {
                            endpoint: {
                              url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: ga,
                              headers: ga,
                            },
                            [at]: Wr,
                          },
                        ],
                        [at]: Pu,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        [at]: GE,
                      },
                    ],
                    [at]: Pu,
                  },
                  {
                    conditions: t9e,
                    rules: [
                      {
                        conditions: [JQe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: ga,
                              headers: ga,
                            },
                            [at]: Wr,
                          },
                        ],
                        [at]: Pu,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        [at]: GE,
                      },
                    ],
                    [at]: Pu,
                  },
                  YQe,
                  {
                    endpoint: { url: zQe, properties: ga, headers: ga },
                    [at]: Wr,
                  },
                ],
                [at]: Pu,
              },
            ],
            [at]: Pu,
          },
          { error: "Invalid Configuration: Missing Region", [at]: GE },
        ],
      }),
      (f9e = ZTr);
  });
var m9e,
  VE,
  eAr,
  h9e,
  g9e = w(() => {
    c();
    (m9e = A(hE())), (VE = A(pE()));
    p9e();
    (eAr = new VE.EndpointCache({
      size: 50,
      params: [
        "Endpoint",
        "Region",
        "UseDualStack",
        "UseFIPS",
        "UseGlobalEndpoint",
      ],
    })),
      (h9e = (e, t = {}) =>
        eAr.get(e, () =>
          (0, VE.resolveEndpoint)(f9e, { endpointParams: e, logger: t.logger }),
        ));
    VE.customEndpointFunctions.aws = m9e.awsEndpointFunctions;
  });
var v9e,
  y9e,
  dU,
  fU,
  _9e,
  E9e = w(() => {
    c();
    ri();
    Gn();
    (v9e = A(At())), (y9e = A(Hh())), (dU = A(fu())), (fU = A(Fe()));
    KZ();
    g9e();
    _9e = (e) => ({
      apiVersion: "2011-06-15",
      base64Decoder: e?.base64Decoder ?? dU.fromBase64,
      base64Encoder: e?.base64Encoder ?? dU.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? h9e,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? GQe,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new ma(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Vl(),
        },
      ],
      logger: e?.logger ?? new v9e.NoOpLogger(),
      serviceId: e?.serviceId ?? "STS",
      urlParser: e?.urlParser ?? y9e.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? fU.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? fU.toUtf8,
    });
  });
var pU,
  Tp,
  b9e,
  mU,
  Op,
  hU,
  S9e,
  C9e,
  w9e,
  O9e,
  T9e,
  A9e,
  P9e = w(() => {
    c();
    kZ();
    ri();
    (pU = A(YO())), (Tp = A(Eu()));
    Gn();
    (b9e = A(XO())),
      (mU = A(Kl())),
      (Op = A(ro())),
      (hU = A(Lh())),
      (S9e = A(yl())),
      (C9e = A(OE()));
    E9e();
    (w9e = A(At())),
      (O9e = A(eT())),
      (T9e = A(At())),
      (A9e = (e) => {
        (0, T9e.emitWarningIfUnsupportedVersion)(process.version);
        let t = (0, O9e.resolveDefaultsModeConfig)(e),
          r = () => t().then(w9e.loadConfigsForDefaultMode),
          n = _9e(e);
        gE(process.version);
        let i = { profile: e?.profile };
        return {
          ...n,
          ...e,
          runtime: "node",
          defaultsMode: t,
          authSchemePreference:
            e?.authSchemePreference ?? (0, Op.loadConfig)(NO, i),
          bodyLengthChecker: e?.bodyLengthChecker ?? S9e.calculateBodyLength,
          defaultUserAgentProvider:
            e?.defaultUserAgentProvider ??
            (0, pU.createDefaultUserAgentProvider)({
              serviceId: n.serviceId,
              clientVersion: $B.version,
            }),
          httpAuthSchemes: e?.httpAuthSchemes ?? [
            {
              schemeId: "aws.auth#sigv4",
              identityProvider: (o) =>
                o.getIdentityProvider("aws.auth#sigv4") ||
                (async (a) =>
                  await e.credentialDefaultProvider(a?.__config || {})()),
              signer: new ma(),
            },
            {
              schemeId: "smithy.api#noAuth",
              identityProvider: (o) =>
                o.getIdentityProvider("smithy.api#noAuth") ||
                (async () => ({})),
              signer: new Vl(),
            },
          ],
          maxAttempts:
            e?.maxAttempts ??
            (0, Op.loadConfig)(mU.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, e),
          region:
            e?.region ??
            (0, Op.loadConfig)(Tp.NODE_REGION_CONFIG_OPTIONS, {
              ...Tp.NODE_REGION_CONFIG_FILE_OPTIONS,
              ...i,
            }),
          requestHandler: hU.NodeHttpHandler.create(e?.requestHandler ?? r),
          retryMode:
            e?.retryMode ??
            (0, Op.loadConfig)(
              {
                ...mU.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () =>
                  (await r()).retryMode || C9e.DEFAULT_RETRY_MODE,
              },
              e,
            ),
          sha256: e?.sha256 ?? b9e.Hash.bind(null, "sha256"),
          streamCollector: e?.streamCollector ?? hU.streamCollector,
          useDualstackEndpoint:
            e?.useDualstackEndpoint ??
            (0, Op.loadConfig)(
              Tp.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS,
              i,
            ),
          useFipsEndpoint:
            e?.useFipsEndpoint ??
            (0, Op.loadConfig)(Tp.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, i),
          userAgentAppId:
            e?.userAgentAppId ??
            (0, Op.loadConfig)(pU.NODE_APP_ID_CONFIG_OPTIONS, i),
        };
      });
  });
var R9e,
  I9e,
  x9e = w(() => {
    c();
    (R9e = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        n = e.credentials;
      return {
        setHttpAuthScheme(i) {
          let o = t.findIndex((a) => a.schemeId === i.schemeId);
          o === -1 ? t.push(i) : t.splice(o, 1, i);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(i) {
          r = i;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(i) {
          n = i;
        },
        credentials() {
          return n;
        },
      };
    }),
      (I9e = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var gU,
  vU,
  yU,
  N9e,
  k9e = w(() => {
    c();
    (gU = A(tT())), (vU = A(ln())), (yU = A(At()));
    x9e();
    N9e = (e, t) => {
      let r = Object.assign(
        (0, gU.getAwsRegionExtensionConfiguration)(e),
        (0, yU.getDefaultExtensionConfiguration)(e),
        (0, vU.getHttpHandlerExtensionConfiguration)(e),
        R9e(e),
      );
      return (
        t.forEach((n) => n.configure(r)),
        Object.assign(
          e,
          (0, gU.resolveAwsRegionExtensionConfiguration)(r),
          (0, yU.resolveDefaultRuntimeConfig)(r),
          (0, vU.resolveHttpHandlerRuntimeConfig)(r),
          I9e(r),
        )
      );
    };
  });
var _U,
  D9e,
  L9e,
  EU,
  M9e,
  q9e,
  j9e,
  bU,
  YZ,
  Au,
  CT = w(() => {
    c();
    (_U = A(uO())),
      (D9e = A(lO())),
      (L9e = A(dO())),
      (EU = A(CE())),
      (M9e = A(Eu()));
    Gn();
    (q9e = A(FO())), (j9e = A(Wl())), (bU = A(Kl())), (YZ = A(At()));
    KZ();
    lU();
    P9e();
    k9e();
    Au = class extends YZ.Client {
      config;
      constructor(...[t]) {
        let r = A9e(t || {});
        super(r), (this.initConfig = r);
        let n = $Qe(r),
          i = (0, EU.resolveUserAgentConfig)(n),
          o = (0, bU.resolveRetryConfig)(i),
          a = (0, M9e.resolveRegionConfig)(o),
          s = (0, _U.resolveHostHeaderConfig)(a),
          u = (0, j9e.resolveEndpointConfig)(s),
          l = VQe(u),
          d = N9e(l, t?.extensions || []);
        (this.config = d),
          this.middlewareStack.use((0, EU.getUserAgentPlugin)(this.config)),
          this.middlewareStack.use((0, bU.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, q9e.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, _U.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, D9e.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, L9e.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use(
            OO(this.config, {
              httpAuthSchemeParametersProvider: HQe,
              identityProviderConfigProvider: async (f) =>
                new Mh({ "aws.auth#sigv4": f.credentials }),
            }),
          ),
          this.middlewareStack.use(TO(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var F9e,
  Vo,
  SU = w(() => {
    c();
    (F9e = A(At())),
      (Vo = class e extends F9e.ServiceException {
        constructor(t) {
          super(t), Object.setPrototypeOf(this, e.prototype);
        }
      });
  });
var XZ,
  JZ,
  ZZ,
  wT,
  OT,
  TT,
  AT,
  PT,
  RT,
  eee,
  tee,
  IT,
  xT = w(() => {
    c();
    XZ = A(At());
    SU();
    (JZ = (e) => ({
      ...e,
      ...(e.SecretAccessKey && { SecretAccessKey: XZ.SENSITIVE_STRING }),
    })),
      (ZZ = (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: JZ(e.Credentials) }),
      })),
      (wT = class e extends Vo {
        name = "ExpiredTokenException";
        $fault = "client";
        constructor(t) {
          super({ name: "ExpiredTokenException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (OT = class e extends Vo {
        name = "MalformedPolicyDocumentException";
        $fault = "client";
        constructor(t) {
          super({
            name: "MalformedPolicyDocumentException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (TT = class e extends Vo {
        name = "PackedPolicyTooLargeException";
        $fault = "client";
        constructor(t) {
          super({
            name: "PackedPolicyTooLargeException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (AT = class e extends Vo {
        name = "RegionDisabledException";
        $fault = "client";
        constructor(t) {
          super({ name: "RegionDisabledException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (PT = class e extends Vo {
        name = "IDPRejectedClaimException";
        $fault = "client";
        constructor(t) {
          super({ name: "IDPRejectedClaimException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (RT = class e extends Vo {
        name = "InvalidIdentityTokenException";
        $fault = "client";
        constructor(t) {
          super({
            name: "InvalidIdentityTokenException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (eee = (e) => ({
        ...e,
        ...(e.WebIdentityToken && { WebIdentityToken: XZ.SENSITIVE_STRING }),
      })),
      (tee = (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: JZ(e.Credentials) }),
      })),
      (IT = class e extends Vo {
        name = "IDPCommunicationErrorException";
        $fault = "client";
        constructor(t) {
          super({
            name: "IDPCommunicationErrorException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      });
  });
var B9e,
  ht,
  U9e,
  H9e,
  G9e,
  V9e,
  $9e,
  tAr,
  rAr,
  nAr,
  iAr,
  oAr,
  aAr,
  sAr,
  cAr,
  uAr,
  z9e,
  lAr,
  dAr,
  fAr,
  pAr,
  mAr,
  hAr,
  K9e,
  gAr,
  vAr,
  W9e,
  yAr,
  _Ar,
  EAr,
  bAr,
  SAr,
  CAr,
  wAr,
  Zl,
  OAr,
  Q9e,
  Y9e,
  X9e,
  J9e,
  ree,
  TAr,
  nee,
  $E,
  AAr,
  iee,
  oee,
  zE,
  aee,
  KE,
  see,
  cee,
  uee,
  WE,
  QE,
  lee,
  dee,
  fee,
  YE,
  pee,
  XE,
  JE,
  mee,
  hee,
  Jl,
  gee,
  vee,
  yee,
  _ee,
  Eee,
  Z9e,
  bee,
  See,
  Cee,
  En,
  eYe,
  PAr,
  wee = w(() => {
    c();
    ri();
    (B9e = A(ln())), (ht = A(At()));
    xT();
    SU();
    (U9e = async (e, t) => {
      let r = Y9e,
        n;
      return (
        (n = eYe({ ...cAr(e, t), [J9e]: TAr, [Z9e]: X9e })),
        Q9e(t, r, "/", void 0, n)
      );
    }),
      (H9e = async (e, t) => {
        let r = Y9e,
          n;
        return (
          (n = eYe({ ...uAr(e, t), [J9e]: AAr, [Z9e]: X9e })),
          Q9e(t, r, "/", void 0, n)
        );
      }),
      (G9e = async (e, t) => {
        if (e.statusCode >= 300) return $9e(e, t);
        let r = await jO(e.body, t),
          n = {};
        return (n = gAr(r.AssumeRoleResult, t)), { $metadata: Zl(e), ...n };
      }),
      (V9e = async (e, t) => {
        if (e.statusCode >= 300) return $9e(e, t);
        let r = await jO(e.body, t),
          n = {};
        return (
          (n = vAr(r.AssumeRoleWithWebIdentityResult, t)),
          { $metadata: Zl(e), ...n }
        );
      }),
      ($9e = async (e, t) => {
        let r = { ...e, body: await Z7(e.body, t) },
          n = PAr(e, r.body);
        switch (n) {
          case "ExpiredTokenException":
          case "com.amazonaws.sts#ExpiredTokenException":
            throw await tAr(r, t);
          case "MalformedPolicyDocument":
          case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await oAr(r, t);
          case "PackedPolicyTooLarge":
          case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await aAr(r, t);
          case "RegionDisabledException":
          case "com.amazonaws.sts#RegionDisabledException":
            throw await sAr(r, t);
          case "IDPCommunicationError":
          case "com.amazonaws.sts#IDPCommunicationErrorException":
            throw await rAr(r, t);
          case "IDPRejectedClaim":
          case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await nAr(r, t);
          case "InvalidIdentityToken":
          case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await iAr(r, t);
          default:
            let i = r.body;
            return OAr({ output: e, parsedBody: i.Error, errorCode: n });
        }
      }),
      (tAr = async (e, t) => {
        let r = e.body,
          n = yAr(r.Error, t),
          i = new wT({ $metadata: Zl(e), ...n });
        return (0, ht.decorateServiceException)(i, r);
      }),
      (rAr = async (e, t) => {
        let r = e.body,
          n = _Ar(r.Error, t),
          i = new IT({ $metadata: Zl(e), ...n });
        return (0, ht.decorateServiceException)(i, r);
      }),
      (nAr = async (e, t) => {
        let r = e.body,
          n = EAr(r.Error, t),
          i = new PT({ $metadata: Zl(e), ...n });
        return (0, ht.decorateServiceException)(i, r);
      }),
      (iAr = async (e, t) => {
        let r = e.body,
          n = bAr(r.Error, t),
          i = new RT({ $metadata: Zl(e), ...n });
        return (0, ht.decorateServiceException)(i, r);
      }),
      (oAr = async (e, t) => {
        let r = e.body,
          n = SAr(r.Error, t),
          i = new OT({ $metadata: Zl(e), ...n });
        return (0, ht.decorateServiceException)(i, r);
      }),
      (aAr = async (e, t) => {
        let r = e.body,
          n = CAr(r.Error, t),
          i = new TT({ $metadata: Zl(e), ...n });
        return (0, ht.decorateServiceException)(i, r);
      }),
      (sAr = async (e, t) => {
        let r = e.body,
          n = wAr(r.Error, t),
          i = new AT({ $metadata: Zl(e), ...n });
        return (0, ht.decorateServiceException)(i, r);
      }),
      (cAr = (e, t) => {
        let r = {};
        if (
          (e[XE] != null && (r[XE] = e[XE]),
          e[JE] != null && (r[JE] = e[JE]),
          e[QE] != null)
        ) {
          let n = z9e(e[QE], t);
          e[QE]?.length === 0 && (r.PolicyArns = []),
            Object.entries(n).forEach(([i, o]) => {
              let a = `PolicyArns.${i}`;
              r[a] = o;
            });
        }
        if (
          (e[WE] != null && (r[WE] = e[WE]),
          e[KE] != null && (r[KE] = e[KE]),
          e[yee] != null)
        ) {
          let n = hAr(e[yee], t);
          e[yee]?.length === 0 && (r.Tags = []),
            Object.entries(n).forEach(([i, o]) => {
              let a = `Tags.${i}`;
              r[a] = o;
            });
        }
        if (e[Eee] != null) {
          let n = mAr(e[Eee], t);
          e[Eee]?.length === 0 && (r.TransitiveTagKeys = []),
            Object.entries(n).forEach(([i, o]) => {
              let a = `TransitiveTagKeys.${i}`;
              r[a] = o;
            });
        }
        if (
          (e[cee] != null && (r[cee] = e[cee]),
          e[gee] != null && (r[gee] = e[gee]),
          e[_ee] != null && (r[_ee] = e[_ee]),
          e[Jl] != null && (r[Jl] = e[Jl]),
          e[dee] != null)
        ) {
          let n = fAr(e[dee], t);
          e[dee]?.length === 0 && (r.ProvidedContexts = []),
            Object.entries(n).forEach(([i, o]) => {
              let a = `ProvidedContexts.${i}`;
              r[a] = o;
            });
        }
        return r;
      }),
      (uAr = (e, t) => {
        let r = {};
        if (
          (e[XE] != null && (r[XE] = e[XE]),
          e[JE] != null && (r[JE] = e[JE]),
          e[See] != null && (r[See] = e[See]),
          e[fee] != null && (r[fee] = e[fee]),
          e[QE] != null)
        ) {
          let n = z9e(e[QE], t);
          e[QE]?.length === 0 && (r.PolicyArns = []),
            Object.entries(n).forEach(([i, o]) => {
              let a = `PolicyArns.${i}`;
              r[a] = o;
            });
        }
        return (
          e[WE] != null && (r[WE] = e[WE]), e[KE] != null && (r[KE] = e[KE]), r
        );
      }),
      (z9e = (e, t) => {
        let r = {},
          n = 1;
        for (let i of e) {
          if (i === null) continue;
          let o = lAr(i, t);
          Object.entries(o).forEach(([a, s]) => {
            r[`member.${n}.${a}`] = s;
          }),
            n++;
        }
        return r;
      }),
      (lAr = (e, t) => {
        let r = {};
        return e[Cee] != null && (r[Cee] = e[Cee]), r;
      }),
      (dAr = (e, t) => {
        let r = {};
        return (
          e[lee] != null && (r[lee] = e[lee]),
          e[aee] != null && (r[aee] = e[aee]),
          r
        );
      }),
      (fAr = (e, t) => {
        let r = {},
          n = 1;
        for (let i of e) {
          if (i === null) continue;
          let o = dAr(i, t);
          Object.entries(o).forEach(([a, s]) => {
            r[`member.${n}.${a}`] = s;
          }),
            n++;
        }
        return r;
      }),
      (pAr = (e, t) => {
        let r = {};
        return (
          e[uee] != null && (r[uee] = e[uee]),
          e[bee] != null && (r[bee] = e[bee]),
          r
        );
      }),
      (mAr = (e, t) => {
        let r = {},
          n = 1;
        for (let i of e) i !== null && ((r[`member.${n}`] = i), n++);
        return r;
      }),
      (hAr = (e, t) => {
        let r = {},
          n = 1;
        for (let i of e) {
          if (i === null) continue;
          let o = pAr(i, t);
          Object.entries(o).forEach(([a, s]) => {
            r[`member.${n}.${a}`] = s;
          }),
            n++;
        }
        return r;
      }),
      (K9e = (e, t) => {
        let r = {};
        return (
          e[nee] != null && (r[nee] = (0, ht.expectString)(e[nee])),
          e[iee] != null && (r[iee] = (0, ht.expectString)(e[iee])),
          r
        );
      }),
      (gAr = (e, t) => {
        let r = {};
        return (
          e[zE] != null && (r[zE] = W9e(e[zE], t)),
          e[$E] != null && (r[$E] = K9e(e[$E], t)),
          e[YE] != null && (r[YE] = (0, ht.strictParseInt32)(e[YE])),
          e[Jl] != null && (r[Jl] = (0, ht.expectString)(e[Jl])),
          r
        );
      }),
      (vAr = (e, t) => {
        let r = {};
        return (
          e[zE] != null && (r[zE] = W9e(e[zE], t)),
          e[hee] != null && (r[hee] = (0, ht.expectString)(e[hee])),
          e[$E] != null && (r[$E] = K9e(e[$E], t)),
          e[YE] != null && (r[YE] = (0, ht.strictParseInt32)(e[YE])),
          e[pee] != null && (r[pee] = (0, ht.expectString)(e[pee])),
          e[oee] != null && (r[oee] = (0, ht.expectString)(e[oee])),
          e[Jl] != null && (r[Jl] = (0, ht.expectString)(e[Jl])),
          r
        );
      }),
      (W9e = (e, t) => {
        let r = {};
        return (
          e[ree] != null && (r[ree] = (0, ht.expectString)(e[ree])),
          e[mee] != null && (r[mee] = (0, ht.expectString)(e[mee])),
          e[vee] != null && (r[vee] = (0, ht.expectString)(e[vee])),
          e[see] != null &&
            (r[see] = (0, ht.expectNonNull)(
              (0, ht.parseRfc3339DateTimeWithOffset)(e[see]),
            )),
          r
        );
      }),
      (yAr = (e, t) => {
        let r = {};
        return e[En] != null && (r[En] = (0, ht.expectString)(e[En])), r;
      }),
      (_Ar = (e, t) => {
        let r = {};
        return e[En] != null && (r[En] = (0, ht.expectString)(e[En])), r;
      }),
      (EAr = (e, t) => {
        let r = {};
        return e[En] != null && (r[En] = (0, ht.expectString)(e[En])), r;
      }),
      (bAr = (e, t) => {
        let r = {};
        return e[En] != null && (r[En] = (0, ht.expectString)(e[En])), r;
      }),
      (SAr = (e, t) => {
        let r = {};
        return e[En] != null && (r[En] = (0, ht.expectString)(e[En])), r;
      }),
      (CAr = (e, t) => {
        let r = {};
        return e[En] != null && (r[En] = (0, ht.expectString)(e[En])), r;
      }),
      (wAr = (e, t) => {
        let r = {};
        return e[En] != null && (r[En] = (0, ht.expectString)(e[En])), r;
      }),
      (Zl = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      })),
      (OAr = (0, ht.withBaseException)(Vo)),
      (Q9e = async (e, t, r, n, i) => {
        let {
            hostname: o,
            protocol: a = "https",
            port: s,
            path: u,
          } = await e.endpoint(),
          l = {
            protocol: a,
            hostname: o,
            port: s,
            method: "POST",
            path: u.endsWith("/") ? u.slice(0, -1) + r : u + r,
            headers: t,
          };
        return (
          n !== void 0 && (l.hostname = n),
          i !== void 0 && (l.body = i),
          new B9e.HttpRequest(l)
        );
      }),
      (Y9e = { "content-type": "application/x-www-form-urlencoded" }),
      (X9e = "2011-06-15"),
      (J9e = "Action"),
      (ree = "AccessKeyId"),
      (TAr = "AssumeRole"),
      (nee = "AssumedRoleId"),
      ($E = "AssumedRoleUser"),
      (AAr = "AssumeRoleWithWebIdentity"),
      (iee = "Arn"),
      (oee = "Audience"),
      (zE = "Credentials"),
      (aee = "ContextAssertion"),
      (KE = "DurationSeconds"),
      (see = "Expiration"),
      (cee = "ExternalId"),
      (uee = "Key"),
      (WE = "Policy"),
      (QE = "PolicyArns"),
      (lee = "ProviderArn"),
      (dee = "ProvidedContexts"),
      (fee = "ProviderId"),
      (YE = "PackedPolicySize"),
      (pee = "Provider"),
      (XE = "RoleArn"),
      (JE = "RoleSessionName"),
      (mee = "SecretAccessKey"),
      (hee = "SubjectFromWebIdentityToken"),
      (Jl = "SourceIdentity"),
      (gee = "SerialNumber"),
      (vee = "SessionToken"),
      (yee = "Tags"),
      (_ee = "TokenCode"),
      (Eee = "TransitiveTagKeys"),
      (Z9e = "Version"),
      (bee = "Value"),
      (See = "WebIdentityToken"),
      (Cee = "arn"),
      (En = "message"),
      (eYe = (e) =>
        Object.entries(e)
          .map(
            ([t, r]) =>
              (0, ht.extendedEncodeURIComponent)(t) +
              "=" +
              (0, ht.extendedEncodeURIComponent)(r),
          )
          .join("&")),
      (PAr = (e, t) => {
        if (t.Error?.Code !== void 0) return t.Error.Code;
        if (e.statusCode == 404) return "NotFound";
      });
  });
var tYe,
  rYe,
  nYe,
  Qh,
  CU = w(() => {
    c();
    (tYe = A(Wl())), (rYe = A(ip())), (nYe = A(At()));
    lU();
    xT();
    wee();
    Qh = class extends (
      nYe.Command.classBuilder()
        .ep(uU)
        .m(function (t, r, n, i) {
          return [
            (0, rYe.getSerdePlugin)(n, this.serialize, this.deserialize),
            (0, tYe.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AWSSecurityTokenServiceV20110615", "AssumeRole", {})
        .n("STSClient", "AssumeRoleCommand")
        .f(void 0, ZZ)
        .ser(U9e)
        .de(G9e)
        .build()
    ) {};
  });
var iYe,
  oYe,
  aYe,
  Yh,
  wU = w(() => {
    c();
    (iYe = A(Wl())), (oYe = A(ip())), (aYe = A(At()));
    lU();
    xT();
    wee();
    Yh = class extends (
      aYe.Command.classBuilder()
        .ep(uU)
        .m(function (t, r, n, i) {
          return [
            (0, oYe.getSerdePlugin)(n, this.serialize, this.deserialize),
            (0, iYe.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {})
        .n("STSClient", "AssumeRoleWithWebIdentityCommand")
        .f(eee, tee)
        .ser(H9e)
        .de(V9e)
        .build()
    ) {};
  });
var sYe,
  RAr,
  OU,
  cYe = w(() => {
    c();
    sYe = A(At());
    CU();
    wU();
    CT();
    (RAr = { AssumeRoleCommand: Qh, AssumeRoleWithWebIdentityCommand: Yh }),
      (OU = class extends Au {});
    (0, sYe.createAggregatedClient)(RAr, OU);
  });
var uYe = w(() => {
  c();
  CU();
  wU();
});
var lYe = w(() => {
  c();
  xT();
});
var dYe,
  fYe,
  pYe,
  mYe,
  hYe,
  gYe,
  vYe = w(() => {
    c();
    gu();
    CU();
    wU();
    (dYe = "us-east-1"),
      (fYe = (e) => {
        if (typeof e?.Arn == "string") {
          let t = e.Arn.split(":");
          if (t.length > 4 && t[4] !== "") return t[4];
        }
      }),
      (pYe = async (e, t, r) => {
        let n = typeof e == "function" ? await e() : e,
          i = typeof t == "function" ? await t() : t;
        return (
          r?.debug?.(
            "@aws-sdk/client-sts::resolveRegion",
            "accepting first of:",
            `${n} (provider)`,
            `${i} (parent client)`,
            `${dYe} (STS default)`,
          ),
          n ?? i ?? dYe
        );
      }),
      (mYe = (e, t) => {
        let r, n;
        return async (i, o) => {
          if (((n = i), !r)) {
            let {
                logger: d = e?.parentClientConfig?.logger,
                region: f,
                requestHandler: m = e?.parentClientConfig?.requestHandler,
                credentialProviderLogger: h,
              } = e,
              y = await pYe(f, e?.parentClientConfig?.region, h),
              _ = !gYe(m);
            r = new t({
              profile: e?.parentClientConfig?.profile,
              credentialDefaultProvider: () => async () => n,
              region: y,
              requestHandler: _ ? m : void 0,
              logger: d,
            });
          }
          let { Credentials: a, AssumedRoleUser: s } = await r.send(new Qh(o));
          if (!a || !a.AccessKeyId || !a.SecretAccessKey)
            throw new Error(
              `Invalid response from STS.assumeRole call with role ${o.RoleArn}`,
            );
          let u = fYe(s),
            l = {
              accessKeyId: a.AccessKeyId,
              secretAccessKey: a.SecretAccessKey,
              sessionToken: a.SessionToken,
              expiration: a.Expiration,
              ...(a.CredentialScope && { credentialScope: a.CredentialScope }),
              ...(u && { accountId: u }),
            };
          return cp(l, "CREDENTIALS_STS_ASSUME_ROLE", "i"), l;
        };
      }),
      (hYe = (e, t) => {
        let r;
        return async (n) => {
          if (!r) {
            let {
                logger: u = e?.parentClientConfig?.logger,
                region: l,
                requestHandler: d = e?.parentClientConfig?.requestHandler,
                credentialProviderLogger: f,
              } = e,
              m = await pYe(l, e?.parentClientConfig?.region, f),
              h = !gYe(d);
            r = new t({
              profile: e?.parentClientConfig?.profile,
              region: m,
              requestHandler: h ? d : void 0,
              logger: u,
            });
          }
          let { Credentials: i, AssumedRoleUser: o } = await r.send(new Yh(n));
          if (!i || !i.AccessKeyId || !i.SecretAccessKey)
            throw new Error(
              `Invalid response from STS.assumeRoleWithWebIdentity call with role ${n.RoleArn}`,
            );
          let a = fYe(o),
            s = {
              accessKeyId: i.AccessKeyId,
              secretAccessKey: i.SecretAccessKey,
              sessionToken: i.SessionToken,
              expiration: i.Expiration,
              ...(i.CredentialScope && { credentialScope: i.CredentialScope }),
              ...(a && { accountId: a }),
            };
          return (
            a && cp(s, "RESOLVED_ACCOUNT_ID", "T"),
            cp(s, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k"),
            s
          );
        };
      }),
      (gYe = (e) => e?.metadata?.handlerProtocol === "h2");
  });
var yYe,
  _Ye,
  EYe,
  IAr,
  bYe = w(() => {
    c();
    vYe();
    CT();
    (yYe = (e, t) =>
      t
        ? class extends e {
            constructor(n) {
              super(n);
              for (let i of t) this.middlewareStack.use(i);
            }
          }
        : e),
      (_Ye = (e = {}, t) => mYe(e, yYe(Au, t))),
      (EYe = (e = {}, t) => hYe(e, yYe(Au, t))),
      (IAr = (e) => (t) =>
        e({ roleAssumer: _Ye(t), roleAssumerWithWebIdentity: EYe(t), ...t }));
  });
var Oee = {};
bn(Oee, {
  AssumeRoleCommand: () => Qh,
  AssumeRoleResponseFilterSensitiveLog: () => ZZ,
  AssumeRoleWithWebIdentityCommand: () => Yh,
  AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => eee,
  AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => tee,
  CredentialsFilterSensitiveLog: () => JZ,
  ExpiredTokenException: () => wT,
  IDPCommunicationErrorException: () => IT,
  IDPRejectedClaimException: () => PT,
  InvalidIdentityTokenException: () => RT,
  MalformedPolicyDocumentException: () => OT,
  PackedPolicyTooLargeException: () => TT,
  RegionDisabledException: () => AT,
  STS: () => OU,
  STSClient: () => Au,
  STSServiceException: () => Vo,
  __Client: () => YZ.Client,
  decorateDefaultCredentialProvider: () => IAr,
  getDefaultRoleAssumer: () => _Ye,
  getDefaultRoleAssumerWithWebIdentity: () => EYe,
});
var Tee = w(() => {
  c();
  CT();
  cYe();
  uYe();
  lYe();
  bYe();
  SU();
});
var Ree = g((fWn, wYe) => {
  "use strict";
  c();
  var TU = Object.defineProperty,
    xAr = Object.getOwnPropertyDescriptor,
    NAr = Object.getOwnPropertyNames,
    kAr = Object.prototype.hasOwnProperty,
    Pee = (e, t) => TU(e, "name", { value: t, configurable: !0 }),
    DAr = (e, t) => {
      for (var r in t) TU(e, r, { get: t[r], enumerable: !0 });
    },
    LAr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of NAr(t))
          !kAr.call(e, i) &&
            i !== r &&
            TU(e, i, {
              get: () => t[i],
              enumerable: !(n = xAr(t, i)) || n.enumerable,
            });
      return e;
    },
    MAr = (e) => LAr(TU({}, "__esModule", { value: !0 }), e),
    CYe = {};
  DAr(CYe, { fromProcess: () => HAr });
  wYe.exports = MAr(CYe);
  var SYe = No(),
    Aee = Ho(),
    qAr = G("child_process"),
    jAr = G("util"),
    FAr = (gu(), ue(qh)),
    BAr = Pee((e, t, r) => {
      if (t.Version !== 1)
        throw Error(
          `Profile ${e} credential_process did not return Version 1.`,
        );
      if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0)
        throw Error(
          `Profile ${e} credential_process returned invalid credentials.`,
        );
      if (t.Expiration) {
        let o = new Date();
        if (new Date(t.Expiration) < o)
          throw Error(
            `Profile ${e} credential_process returned expired credentials.`,
          );
      }
      let n = t.AccountId;
      !n && r?.[e]?.aws_account_id && (n = r[e].aws_account_id);
      let i = {
        accessKeyId: t.AccessKeyId,
        secretAccessKey: t.SecretAccessKey,
        ...(t.SessionToken && { sessionToken: t.SessionToken }),
        ...(t.Expiration && { expiration: new Date(t.Expiration) }),
        ...(t.CredentialScope && { credentialScope: t.CredentialScope }),
        ...(n && { accountId: n }),
      };
      return (0, FAr.setCredentialFeature)(i, "CREDENTIALS_PROCESS", "w"), i;
    }, "getValidatedProcessCredentials"),
    UAr = Pee(async (e, t, r) => {
      let n = t[e];
      if (t[e]) {
        let i = n.credential_process;
        if (i !== void 0) {
          let o = (0, jAr.promisify)(qAr.exec);
          try {
            let { stdout: a } = await o(i),
              s;
            try {
              s = JSON.parse(a.trim());
            } catch {
              throw Error(
                `Profile ${e} credential_process returned invalid JSON.`,
              );
            }
            return BAr(e, s, t);
          } catch (a) {
            throw new Aee.CredentialsProviderError(a.message, { logger: r });
          }
        } else
          throw new Aee.CredentialsProviderError(
            `Profile ${e} did not contain credential_process.`,
            { logger: r },
          );
      } else
        throw new Aee.CredentialsProviderError(
          `Profile ${e} could not be found in shared credentials file.`,
          { logger: r },
        );
    }, "resolveProcessCredentials"),
    HAr = Pee(
      (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          e.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
          let r = await (0, SYe.parseKnownFiles)(e);
          return UAr(
            (0, SYe.getProfileName)({ profile: e.profile ?? t?.profile }),
            r,
            e.logger,
          );
        },
      "fromProcess",
    );
});
var Iee = g((Ru) => {
  "use strict";
  c();
  var GAr =
      (Ru && Ru.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r);
            var i = Object.getOwnPropertyDescriptor(t, r);
            (!i ||
              ("get" in i ? !t.__esModule : i.writable || i.configurable)) &&
              (i = {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              }),
              Object.defineProperty(e, n, i);
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    VAr =
      (Ru && Ru.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: !0, value: t });
          }
        : function (e, t) {
            e.default = t;
          }),
    $Ar =
      (Ru && Ru.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null)
          for (var r in e)
            r !== "default" &&
              Object.prototype.hasOwnProperty.call(e, r) &&
              GAr(t, e, r);
        return VAr(t, e), t;
      };
  Object.defineProperty(Ru, "__esModule", { value: !0 });
  Ru.fromWebToken = void 0;
  var zAr = (e) => async (t) => {
    e.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
    let {
        roleArn: r,
        roleSessionName: n,
        webIdentityToken: i,
        providerId: o,
        policyArns: a,
        policy: s,
        durationSeconds: u,
      } = e,
      { roleAssumerWithWebIdentity: l } = e;
    if (!l) {
      let { getDefaultRoleAssumerWithWebIdentity: d } =
        await Promise.resolve().then(() => $Ar((Tee(), ue(Oee))));
      l = d(
        {
          ...e.clientConfig,
          credentialProviderLogger: e.logger,
          parentClientConfig: {
            ...t?.callerClientConfig,
            ...e.parentClientConfig,
          },
        },
        e.clientPlugins,
      );
    }
    return l({
      RoleArn: r,
      RoleSessionName: n ?? `aws-sdk-js-session-${Date.now()}`,
      WebIdentityToken: i,
      ProviderId: o,
      PolicyArns: a,
      Policy: s,
      DurationSeconds: u,
    });
  };
  Ru.fromWebToken = zAr;
});
var TYe = g((AU) => {
  "use strict";
  c();
  Object.defineProperty(AU, "__esModule", { value: !0 });
  AU.fromTokenFile = void 0;
  var KAr = (gu(), ue(qh)),
    WAr = Ho(),
    QAr = G("fs"),
    YAr = Iee(),
    OYe = "AWS_WEB_IDENTITY_TOKEN_FILE",
    XAr = "AWS_ROLE_ARN",
    JAr = "AWS_ROLE_SESSION_NAME",
    ZAr =
      (e = {}) =>
      async () => {
        e.logger?.debug(
          "@aws-sdk/credential-provider-web-identity - fromTokenFile",
        );
        let t = e?.webIdentityTokenFile ?? process.env[OYe],
          r = e?.roleArn ?? process.env[XAr],
          n = e?.roleSessionName ?? process.env[JAr];
        if (!t || !r)
          throw new WAr.CredentialsProviderError(
            "Web identity configuration not specified",
            { logger: e.logger },
          );
        let i = await (0, YAr.fromWebToken)({
          ...e,
          webIdentityToken: (0, QAr.readFileSync)(t, { encoding: "ascii" }),
          roleArn: r,
          roleSessionName: n,
        })();
        return (
          t === process.env[OYe] &&
            (0, KAr.setCredentialFeature)(
              i,
              "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN",
              "h",
            ),
          i
        );
      };
  AU.fromTokenFile = ZAr;
});
var kee = g((yWn, PU) => {
  "use strict";
  c();
  var AYe = Object.defineProperty,
    ePr = Object.getOwnPropertyDescriptor,
    tPr = Object.getOwnPropertyNames,
    rPr = Object.prototype.hasOwnProperty,
    xee = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of tPr(t))
          !rPr.call(e, i) &&
            i !== r &&
            AYe(e, i, {
              get: () => t[i],
              enumerable: !(n = ePr(t, i)) || n.enumerable,
            });
      return e;
    },
    PYe = (e, t, r) => (xee(e, t, "default"), r && xee(r, t, "default")),
    nPr = (e) => xee(AYe({}, "__esModule", { value: !0 }), e),
    Nee = {};
  PU.exports = nPr(Nee);
  PYe(Nee, TYe(), PU.exports);
  PYe(Nee, Iee(), PU.exports);
});
var MYe = g((EWn, LYe) => {
  "use strict";
  c();
  var iPr = Object.create,
    kT = Object.defineProperty,
    oPr = Object.getOwnPropertyDescriptor,
    aPr = Object.getOwnPropertyNames,
    sPr = Object.getPrototypeOf,
    cPr = Object.prototype.hasOwnProperty,
    Ln = (e, t) => kT(e, "name", { value: t, configurable: !0 }),
    uPr = (e, t) => {
      for (var r in t) kT(e, r, { get: t[r], enumerable: !0 });
    },
    NYe = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of aPr(t))
          !cPr.call(e, i) &&
            i !== r &&
            kT(e, i, {
              get: () => t[i],
              enumerable: !(n = oPr(t, i)) || n.enumerable,
            });
      return e;
    },
    Ap = (e, t, r) => (
      (r = e != null ? iPr(sPr(e)) : {}),
      NYe(
        t || !e || !e.__esModule
          ? kT(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    lPr = (e) => NYe(kT({}, "__esModule", { value: !0 }), e),
    kYe = {};
  uPr(kYe, { fromIni: () => SPr });
  LYe.exports = lPr(kYe);
  var Lee = No(),
    Pp = (gu(), ue(qh)),
    NT = Ho(),
    dPr = Ln((e, t, r) => {
      let n = {
        EcsContainer: Ln(async (i) => {
          let { fromHttp: o } = await Promise.resolve().then(() => Ap(_Z())),
            { fromContainerMetadata: a } = await Promise.resolve().then(() =>
              Ap(QO()),
            );
          return (
            r?.debug(
              "@aws-sdk/credential-provider-ini - credential_source is EcsContainer",
            ),
            async () => (0, NT.chain)(o(i ?? {}), a(i))().then(Dee)
          );
        }, "EcsContainer"),
        Ec2InstanceMetadata: Ln(async (i) => {
          r?.debug(
            "@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata",
          );
          let { fromInstanceMetadata: o } = await Promise.resolve().then(() =>
            Ap(QO()),
          );
          return async () => o(i)().then(Dee);
        }, "Ec2InstanceMetadata"),
        Environment: Ln(async (i) => {
          r?.debug(
            "@aws-sdk/credential-provider-ini - credential_source is Environment",
          );
          let { fromEnv: o } = await Promise.resolve().then(() => Ap(fZ()));
          return async () => o(i)().then(Dee);
        }, "Environment"),
      };
      if (e in n) return n[e];
      throw new NT.CredentialsProviderError(
        `Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`,
        { logger: r },
      );
    }, "resolveCredentialSource"),
    Dee = Ln(
      (e) =>
        (0, Pp.setCredentialFeature)(
          e,
          "CREDENTIALS_PROFILE_NAMED_PROVIDER",
          "p",
        ),
      "setNamedProvider",
    ),
    fPr = Ln(
      (e, { profile: t = "default", logger: r } = {}) =>
        !!e &&
        typeof e == "object" &&
        typeof e.role_arn == "string" &&
        ["undefined", "string"].indexOf(typeof e.role_session_name) > -1 &&
        ["undefined", "string"].indexOf(typeof e.external_id) > -1 &&
        ["undefined", "string"].indexOf(typeof e.mfa_serial) > -1 &&
        (pPr(e, { profile: t, logger: r }) ||
          mPr(e, { profile: t, logger: r })),
      "isAssumeRoleProfile",
    ),
    pPr = Ln((e, { profile: t, logger: r }) => {
      let n =
        typeof e.source_profile == "string" && typeof e.credential_source > "u";
      return (
        n &&
          r?.debug?.(
            `    ${t} isAssumeRoleWithSourceProfile source_profile=${e.source_profile}`,
          ),
        n
      );
    }, "isAssumeRoleWithSourceProfile"),
    mPr = Ln((e, { profile: t, logger: r }) => {
      let n =
        typeof e.credential_source == "string" && typeof e.source_profile > "u";
      return (
        n &&
          r?.debug?.(
            `    ${t} isCredentialSourceProfile credential_source=${e.credential_source}`,
          ),
        n
      );
    }, "isCredentialSourceProfile"),
    hPr = Ln(async (e, t, r, n = {}) => {
      r.logger?.debug(
        "@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)",
      );
      let i = t[e],
        { source_profile: o, region: a } = i;
      if (!r.roleAssumer) {
        let { getDefaultRoleAssumer: u } = await Promise.resolve().then(() =>
          Ap((Tee(), ue(Oee))),
        );
        r.roleAssumer = u(
          {
            ...r.clientConfig,
            credentialProviderLogger: r.logger,
            parentClientConfig: {
              ...r?.parentClientConfig,
              region: a ?? r?.parentClientConfig?.region,
            },
          },
          r.clientPlugins,
        );
      }
      if (o && o in n)
        throw new NT.CredentialsProviderError(
          `Detected a cycle attempting to resolve credentials for profile ${(0, Lee.getProfileName)(r)}. Profiles visited: ` +
            Object.keys(n).join(", "),
          { logger: r.logger },
        );
      r.logger?.debug(
        `@aws-sdk/credential-provider-ini - finding credential resolver using ${o ? `source_profile=[${o}]` : `profile=[${e}]`}`,
      );
      let s = o
        ? DYe(o, t, r, { ...n, [o]: !0 }, RYe(t[o] ?? {}))
        : (await dPr(i.credential_source, e, r.logger)(r))();
      if (RYe(i))
        return s.then((u) =>
          (0, Pp.setCredentialFeature)(
            u,
            "CREDENTIALS_PROFILE_SOURCE_PROFILE",
            "o",
          ),
        );
      {
        let u = {
            RoleArn: i.role_arn,
            RoleSessionName: i.role_session_name || `aws-sdk-js-${Date.now()}`,
            ExternalId: i.external_id,
            DurationSeconds: parseInt(i.duration_seconds || "3600", 10),
          },
          { mfa_serial: l } = i;
        if (l) {
          if (!r.mfaCodeProvider)
            throw new NT.CredentialsProviderError(
              `Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`,
              { logger: r.logger, tryNextLink: !1 },
            );
          (u.SerialNumber = l), (u.TokenCode = await r.mfaCodeProvider(l));
        }
        let d = await s;
        return r
          .roleAssumer(d, u)
          .then((f) =>
            (0, Pp.setCredentialFeature)(
              f,
              "CREDENTIALS_PROFILE_SOURCE_PROFILE",
              "o",
            ),
          );
      }
    }, "resolveAssumeRoleCredentials"),
    RYe = Ln(
      (e) => !e.role_arn && !!e.credential_source,
      "isCredentialSourceWithoutRoleArn",
    ),
    gPr = Ln(
      (e) =>
        !!e && typeof e == "object" && typeof e.credential_process == "string",
      "isProcessProfile",
    ),
    vPr = Ln(
      async (e, t) =>
        Promise.resolve()
          .then(() => Ap(Ree()))
          .then(({ fromProcess: r }) =>
            r({ ...e, profile: t })().then((n) =>
              (0, Pp.setCredentialFeature)(
                n,
                "CREDENTIALS_PROFILE_PROCESS",
                "v",
              ),
            ),
          ),
      "resolveProcessCredentials",
    ),
    yPr = Ln(async (e, t, r = {}) => {
      let { fromSSO: n } = await Promise.resolve().then(() => Ap(zZ()));
      return n({
        profile: e,
        logger: r.logger,
        parentClientConfig: r.parentClientConfig,
        clientConfig: r.clientConfig,
      })().then((i) =>
        t.sso_session
          ? (0, Pp.setCredentialFeature)(i, "CREDENTIALS_PROFILE_SSO", "r")
          : (0, Pp.setCredentialFeature)(
              i,
              "CREDENTIALS_PROFILE_SSO_LEGACY",
              "t",
            ),
      );
    }, "resolveSsoCredentials"),
    _Pr = Ln(
      (e) =>
        e &&
        (typeof e.sso_start_url == "string" ||
          typeof e.sso_account_id == "string" ||
          typeof e.sso_session == "string" ||
          typeof e.sso_region == "string" ||
          typeof e.sso_role_name == "string"),
      "isSsoProfile",
    ),
    IYe = Ln(
      (e) =>
        !!e &&
        typeof e == "object" &&
        typeof e.aws_access_key_id == "string" &&
        typeof e.aws_secret_access_key == "string" &&
        ["undefined", "string"].indexOf(typeof e.aws_session_token) > -1 &&
        ["undefined", "string"].indexOf(typeof e.aws_account_id) > -1,
      "isStaticCredsProfile",
    ),
    xYe = Ln(async (e, t) => {
      t?.logger?.debug(
        "@aws-sdk/credential-provider-ini - resolveStaticCredentials",
      );
      let r = {
        accessKeyId: e.aws_access_key_id,
        secretAccessKey: e.aws_secret_access_key,
        sessionToken: e.aws_session_token,
        ...(e.aws_credential_scope && {
          credentialScope: e.aws_credential_scope,
        }),
        ...(e.aws_account_id && { accountId: e.aws_account_id }),
      };
      return (0, Pp.setCredentialFeature)(r, "CREDENTIALS_PROFILE", "n");
    }, "resolveStaticCredentials"),
    EPr = Ln(
      (e) =>
        !!e &&
        typeof e == "object" &&
        typeof e.web_identity_token_file == "string" &&
        typeof e.role_arn == "string" &&
        ["undefined", "string"].indexOf(typeof e.role_session_name) > -1,
      "isWebIdentityProfile",
    ),
    bPr = Ln(
      async (e, t) =>
        Promise.resolve()
          .then(() => Ap(kee()))
          .then(({ fromTokenFile: r }) =>
            r({
              webIdentityTokenFile: e.web_identity_token_file,
              roleArn: e.role_arn,
              roleSessionName: e.role_session_name,
              roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity,
              logger: t.logger,
              parentClientConfig: t.parentClientConfig,
            })().then((n) =>
              (0, Pp.setCredentialFeature)(
                n,
                "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN",
                "q",
              ),
            ),
          ),
      "resolveWebIdentityCredentials",
    ),
    DYe = Ln(async (e, t, r, n = {}, i = !1) => {
      let o = t[e];
      if (Object.keys(n).length > 0 && IYe(o)) return xYe(o, r);
      if (i || fPr(o, { profile: e, logger: r.logger })) return hPr(e, t, r, n);
      if (IYe(o)) return xYe(o, r);
      if (EPr(o)) return bPr(o, r);
      if (gPr(o)) return vPr(r, e);
      if (_Pr(o)) return await yPr(e, o, r);
      throw new NT.CredentialsProviderError(
        `Could not resolve credentials using profile: [${e}] in configuration/credentials file(s).`,
        { logger: r.logger },
      );
    }, "resolveProfileData"),
    SPr = Ln(
      (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          let r = {
            ...e,
            parentClientConfig: { ...t, ...e.parentClientConfig },
          };
          r.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
          let n = await (0, Lee.parseKnownFiles)(r);
          return DYe(
            (0, Lee.getProfileName)({ profile: e.profile ?? t?.profile }),
            n,
            r,
          );
        },
      "fromIni",
    );
});
var VYe = g((SWn, GYe) => {
  "use strict";
  c();
  var CPr = Object.create,
    DT = Object.defineProperty,
    wPr = Object.getOwnPropertyDescriptor,
    OPr = Object.getOwnPropertyNames,
    TPr = Object.getPrototypeOf,
    APr = Object.prototype.hasOwnProperty,
    RU = (e, t) => DT(e, "name", { value: t, configurable: !0 }),
    PPr = (e, t) => {
      for (var r in t) DT(e, r, { get: t[r], enumerable: !0 });
    },
    FYe = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of OPr(t))
          !APr.call(e, i) &&
            i !== r &&
            DT(e, i, {
              get: () => t[i],
              enumerable: !(n = wPr(t, i)) || n.enumerable,
            });
      return e;
    },
    ZE = (e, t, r) => (
      (r = e != null ? CPr(TPr(e)) : {}),
      FYe(
        t || !e || !e.__esModule
          ? DT(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    RPr = (e) => FYe(DT({}, "__esModule", { value: !0 }), e),
    BYe = {};
  PPr(BYe, {
    credentialsTreatedAsExpired: () => HYe,
    credentialsWillNeedRefresh: () => UYe,
    defaultProvider: () => NPr,
  });
  GYe.exports = RPr(BYe);
  var Mee = fZ(),
    IPr = No(),
    Xh = Ho(),
    qYe = "AWS_EC2_METADATA_DISABLED",
    xPr = RU(async (e) => {
      let {
        ENV_CMDS_FULL_URI: t,
        ENV_CMDS_RELATIVE_URI: r,
        fromContainerMetadata: n,
        fromInstanceMetadata: i,
      } = await Promise.resolve().then(() => ZE(QO()));
      if (process.env[r] || process.env[t]) {
        e.logger?.debug(
          "@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata",
        );
        let { fromHttp: o } = await Promise.resolve().then(() => ZE(_Z()));
        return (0, Xh.chain)(o(e), n(e));
      }
      return process.env[qYe] && process.env[qYe] !== "false"
        ? async () => {
            throw new Xh.CredentialsProviderError(
              "EC2 Instance Metadata Service access disabled",
              { logger: e.logger },
            );
          }
        : (e.logger?.debug(
            "@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata",
          ),
          i(e));
    }, "remoteProvider"),
    jYe = !1,
    NPr = RU(
      (e = {}) =>
        (0, Xh.memoize)(
          (0, Xh.chain)(
            async () => {
              if (e.profile ?? process.env[IPr.ENV_PROFILE])
                throw (
                  (process.env[Mee.ENV_KEY] &&
                    process.env[Mee.ENV_SECRET] &&
                    (jYe ||
                      ((e.logger?.warn &&
                        e.logger?.constructor?.name !== "NoOpLogger"
                        ? e.logger.warn
                        : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`),
                      (jYe = !0))),
                  new Xh.CredentialsProviderError(
                    "AWS_PROFILE is set, skipping fromEnv provider.",
                    { logger: e.logger, tryNextLink: !0 },
                  ))
                );
              return (
                e.logger?.debug(
                  "@aws-sdk/credential-provider-node - defaultProvider::fromEnv",
                ),
                (0, Mee.fromEnv)(e)()
              );
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromSSO",
              );
              let {
                ssoStartUrl: t,
                ssoAccountId: r,
                ssoRegion: n,
                ssoRoleName: i,
                ssoSession: o,
              } = e;
              if (!t && !r && !n && !i && !o)
                throw new Xh.CredentialsProviderError(
                  "Skipping SSO provider in default chain (inputs do not include SSO fields).",
                  { logger: e.logger },
                );
              let { fromSSO: a } = await Promise.resolve().then(() => ZE(zZ()));
              return a(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromIni",
              );
              let { fromIni: t } = await Promise.resolve().then(() =>
                ZE(MYe()),
              );
              return t(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromProcess",
              );
              let { fromProcess: t } = await Promise.resolve().then(() =>
                ZE(Ree()),
              );
              return t(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile",
              );
              let { fromTokenFile: t } = await Promise.resolve().then(() =>
                ZE(kee()),
              );
              return t(e)();
            },
            async () => (
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::remoteProvider",
              ),
              (await xPr(e))()
            ),
            async () => {
              throw new Xh.CredentialsProviderError(
                "Could not load credentials from any providers",
                { tryNextLink: !1, logger: e.logger },
              );
            },
          ),
          HYe,
          UYe,
        ),
      "defaultProvider",
    ),
    UYe = RU((e) => e?.expiration !== void 0, "credentialsWillNeedRefresh"),
    HYe = RU(
      (e) =>
        e?.expiration !== void 0 && e.expiration.getTime() - Date.now() < 3e5,
      "credentialsTreatedAsExpired",
    );
});
var eXe = g((wWn, ZYe) => {
  c();
  var IU = Object.defineProperty,
    kPr = Object.getOwnPropertyDescriptor,
    DPr = Object.getOwnPropertyNames,
    LPr = Object.prototype.hasOwnProperty,
    xU = (e, t) => IU(e, "name", { value: t, configurable: !0 }),
    MPr = (e, t) => {
      for (var r in t) IU(e, r, { get: t[r], enumerable: !0 });
    },
    qPr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of DPr(t))
          !LPr.call(e, i) &&
            i !== r &&
            IU(e, i, {
              get: () => t[i],
              enumerable: !(n = kPr(t, i)) || n.enumerable,
            });
      return e;
    },
    jPr = (e) => qPr(IU({}, "__esModule", { value: !0 }), e),
    $Ye = {};
  MPr($Ye, {
    AlgorithmId: () => QYe,
    EndpointURLScheme: () => WYe,
    FieldPosition: () => YYe,
    HttpApiKeyAuthLocation: () => KYe,
    HttpAuthLocation: () => zYe,
    IniSectionType: () => XYe,
    RequestHandlerProtocol: () => JYe,
    SMITHY_CONTEXT_KEY: () => GPr,
    getDefaultClientConfiguration: () => UPr,
    resolveDefaultRuntimeConfig: () => HPr,
  });
  ZYe.exports = jPr($Ye);
  var zYe = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(zYe || {}),
    KYe = ((e) => ((e.HEADER = "header"), (e.QUERY = "query"), e))(KYe || {}),
    WYe = ((e) => ((e.HTTP = "http"), (e.HTTPS = "https"), e))(WYe || {}),
    QYe = ((e) => (
      (e.MD5 = "md5"),
      (e.CRC32 = "crc32"),
      (e.CRC32C = "crc32c"),
      (e.SHA1 = "sha1"),
      (e.SHA256 = "sha256"),
      e
    ))(QYe || {}),
    FPr = xU((e) => {
      let t = [];
      return (
        e.sha256 !== void 0 &&
          t.push({
            algorithmId: () => "sha256",
            checksumConstructor: () => e.sha256,
          }),
        e.md5 != null &&
          t.push({
            algorithmId: () => "md5",
            checksumConstructor: () => e.md5,
          }),
        {
          addChecksumAlgorithm(r) {
            t.push(r);
          },
          checksumAlgorithms() {
            return t;
          },
        }
      );
    }, "getChecksumConfiguration"),
    BPr = xU((e) => {
      let t = {};
      return (
        e.checksumAlgorithms().forEach((r) => {
          t[r.algorithmId()] = r.checksumConstructor();
        }),
        t
      );
    }, "resolveChecksumRuntimeConfig"),
    UPr = xU((e) => FPr(e), "getDefaultClientConfiguration"),
    HPr = xU((e) => BPr(e), "resolveDefaultRuntimeConfig"),
    YYe = ((e) => (
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER"), e
    ))(YYe || {}),
    GPr = "__smithy_context",
    XYe = ((e) => (
      (e.PROFILE = "profile"),
      (e.SSO_SESSION = "sso-session"),
      (e.SERVICES = "services"),
      e
    ))(XYe || {}),
    JYe = ((e) => (
      (e.HTTP_0_9 = "http/0.9"),
      (e.HTTP_1_0 = "http/1.0"),
      (e.TDS_8_0 = "tds/8.0"),
      e
    ))(JYe || {});
});
var aXe = g((TWn, oXe) => {
  c();
  var NU = Object.defineProperty,
    VPr = Object.getOwnPropertyDescriptor,
    $Pr = Object.getOwnPropertyNames,
    zPr = Object.prototype.hasOwnProperty,
    Rp = (e, t) => NU(e, "name", { value: t, configurable: !0 }),
    KPr = (e, t) => {
      for (var r in t) NU(e, r, { get: t[r], enumerable: !0 });
    },
    WPr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of $Pr(t))
          !zPr.call(e, i) &&
            i !== r &&
            NU(e, i, {
              get: () => t[i],
              enumerable: !(n = VPr(t, i)) || n.enumerable,
            });
      return e;
    },
    QPr = (e) => WPr(NU({}, "__esModule", { value: !0 }), e),
    tXe = {};
  KPr(tXe, {
    Field: () => JPr,
    Fields: () => ZPr,
    HttpRequest: () => eRr,
    HttpResponse: () => tRr,
    IHttpRequest: () => rXe.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => YPr,
    isValidHostname: () => iXe,
    resolveHttpHandlerRuntimeConfig: () => XPr,
  });
  oXe.exports = QPr(tXe);
  var YPr = Rp(
      (e) => ({
        setHttpHandler(t) {
          e.httpHandler = t;
        },
        httpHandler() {
          return e.httpHandler;
        },
        updateHttpClientConfig(t, r) {
          e.httpHandler?.updateHttpClientConfig(t, r);
        },
        httpHandlerConfigs() {
          return e.httpHandler.httpHandlerConfigs();
        },
      }),
      "getHttpHandlerExtensionConfiguration",
    ),
    XPr = Rp(
      (e) => ({ httpHandler: e.httpHandler() }),
      "resolveHttpHandlerRuntimeConfig",
    ),
    rXe = eXe(),
    JPr = class {
      static {
        Rp(this, "Field");
      }
      constructor({
        name: e,
        kind: t = rXe.FieldPosition.HEADER,
        values: r = [],
      }) {
        (this.name = e), (this.kind = t), (this.values = r);
      }
      add(e) {
        this.values.push(e);
      }
      set(e) {
        this.values = e;
      }
      remove(e) {
        this.values = this.values.filter((t) => t !== e);
      }
      toString() {
        return this.values
          .map((e) => (e.includes(",") || e.includes(" ") ? `"${e}"` : e))
          .join(", ");
      }
      get() {
        return this.values;
      }
    },
    ZPr = class {
      constructor({ fields: e = [], encoding: t = "utf-8" }) {
        (this.entries = {}),
          e.forEach(this.setField.bind(this)),
          (this.encoding = t);
      }
      static {
        Rp(this, "Fields");
      }
      setField(e) {
        this.entries[e.name.toLowerCase()] = e;
      }
      getField(e) {
        return this.entries[e.toLowerCase()];
      }
      removeField(e) {
        delete this.entries[e.toLowerCase()];
      }
      getByType(e) {
        return Object.values(this.entries).filter((t) => t.kind === e);
      }
    },
    eRr = class qee {
      static {
        Rp(this, "HttpRequest");
      }
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new qee({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = nXe(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return qee.clone(this);
      }
    };
  function nXe(e) {
    return Object.keys(e).reduce((t, r) => {
      let n = e[r];
      return { ...t, [r]: Array.isArray(n) ? [...n] : n };
    }, {});
  }
  Rp(nXe, "cloneQuery");
  var tRr = class {
    static {
      Rp(this, "HttpResponse");
    }
    constructor(e) {
      (this.statusCode = e.statusCode),
        (this.reason = e.reason),
        (this.headers = e.headers || {}),
        (this.body = e.body);
    }
    static isInstance(e) {
      if (!e) return !1;
      let t = e;
      return typeof t.statusCode == "number" && typeof t.headers == "object";
    }
  };
  function iXe(e) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e);
  }
  Rp(iXe, "isValidHostname");
});
var TXe = g((xWn, OXe) => {
  "use strict";
  c();
  var kU = Object.defineProperty,
    rRr = Object.getOwnPropertyDescriptor,
    nRr = Object.getOwnPropertyNames,
    iRr = Object.prototype.hasOwnProperty,
    Rt = (e, t) => kU(e, "name", { value: t, configurable: !0 }),
    oRr = (e, t) => {
      for (var r in t) kU(e, r, { get: t[r], enumerable: !0 });
    },
    aRr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of nRr(t))
          !iRr.call(e, i) &&
            i !== r &&
            kU(e, i, {
              get: () => t[i],
              enumerable: !(n = rRr(t, i)) || n.enumerable,
            });
      return e;
    },
    sRr = (e) => aRr(kU({}, "__esModule", { value: !0 }), e),
    cXe = {};
  oRr(cXe, {
    NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS: () => cRr,
    NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME: () => uXe,
    NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME: () => lXe,
    NODE_USE_ARN_REGION_CONFIG_OPTIONS: () => uRr,
    NODE_USE_ARN_REGION_ENV_NAME: () => dXe,
    NODE_USE_ARN_REGION_INI_NAME: () => fXe,
    bucketEndpointMiddleware: () => SXe,
    bucketEndpointMiddlewareOptions: () => CXe,
    bucketHostname: () => Bee,
    getArnResources: () => EXe,
    getBucketEndpointPlugin: () => RRr,
    getSuffixForArnEndpoint: () => gXe,
    resolveBucketEndpointConfig: () => wXe,
    validateAccountId: () => _Xe,
    validateDNSHostLabel: () => eb,
    validateNoDualstack: () => LU,
    validateNoFIPS: () => bXe,
    validateOutpostService: () => vXe,
    validatePartition: () => yXe,
    validateRegion: () => DU,
  });
  OXe.exports = sRr(cXe);
  var Ip = GC(),
    uXe = "AWS_S3_DISABLE_MULTIREGION_ACCESS_POINTS",
    lXe = "s3_disable_multiregion_access_points",
    cRr = {
      environmentVariableSelector: Rt(
        (e) => (0, Ip.booleanSelector)(e, uXe, Ip.SelectorType.ENV),
        "environmentVariableSelector",
      ),
      configFileSelector: Rt(
        (e) => (0, Ip.booleanSelector)(e, lXe, Ip.SelectorType.CONFIG),
        "configFileSelector",
      ),
      default: !1,
    },
    dXe = "AWS_S3_USE_ARN_REGION",
    fXe = "s3_use_arn_region",
    uRr = {
      environmentVariableSelector: Rt(
        (e) => (0, Ip.booleanSelector)(e, dXe, Ip.SelectorType.ENV),
        "environmentVariableSelector",
      ),
      configFileSelector: Rt(
        (e) => (0, Ip.booleanSelector)(e, fXe, Ip.SelectorType.CONFIG),
        "configFileSelector",
      ),
      default: !1,
    },
    sXe = AX(),
    lRr = aXe(),
    dRr = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/,
    fRr = /(\d+\.){3}\d+/,
    pRr = /\.\./,
    pXe = /\./,
    mRr = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./,
    mXe = /^s3(-external-1)?\.amazonaws\.com$/,
    Fee = "amazonaws.com",
    hRr = Rt((e) => typeof e.bucketName == "string", "isBucketNameOptions"),
    gRr = Rt(
      (e) => dRr.test(e) && !fRr.test(e) && !pRr.test(e),
      "isDnsCompatibleBucketName",
    ),
    hXe = Rt((e) => {
      let t = e.match(mRr);
      return [t[4], e.replace(new RegExp(`^${t[0]}`), "")];
    }, "getRegionalSuffix"),
    vRr = Rt((e) => (mXe.test(e) ? ["us-east-1", Fee] : hXe(e)), "getSuffix"),
    gXe = Rt(
      (e) => (mXe.test(e) ? [e.replace(`.${Fee}`, ""), Fee] : hXe(e)),
      "getSuffixForArnEndpoint",
    ),
    yRr = Rt((e) => {
      if (e.pathStyleEndpoint)
        throw new Error(
          "Path-style S3 endpoint is not supported when bucket is an ARN",
        );
      if (e.accelerateEndpoint)
        throw new Error(
          "Accelerate endpoint is not supported when bucket is an ARN",
        );
      if (!e.tlsCompatible)
        throw new Error("HTTPS is required when bucket is an ARN");
    }, "validateArnEndpointOptions"),
    _Rr = Rt((e) => {
      if (e !== "s3" && e !== "s3-outposts" && e !== "s3-object-lambda")
        throw new Error(
          "Expect 's3' or 's3-outposts' or 's3-object-lambda' in ARN service component",
        );
    }, "validateService"),
    ERr = Rt((e) => {
      if (e !== "s3")
        throw new Error("Expect 's3' in Accesspoint ARN service component");
    }, "validateS3Service"),
    vXe = Rt((e) => {
      if (e !== "s3-outposts")
        throw new Error("Expect 's3-posts' in Outpost ARN service component");
    }, "validateOutpostService"),
    yXe = Rt((e, t) => {
      if (e !== t.clientPartition)
        throw new Error(
          `Partition in ARN is incompatible, got "${e}" but expected "${t.clientPartition}"`,
        );
    }, "validatePartition"),
    DU = Rt((e, t) => {
      if (e === "") throw new Error("ARN region is empty");
      if (t.useFipsEndpoint)
        if (t.allowFipsRegion) {
          if (!jee(e, t.clientRegion))
            throw new Error(
              `Client FIPS region ${t.clientRegion} doesn't match region ${e} in ARN`,
            );
        } else throw new Error("FIPS region is not supported");
      if (
        !t.useArnRegion &&
        !jee(e, t.clientRegion || "") &&
        !jee(e, t.clientSigningRegion || "")
      )
        throw new Error(
          `Region in ARN is incompatible, got ${e} but expected ${t.clientRegion}`,
        );
    }, "validateRegion"),
    Uee = Rt((e) => {
      if (["s3-external-1", "aws-global"].includes(e))
        throw new Error(`Client region ${e} is not regional`);
    }, "validateRegionalClient"),
    jee = Rt((e, t) => e === t, "isEqualRegions"),
    _Xe = Rt((e) => {
      if (!/[0-9]{12}/.exec(e))
        throw new Error(
          "Access point ARN accountID does not match regex '[0-9]{12}'",
        );
    }, "validateAccountId"),
    eb = Rt((e, t = { tlsCompatible: !0 }) => {
      if (
        e.length >= 64 ||
        !/^[a-z0-9][a-z0-9.-]*[a-z0-9]$/.test(e) ||
        /(\d+\.){3}\d+/.test(e) ||
        /[.-]{2}/.test(e) ||
        (t?.tlsCompatible && pXe.test(e))
      )
        throw new Error(`Invalid DNS label ${e}`);
    }, "validateDNSHostLabel"),
    bRr = Rt((e) => {
      if (e.isCustomEndpoint) {
        if (e.dualstackEndpoint)
          throw new Error(
            "Dualstack endpoint is not supported with custom endpoint",
          );
        if (e.accelerateEndpoint)
          throw new Error(
            "Accelerate endpoint is not supported with custom endpoint",
          );
      }
    }, "validateCustomEndpoint"),
    EXe = Rt((e) => {
      let t = e.includes(":") ? ":" : "/",
        [r, ...n] = e.split(t);
      if (r === "accesspoint") {
        if (n.length !== 1 || n[0] === "")
          throw new Error(
            `Access Point ARN should have one resource accesspoint${t}{accesspointname}`,
          );
        return { accesspointName: n[0] };
      } else if (r === "outpost") {
        if (!n[0] || n[1] !== "accesspoint" || !n[2] || n.length !== 3)
          throw new Error(
            `Outpost ARN should have resource outpost${t}{outpostId}${t}accesspoint${t}{accesspointName}`,
          );
        let [i, o, a] = n;
        return { outpostId: i, accesspointName: a };
      } else
        throw new Error(
          `ARN resource should begin with 'accesspoint${t}' or 'outpost${t}'`,
        );
    }, "getArnResources"),
    LU = Rt((e) => {
      if (e)
        throw new Error(
          "Dualstack endpoint is not supported with Outpost or Multi-region Access Point ARN.",
        );
    }, "validateNoDualstack"),
    bXe = Rt((e) => {
      if (e) throw new Error("FIPS region is not supported with Outpost.");
    }, "validateNoFIPS"),
    SRr = Rt((e) => {
      try {
        e.split(".").forEach((t) => {
          eb(t);
        });
      } catch {
        throw new Error(`"${e}" is not a DNS compatible name.`);
      }
    }, "validateMrapAlias"),
    Bee = Rt((e) => (bRr(e), hRr(e) ? CRr(e) : wRr(e)), "bucketHostname"),
    CRr = Rt(
      ({
        accelerateEndpoint: e = !1,
        clientRegion: t,
        baseHostname: r,
        bucketName: n,
        dualstackEndpoint: i = !1,
        fipsEndpoint: o = !1,
        pathStyleEndpoint: a = !1,
        tlsCompatible: s = !0,
        isCustomEndpoint: u = !1,
      }) => {
        let [l, d] = u ? [t, r] : vRr(r);
        return a || !gRr(n) || (s && pXe.test(n))
          ? { bucketEndpoint: !1, hostname: i ? `s3.dualstack.${l}.${d}` : r }
          : (e
              ? (r = `s3-accelerate${i ? ".dualstack" : ""}.${d}`)
              : i && (r = `s3.dualstack.${l}.${d}`),
            { bucketEndpoint: !0, hostname: `${n}.${r}` });
      },
      "getEndpointFromBucketName",
    ),
    wRr = Rt((e) => {
      let { isCustomEndpoint: t, baseHostname: r, clientRegion: n } = e,
        i = t ? r : gXe(r)[1],
        {
          pathStyleEndpoint: o,
          accelerateEndpoint: a = !1,
          fipsEndpoint: s = !1,
          tlsCompatible: u = !0,
          bucketName: l,
          clientPartition: d = "aws",
        } = e;
      yRr({ pathStyleEndpoint: o, accelerateEndpoint: a, tlsCompatible: u });
      let {
        service: f,
        partition: m,
        accountId: h,
        region: y,
        resource: _,
      } = l;
      _Rr(f), yXe(m, { clientPartition: d }), _Xe(h);
      let { accesspointName: E, outpostId: b } = EXe(_);
      return f === "s3-object-lambda"
        ? ORr({
            ...e,
            tlsCompatible: u,
            bucketName: l,
            accesspointName: E,
            hostnameSuffix: i,
          })
        : y === ""
          ? TRr({ ...e, clientRegion: n, mrapAlias: E, hostnameSuffix: i })
          : b
            ? ARr({
                ...e,
                clientRegion: n,
                outpostId: b,
                accesspointName: E,
                hostnameSuffix: i,
              })
            : PRr({
                ...e,
                clientRegion: n,
                accesspointName: E,
                hostnameSuffix: i,
              });
    }, "getEndpointFromArn"),
    ORr = Rt(
      ({
        dualstackEndpoint: e = !1,
        fipsEndpoint: t = !1,
        tlsCompatible: r = !0,
        useArnRegion: n,
        clientRegion: i,
        clientSigningRegion: o = i,
        accesspointName: a,
        bucketName: s,
        hostnameSuffix: u,
      }) => {
        let { accountId: l, region: d, service: f } = s;
        Uee(i),
          DU(d, {
            useArnRegion: n,
            clientRegion: i,
            clientSigningRegion: o,
            allowFipsRegion: !0,
            useFipsEndpoint: t,
          }),
          LU(e);
        let m = `${a}-${l}`;
        eb(m, { tlsCompatible: r });
        let h = n ? d : i,
          y = n ? d : o;
        return {
          bucketEndpoint: !0,
          hostname: `${m}.${f}${t ? "-fips" : ""}.${h}.${u}`,
          signingRegion: y,
          signingService: f,
        };
      },
      "getEndpointFromObjectLambdaArn",
    ),
    TRr = Rt(
      ({
        disableMultiregionAccessPoints: e,
        dualstackEndpoint: t = !1,
        isCustomEndpoint: r,
        mrapAlias: n,
        hostnameSuffix: i,
      }) => {
        if (e === !0)
          throw new Error(
            "SDK is attempting to use a MRAP ARN. Please enable to feature.",
          );
        return (
          SRr(n),
          LU(t),
          {
            bucketEndpoint: !0,
            hostname: `${n}${r ? "" : ".accesspoint.s3-global"}.${i}`,
            signingRegion: "*",
          }
        );
      },
      "getEndpointFromMRAPArn",
    ),
    ARr = Rt(
      ({
        useArnRegion: e,
        clientRegion: t,
        clientSigningRegion: r = t,
        bucketName: n,
        outpostId: i,
        dualstackEndpoint: o = !1,
        fipsEndpoint: a = !1,
        tlsCompatible: s = !0,
        accesspointName: u,
        isCustomEndpoint: l,
        hostnameSuffix: d,
      }) => {
        Uee(t),
          DU(n.region, {
            useArnRegion: e,
            clientRegion: t,
            clientSigningRegion: r,
            useFipsEndpoint: a,
          });
        let f = `${u}-${n.accountId}`;
        eb(f, { tlsCompatible: s });
        let m = e ? n.region : t,
          h = e ? n.region : r;
        return (
          vXe(n.service),
          eb(i, { tlsCompatible: s }),
          LU(o),
          bXe(a),
          {
            bucketEndpoint: !0,
            hostname: `${`${f}.${i}`}${l ? "" : `.s3-outposts.${m}`}.${d}`,
            signingRegion: h,
            signingService: "s3-outposts",
          }
        );
      },
      "getEndpointFromOutpostArn",
    ),
    PRr = Rt(
      ({
        useArnRegion: e,
        clientRegion: t,
        clientSigningRegion: r = t,
        bucketName: n,
        dualstackEndpoint: i = !1,
        fipsEndpoint: o = !1,
        tlsCompatible: a = !0,
        accesspointName: s,
        isCustomEndpoint: u,
        hostnameSuffix: l,
      }) => {
        Uee(t),
          DU(n.region, {
            useArnRegion: e,
            clientRegion: t,
            clientSigningRegion: r,
            allowFipsRegion: !0,
            useFipsEndpoint: o,
          });
        let d = `${s}-${n.accountId}`;
        eb(d, { tlsCompatible: a });
        let f = e ? n.region : t,
          m = e ? n.region : r;
        return (
          ERr(n.service),
          {
            bucketEndpoint: !0,
            hostname: `${d}${u ? "" : `.s3-accesspoint${o ? "-fips" : ""}${i ? ".dualstack" : ""}.${f}`}.${l}`,
            signingRegion: m,
          }
        );
      },
      "getEndpointFromAccessPointArn",
    ),
    SXe = Rt(
      (e) => (t, r) => async (n) => {
        let { Bucket: i } = n.input,
          o = e.bucketEndpoint,
          a = n.request;
        if (lRr.HttpRequest.isInstance(a)) {
          if (e.bucketEndpoint) a.hostname = i;
          else if ((0, sXe.validate)(i)) {
            let s = (0, sXe.parse)(i),
              u = await e.region(),
              l = await e.useDualstackEndpoint(),
              d = await e.useFipsEndpoint(),
              { partition: f, signingRegion: m = u } =
                (await e.regionInfoProvider(u, {
                  useDualstackEndpoint: l,
                  useFipsEndpoint: d,
                })) || {},
              h = await e.useArnRegion(),
              {
                hostname: y,
                bucketEndpoint: _,
                signingRegion: E,
                signingService: b,
              } = Bee({
                bucketName: s,
                baseHostname: a.hostname,
                accelerateEndpoint: e.useAccelerateEndpoint,
                dualstackEndpoint: l,
                fipsEndpoint: d,
                pathStyleEndpoint: e.forcePathStyle,
                tlsCompatible: a.protocol === "https:",
                useArnRegion: h,
                clientPartition: f,
                clientSigningRegion: m,
                clientRegion: u,
                isCustomEndpoint: e.isCustomEndpoint,
                disableMultiregionAccessPoints:
                  await e.disableMultiregionAccessPoints(),
              });
            E && E !== m && (r.signing_region = E),
              b && b !== "s3" && (r.signing_service = b),
              (a.hostname = y),
              (o = _);
          } else {
            let s = await e.region(),
              u = await e.useDualstackEndpoint(),
              l = await e.useFipsEndpoint(),
              { hostname: d, bucketEndpoint: f } = Bee({
                bucketName: i,
                clientRegion: s,
                baseHostname: a.hostname,
                accelerateEndpoint: e.useAccelerateEndpoint,
                dualstackEndpoint: u,
                fipsEndpoint: l,
                pathStyleEndpoint: e.forcePathStyle,
                tlsCompatible: a.protocol === "https:",
                isCustomEndpoint: e.isCustomEndpoint,
              });
            (a.hostname = d), (o = f);
          }
          o &&
            ((a.path = a.path.replace(/^(\/)?[^\/]+/, "")),
            a.path === "" && (a.path = "/"));
        }
        return t({ ...n, request: a });
      },
      "bucketEndpointMiddleware",
    ),
    CXe = {
      tags: ["BUCKET_ENDPOINT"],
      name: "bucketEndpointMiddleware",
      relation: "before",
      toMiddleware: "hostHeaderMiddleware",
      override: !0,
    },
    RRr = Rt(
      (e) => ({
        applyToStack: Rt((t) => {
          t.addRelativeTo(SXe(e), CXe);
        }, "applyToStack"),
      }),
      "getBucketEndpointPlugin",
    );
  function wXe(e) {
    let {
      bucketEndpoint: t = !1,
      forcePathStyle: r = !1,
      useAccelerateEndpoint: n = !1,
      useArnRegion: i = !1,
      disableMultiregionAccessPoints: o = !1,
    } = e;
    return Object.assign(e, {
      bucketEndpoint: t,
      forcePathStyle: r,
      useAccelerateEndpoint: n,
      useArnRegion: typeof i == "function" ? i : () => Promise.resolve(i),
      disableMultiregionAccessPoints:
        typeof o == "function" ? o : () => Promise.resolve(o),
    });
  }
  Rt(wXe, "resolveBucketEndpointConfig");
});
var DXe = g((kWn, kXe) => {
  c();
  var qU = Object.defineProperty,
    IRr = Object.getOwnPropertyDescriptor,
    xRr = Object.getOwnPropertyNames,
    NRr = Object.prototype.hasOwnProperty,
    ed = (e, t) => qU(e, "name", { value: t, configurable: !0 }),
    kRr = (e, t) => {
      for (var r in t) qU(e, r, { get: t[r], enumerable: !0 });
    },
    DRr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of xRr(t))
          !NRr.call(e, i) &&
            i !== r &&
            qU(e, i, {
              get: () => t[i],
              enumerable: !(n = IRr(t, i)) || n.enumerable,
            });
      return e;
    },
    LRr = (e) => DRr(qU({}, "__esModule", { value: !0 }), e),
    PXe = {};
  kRr(PXe, {
    EventStreamCodec: () => WRr,
    HeaderMarshaller: () => IXe,
    Int64: () => MU,
    MessageDecoderStream: () => QRr,
    MessageEncoderStream: () => YRr,
    SmithyMessageDecoderStream: () => XRr,
    SmithyMessageEncoderStream: () => JRr,
  });
  kXe.exports = LRr(PXe);
  var MRr = cO(),
    Jh = zs(),
    MU = class RXe {
      constructor(t) {
        if (((this.bytes = t), t.byteLength !== 8))
          throw new Error("Int64 buffers must be exactly 8 bytes");
      }
      static {
        ed(this, "Int64");
      }
      static fromNumber(t) {
        if (t > 9223372036854776e3 || t < -9223372036854776e3)
          throw new Error(
            `${t} is too large (or, if negative, too small) to represent as an Int64`,
          );
        let r = new Uint8Array(8);
        for (
          let n = 7, i = Math.abs(Math.round(t));
          n > -1 && i > 0;
          n--, i /= 256
        )
          r[n] = i;
        return t < 0 && Hee(r), new RXe(r);
      }
      valueOf() {
        let t = this.bytes.slice(0),
          r = t[0] & 128;
        return r && Hee(t), parseInt((0, Jh.toHex)(t), 16) * (r ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  function Hee(e) {
    for (let t = 0; t < 8; t++) e[t] ^= 255;
    for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
  }
  ed(Hee, "negate");
  var IXe = class {
      constructor(e, t) {
        (this.toUtf8 = e), (this.fromUtf8 = t);
      }
      static {
        ed(this, "HeaderMarshaller");
      }
      format(e) {
        let t = [];
        for (let i of Object.keys(e)) {
          let o = this.fromUtf8(i);
          t.push(
            Uint8Array.from([o.byteLength]),
            o,
            this.formatHeaderValue(e[i]),
          );
        }
        let r = new Uint8Array(t.reduce((i, o) => i + o.byteLength, 0)),
          n = 0;
        for (let i of t) r.set(i, n), (n += i.byteLength);
        return r;
      }
      formatHeaderValue(e) {
        switch (e.type) {
          case "boolean":
            return Uint8Array.from([e.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, e.value]);
          case "short":
            let t = new DataView(new ArrayBuffer(3));
            return (
              t.setUint8(0, 3),
              t.setInt16(1, e.value, !1),
              new Uint8Array(t.buffer)
            );
          case "integer":
            let r = new DataView(new ArrayBuffer(5));
            return (
              r.setUint8(0, 4),
              r.setInt32(1, e.value, !1),
              new Uint8Array(r.buffer)
            );
          case "long":
            let n = new Uint8Array(9);
            return (n[0] = 5), n.set(e.value.bytes, 1), n;
          case "binary":
            let i = new DataView(new ArrayBuffer(3 + e.value.byteLength));
            i.setUint8(0, 6), i.setUint16(1, e.value.byteLength, !1);
            let o = new Uint8Array(i.buffer);
            return o.set(e.value, 3), o;
          case "string":
            let a = this.fromUtf8(e.value),
              s = new DataView(new ArrayBuffer(3 + a.byteLength));
            s.setUint8(0, 7), s.setUint16(1, a.byteLength, !1);
            let u = new Uint8Array(s.buffer);
            return u.set(a, 3), u;
          case "timestamp":
            let l = new Uint8Array(9);
            return (
              (l[0] = 8), l.set(MU.fromNumber(e.value.valueOf()).bytes, 1), l
            );
          case "uuid":
            if (!$Rr.test(e.value))
              throw new Error(`Invalid UUID received: ${e.value}`);
            let d = new Uint8Array(17);
            return (
              (d[0] = 9),
              d.set((0, Jh.fromHex)(e.value.replace(/\-/g, "")), 1),
              d
            );
        }
      }
      parse(e) {
        let t = {},
          r = 0;
        for (; r < e.byteLength; ) {
          let n = e.getUint8(r++),
            i = this.toUtf8(new Uint8Array(e.buffer, e.byteOffset + r, n));
          switch (((r += n), e.getUint8(r++))) {
            case 0:
              t[i] = { type: AXe, value: !0 };
              break;
            case 1:
              t[i] = { type: AXe, value: !1 };
              break;
            case 2:
              t[i] = { type: qRr, value: e.getInt8(r++) };
              break;
            case 3:
              (t[i] = { type: jRr, value: e.getInt16(r, !1) }), (r += 2);
              break;
            case 4:
              (t[i] = { type: FRr, value: e.getInt32(r, !1) }), (r += 4);
              break;
            case 5:
              (t[i] = {
                type: BRr,
                value: new MU(new Uint8Array(e.buffer, e.byteOffset + r, 8)),
              }),
                (r += 8);
              break;
            case 6:
              let o = e.getUint16(r, !1);
              (r += 2),
                (t[i] = {
                  type: URr,
                  value: new Uint8Array(e.buffer, e.byteOffset + r, o),
                }),
                (r += o);
              break;
            case 7:
              let a = e.getUint16(r, !1);
              (r += 2),
                (t[i] = {
                  type: HRr,
                  value: this.toUtf8(
                    new Uint8Array(e.buffer, e.byteOffset + r, a),
                  ),
                }),
                (r += a);
              break;
            case 8:
              (t[i] = {
                type: GRr,
                value: new Date(
                  new MU(
                    new Uint8Array(e.buffer, e.byteOffset + r, 8),
                  ).valueOf(),
                ),
              }),
                (r += 8);
              break;
            case 9:
              let s = new Uint8Array(e.buffer, e.byteOffset + r, 16);
              (r += 16),
                (t[i] = {
                  type: VRr,
                  value: `${(0, Jh.toHex)(s.subarray(0, 4))}-${(0, Jh.toHex)(s.subarray(4, 6))}-${(0, Jh.toHex)(s.subarray(6, 8))}-${(0, Jh.toHex)(s.subarray(8, 10))}-${(0, Jh.toHex)(s.subarray(10))}`,
                });
              break;
            default:
              throw new Error("Unrecognized header type tag");
          }
        }
        return t;
      }
    },
    AXe = "boolean",
    qRr = "byte",
    jRr = "short",
    FRr = "integer",
    BRr = "long",
    URr = "binary",
    HRr = "string",
    GRr = "timestamp",
    VRr = "uuid",
    $Rr = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    zRr = cO(),
    xXe = 4,
    xp = xXe * 2,
    Zh = 4,
    KRr = xp + Zh * 2;
  function NXe({ byteLength: e, byteOffset: t, buffer: r }) {
    if (e < KRr)
      throw new Error(
        "Provided message too short to accommodate event stream message overhead",
      );
    let n = new DataView(r, t, e),
      i = n.getUint32(0, !1);
    if (e !== i)
      throw new Error(
        "Reported message length does not match received message length",
      );
    let o = n.getUint32(xXe, !1),
      a = n.getUint32(xp, !1),
      s = n.getUint32(e - Zh, !1),
      u = new zRr.Crc32().update(new Uint8Array(r, t, xp));
    if (a !== u.digest())
      throw new Error(
        `The prelude checksum specified in the message (${a}) does not match the calculated CRC32 checksum (${u.digest()})`,
      );
    if ((u.update(new Uint8Array(r, t + xp, e - (xp + Zh))), s !== u.digest()))
      throw new Error(
        `The message checksum (${u.digest()}) did not match the expected value of ${s}`,
      );
    return {
      headers: new DataView(r, t + xp + Zh, o),
      body: new Uint8Array(r, t + xp + Zh + o, i - o - (xp + Zh + Zh)),
    };
  }
  ed(NXe, "splitMessage");
  var WRr = class {
      static {
        ed(this, "EventStreamCodec");
      }
      constructor(e, t) {
        (this.headerMarshaller = new IXe(e, t)),
          (this.messageBuffer = []),
          (this.isEndOfStream = !1);
      }
      feed(e) {
        this.messageBuffer.push(this.decode(e));
      }
      endOfStream() {
        this.isEndOfStream = !0;
      }
      getMessage() {
        let e = this.messageBuffer.pop(),
          t = this.isEndOfStream;
        return {
          getMessage() {
            return e;
          },
          isEndOfStream() {
            return t;
          },
        };
      }
      getAvailableMessages() {
        let e = this.messageBuffer;
        this.messageBuffer = [];
        let t = this.isEndOfStream;
        return {
          getMessages() {
            return e;
          },
          isEndOfStream() {
            return t;
          },
        };
      }
      encode({ headers: e, body: t }) {
        let r = this.headerMarshaller.format(e),
          n = r.byteLength + t.byteLength + 16,
          i = new Uint8Array(n),
          o = new DataView(i.buffer, i.byteOffset, i.byteLength),
          a = new MRr.Crc32();
        return (
          o.setUint32(0, n, !1),
          o.setUint32(4, r.byteLength, !1),
          o.setUint32(8, a.update(i.subarray(0, 8)).digest(), !1),
          i.set(r, 12),
          i.set(t, r.byteLength + 12),
          o.setUint32(n - 4, a.update(i.subarray(8, n - 4)).digest(), !1),
          i
        );
      }
      decode(e) {
        let { headers: t, body: r } = NXe(e);
        return { headers: this.headerMarshaller.parse(t), body: r };
      }
      formatHeaders(e) {
        return this.headerMarshaller.format(e);
      }
    },
    QRr = class {
      constructor(e) {
        this.options = e;
      }
      static {
        ed(this, "MessageDecoderStream");
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (let e of this.options.inputStream)
          yield this.options.decoder.decode(e);
      }
    },
    YRr = class {
      constructor(e) {
        this.options = e;
      }
      static {
        ed(this, "MessageEncoderStream");
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (let e of this.options.messageStream)
          yield this.options.encoder.encode(e);
        this.options.includeEndFrame && (yield new Uint8Array(0));
      }
    },
    XRr = class {
      constructor(e) {
        this.options = e;
      }
      static {
        ed(this, "SmithyMessageDecoderStream");
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (let e of this.options.messageStream) {
          let t = await this.options.deserializer(e);
          t !== void 0 && (yield t);
        }
      }
    },
    JRr = class {
      constructor(e) {
        this.options = e;
      }
      static {
        ed(this, "SmithyMessageEncoderStream");
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (let e of this.options.inputStream)
          yield this.options.serializer(e);
      }
    };
});
var BXe = g((UWn, FXe) => {
  c();
  var jU = Object.defineProperty,
    ZRr = Object.getOwnPropertyDescriptor,
    eIr = Object.getOwnPropertyNames,
    tIr = Object.prototype.hasOwnProperty,
    tb = (e, t) => jU(e, "name", { value: t, configurable: !0 }),
    rIr = (e, t) => {
      for (var r in t) jU(e, r, { get: t[r], enumerable: !0 });
    },
    nIr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of eIr(t))
          !tIr.call(e, i) &&
            i !== r &&
            jU(e, i, {
              get: () => t[i],
              enumerable: !(n = ZRr(t, i)) || n.enumerable,
            });
      return e;
    },
    iIr = (e) => nIr(jU({}, "__esModule", { value: !0 }), e),
    LXe = {};
  rIr(LXe, {
    EventStreamMarshaller: () => jXe,
    eventStreamSerdeProvider: () => oIr,
  });
  FXe.exports = iIr(LXe);
  var LT = DXe();
  function MXe(e) {
    let t = 0,
      r = 0,
      n = null,
      i = null,
      o = tb((s) => {
        if (typeof s != "number")
          throw new Error(
            "Attempted to allocate an event message where size was not a number: " +
              s,
          );
        (t = s),
          (r = 4),
          (n = new Uint8Array(s)),
          new DataView(n.buffer).setUint32(0, s, !1);
      }, "allocateMessage"),
      a = tb(async function* () {
        let s = e[Symbol.asyncIterator]();
        for (;;) {
          let { value: u, done: l } = await s.next();
          if (l) {
            if (t)
              if (t === r) yield n;
              else throw new Error("Truncated event message received.");
            else return;
            return;
          }
          let d = u.length,
            f = 0;
          for (; f < d; ) {
            if (!n) {
              let h = d - f;
              i || (i = new Uint8Array(4));
              let y = Math.min(4 - r, h);
              if ((i.set(u.slice(f, f + y), r), (r += y), (f += y), r < 4))
                break;
              o(new DataView(i.buffer).getUint32(0, !1)), (i = null);
            }
            let m = Math.min(t - r, d - f);
            n.set(u.slice(f, f + m), r),
              (r += m),
              (f += m),
              t && t === r && (yield n, (n = null), (t = 0), (r = 0));
          }
        }
      }, "iterator");
    return { [Symbol.asyncIterator]: a };
  }
  tb(MXe, "getChunkedStream");
  function qXe(e, t) {
    return async function (r) {
      let { value: n } = r.headers[":message-type"];
      if (n === "error") {
        let i = new Error(r.headers[":error-message"].value || "UnknownError");
        throw ((i.name = r.headers[":error-code"].value), i);
      } else if (n === "exception") {
        let i = r.headers[":exception-type"].value,
          o = { [i]: r },
          a = await e(o);
        if (a.$unknown) {
          let s = new Error(t(r.body));
          throw ((s.name = i), s);
        }
        throw a[i];
      } else if (n === "event") {
        let i = { [r.headers[":event-type"].value]: r },
          o = await e(i);
        return o.$unknown ? void 0 : o;
      } else
        throw Error(
          `Unrecognizable event type: ${r.headers[":event-type"].value}`,
        );
    };
  }
  tb(qXe, "getMessageUnmarshaller");
  var jXe = class {
      static {
        tb(this, "EventStreamMarshaller");
      }
      constructor({ utf8Encoder: e, utf8Decoder: t }) {
        (this.eventStreamCodec = new LT.EventStreamCodec(e, t)),
          (this.utfEncoder = e);
      }
      deserialize(e, t) {
        let r = MXe(e);
        return new LT.SmithyMessageDecoderStream({
          messageStream: new LT.MessageDecoderStream({
            inputStream: r,
            decoder: this.eventStreamCodec,
          }),
          deserializer: qXe(t, this.utfEncoder),
        });
      }
      serialize(e, t) {
        return new LT.MessageEncoderStream({
          messageStream: new LT.SmithyMessageEncoderStream({
            inputStream: e,
            serializer: t,
          }),
          encoder: this.eventStreamCodec,
          includeEndFrame: !0,
        });
      }
    },
    oIr = tb((e) => new jXe(e), "eventStreamSerdeProvider");
});
var $Xe = g((VWn, VXe) => {
  c();
  var FU = Object.defineProperty,
    aIr = Object.getOwnPropertyDescriptor,
    sIr = Object.getOwnPropertyNames,
    cIr = Object.prototype.hasOwnProperty,
    Gee = (e, t) => FU(e, "name", { value: t, configurable: !0 }),
    uIr = (e, t) => {
      for (var r in t) FU(e, r, { get: t[r], enumerable: !0 });
    },
    lIr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of sIr(t))
          !cIr.call(e, i) &&
            i !== r &&
            FU(e, i, {
              get: () => t[i],
              enumerable: !(n = aIr(t, i)) || n.enumerable,
            });
      return e;
    },
    dIr = (e) => lIr(FU({}, "__esModule", { value: !0 }), e),
    UXe = {};
  uIr(UXe, {
    EventStreamMarshaller: () => GXe,
    eventStreamSerdeProvider: () => mIr,
  });
  VXe.exports = dIr(UXe);
  var fIr = BXe(),
    pIr = G("stream");
  async function* HXe(e) {
    let t = !1,
      r = !1,
      n = new Array();
    for (
      e.on("error", (i) => {
        if ((t || (t = !0), i)) throw i;
      }),
        e.on("data", (i) => {
          n.push(i);
        }),
        e.on("end", () => {
          t = !0;
        });
      !r;

    ) {
      let i = await new Promise((o) => setTimeout(() => o(n.shift()), 0));
      i && (yield i), (r = t && n.length === 0);
    }
  }
  Gee(HXe, "readabletoIterable");
  var GXe = class {
      static {
        Gee(this, "EventStreamMarshaller");
      }
      constructor({ utf8Encoder: e, utf8Decoder: t }) {
        this.universalMarshaller = new fIr.EventStreamMarshaller({
          utf8Decoder: t,
          utf8Encoder: e,
        });
      }
      deserialize(e, t) {
        let r = typeof e[Symbol.asyncIterator] == "function" ? e : HXe(e);
        return this.universalMarshaller.deserialize(r, t);
      }
      serialize(e, t) {
        return pIr.Readable.from(this.universalMarshaller.serialize(e, t));
      }
    },
    mIr = Gee((e) => new GXe(e), "eventStreamSerdeProvider");
});
var QXe = g((KWn, WXe) => {
  c();
  var BU = Object.defineProperty,
    hIr = Object.getOwnPropertyDescriptor,
    gIr = Object.getOwnPropertyNames,
    vIr = Object.prototype.hasOwnProperty,
    UU = (e, t) => BU(e, "name", { value: t, configurable: !0 }),
    yIr = (e, t) => {
      for (var r in t) BU(e, r, { get: t[r], enumerable: !0 });
    },
    _Ir = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of gIr(t))
          !vIr.call(e, i) &&
            i !== r &&
            BU(e, i, {
              get: () => t[i],
              enumerable: !(n = hIr(t, i)) || n.enumerable,
            });
      return e;
    },
    EIr = (e) => _Ir(BU({}, "__esModule", { value: !0 }), e),
    zXe = {};
  yIr(zXe, { fileStreamHasher: () => wIr, readableStreamHasher: () => TIr });
  WXe.exports = EIr(zXe);
  var bIr = G("fs"),
    SIr = Fe(),
    CIr = G("stream"),
    KXe = class extends CIr.Writable {
      constructor(e, t) {
        super(t), (this.hash = e);
      }
      static {
        UU(this, "HashCalculator");
      }
      _write(e, t, r) {
        try {
          this.hash.update((0, SIr.toUint8Array)(e));
        } catch (n) {
          return r(n);
        }
        r();
      }
    },
    wIr = UU(
      (e, t) =>
        new Promise((r, n) => {
          if (!OIr(t)) {
            n(new Error("Unable to calculate hash for non-file streams."));
            return;
          }
          let i = (0, bIr.createReadStream)(t.path, {
              start: t.start,
              end: t.end,
            }),
            o = new e(),
            a = new KXe(o);
          i.pipe(a),
            i.on("error", (s) => {
              a.end(), n(s);
            }),
            a.on("error", n),
            a.on("finish", function () {
              o.digest().then(r).catch(n);
            });
        }),
      "fileStreamHasher",
    ),
    OIr = UU((e) => typeof e.path == "string", "isReadStream"),
    TIr = UU((e, t) => {
      if (t.readableFlowing !== null)
        throw new Error("Unable to calculate hash for flowing readable stream");
      let r = new e(),
        n = new KXe(r);
      return (
        t.pipe(n),
        new Promise((i, o) => {
          t.on("error", (a) => {
            n.end(), o(a);
          }),
            n.on("error", o),
            n.on("finish", () => {
              r.digest().then(i).catch(o);
            });
        })
      );
    }, "readableStreamHasher");
});
var e7e = g((HU) => {
  "use strict";
  c();
  Object.defineProperty(HU, "__esModule", { value: !0 });
  HU.getRuntimeConfig = void 0;
  var YXe = (ri(), ue(yu)),
    AIr = IJ(),
    PIr = At(),
    RIr = Hh(),
    XXe = fu(),
    JXe = r1(),
    ZXe = Fe(),
    IIr = dZ(),
    xIr = lZ(),
    NIr = (e) => ({
      apiVersion: "2006-03-01",
      base64Decoder: e?.base64Decoder ?? XXe.fromBase64,
      base64Encoder: e?.base64Encoder ?? XXe.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? xIr.defaultEndpointResolver,
      extensions: e?.extensions ?? [],
      getAwsChunkedEncodingStream:
        e?.getAwsChunkedEncodingStream ?? JXe.getAwsChunkedEncodingStream,
      httpAuthSchemeProvider:
        e?.httpAuthSchemeProvider ?? IIr.defaultS3HttpAuthSchemeProvider,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new YXe.AwsSdkSigV4Signer(),
        },
        {
          schemeId: "aws.auth#sigv4a",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4a"),
          signer: new YXe.AwsSdkSigV4ASigner(),
        },
      ],
      logger: e?.logger ?? new PIr.NoOpLogger(),
      sdkStreamMixin: e?.sdkStreamMixin ?? JXe.sdkStreamMixin,
      serviceId: e?.serviceId ?? "S3",
      signerConstructor: e?.signerConstructor ?? AIr.SignatureV4MultiRegion,
      signingEscapePath: e?.signingEscapePath ?? !1,
      urlParser: e?.urlParser ?? RIr.parseUrl,
      useArnRegion: e?.useArnRegion ?? !1,
      utf8Decoder: e?.utf8Decoder ?? ZXe.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? ZXe.toUtf8,
    });
  HU.getRuntimeConfig = NIr;
});
var o7e = g((VU) => {
  "use strict";
  c();
  Object.defineProperty(VU, "__esModule", { value: !0 });
  VU.getRuntimeConfig = void 0;
  var kIr = (go(), ue(ho)),
    DIr = kIr.__importDefault(S6e()),
    Vee = (ri(), ue(yu)),
    LIr = VYe(),
    MIr = TXe(),
    t7e = rY(),
    qIr = Te(),
    r7e = YO(),
    GU = Eu(),
    jIr = $Xe(),
    $ee = XO(),
    FIr = QXe(),
    n7e = Kl(),
    hs = ro(),
    i7e = Lh(),
    BIr = yl(),
    UIr = OE(),
    HIr = e7e(),
    GIr = At(),
    VIr = eT(),
    $Ir = At(),
    zIr = (e) => {
      (0, $Ir.emitWarningIfUnsupportedVersion)(process.version);
      let t = (0, VIr.resolveDefaultsModeConfig)(e),
        r = () => t().then(GIr.loadConfigsForDefaultMode),
        n = (0, HIr.getRuntimeConfig)(e);
      (0, Vee.emitWarningIfUnsupportedVersion)(process.version);
      let i = { profile: e?.profile };
      return {
        ...n,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference:
          e?.authSchemePreference ??
          (0, hs.loadConfig)(Vee.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, i),
        bodyLengthChecker: e?.bodyLengthChecker ?? BIr.calculateBodyLength,
        credentialDefaultProvider:
          e?.credentialDefaultProvider ?? LIr.defaultProvider,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          (0, r7e.createDefaultUserAgentProvider)({
            serviceId: n.serviceId,
            clientVersion: DIr.default.version,
          }),
        disableS3ExpressSessionAuth:
          e?.disableS3ExpressSessionAuth ??
          (0, hs.loadConfig)(
            qIr.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS,
            i,
          ),
        eventStreamSerdeProvider:
          e?.eventStreamSerdeProvider ?? jIr.eventStreamSerdeProvider,
        maxAttempts:
          e?.maxAttempts ??
          (0, hs.loadConfig)(n7e.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, e),
        md5: e?.md5 ?? $ee.Hash.bind(null, "md5"),
        region:
          e?.region ??
          (0, hs.loadConfig)(GU.NODE_REGION_CONFIG_OPTIONS, {
            ...GU.NODE_REGION_CONFIG_FILE_OPTIONS,
            ...i,
          }),
        requestChecksumCalculation:
          e?.requestChecksumCalculation ??
          (0, hs.loadConfig)(
            t7e.NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS,
            i,
          ),
        requestHandler: i7e.NodeHttpHandler.create(e?.requestHandler ?? r),
        responseChecksumValidation:
          e?.responseChecksumValidation ??
          (0, hs.loadConfig)(
            t7e.NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS,
            i,
          ),
        retryMode:
          e?.retryMode ??
          (0, hs.loadConfig)(
            {
              ...n7e.NODE_RETRY_MODE_CONFIG_OPTIONS,
              default: async () =>
                (await r()).retryMode || UIr.DEFAULT_RETRY_MODE,
            },
            e,
          ),
        sha1: e?.sha1 ?? $ee.Hash.bind(null, "sha1"),
        sha256: e?.sha256 ?? $ee.Hash.bind(null, "sha256"),
        sigv4aSigningRegionSet:
          e?.sigv4aSigningRegionSet ??
          (0, hs.loadConfig)(Vee.NODE_SIGV4A_CONFIG_OPTIONS, i),
        streamCollector: e?.streamCollector ?? i7e.streamCollector,
        streamHasher: e?.streamHasher ?? FIr.readableStreamHasher,
        useArnRegion:
          e?.useArnRegion ??
          (0, hs.loadConfig)(MIr.NODE_USE_ARN_REGION_CONFIG_OPTIONS, i),
        useDualstackEndpoint:
          e?.useDualstackEndpoint ??
          (0, hs.loadConfig)(GU.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, i),
        useFipsEndpoint:
          e?.useFipsEndpoint ??
          (0, hs.loadConfig)(GU.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, i),
        userAgentAppId:
          e?.userAgentAppId ??
          (0, hs.loadConfig)(r7e.NODE_APP_ID_CONFIG_OPTIONS, i),
      };
    };
  VU.getRuntimeConfig = zIr;
});
var u7e = g((e6n, c7e) => {
  "use strict";
  c();
  var zU = Object.defineProperty,
    KIr = Object.getOwnPropertyDescriptor,
    WIr = Object.getOwnPropertyNames,
    QIr = Object.prototype.hasOwnProperty,
    $U = (e, t) => zU(e, "name", { value: t, configurable: !0 }),
    YIr = (e, t) => {
      for (var r in t) zU(e, r, { get: t[r], enumerable: !0 });
    },
    XIr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of WIr(t))
          !QIr.call(e, i) &&
            i !== r &&
            zU(e, i, {
              get: () => t[i],
              enumerable: !(n = KIr(t, i)) || n.enumerable,
            });
      return e;
    },
    JIr = (e) => XIr(zU({}, "__esModule", { value: !0 }), e),
    a7e = {};
  YIr(a7e, {
    getSsecPlugin: () => ZIr,
    isValidBase64EncodedSSECustomerKey: () => Kee,
    ssecMiddleware: () => zee,
    ssecMiddlewareOptions: () => s7e,
  });
  c7e.exports = JIr(a7e);
  function zee(e) {
    return (t) => async (r) => {
      let n = { ...r.input },
        i = [
          { target: "SSECustomerKey", hash: "SSECustomerKeyMD5" },
          {
            target: "CopySourceSSECustomerKey",
            hash: "CopySourceSSECustomerKeyMD5",
          },
        ];
      for (let o of i) {
        let a = n[o.target];
        if (a) {
          let s;
          typeof a == "string"
            ? Kee(a, e)
              ? (s = e.base64Decoder(a))
              : ((s = e.utf8Decoder(a)), (n[o.target] = e.base64Encoder(s)))
            : ((s = ArrayBuffer.isView(a)
                ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength)
                : new Uint8Array(a)),
              (n[o.target] = e.base64Encoder(s)));
          let u = new e.md5();
          u.update(s), (n[o.hash] = e.base64Encoder(await u.digest()));
        }
      }
      return t({ ...r, input: n });
    };
  }
  $U(zee, "ssecMiddleware");
  var s7e = {
      name: "ssecMiddleware",
      step: "initialize",
      tags: ["SSE"],
      override: !0,
    },
    ZIr = $U(
      (e) => ({
        applyToStack: $U((t) => {
          t.add(zee(e), s7e);
        }, "applyToStack"),
      }),
      "getSsecPlugin",
    );
  function Kee(e, t) {
    if (
      !/^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)
    )
      return !1;
    try {
      return t.base64Decoder(e).length === 32;
    } catch {
      return !1;
    }
  }
  $U(Kee, "isValidBase64EncodedSSECustomerKey");
});
var p7e = g((r6n, f7e) => {
  "use strict";
  c();
  var KU = Object.defineProperty,
    exr = Object.getOwnPropertyDescriptor,
    txr = Object.getOwnPropertyNames,
    rxr = Object.prototype.hasOwnProperty,
    Wee = (e, t) => KU(e, "name", { value: t, configurable: !0 }),
    nxr = (e, t) => {
      for (var r in t) KU(e, r, { get: t[r], enumerable: !0 });
    },
    ixr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of txr(t))
          !rxr.call(e, i) &&
            i !== r &&
            KU(e, i, {
              get: () => t[i],
              enumerable: !(n = exr(t, i)) || n.enumerable,
            });
      return e;
    },
    oxr = (e) => ixr(KU({}, "__esModule", { value: !0 }), e),
    l7e = {};
  nxr(l7e, {
    getLocationConstraintPlugin: () => axr,
    locationConstraintMiddleware: () => Qee,
    locationConstraintMiddlewareOptions: () => d7e,
  });
  f7e.exports = oxr(l7e);
  function Qee(e) {
    return (t) => async (r) => {
      let { CreateBucketConfiguration: n } = r.input,
        i = await e.region();
      return (
        !n?.LocationConstraint &&
          !n?.Location &&
          (r = {
            ...r,
            input: {
              ...r.input,
              CreateBucketConfiguration:
                i === "us-east-1" ? void 0 : { LocationConstraint: i },
            },
          }),
        t(r)
      );
    };
  }
  Wee(Qee, "locationConstraintMiddleware");
  var d7e = {
      step: "initialize",
      tags: ["LOCATION_CONSTRAINT", "CREATE_BUCKET_CONFIGURATION"],
      name: "locationConstraintMiddleware",
      override: !0,
    },
    axr = Wee(
      (e) => ({
        applyToStack: Wee((t) => {
          t.add(Qee(e), d7e);
        }, "applyToStack"),
      }),
      "getLocationConstraintPlugin",
    );
});
var E7e = g((i6n, _7e) => {
  c();
  var WU = Object.defineProperty,
    sxr = Object.getOwnPropertyDescriptor,
    cxr = Object.getOwnPropertyNames,
    uxr = Object.prototype.hasOwnProperty,
    Iu = (e, t) => WU(e, "name", { value: t, configurable: !0 }),
    lxr = (e, t) => {
      for (var r in t) WU(e, r, { get: t[r], enumerable: !0 });
    },
    dxr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of cxr(t))
          !uxr.call(e, i) &&
            i !== r &&
            WU(e, i, {
              get: () => t[i],
              enumerable: !(n = sxr(t, i)) || n.enumerable,
            });
      return e;
    },
    fxr = (e) => dxr(WU({}, "__esModule", { value: !0 }), e),
    g7e = {};
  lxr(g7e, {
    WaiterState: () => y7e,
    checkExceptions: () => mxr,
    createWaiter: () => _xr,
    waiterServiceDefaults: () => v7e,
  });
  _7e.exports = fxr(g7e);
  var pxr = Iu((e) => new Promise((t) => setTimeout(t, e * 1e3)), "sleep"),
    v7e = { minDelay: 2, maxDelay: 120 },
    y7e = ((e) => (
      (e.ABORTED = "ABORTED"),
      (e.FAILURE = "FAILURE"),
      (e.SUCCESS = "SUCCESS"),
      (e.RETRY = "RETRY"),
      (e.TIMEOUT = "TIMEOUT"),
      e
    ))(y7e || {}),
    mxr = Iu((e) => {
      if (e.state === "ABORTED") {
        let t = new Error(
          `${JSON.stringify({ ...e, reason: "Request was aborted" })}`,
        );
        throw ((t.name = "AbortError"), t);
      } else if (e.state === "TIMEOUT") {
        let t = new Error(
          `${JSON.stringify({ ...e, reason: "Waiter has timed out" })}`,
        );
        throw ((t.name = "TimeoutError"), t);
      } else if (e.state !== "SUCCESS") throw new Error(`${JSON.stringify(e)}`);
      return e;
    }, "checkExceptions"),
    hxr = Iu((e, t, r, n) => {
      if (n > r) return t;
      let i = e * 2 ** (n - 1);
      return gxr(e, i);
    }, "exponentialBackoffWithJitter"),
    gxr = Iu((e, t) => e + Math.random() * (t - e), "randomInRange"),
    vxr = Iu(
      async (
        {
          minDelay: e,
          maxDelay: t,
          maxWaitTime: r,
          abortController: n,
          client: i,
          abortSignal: o,
        },
        a,
        s,
      ) => {
        let u = {},
          { state: l, reason: d } = await s(i, a);
        if (d) {
          let y = m7e(d);
          (u[y] |= 0), (u[y] += 1);
        }
        if (l !== "RETRY") return { state: l, reason: d, observedResponses: u };
        let f = 1,
          m = Date.now() + r * 1e3,
          h = Math.log(t / e) / Math.log(2) + 1;
        for (;;) {
          if (n?.signal?.aborted || o?.aborted) {
            let b = "AbortController signal aborted.";
            return (
              (u[b] |= 0),
              (u[b] += 1),
              { state: "ABORTED", observedResponses: u }
            );
          }
          let y = hxr(e, t, h, f);
          if (Date.now() + y * 1e3 > m)
            return { state: "TIMEOUT", observedResponses: u };
          await pxr(y);
          let { state: _, reason: E } = await s(i, a);
          if (E) {
            let b = m7e(E);
            (u[b] |= 0), (u[b] += 1);
          }
          if (_ !== "RETRY")
            return { state: _, reason: E, observedResponses: u };
          f += 1;
        }
      },
      "runPolling",
    ),
    m7e = Iu(
      (e) =>
        e?.$responseBodyText
          ? `Deserialization error for body: ${e.$responseBodyText}`
          : e?.$metadata?.httpStatusCode
            ? e.$response || e.message
              ? `${e.$response.statusCode ?? e.$metadata.httpStatusCode ?? "Unknown"}: ${e.message}`
              : `${e.$metadata.httpStatusCode}: OK`
            : String(e?.message ?? JSON.stringify(e) ?? "Unknown"),
      "createMessageFromResponse",
    ),
    yxr = Iu((e) => {
      if (e.maxWaitTime <= 0)
        throw new Error(
          "WaiterConfiguration.maxWaitTime must be greater than 0",
        );
      if (e.minDelay <= 0)
        throw new Error("WaiterConfiguration.minDelay must be greater than 0");
      if (e.maxDelay <= 0)
        throw new Error("WaiterConfiguration.maxDelay must be greater than 0");
      if (e.maxWaitTime <= e.minDelay)
        throw new Error(
          `WaiterConfiguration.maxWaitTime [${e.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${e.minDelay}] for this waiter`,
        );
      if (e.maxDelay < e.minDelay)
        throw new Error(
          `WaiterConfiguration.maxDelay [${e.maxDelay}] must be greater than WaiterConfiguration.minDelay [${e.minDelay}] for this waiter`,
        );
    }, "validateWaiterOptions"),
    h7e = Iu(
      async (e) =>
        new Promise((t) => {
          let r = Iu(() => t({ state: "ABORTED" }), "onAbort");
          typeof e.addEventListener == "function"
            ? e.addEventListener("abort", r)
            : (e.onabort = r);
        }),
      "abortTimeout",
    ),
    _xr = Iu(async (e, t, r) => {
      let n = { ...v7e, ...e };
      yxr(n);
      let i = [vxr(n, t, r)];
      return (
        e.abortController && i.push(h7e(e.abortController.signal)),
        e.abortSignal && i.push(h7e(e.abortSignal)),
        Promise.race(i)
      );
    }, "createWaiter");
});
var Frt = g((a6n, jrt) => {
  "use strict";
  c();
  var WH = Object.defineProperty,
    Exr = Object.getOwnPropertyDescriptor,
    bxr = Object.getOwnPropertyNames,
    Sxr = Object.prototype.hasOwnProperty,
    v = (e, t) => WH(e, "name", { value: t, configurable: !0 }),
    Cxr = (e, t) => {
      for (var r in t) WH(e, r, { get: t[r], enumerable: !0 });
    },
    wxr = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of bxr(t))
          !Sxr.call(e, i) &&
            i !== r &&
            WH(e, i, {
              get: () => t[i],
              enumerable: !(n = Exr(t, i)) || n.enumerable,
            });
      return e;
    },
    Oxr = (e) => wxr(WH({}, "__esModule", { value: !0 }), e),
    Z7e = {};
  Cxr(Z7e, {
    AbortMultipartUploadCommand: () => Yet,
    AnalyticsFilter: () => DH,
    AnalyticsS3ExportFileFormat: () => rNr,
    ArchiveStatus: () => kNr,
    BucketAccelerateStatus: () => Mxr,
    BucketAlreadyExists: () => oJe,
    BucketAlreadyOwnedByYou: () => sJe,
    BucketCannedACL: () => Qxr,
    BucketLocationConstraint: () => Zxr,
    BucketLogsPermission: () => pNr,
    BucketType: () => Xxr,
    BucketVersioningStatus: () => TNr,
    ChecksumAlgorithm: () => Gxr,
    ChecksumMode: () => RNr,
    ChecksumType: () => Bxr,
    CompleteMultipartUploadCommand: () => Xet,
    CompleteMultipartUploadOutputFilterSensitiveLog: () => vJe,
    CompleteMultipartUploadRequestFilterSensitiveLog: () => yJe,
    CompressionType: () => UNr,
    CopyObjectCommand: () => Jet,
    CopyObjectOutputFilterSensitiveLog: () => _Je,
    CopyObjectRequestFilterSensitiveLog: () => EJe,
    CreateBucketCommand: () => Zet,
    CreateBucketMetadataTableConfigurationCommand: () => ett,
    CreateMultipartUploadCommand: () => ttt,
    CreateMultipartUploadOutputFilterSensitiveLog: () => bJe,
    CreateMultipartUploadRequestFilterSensitiveLog: () => SJe,
    CreateSessionCommand: () => Gre,
    CreateSessionOutputFilterSensitiveLog: () => wJe,
    CreateSessionRequestFilterSensitiveLog: () => OJe,
    DataRedundancy: () => Yxr,
    DeleteBucketAnalyticsConfigurationCommand: () => rtt,
    DeleteBucketCommand: () => ntt,
    DeleteBucketCorsCommand: () => itt,
    DeleteBucketEncryptionCommand: () => ott,
    DeleteBucketIntelligentTieringConfigurationCommand: () => att,
    DeleteBucketInventoryConfigurationCommand: () => stt,
    DeleteBucketLifecycleCommand: () => ctt,
    DeleteBucketMetadataTableConfigurationCommand: () => utt,
    DeleteBucketMetricsConfigurationCommand: () => ltt,
    DeleteBucketOwnershipControlsCommand: () => dtt,
    DeleteBucketPolicyCommand: () => ftt,
    DeleteBucketReplicationCommand: () => ptt,
    DeleteBucketTaggingCommand: () => mtt,
    DeleteBucketWebsiteCommand: () => htt,
    DeleteMarkerReplicationStatus: () => vNr,
    DeleteObjectCommand: () => gtt,
    DeleteObjectTaggingCommand: () => ytt,
    DeleteObjectsCommand: () => vtt,
    DeletePublicAccessBlockCommand: () => _tt,
    EncodingType: () => DNr,
    EncryptionFilterSensitiveLog: () => rZe,
    EncryptionTypeMismatch: () => HJe,
    Event: () => hNr,
    ExistingObjectReplicationStatus: () => ENr,
    ExpirationStatus: () => dNr,
    ExpressionType: () => BNr,
    FileHeaderInfo: () => HNr,
    FilterRuleName: () => gNr,
    GetBucketAccelerateConfigurationCommand: () => Ett,
    GetBucketAclCommand: () => btt,
    GetBucketAnalyticsConfigurationCommand: () => Stt,
    GetBucketCorsCommand: () => Ctt,
    GetBucketEncryptionCommand: () => wtt,
    GetBucketEncryptionOutputFilterSensitiveLog: () => PJe,
    GetBucketIntelligentTieringConfigurationCommand: () => Ott,
    GetBucketInventoryConfigurationCommand: () => Ttt,
    GetBucketInventoryConfigurationOutputFilterSensitiveLog: () => kJe,
    GetBucketLifecycleConfigurationCommand: () => Att,
    GetBucketLocationCommand: () => Ptt,
    GetBucketLoggingCommand: () => Rtt,
    GetBucketMetadataTableConfigurationCommand: () => Itt,
    GetBucketMetricsConfigurationCommand: () => xtt,
    GetBucketNotificationConfigurationCommand: () => Ntt,
    GetBucketOwnershipControlsCommand: () => ktt,
    GetBucketPolicyCommand: () => Dtt,
    GetBucketPolicyStatusCommand: () => Ltt,
    GetBucketReplicationCommand: () => Mtt,
    GetBucketRequestPaymentCommand: () => qtt,
    GetBucketTaggingCommand: () => jtt,
    GetBucketVersioningCommand: () => Ftt,
    GetBucketWebsiteCommand: () => Btt,
    GetObjectAclCommand: () => Utt,
    GetObjectAttributesCommand: () => Htt,
    GetObjectAttributesRequestFilterSensitiveLog: () => MJe,
    GetObjectCommand: () => Gtt,
    GetObjectLegalHoldCommand: () => Vtt,
    GetObjectLockConfigurationCommand: () => $tt,
    GetObjectOutputFilterSensitiveLog: () => DJe,
    GetObjectRequestFilterSensitiveLog: () => LJe,
    GetObjectRetentionCommand: () => ztt,
    GetObjectTaggingCommand: () => Ktt,
    GetObjectTorrentCommand: () => Wtt,
    GetObjectTorrentOutputFilterSensitiveLog: () => qJe,
    GetPublicAccessBlockCommand: () => Qtt,
    HeadBucketCommand: () => u3,
    HeadObjectCommand: () => l3,
    HeadObjectOutputFilterSensitiveLog: () => jJe,
    HeadObjectRequestFilterSensitiveLog: () => FJe,
    IntelligentTieringAccessTier: () => oNr,
    IntelligentTieringStatus: () => iNr,
    InvalidObjectState: () => dJe,
    InvalidRequest: () => VJe,
    InvalidWriteOffset: () => zJe,
    InventoryConfigurationFilterSensitiveLog: () => QH,
    InventoryDestinationFilterSensitiveLog: () => NJe,
    InventoryEncryptionFilterSensitiveLog: () => IJe,
    InventoryFormat: () => aNr,
    InventoryFrequency: () => uNr,
    InventoryIncludedObjectVersions: () => sNr,
    InventoryOptionalField: () => cNr,
    InventoryS3BucketDestinationFilterSensitiveLog: () => xJe,
    JSONType: () => GNr,
    ListBucketAnalyticsConfigurationsCommand: () => Ytt,
    ListBucketIntelligentTieringConfigurationsCommand: () => Xtt,
    ListBucketInventoryConfigurationsCommand: () => Jtt,
    ListBucketInventoryConfigurationsOutputFilterSensitiveLog: () => BJe,
    ListBucketMetricsConfigurationsCommand: () => Ztt,
    ListBucketsCommand: () => Vre,
    ListDirectoryBucketsCommand: () => $re,
    ListMultipartUploadsCommand: () => ert,
    ListObjectVersionsCommand: () => rrt,
    ListObjectsCommand: () => trt,
    ListObjectsV2Command: () => zre,
    ListPartsCommand: () => Kre,
    ListPartsRequestFilterSensitiveLog: () => UJe,
    LocationType: () => Jxr,
    MFADelete: () => jNr,
    MFADeleteStatus: () => ONr,
    MetadataDirective: () => Vxr,
    MetricsFilter: () => LH,
    MetricsStatus: () => yNr,
    NoSuchBucket: () => uJe,
    NoSuchKey: () => pJe,
    NoSuchUpload: () => tJe,
    NotFound: () => hJe,
    ObjectAlreadyInActiveTierError: () => YJe,
    ObjectAttributes: () => INr,
    ObjectCannedACL: () => Hxr,
    ObjectLockEnabled: () => xNr,
    ObjectLockLegalHoldStatus: () => $xr,
    ObjectLockMode: () => zxr,
    ObjectLockRetentionMode: () => NNr,
    ObjectNotInActiveTierError: () => nJe,
    ObjectOwnership: () => eNr,
    ObjectStorageClass: () => LNr,
    ObjectVersionStorageClass: () => qNr,
    OptionalObjectAttributes: () => MNr,
    OutputLocationFilterSensitiveLog: () => iZe,
    OwnerOverride: () => Fxr,
    PartitionDateSource: () => mNr,
    Payer: () => wNr,
    Permission: () => jxr,
    Protocol: () => ANr,
    PutBucketAccelerateConfigurationCommand: () => nrt,
    PutBucketAclCommand: () => irt,
    PutBucketAnalyticsConfigurationCommand: () => ort,
    PutBucketCorsCommand: () => art,
    PutBucketEncryptionCommand: () => srt,
    PutBucketEncryptionRequestFilterSensitiveLog: () => JJe,
    PutBucketIntelligentTieringConfigurationCommand: () => crt,
    PutBucketInventoryConfigurationCommand: () => urt,
    PutBucketInventoryConfigurationRequestFilterSensitiveLog: () => ZJe,
    PutBucketLifecycleConfigurationCommand: () => lrt,
    PutBucketLoggingCommand: () => drt,
    PutBucketMetricsConfigurationCommand: () => frt,
    PutBucketNotificationConfigurationCommand: () => prt,
    PutBucketOwnershipControlsCommand: () => mrt,
    PutBucketPolicyCommand: () => hrt,
    PutBucketReplicationCommand: () => grt,
    PutBucketRequestPaymentCommand: () => vrt,
    PutBucketTaggingCommand: () => yrt,
    PutBucketVersioningCommand: () => _rt,
    PutBucketWebsiteCommand: () => Ert,
    PutObjectAclCommand: () => brt,
    PutObjectCommand: () => Srt,
    PutObjectLegalHoldCommand: () => Crt,
    PutObjectLockConfigurationCommand: () => wrt,
    PutObjectOutputFilterSensitiveLog: () => eZe,
    PutObjectRequestFilterSensitiveLog: () => tZe,
    PutObjectRetentionCommand: () => Ort,
    PutObjectTaggingCommand: () => Trt,
    PutPublicAccessBlockCommand: () => Art,
    QuoteFields: () => VNr,
    ReplicaModificationsStatus: () => bNr,
    ReplicationRuleStatus: () => CNr,
    ReplicationStatus: () => PNr,
    ReplicationTimeStatus: () => _Nr,
    RequestCharged: () => Dxr,
    RequestPayer: () => Lxr,
    RestoreObjectCommand: () => Prt,
    RestoreObjectRequestFilterSensitiveLog: () => aZe,
    RestoreRequestFilterSensitiveLog: () => oZe,
    RestoreRequestType: () => $Nr,
    S3: () => krt,
    S3Client: () => cS,
    S3LocationFilterSensitiveLog: () => nZe,
    S3ServiceException: () => po,
    SSEKMSFilterSensitiveLog: () => RJe,
    SelectObjectContentCommand: () => Rrt,
    SelectObjectContentEventStream: () => Ate,
    SelectObjectContentEventStreamFilterSensitiveLog: () => zNr,
    SelectObjectContentOutputFilterSensitiveLog: () => sZe,
    SelectObjectContentRequestFilterSensitiveLog: () => cZe,
    ServerSideEncryption: () => Uxr,
    ServerSideEncryptionByDefaultFilterSensitiveLog: () => TJe,
    ServerSideEncryptionConfigurationFilterSensitiveLog: () => lre,
    ServerSideEncryptionRuleFilterSensitiveLog: () => AJe,
    SessionCredentialsFilterSensitiveLog: () => CJe,
    SessionMode: () => tNr,
    SseKmsEncryptedObjectsStatus: () => SNr,
    StorageClass: () => Kxr,
    StorageClassAnalysisSchemaVersion: () => nNr,
    TaggingDirective: () => Wxr,
    Tier: () => FNr,
    TooManyParts: () => WJe,
    TransitionDefaultMinimumObjectSize: () => fNr,
    TransitionStorageClass: () => lNr,
    Type: () => qxr,
    UploadPartCommand: () => Irt,
    UploadPartCopyCommand: () => xrt,
    UploadPartCopyOutputFilterSensitiveLog: () => dZe,
    UploadPartCopyRequestFilterSensitiveLog: () => fZe,
    UploadPartOutputFilterSensitiveLog: () => uZe,
    UploadPartRequestFilterSensitiveLog: () => lZe,
    WriteGetObjectResponseCommand: () => Nrt,
    WriteGetObjectResponseRequestFilterSensitiveLog: () => pZe,
    __Client: () => p.Client,
    paginateListBuckets: () => kVr,
    paginateListDirectoryBuckets: () => LVr,
    paginateListObjectsV2: () => qVr,
    paginateListParts: () => FVr,
    waitForBucketExists: () => BVr,
    waitForBucketNotExists: () => HVr,
    waitForObjectExists: () => VVr,
    waitForObjectNotExists: () => zVr,
    waitUntilBucketExists: () => UVr,
    waitUntilBucketNotExists: () => GVr,
    waitUntilObjectExists: () => $Vr,
    waitUntilObjectNotExists: () => KVr,
  });
  jrt.exports = Oxr(Z7e);
  var Txr = MLe(),
    kr = rY(),
    b7e = uO(),
    Axr = lO(),
    Pxr = dO(),
    MT = Te(),
    S7e = CE(),
    Rxr = Eu(),
    Yee = (Gn(), ue(rc)),
    Ixr = g2e(),
    xxr = FO(),
    C7e = Kl(),
    w7e = dZ(),
    Nxr = Te(),
    W = Wl(),
    Q = ip(),
    kxr = v(
      (e) =>
        Object.assign(e, {
          useFipsEndpoint: e.useFipsEndpoint ?? !1,
          useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
          forcePathStyle: e.forcePathStyle ?? !1,
          useAccelerateEndpoint: e.useAccelerateEndpoint ?? !1,
          useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
          disableMultiregionAccessPoints:
            e.disableMultiregionAccessPoints ?? !1,
          defaultSigningName: "s3",
        }),
      "resolveClientEndpointParameters",
    ),
    Y = {
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: {
        type: "clientContextParams",
        name: "disableMultiregionAccessPoints",
      },
      Accelerate: {
        type: "clientContextParams",
        name: "useAccelerateEndpoint",
      },
      DisableS3ExpressSessionAuth: {
        type: "clientContextParams",
        name: "disableS3ExpressSessionAuth",
      },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
    },
    p = At(),
    po = class eJe extends p.ServiceException {
      static {
        v(this, "S3ServiceException");
      }
      constructor(t) {
        super(t), Object.setPrototypeOf(this, eJe.prototype);
      }
    },
    Dxr = { requester: "requester" },
    Lxr = { requester: "requester" },
    tJe = class rJe extends po {
      static {
        v(this, "NoSuchUpload");
      }
      name = "NoSuchUpload";
      $fault = "client";
      constructor(t) {
        super({ name: "NoSuchUpload", $fault: "client", ...t }),
          Object.setPrototypeOf(this, rJe.prototype);
      }
    },
    Mxr = { Enabled: "Enabled", Suspended: "Suspended" },
    qxr = {
      AmazonCustomerByEmail: "AmazonCustomerByEmail",
      CanonicalUser: "CanonicalUser",
      Group: "Group",
    },
    jxr = {
      FULL_CONTROL: "FULL_CONTROL",
      READ: "READ",
      READ_ACP: "READ_ACP",
      WRITE: "WRITE",
      WRITE_ACP: "WRITE_ACP",
    },
    Fxr = { Destination: "Destination" },
    Bxr = { COMPOSITE: "COMPOSITE", FULL_OBJECT: "FULL_OBJECT" },
    Uxr = {
      AES256: "AES256",
      aws_kms: "aws:kms",
      aws_kms_dsse: "aws:kms:dsse",
    },
    Hxr = {
      authenticated_read: "authenticated-read",
      aws_exec_read: "aws-exec-read",
      bucket_owner_full_control: "bucket-owner-full-control",
      bucket_owner_read: "bucket-owner-read",
      private: "private",
      public_read: "public-read",
      public_read_write: "public-read-write",
    },
    Gxr = {
      CRC32: "CRC32",
      CRC32C: "CRC32C",
      CRC64NVME: "CRC64NVME",
      SHA1: "SHA1",
      SHA256: "SHA256",
    },
    Vxr = { COPY: "COPY", REPLACE: "REPLACE" },
    $xr = { OFF: "OFF", ON: "ON" },
    zxr = { COMPLIANCE: "COMPLIANCE", GOVERNANCE: "GOVERNANCE" },
    Kxr = {
      DEEP_ARCHIVE: "DEEP_ARCHIVE",
      EXPRESS_ONEZONE: "EXPRESS_ONEZONE",
      GLACIER: "GLACIER",
      GLACIER_IR: "GLACIER_IR",
      INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
      ONEZONE_IA: "ONEZONE_IA",
      OUTPOSTS: "OUTPOSTS",
      REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
      SNOW: "SNOW",
      STANDARD: "STANDARD",
      STANDARD_IA: "STANDARD_IA",
    },
    Wxr = { COPY: "COPY", REPLACE: "REPLACE" },
    nJe = class iJe extends po {
      static {
        v(this, "ObjectNotInActiveTierError");
      }
      name = "ObjectNotInActiveTierError";
      $fault = "client";
      constructor(t) {
        super({ name: "ObjectNotInActiveTierError", $fault: "client", ...t }),
          Object.setPrototypeOf(this, iJe.prototype);
      }
    },
    oJe = class aJe extends po {
      static {
        v(this, "BucketAlreadyExists");
      }
      name = "BucketAlreadyExists";
      $fault = "client";
      constructor(t) {
        super({ name: "BucketAlreadyExists", $fault: "client", ...t }),
          Object.setPrototypeOf(this, aJe.prototype);
      }
    },
    sJe = class cJe extends po {
      static {
        v(this, "BucketAlreadyOwnedByYou");
      }
      name = "BucketAlreadyOwnedByYou";
      $fault = "client";
      constructor(t) {
        super({ name: "BucketAlreadyOwnedByYou", $fault: "client", ...t }),
          Object.setPrototypeOf(this, cJe.prototype);
      }
    },
    Qxr = {
      authenticated_read: "authenticated-read",
      private: "private",
      public_read: "public-read",
      public_read_write: "public-read-write",
    },
    Yxr = {
      SingleAvailabilityZone: "SingleAvailabilityZone",
      SingleLocalZone: "SingleLocalZone",
    },
    Xxr = { Directory: "Directory" },
    Jxr = { AvailabilityZone: "AvailabilityZone", LocalZone: "LocalZone" },
    Zxr = {
      EU: "EU",
      af_south_1: "af-south-1",
      ap_east_1: "ap-east-1",
      ap_northeast_1: "ap-northeast-1",
      ap_northeast_2: "ap-northeast-2",
      ap_northeast_3: "ap-northeast-3",
      ap_south_1: "ap-south-1",
      ap_south_2: "ap-south-2",
      ap_southeast_1: "ap-southeast-1",
      ap_southeast_2: "ap-southeast-2",
      ap_southeast_3: "ap-southeast-3",
      ap_southeast_4: "ap-southeast-4",
      ap_southeast_5: "ap-southeast-5",
      ca_central_1: "ca-central-1",
      cn_north_1: "cn-north-1",
      cn_northwest_1: "cn-northwest-1",
      eu_central_1: "eu-central-1",
      eu_central_2: "eu-central-2",
      eu_north_1: "eu-north-1",
      eu_south_1: "eu-south-1",
      eu_south_2: "eu-south-2",
      eu_west_1: "eu-west-1",
      eu_west_2: "eu-west-2",
      eu_west_3: "eu-west-3",
      il_central_1: "il-central-1",
      me_central_1: "me-central-1",
      me_south_1: "me-south-1",
      sa_east_1: "sa-east-1",
      us_east_2: "us-east-2",
      us_gov_east_1: "us-gov-east-1",
      us_gov_west_1: "us-gov-west-1",
      us_west_1: "us-west-1",
      us_west_2: "us-west-2",
    },
    eNr = {
      BucketOwnerEnforced: "BucketOwnerEnforced",
      BucketOwnerPreferred: "BucketOwnerPreferred",
      ObjectWriter: "ObjectWriter",
    },
    tNr = { ReadOnly: "ReadOnly", ReadWrite: "ReadWrite" },
    uJe = class lJe extends po {
      static {
        v(this, "NoSuchBucket");
      }
      name = "NoSuchBucket";
      $fault = "client";
      constructor(t) {
        super({ name: "NoSuchBucket", $fault: "client", ...t }),
          Object.setPrototypeOf(this, lJe.prototype);
      }
    },
    DH;
  ((e) => {
    e.visit = v(
      (t, r) =>
        t.Prefix !== void 0
          ? r.Prefix(t.Prefix)
          : t.Tag !== void 0
            ? r.Tag(t.Tag)
            : t.And !== void 0
              ? r.And(t.And)
              : r._(t.$unknown[0], t.$unknown[1]),
      "visit",
    );
  })(DH || (DH = {}));
  var rNr = { CSV: "CSV" },
    nNr = { V_1: "V_1" },
    iNr = { Disabled: "Disabled", Enabled: "Enabled" },
    oNr = {
      ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
      DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS",
    },
    aNr = { CSV: "CSV", ORC: "ORC", Parquet: "Parquet" },
    sNr = { All: "All", Current: "Current" },
    cNr = {
      BucketKeyStatus: "BucketKeyStatus",
      ChecksumAlgorithm: "ChecksumAlgorithm",
      ETag: "ETag",
      EncryptionStatus: "EncryptionStatus",
      IntelligentTieringAccessTier: "IntelligentTieringAccessTier",
      IsMultipartUploaded: "IsMultipartUploaded",
      LastModifiedDate: "LastModifiedDate",
      ObjectAccessControlList: "ObjectAccessControlList",
      ObjectLockLegalHoldStatus: "ObjectLockLegalHoldStatus",
      ObjectLockMode: "ObjectLockMode",
      ObjectLockRetainUntilDate: "ObjectLockRetainUntilDate",
      ObjectOwner: "ObjectOwner",
      ReplicationStatus: "ReplicationStatus",
      Size: "Size",
      StorageClass: "StorageClass",
    },
    uNr = { Daily: "Daily", Weekly: "Weekly" },
    lNr = {
      DEEP_ARCHIVE: "DEEP_ARCHIVE",
      GLACIER: "GLACIER",
      GLACIER_IR: "GLACIER_IR",
      INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
      ONEZONE_IA: "ONEZONE_IA",
      STANDARD_IA: "STANDARD_IA",
    },
    dNr = { Disabled: "Disabled", Enabled: "Enabled" },
    fNr = {
      all_storage_classes_128K: "all_storage_classes_128K",
      varies_by_storage_class: "varies_by_storage_class",
    },
    pNr = { FULL_CONTROL: "FULL_CONTROL", READ: "READ", WRITE: "WRITE" },
    mNr = { DeliveryTime: "DeliveryTime", EventTime: "EventTime" },
    LH;
  ((e) => {
    e.visit = v(
      (t, r) =>
        t.Prefix !== void 0
          ? r.Prefix(t.Prefix)
          : t.Tag !== void 0
            ? r.Tag(t.Tag)
            : t.AccessPointArn !== void 0
              ? r.AccessPointArn(t.AccessPointArn)
              : t.And !== void 0
                ? r.And(t.And)
                : r._(t.$unknown[0], t.$unknown[1]),
      "visit",
    );
  })(LH || (LH = {}));
  var hNr = {
      s3_IntelligentTiering: "s3:IntelligentTiering",
      s3_LifecycleExpiration_: "s3:LifecycleExpiration:*",
      s3_LifecycleExpiration_Delete: "s3:LifecycleExpiration:Delete",
      s3_LifecycleExpiration_DeleteMarkerCreated:
        "s3:LifecycleExpiration:DeleteMarkerCreated",
      s3_LifecycleTransition: "s3:LifecycleTransition",
      s3_ObjectAcl_Put: "s3:ObjectAcl:Put",
      s3_ObjectCreated_: "s3:ObjectCreated:*",
      s3_ObjectCreated_CompleteMultipartUpload:
        "s3:ObjectCreated:CompleteMultipartUpload",
      s3_ObjectCreated_Copy: "s3:ObjectCreated:Copy",
      s3_ObjectCreated_Post: "s3:ObjectCreated:Post",
      s3_ObjectCreated_Put: "s3:ObjectCreated:Put",
      s3_ObjectRemoved_: "s3:ObjectRemoved:*",
      s3_ObjectRemoved_Delete: "s3:ObjectRemoved:Delete",
      s3_ObjectRemoved_DeleteMarkerCreated:
        "s3:ObjectRemoved:DeleteMarkerCreated",
      s3_ObjectRestore_: "s3:ObjectRestore:*",
      s3_ObjectRestore_Completed: "s3:ObjectRestore:Completed",
      s3_ObjectRestore_Delete: "s3:ObjectRestore:Delete",
      s3_ObjectRestore_Post: "s3:ObjectRestore:Post",
      s3_ObjectTagging_: "s3:ObjectTagging:*",
      s3_ObjectTagging_Delete: "s3:ObjectTagging:Delete",
      s3_ObjectTagging_Put: "s3:ObjectTagging:Put",
      s3_ReducedRedundancyLostObject: "s3:ReducedRedundancyLostObject",
      s3_Replication_: "s3:Replication:*",
      s3_Replication_OperationFailedReplication:
        "s3:Replication:OperationFailedReplication",
      s3_Replication_OperationMissedThreshold:
        "s3:Replication:OperationMissedThreshold",
      s3_Replication_OperationNotTracked: "s3:Replication:OperationNotTracked",
      s3_Replication_OperationReplicatedAfterThreshold:
        "s3:Replication:OperationReplicatedAfterThreshold",
    },
    gNr = { prefix: "prefix", suffix: "suffix" },
    vNr = { Disabled: "Disabled", Enabled: "Enabled" },
    yNr = { Disabled: "Disabled", Enabled: "Enabled" },
    _Nr = { Disabled: "Disabled", Enabled: "Enabled" },
    ENr = { Disabled: "Disabled", Enabled: "Enabled" },
    bNr = { Disabled: "Disabled", Enabled: "Enabled" },
    SNr = { Disabled: "Disabled", Enabled: "Enabled" },
    CNr = { Disabled: "Disabled", Enabled: "Enabled" },
    wNr = { BucketOwner: "BucketOwner", Requester: "Requester" },
    ONr = { Disabled: "Disabled", Enabled: "Enabled" },
    TNr = { Enabled: "Enabled", Suspended: "Suspended" },
    ANr = { http: "http", https: "https" },
    PNr = {
      COMPLETE: "COMPLETE",
      COMPLETED: "COMPLETED",
      FAILED: "FAILED",
      PENDING: "PENDING",
      REPLICA: "REPLICA",
    },
    RNr = { ENABLED: "ENABLED" },
    dJe = class fJe extends po {
      static {
        v(this, "InvalidObjectState");
      }
      name = "InvalidObjectState";
      $fault = "client";
      StorageClass;
      AccessTier;
      constructor(t) {
        super({ name: "InvalidObjectState", $fault: "client", ...t }),
          Object.setPrototypeOf(this, fJe.prototype),
          (this.StorageClass = t.StorageClass),
          (this.AccessTier = t.AccessTier);
      }
    },
    pJe = class mJe extends po {
      static {
        v(this, "NoSuchKey");
      }
      name = "NoSuchKey";
      $fault = "client";
      constructor(t) {
        super({ name: "NoSuchKey", $fault: "client", ...t }),
          Object.setPrototypeOf(this, mJe.prototype);
      }
    },
    INr = {
      CHECKSUM: "Checksum",
      ETAG: "ETag",
      OBJECT_PARTS: "ObjectParts",
      OBJECT_SIZE: "ObjectSize",
      STORAGE_CLASS: "StorageClass",
    },
    xNr = { Enabled: "Enabled" },
    NNr = { COMPLIANCE: "COMPLIANCE", GOVERNANCE: "GOVERNANCE" },
    hJe = class gJe extends po {
      static {
        v(this, "NotFound");
      }
      name = "NotFound";
      $fault = "client";
      constructor(t) {
        super({ name: "NotFound", $fault: "client", ...t }),
          Object.setPrototypeOf(this, gJe.prototype);
      }
    },
    kNr = {
      ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
      DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS",
    },
    DNr = { url: "url" },
    LNr = {
      DEEP_ARCHIVE: "DEEP_ARCHIVE",
      EXPRESS_ONEZONE: "EXPRESS_ONEZONE",
      GLACIER: "GLACIER",
      GLACIER_IR: "GLACIER_IR",
      INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
      ONEZONE_IA: "ONEZONE_IA",
      OUTPOSTS: "OUTPOSTS",
      REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
      SNOW: "SNOW",
      STANDARD: "STANDARD",
      STANDARD_IA: "STANDARD_IA",
    },
    MNr = { RESTORE_STATUS: "RestoreStatus" },
    qNr = { STANDARD: "STANDARD" },
    vJe = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
      }),
      "CompleteMultipartUploadOutputFilterSensitiveLog",
    ),
    yJe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
      }),
      "CompleteMultipartUploadRequestFilterSensitiveLog",
    ),
    _Je = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
        ...(e.SSEKMSEncryptionContext && {
          SSEKMSEncryptionContext: p.SENSITIVE_STRING,
        }),
      }),
      "CopyObjectOutputFilterSensitiveLog",
    ),
    EJe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
        ...(e.SSEKMSEncryptionContext && {
          SSEKMSEncryptionContext: p.SENSITIVE_STRING,
        }),
        ...(e.CopySourceSSECustomerKey && {
          CopySourceSSECustomerKey: p.SENSITIVE_STRING,
        }),
      }),
      "CopyObjectRequestFilterSensitiveLog",
    ),
    bJe = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
        ...(e.SSEKMSEncryptionContext && {
          SSEKMSEncryptionContext: p.SENSITIVE_STRING,
        }),
      }),
      "CreateMultipartUploadOutputFilterSensitiveLog",
    ),
    SJe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
        ...(e.SSEKMSEncryptionContext && {
          SSEKMSEncryptionContext: p.SENSITIVE_STRING,
        }),
      }),
      "CreateMultipartUploadRequestFilterSensitiveLog",
    ),
    CJe = v(
      (e) => ({
        ...e,
        ...(e.SecretAccessKey && { SecretAccessKey: p.SENSITIVE_STRING }),
        ...(e.SessionToken && { SessionToken: p.SENSITIVE_STRING }),
      }),
      "SessionCredentialsFilterSensitiveLog",
    ),
    wJe = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
        ...(e.SSEKMSEncryptionContext && {
          SSEKMSEncryptionContext: p.SENSITIVE_STRING,
        }),
        ...(e.Credentials && { Credentials: CJe(e.Credentials) }),
      }),
      "CreateSessionOutputFilterSensitiveLog",
    ),
    OJe = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
        ...(e.SSEKMSEncryptionContext && {
          SSEKMSEncryptionContext: p.SENSITIVE_STRING,
        }),
      }),
      "CreateSessionRequestFilterSensitiveLog",
    ),
    TJe = v(
      (e) => ({
        ...e,
        ...(e.KMSMasterKeyID && { KMSMasterKeyID: p.SENSITIVE_STRING }),
      }),
      "ServerSideEncryptionByDefaultFilterSensitiveLog",
    ),
    AJe = v(
      (e) => ({
        ...e,
        ...(e.ApplyServerSideEncryptionByDefault && {
          ApplyServerSideEncryptionByDefault: TJe(
            e.ApplyServerSideEncryptionByDefault,
          ),
        }),
      }),
      "ServerSideEncryptionRuleFilterSensitiveLog",
    ),
    lre = v(
      (e) => ({ ...e, ...(e.Rules && { Rules: e.Rules.map((t) => AJe(t)) }) }),
      "ServerSideEncryptionConfigurationFilterSensitiveLog",
    ),
    PJe = v(
      (e) => ({
        ...e,
        ...(e.ServerSideEncryptionConfiguration && {
          ServerSideEncryptionConfiguration: lre(
            e.ServerSideEncryptionConfiguration,
          ),
        }),
      }),
      "GetBucketEncryptionOutputFilterSensitiveLog",
    ),
    RJe = v(
      (e) => ({ ...e, ...(e.KeyId && { KeyId: p.SENSITIVE_STRING }) }),
      "SSEKMSFilterSensitiveLog",
    ),
    IJe = v(
      (e) => ({ ...e, ...(e.SSEKMS && { SSEKMS: RJe(e.SSEKMS) }) }),
      "InventoryEncryptionFilterSensitiveLog",
    ),
    xJe = v(
      (e) => ({ ...e, ...(e.Encryption && { Encryption: IJe(e.Encryption) }) }),
      "InventoryS3BucketDestinationFilterSensitiveLog",
    ),
    NJe = v(
      (e) => ({
        ...e,
        ...(e.S3BucketDestination && {
          S3BucketDestination: xJe(e.S3BucketDestination),
        }),
      }),
      "InventoryDestinationFilterSensitiveLog",
    ),
    QH = v(
      (e) => ({
        ...e,
        ...(e.Destination && { Destination: NJe(e.Destination) }),
      }),
      "InventoryConfigurationFilterSensitiveLog",
    ),
    kJe = v(
      (e) => ({
        ...e,
        ...(e.InventoryConfiguration && {
          InventoryConfiguration: QH(e.InventoryConfiguration),
        }),
      }),
      "GetBucketInventoryConfigurationOutputFilterSensitiveLog",
    ),
    DJe = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
      }),
      "GetObjectOutputFilterSensitiveLog",
    ),
    LJe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
      }),
      "GetObjectRequestFilterSensitiveLog",
    ),
    MJe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
      }),
      "GetObjectAttributesRequestFilterSensitiveLog",
    ),
    qJe = v((e) => ({ ...e }), "GetObjectTorrentOutputFilterSensitiveLog"),
    jJe = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
      }),
      "HeadObjectOutputFilterSensitiveLog",
    ),
    FJe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
      }),
      "HeadObjectRequestFilterSensitiveLog",
    ),
    BJe = v(
      (e) => ({
        ...e,
        ...(e.InventoryConfigurationList && {
          InventoryConfigurationList: e.InventoryConfigurationList.map((t) =>
            QH(t),
          ),
        }),
      }),
      "ListBucketInventoryConfigurationsOutputFilterSensitiveLog",
    ),
    UJe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
      }),
      "ListPartsRequestFilterSensitiveLog",
    ),
    Be = (ri(), ue(yu)),
    R = b6e(),
    X = (Gn(), ue(rc)),
    Tte = ln(),
    jNr = { Disabled: "Disabled", Enabled: "Enabled" },
    HJe = class GJe extends po {
      static {
        v(this, "EncryptionTypeMismatch");
      }
      name = "EncryptionTypeMismatch";
      $fault = "client";
      constructor(t) {
        super({ name: "EncryptionTypeMismatch", $fault: "client", ...t }),
          Object.setPrototypeOf(this, GJe.prototype);
      }
    },
    VJe = class $Je extends po {
      static {
        v(this, "InvalidRequest");
      }
      name = "InvalidRequest";
      $fault = "client";
      constructor(t) {
        super({ name: "InvalidRequest", $fault: "client", ...t }),
          Object.setPrototypeOf(this, $Je.prototype);
      }
    },
    zJe = class KJe extends po {
      static {
        v(this, "InvalidWriteOffset");
      }
      name = "InvalidWriteOffset";
      $fault = "client";
      constructor(t) {
        super({ name: "InvalidWriteOffset", $fault: "client", ...t }),
          Object.setPrototypeOf(this, KJe.prototype);
      }
    },
    WJe = class QJe extends po {
      static {
        v(this, "TooManyParts");
      }
      name = "TooManyParts";
      $fault = "client";
      constructor(t) {
        super({ name: "TooManyParts", $fault: "client", ...t }),
          Object.setPrototypeOf(this, QJe.prototype);
      }
    },
    YJe = class XJe extends po {
      static {
        v(this, "ObjectAlreadyInActiveTierError");
      }
      name = "ObjectAlreadyInActiveTierError";
      $fault = "client";
      constructor(t) {
        super({
          name: "ObjectAlreadyInActiveTierError",
          $fault: "client",
          ...t,
        }),
          Object.setPrototypeOf(this, XJe.prototype);
      }
    },
    FNr = { Bulk: "Bulk", Expedited: "Expedited", Standard: "Standard" },
    BNr = { SQL: "SQL" },
    UNr = { BZIP2: "BZIP2", GZIP: "GZIP", NONE: "NONE" },
    HNr = { IGNORE: "IGNORE", NONE: "NONE", USE: "USE" },
    GNr = { DOCUMENT: "DOCUMENT", LINES: "LINES" },
    VNr = { ALWAYS: "ALWAYS", ASNEEDED: "ASNEEDED" },
    $Nr = { SELECT: "SELECT" },
    Ate;
  ((e) => {
    e.visit = v(
      (t, r) =>
        t.Records !== void 0
          ? r.Records(t.Records)
          : t.Stats !== void 0
            ? r.Stats(t.Stats)
            : t.Progress !== void 0
              ? r.Progress(t.Progress)
              : t.Cont !== void 0
                ? r.Cont(t.Cont)
                : t.End !== void 0
                  ? r.End(t.End)
                  : r._(t.$unknown[0], t.$unknown[1]),
      "visit",
    );
  })(Ate || (Ate = {}));
  var JJe = v(
      (e) => ({
        ...e,
        ...(e.ServerSideEncryptionConfiguration && {
          ServerSideEncryptionConfiguration: lre(
            e.ServerSideEncryptionConfiguration,
          ),
        }),
      }),
      "PutBucketEncryptionRequestFilterSensitiveLog",
    ),
    ZJe = v(
      (e) => ({
        ...e,
        ...(e.InventoryConfiguration && {
          InventoryConfiguration: QH(e.InventoryConfiguration),
        }),
      }),
      "PutBucketInventoryConfigurationRequestFilterSensitiveLog",
    ),
    eZe = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
        ...(e.SSEKMSEncryptionContext && {
          SSEKMSEncryptionContext: p.SENSITIVE_STRING,
        }),
      }),
      "PutObjectOutputFilterSensitiveLog",
    ),
    tZe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
        ...(e.SSEKMSEncryptionContext && {
          SSEKMSEncryptionContext: p.SENSITIVE_STRING,
        }),
      }),
      "PutObjectRequestFilterSensitiveLog",
    ),
    rZe = v(
      (e) => ({ ...e, ...(e.KMSKeyId && { KMSKeyId: p.SENSITIVE_STRING }) }),
      "EncryptionFilterSensitiveLog",
    ),
    nZe = v(
      (e) => ({ ...e, ...(e.Encryption && { Encryption: rZe(e.Encryption) }) }),
      "S3LocationFilterSensitiveLog",
    ),
    iZe = v(
      (e) => ({ ...e, ...(e.S3 && { S3: nZe(e.S3) }) }),
      "OutputLocationFilterSensitiveLog",
    ),
    oZe = v(
      (e) => ({
        ...e,
        ...(e.OutputLocation && { OutputLocation: iZe(e.OutputLocation) }),
      }),
      "RestoreRequestFilterSensitiveLog",
    ),
    aZe = v(
      (e) => ({
        ...e,
        ...(e.RestoreRequest && { RestoreRequest: oZe(e.RestoreRequest) }),
      }),
      "RestoreObjectRequestFilterSensitiveLog",
    ),
    zNr = v((e) => {
      if (e.Records !== void 0) return { Records: e.Records };
      if (e.Stats !== void 0) return { Stats: e.Stats };
      if (e.Progress !== void 0) return { Progress: e.Progress };
      if (e.Cont !== void 0) return { Cont: e.Cont };
      if (e.End !== void 0) return { End: e.End };
      if (e.$unknown !== void 0) return { [e.$unknown[0]]: "UNKNOWN" };
    }, "SelectObjectContentEventStreamFilterSensitiveLog"),
    sZe = v(
      (e) => ({ ...e, ...(e.Payload && { Payload: "STREAMING_CONTENT" }) }),
      "SelectObjectContentOutputFilterSensitiveLog",
    ),
    cZe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
      }),
      "SelectObjectContentRequestFilterSensitiveLog",
    ),
    uZe = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
      }),
      "UploadPartOutputFilterSensitiveLog",
    ),
    lZe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
      }),
      "UploadPartRequestFilterSensitiveLog",
    ),
    dZe = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
      }),
      "UploadPartCopyOutputFilterSensitiveLog",
    ),
    fZe = v(
      (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: p.SENSITIVE_STRING }),
        ...(e.CopySourceSSECustomerKey && {
          CopySourceSSECustomerKey: p.SENSITIVE_STRING,
        }),
      }),
      "UploadPartCopyRequestFilterSensitiveLog",
    ),
    pZe = v(
      (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: p.SENSITIVE_STRING }),
      }),
      "WriteGetObjectResponseRequestFilterSensitiveLog",
    ),
    KNr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [or]: e[nr],
          [te]: e[ee],
          [aGr]: [
            () => (0, p.isSerializableHeaderValue)(e[x7e]),
            () => (0, p.dateToUtcString)(e[x7e]).toString(),
          ],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({
        [di]: [, "AbortMultipartUpload"],
        [XT]: [, (0, p.expectNonNull)(e[Wo], "UploadId")],
      });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_AbortMultipartUploadCommand"),
    WNr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [Hg]: e[_r],
          [Gg]: e[Er],
          [Vg]: e[br],
          [$g]: e[Sr],
          [zg]: e[Cr],
          [nS]: e[wr],
          [lGr]: [
            () => (0, p.isSerializableHeaderValue)(e[M7e]),
            () => e[M7e].toString(),
          ],
          [or]: e[nr],
          [te]: e[ee],
          [QT]: e[HT],
          [o3]: e[JH],
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [XT]: [, (0, p.expectNonNull)(e[Wo], "UploadId")] }),
        o,
        a;
      return (
        e.MultipartUpload !== void 0 &&
          ((a = sqr(e.MultipartUpload, t)),
          (a = a.n("CompleteMultipartUpload")),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("POST").h(n).q(i).b(o),
        r.build()
      );
    }, "se_CompleteMultipartUploadCommand"),
    QNr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [rS]: e[Vb],
          [VT]: e[$b],
          [qre]: e[lt],
          [$T]: e[zb],
          [zT]: e[Kb],
          [KT]: e[Wb],
          [WT]: e[Qb],
          [jet]: e[LZe],
          [Fet]: e[MZe],
          [Bet]: [
            () => (0, p.isSerializableHeaderValue)(e[MH]),
            () => (0, p.dateToUtcString)(e[MH]).toString(),
          ],
          [Uet]: e[qZe],
          [Het]: [
            () => (0, p.isSerializableHeaderValue)(e[qH]),
            () => (0, p.dateToUtcString)(e[qH]).toString(),
          ],
          [qg]: [
            () => (0, p.isSerializableHeaderValue)(e[Du]),
            () => (0, p.dateToUtcString)(e[Du]).toString(),
          ],
          [iS]: e[Yb],
          [oS]: e[Xb],
          [aS]: e[Jb],
          [sS]: e[Zb],
          [uGr]: e[KUr],
          [_Gr]: e[GHr],
          [_a]: e[Ji],
          [tA]: e[st],
          [rA]: e[GT],
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
          [Ea]: e[Li],
          [Up]: e[Bp],
          [fn]: [
            () => (0, p.isSerializableHeaderValue)(e[xr]),
            () => e[xr].toString(),
          ],
          [Get]: e[jZe],
          [Vet]: e[FZe],
          [$et]: e[BZe],
          [or]: e[nr],
          [Ure]: e[kg],
          [eA]: e[eS],
          [jg]: [
            () => (0, p.isSerializableHeaderValue)(e[Lu]),
            () => (0, p.serializeDateTime)(e[Lu]).toString(),
          ],
          [ZT]: e[Bg],
          [te]: e[ee],
          [Qet]: e[GZe],
          ...(e.Metadata !== void 0 &&
            Object.keys(e.Metadata).reduce(
              (a, s) => (
                (a[`x-amz-meta-${s.toLowerCase()}`] = e.Metadata[s]), a
              ),
              {},
            )),
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [di]: [, "CopyObject"] });
      return (
        r
          .m("PUT")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_CopyObjectCommand"),
    YNr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [rS]: e[Vb],
          [iS]: e[Yb],
          [oS]: e[Xb],
          [aS]: e[Jb],
          [jre]: e[yre],
          [sS]: e[Zb],
          [_3r]: [
            () => (0, p.isSerializableHeaderValue)(e[j7e]),
            () => e[j7e].toString(),
          ],
          [pGr]: e[FT],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i, o;
      return (
        e.CreateBucketConfiguration !== void 0 &&
          ((o = mqr(e.CreateBucketConfiguration, t)),
          (i = ir),
          o.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (i += o.toString())),
        r.m("PUT").h(n).b(i),
        r.build()
      );
    }, "se_CreateBucketCommand"),
    XNr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Rre]: [, ""] }),
        o,
        a;
      return (
        e.MetadataTableConfiguration !== void 0 &&
          ((a = ejr(e.MetadataTableConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("POST").h(n).q(i).b(o),
        r.build()
      );
    }, "se_CreateBucketMetadataTableConfigurationCommand"),
    JNr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [rS]: e[Vb],
          [VT]: e[$b],
          [$T]: e[zb],
          [zT]: e[Kb],
          [KT]: e[Wb],
          [WT]: e[Qb],
          [qg]: [
            () => (0, p.isSerializableHeaderValue)(e[Du]),
            () => (0, p.dateToUtcString)(e[Du]).toString(),
          ],
          [iS]: e[Yb],
          [oS]: e[Xb],
          [aS]: e[Jb],
          [sS]: e[Zb],
          [_a]: e[Ji],
          [tA]: e[st],
          [rA]: e[GT],
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
          [Ea]: e[Li],
          [Up]: e[Bp],
          [fn]: [
            () => (0, p.isSerializableHeaderValue)(e[xr]),
            () => e[xr].toString(),
          ],
          [or]: e[nr],
          [Ure]: e[kg],
          [eA]: e[eS],
          [jg]: [
            () => (0, p.isSerializableHeaderValue)(e[Lu]),
            () => (0, p.serializeDateTime)(e[Lu]).toString(),
          ],
          [ZT]: e[Bg],
          [te]: e[ee],
          [qre]: e[lt],
          [nS]: e[wr],
          ...(e.Metadata !== void 0 &&
            Object.keys(e.Metadata).reduce(
              (a, s) => (
                (a[`x-amz-meta-${s.toLowerCase()}`] = e.Metadata[s]), a
              ),
              {},
            )),
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [ket]: [, ""] });
      return (
        r
          .m("POST")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_CreateMultipartUploadCommand"),
    ZNr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [S3r]: e[MHr],
          [_a]: e[Ji],
          [Ea]: e[Li],
          [Up]: e[Bp],
          [fn]: [
            () => (0, p.isSerializableHeaderValue)(e[xr]),
            () => e[xr].toString(),
          ],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [c3r]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_CreateSessionCommand"),
    ekr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      return (
        r.bp("/"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r
          .m("DELETE")
          .h(n)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketCommand"),
    tkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [ZH]: [, ""],
        [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
      });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketAnalyticsConfigurationCommand"),
    rkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Tre]: [, ""] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketCorsCommand"),
    nkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Are]: [, ""] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketEncryptionCommand"),
    ikr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = {};
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [a3]: [, ""],
        [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
      });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketIntelligentTieringConfigurationCommand"),
    okr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [i3]: [, ""],
        [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
      });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketInventoryConfigurationCommand"),
    akr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Pre]: [, ""] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketLifecycleCommand"),
    skr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Rre]: [, ""] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketMetadataTableConfigurationCommand"),
    ckr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [s3]: [, ""],
        [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
      });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketMetricsConfigurationCommand"),
    ukr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [xre]: [, ""] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketOwnershipControlsCommand"),
    lkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Nre]: [, ""] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketPolicyCommand"),
    dkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Dre]: [, ""] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketReplicationCommand"),
    fkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [tS]: [, ""] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketTaggingCommand"),
    pkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Lre]: [, ""] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteBucketWebsiteCommand"),
    mkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [Fre]: e[_re],
          [or]: e[nr],
          [Mre]: [
            () => (0, p.isSerializableHeaderValue)(e[qb]),
            () => e[qb].toString(),
          ],
          [te]: e[ee],
          [QT]: e[HT],
          [sGr]: [
            () => (0, p.isSerializableHeaderValue)(e[N7e]),
            () => (0, p.dateToUtcString)(e[N7e]).toString(),
          ],
          [cGr]: [
            () => (0, p.isSerializableHeaderValue)(e[k7e]),
            () => e[k7e].toString(),
          ],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [di]: [, "DeleteObject"], [Qo]: [, e[dt]] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteObjectCommand"),
    hkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [Fre]: e[_re],
          [or]: e[nr],
          [Mre]: [
            () => (0, p.isSerializableHeaderValue)(e[qb]),
            () => e[qb].toString(),
          ],
          [te]: e[ee],
          [on]: e[lt],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [XHr]: [, ""] }),
        o,
        a;
      return (
        e.Delete !== void 0 &&
          ((a = yqr(e.Delete, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("POST").h(n).q(i).b(o),
        r.build()
      );
    }, "se_DeleteObjectsCommand"),
    gkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [tS]: [, ""], [Qo]: [, e[dt]] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeleteObjectTaggingCommand"),
    vkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [kre]: [, ""] });
      return (
        r
          .m("DELETE")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_DeletePublicAccessBlockCommand"),
    ykr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [te]: e[ee],
          [or]: e[nr],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [det]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketAccelerateConfigurationCommand"),
    _kr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [e3]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketAclCommand"),
    Ekr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [ZH]: [, ""],
        [di]: [, "GetBucketAnalyticsConfiguration"],
        [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketAnalyticsConfigurationCommand"),
    bkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Tre]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketCorsCommand"),
    Skr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Are]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketEncryptionCommand"),
    Ckr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = {};
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [a3]: [, ""],
        [di]: [, "GetBucketIntelligentTieringConfiguration"],
        [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketIntelligentTieringConfigurationCommand"),
    wkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [i3]: [, ""],
        [di]: [, "GetBucketInventoryConfiguration"],
        [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketInventoryConfigurationCommand"),
    Okr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Pre]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketLifecycleConfigurationCommand"),
    Tkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [_et]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketLocationCommand"),
    Akr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Eet]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketLoggingCommand"),
    Pkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Rre]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketMetadataTableConfigurationCommand"),
    Rkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [s3]: [, ""],
        [di]: [, "GetBucketMetricsConfiguration"],
        [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketMetricsConfigurationCommand"),
    Ikr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [bet]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketNotificationConfigurationCommand"),
    xkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [xre]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketOwnershipControlsCommand"),
    Nkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Nre]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketPolicyCommand"),
    kkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [o3r]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketPolicyStatusCommand"),
    Dkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Dre]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketReplicationCommand"),
    Lkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [wet]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketRequestPaymentCommand"),
    Mkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [tS]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketTaggingCommand"),
    qkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Det]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketVersioningCommand"),
    jkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Lre]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetBucketWebsiteCommand"),
    Fkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [QT]: e[HT],
          [het]: [
            () => (0, p.isSerializableHeaderValue)(e[jH]),
            () => (0, p.dateToUtcString)(e[jH]).toString(),
          ],
          [o3]: e[JH],
          [get]: [
            () => (0, p.isSerializableHeaderValue)(e[FH]),
            () => (0, p.dateToUtcString)(e[FH]).toString(),
          ],
          [Oet]: e[ZZe],
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
          [or]: e[nr],
          [te]: e[ee],
          [qet]: e[DZe],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({
        [di]: [, "GetObject"],
        [Tet]: [, e[eet]],
        [Aet]: [, e[tet]],
        [Pet]: [, e[ret]],
        [Ret]: [, e[net]],
        [Iet]: [, e[iet]],
        [xet]: [
          () => e.ResponseExpires !== void 0,
          () => (0, p.dateToUtcString)(e[oet]).toString(),
        ],
        [Qo]: [, e[dt]],
        [c3]: [() => e.PartNumber !== void 0, () => e[$o].toString()],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetObjectCommand"),
    Bkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [or]: e[nr],
          [te]: e[ee],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [e3]: [, ""], [Qo]: [, e[dt]] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetObjectAclCommand"),
    Ukr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [dGr]: [
            () => (0, p.isSerializableHeaderValue)(e[nd]),
            () => e[nd].toString(),
          ],
          [mGr]: e[Lp],
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
          [or]: e[nr],
          [te]: e[ee],
          [fGr]: [
            () => (0, p.isSerializableHeaderValue)(e[q7e]),
            () => (e[q7e] || []).map(p.quoteHeader).join(", "),
          ],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [QHr]: [, ""], [Qo]: [, e[dt]] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetObjectAttributesCommand"),
    Hkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [or]: e[nr],
          [te]: e[ee],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [yet]: [, ""], [Qo]: [, e[dt]] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetObjectLegalHoldCommand"),
    Gkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Cet]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetObjectLockConfigurationCommand"),
    Vkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [or]: e[nr],
          [te]: e[ee],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [Net]: [, ""], [Qo]: [, e[dt]] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetObjectRetentionCommand"),
    $kr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [te]: e[ee],
          [or]: e[nr],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [tS]: [, ""], [Qo]: [, e[dt]] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetObjectTaggingCommand"),
    zkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [or]: e[nr],
          [te]: e[ee],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [f3r]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetObjectTorrentCommand"),
    Kkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [kre]: [, ""] });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_GetPublicAccessBlockCommand"),
    Wkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      return (
        r.bp("/"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r
          .m("HEAD")
          .h(n)
          .b(void 0),
        r.build()
      );
    }, "se_HeadBucketCommand"),
    Qkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [QT]: e[HT],
          [het]: [
            () => (0, p.isSerializableHeaderValue)(e[jH]),
            () => (0, p.dateToUtcString)(e[jH]).toString(),
          ],
          [o3]: e[JH],
          [get]: [
            () => (0, p.isSerializableHeaderValue)(e[FH]),
            () => (0, p.dateToUtcString)(e[FH]).toString(),
          ],
          [Oet]: e[ZZe],
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
          [or]: e[nr],
          [te]: e[ee],
          [qet]: e[DZe],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({
        [Tet]: [, e[eet]],
        [Aet]: [, e[tet]],
        [Pet]: [, e[ret]],
        [Ret]: [, e[net]],
        [Iet]: [, e[iet]],
        [xet]: [
          () => e.ResponseExpires !== void 0,
          () => (0, p.dateToUtcString)(e[oet]).toString(),
        ],
        [Qo]: [, e[dt]],
        [c3]: [() => e.PartNumber !== void 0, () => e[$o].toString()],
      });
      return (
        r
          .m("HEAD")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_HeadObjectCommand"),
    Ykr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [ZH]: [, ""],
        [di]: [, "ListBucketAnalyticsConfigurations"],
        [Ug]: [, e[sr]],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListBucketAnalyticsConfigurationsCommand"),
    Xkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = {};
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [a3]: [, ""],
        [di]: [, "ListBucketIntelligentTieringConfigurations"],
        [Ug]: [, e[sr]],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListBucketIntelligentTieringConfigurationsCommand"),
    Jkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [i3]: [, ""],
        [di]: [, "ListBucketInventoryConfigurations"],
        [Ug]: [, e[sr]],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListBucketInventoryConfigurationsCommand"),
    Zkr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, { [te]: e[ee] });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [s3]: [, ""],
        [di]: [, "ListBucketMetricsConfigurations"],
        [Ug]: [, e[sr]],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListBucketMetricsConfigurationsCommand"),
    eDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = {};
      r.bp("/");
      let i = (0, p.map)({
        [di]: [, "ListBuckets"],
        [t3r]: [() => e.MaxBuckets !== void 0, () => e[zUr].toString()],
        [Ug]: [, e[sr]],
        [YT]: [, e[re]],
        [YHr]: [, e[qT]],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListBucketsCommand"),
    tDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = {};
      r.bp("/");
      let i = (0, p.map)({
        [di]: [, "ListDirectoryBuckets"],
        [Ug]: [, e[sr]],
        [r3r]: [
          () => e.MaxDirectoryBuckets !== void 0,
          () => e[WUr].toString(),
        ],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListDirectoryBucketsCommand"),
    rDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [te]: e[ee],
          [or]: e[nr],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [ket]: [, ""],
        [t3]: [, e[Yi]],
        [r3]: [, e[Xi]],
        [vet]: [, e[Dp]],
        [i3r]: [() => e.MaxUploads !== void 0, () => e[fH].toString()],
        [YT]: [, e[re]],
        [p3r]: [, e[xH]],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListMultipartUploadsCommand"),
    nDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [or]: e[nr],
          [te]: e[ee],
          [Bre]: [
            () => (0, p.isSerializableHeaderValue)(e[jb]),
            () => (e[jb] || []).map(p.quoteHeader).join(", "),
          ],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [t3]: [, e[Yi]],
        [r3]: [, e[Xi]],
        [e3r]: [, e[lH]],
        [Ire]: [() => e.MaxKeys !== void 0, () => e[vs].toString()],
        [YT]: [, e[re]],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListObjectsCommand"),
    iDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [or]: e[nr],
          [te]: e[ee],
          [Bre]: [
            () => (0, p.isSerializableHeaderValue)(e[jb]),
            () => (e[jb] || []).map(p.quoteHeader).join(", "),
          ],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [ZHr]: [, "2"],
        [t3]: [, e[Yi]],
        [r3]: [, e[Xi]],
        [Ire]: [() => e.MaxKeys !== void 0, () => e[vs].toString()],
        [YT]: [, e[re]],
        [Ug]: [, e[sr]],
        [JHr]: [() => e.FetchOwner !== void 0, () => e[pUr].toString()],
        [u3r]: [, e[CH]],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListObjectsV2Command"),
    oDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [te]: e[ee],
          [or]: e[nr],
          [Bre]: [
            () => (0, p.isSerializableHeaderValue)(e[jb]),
            () => (e[jb] || []).map(p.quoteHeader).join(", "),
          ],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
        [m3r]: [, ""],
        [t3]: [, e[Yi]],
        [r3]: [, e[Xi]],
        [vet]: [, e[Dp]],
        [Ire]: [() => e.MaxKeys !== void 0, () => e[vs].toString()],
        [YT]: [, e[re]],
        [h3r]: [, e[kH]],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListObjectVersionsCommand"),
    aDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [or]: e[nr],
          [te]: e[ee],
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({
        [di]: [, "ListParts"],
        [n3r]: [() => e.MaxParts !== void 0, () => e[nd].toString()],
        [a3r]: [, e[Lp]],
        [XT]: [, (0, p.expectNonNull)(e[Wo], "UploadId")],
      });
      return (
        r
          .m("GET")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_ListPartsCommand"),
    sDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [te]: e[ee],
          [on]: e[lt],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [det]: [, ""] }),
        o,
        a;
      return (
        e.AccelerateConfiguration !== void 0 &&
          ((a = WMr(e.AccelerateConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketAccelerateConfigurationCommand"),
    cDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [rS]: e[Vb],
          [qn]: e[Mn],
          [on]: e[lt],
          [iS]: e[Yb],
          [oS]: e[Xb],
          [aS]: e[Jb],
          [jre]: e[yre],
          [sS]: e[Zb],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [e3]: [, ""] }),
        o,
        a;
      return (
        e.AccessControlPolicy !== void 0 &&
          ((a = mZe(e.AccessControlPolicy, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketAclCommand"),
    uDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
          [ZH]: [, ""],
          [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
        }),
        o,
        a;
      return (
        e.AnalyticsConfiguration !== void 0 &&
          ((a = eqr(e.AnalyticsConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketAnalyticsConfigurationCommand"),
    lDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Tre]: [, ""] }),
        o,
        a;
      return (
        e.CORSConfiguration !== void 0 &&
          ((a = dqr(e.CORSConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketCorsCommand"),
    dDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Are]: [, ""] }),
        o,
        a;
      return (
        e.ServerSideEncryptionConfiguration !== void 0 &&
          ((a = $jr(e.ServerSideEncryptionConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketEncryptionCommand"),
    fDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = { "content-type": "application/xml" };
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
          [a3]: [, ""],
          [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
        }),
        o,
        a;
      return (
        e.IntelligentTieringConfiguration !== void 0 &&
          ((a = kqr(e.IntelligentTieringConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketIntelligentTieringConfigurationCommand"),
    pDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
          [i3]: [, ""],
          [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
        }),
        o,
        a;
      return (
        e.InventoryConfiguration !== void 0 &&
          ((a = Lqr(e.InventoryConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketInventoryConfigurationCommand"),
    mDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [on]: e[lt],
          [te]: e[ee],
          [Hre]: e[Ore],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Pre]: [, ""] }),
        o,
        a;
      return (
        e.LifecycleConfiguration !== void 0 &&
          ((a = oqr(e.LifecycleConfiguration, t)),
          (a = a.n("LifecycleConfiguration")),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketLifecycleConfigurationCommand"),
    hDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Eet]: [, ""] }),
        o,
        a;
      return (
        e.BucketLoggingStatus !== void 0 &&
          ((a = aqr(e.BucketLoggingStatus, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketLoggingCommand"),
    gDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({
          [s3]: [, ""],
          [Os]: [, (0, p.expectNonNull)(e[je], "Id")],
        }),
        o,
        a;
      return (
        e.MetricsConfiguration !== void 0 &&
          ((a = njr(e.MetricsConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketMetricsConfigurationCommand"),
    vDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [te]: e[ee],
          [yGr]: [
            () => (0, p.isSerializableHeaderValue)(e[B7e]),
            () => e[B7e].toString(),
          ],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [bet]: [, ""] }),
        o,
        a;
      return (
        e.NotificationConfiguration !== void 0 &&
          ((a = cjr(e.NotificationConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketNotificationConfigurationCommand"),
    yDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [xre]: [, ""] }),
        o,
        a;
      return (
        e.OwnershipControls !== void 0 &&
          ((a = vjr(e.OwnershipControls, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketOwnershipControlsCommand"),
    _Dr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "text/plain",
          [qn]: e[Mn],
          [on]: e[lt],
          [b3r]: [
            () => (0, p.isSerializableHeaderValue)(e[A7e]),
            () => e[A7e].toString(),
          ],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Nre]: [, ""] }),
        o,
        a;
      return (
        e.Policy !== void 0 && ((a = e.Policy), (o = a)),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketPolicyCommand"),
    EDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [Met]: e[cet],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Dre]: [, ""] }),
        o,
        a;
      return (
        e.ReplicationConfiguration !== void 0 &&
          ((a = Pjr(e.ReplicationConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketReplicationCommand"),
    bDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [wet]: [, ""] }),
        o,
        a;
      return (
        e.RequestPaymentConfiguration !== void 0 &&
          ((a = Djr(e.RequestPaymentConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketRequestPaymentCommand"),
    SDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [tS]: [, ""] }),
        o,
        a;
      return (
        e.Tagging !== void 0 &&
          ((a = pre(e.Tagging, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketTaggingCommand"),
    CDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [Fre]: e[_re],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Det]: [, ""] }),
        o,
        a;
      return (
        e.VersioningConfiguration !== void 0 &&
          ((a = dFr(e.VersioningConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketVersioningCommand"),
    wDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Lre]: [, ""] }),
        o,
        a;
      return (
        e.WebsiteConfiguration !== void 0 &&
          ((a = fFr(e.WebsiteConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutBucketWebsiteCommand"),
    ODr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [WT]: e[Qb] || "application/octet-stream",
          [rS]: e[Vb],
          [VT]: e[$b],
          [$T]: e[zb],
          [zT]: e[Kb],
          [KT]: e[Wb],
          [Mg]: [
            () => (0, p.isSerializableHeaderValue)(e[qp]),
            () => e[qp].toString(),
          ],
          [qn]: e[Mn],
          [on]: e[lt],
          [Hg]: e[_r],
          [Gg]: e[Er],
          [Vg]: e[br],
          [$g]: e[Sr],
          [zg]: e[Cr],
          [qg]: [
            () => (0, p.isSerializableHeaderValue)(e[Du]),
            () => (0, p.dateToUtcString)(e[Du]).toString(),
          ],
          [QT]: e[HT],
          [o3]: e[JH],
          [iS]: e[Yb],
          [oS]: e[Xb],
          [aS]: e[Jb],
          [sS]: e[Zb],
          [EGr]: [
            () => (0, p.isSerializableHeaderValue)(e[$7e]),
            () => e[$7e].toString(),
          ],
          [_a]: e[Ji],
          [tA]: e[st],
          [rA]: e[GT],
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
          [Ea]: e[Li],
          [Up]: e[Bp],
          [fn]: [
            () => (0, p.isSerializableHeaderValue)(e[xr]),
            () => e[xr].toString(),
          ],
          [or]: e[nr],
          [Ure]: e[kg],
          [eA]: e[eS],
          [jg]: [
            () => (0, p.isSerializableHeaderValue)(e[Lu]),
            () => (0, p.serializeDateTime)(e[Lu]).toString(),
          ],
          [ZT]: e[Bg],
          [te]: e[ee],
          ...(e.Metadata !== void 0 &&
            Object.keys(e.Metadata).reduce(
              (s, u) => (
                (s[`x-amz-meta-${u.toLowerCase()}`] = e.Metadata[u]), s
              ),
              {},
            )),
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [di]: [, "PutObject"] }),
        o,
        a;
      return (
        e.Body !== void 0 && ((a = e.Body), (o = a)),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutObjectCommand"),
    TDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [rS]: e[Vb],
          [qn]: e[Mn],
          [on]: e[lt],
          [iS]: e[Yb],
          [oS]: e[Xb],
          [aS]: e[Jb],
          [jre]: e[yre],
          [sS]: e[Zb],
          [or]: e[nr],
          [te]: e[ee],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [e3]: [, ""], [Qo]: [, e[dt]] }),
        o,
        a;
      return (
        e.AccessControlPolicy !== void 0 &&
          ((a = mZe(e.AccessControlPolicy, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutObjectAclCommand"),
    ADr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [or]: e[nr],
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [yet]: [, ""], [Qo]: [, e[dt]] }),
        o,
        a;
      return (
        e.LegalHold !== void 0 &&
          ((a = fjr(e.LegalHold, t)),
          (a = a.n("LegalHold")),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutObjectLegalHoldCommand"),
    PDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [or]: e[nr],
          [Met]: e[cet],
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [Cet]: [, ""] }),
        o,
        a;
      return (
        e.ObjectLockConfiguration !== void 0 &&
          ((a = djr(e.ObjectLockConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutObjectLockConfigurationCommand"),
    RDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [or]: e[nr],
          [Mre]: [
            () => (0, p.isSerializableHeaderValue)(e[qb]),
            () => e[qb].toString(),
          ],
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [Net]: [, ""], [Qo]: [, e[dt]] }),
        o,
        a;
      return (
        e.Retention !== void 0 &&
          ((a = pjr(e.Retention, t)),
          (a = a.n("Retention")),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutObjectRetentionCommand"),
    IDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
          [or]: e[nr],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [tS]: [, ""], [Qo]: [, e[dt]] }),
        o,
        a;
      return (
        e.Tagging !== void 0 &&
          ((a = pre(e.Tagging, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutObjectTaggingCommand"),
    xDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [qn]: e[Mn],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
      let i = (0, p.map)({ [kre]: [, ""] }),
        o,
        a;
      return (
        e.PublicAccessBlockConfiguration !== void 0 &&
          ((a = Sjr(e.PublicAccessBlockConfiguration, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_PutPublicAccessBlockCommand"),
    NDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [or]: e[nr],
          [on]: e[lt],
          [te]: e[ee],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [s3r]: [, ""], [Qo]: [, e[dt]] }),
        o,
        a;
      return (
        e.RestoreRequest !== void 0 &&
          ((a = Mjr(e.RestoreRequest, t)),
          (o = ir),
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          (o += a.toString())),
        r.m("POST").h(n).q(i).b(o),
        r.build()
      );
    }, "se_RestoreObjectCommand"),
    kDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/xml",
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
          [te]: e[ee],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({ [l3r]: [, ""], [d3r]: [, "2"] }),
        o;
      o = ir;
      let a = new R.XmlNode(qHr);
      return (
        a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
        a.cc(e, $Ze),
        a.cc(e, VZe),
        e[yg] != null && a.c(vZe(e[yg], t).n(yg)),
        e[Cg] != null && a.c(yZe(e[Cg], t).n(Cg)),
        e[bH] != null && a.c(Ljr(e[bH], t).n(bH)),
        e[OH] != null && a.c(Hjr(e[OH], t).n(OH)),
        (o += a.toString()),
        r.m("POST").h(n).q(i).b(o),
        r.build()
      );
    }, "se_SelectObjectContentCommand"),
    DDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "content-type": "application/octet-stream",
          [Mg]: [
            () => (0, p.isSerializableHeaderValue)(e[qp]),
            () => e[qp].toString(),
          ],
          [qn]: e[Mn],
          [on]: e[lt],
          [Hg]: e[_r],
          [Gg]: e[Er],
          [Vg]: e[br],
          [$g]: e[Sr],
          [zg]: e[Cr],
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
          [or]: e[nr],
          [te]: e[ee],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({
          [di]: [, "UploadPart"],
          [c3]: [
            (0, p.expectNonNull)(e.PartNumber, "PartNumber") != null,
            () => e[$o].toString(),
          ],
          [XT]: [, (0, p.expectNonNull)(e[Wo], "UploadId")],
        }),
        o,
        a;
      return (
        e.Body !== void 0 && ((a = e.Body), (o = a)),
        r.m("PUT").h(n).q(i).b(o),
        r.build()
      );
    }, "se_UploadPartCommand"),
    LDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          [jet]: e[LZe],
          [Fet]: e[MZe],
          [Bet]: [
            () => (0, p.isSerializableHeaderValue)(e[MH]),
            () => (0, p.dateToUtcString)(e[MH]).toString(),
          ],
          [Uet]: e[qZe],
          [Het]: [
            () => (0, p.isSerializableHeaderValue)(e[qH]),
            () => (0, p.dateToUtcString)(e[qH]).toString(),
          ],
          [C3r]: e[eUr],
          [ui]: e[zn],
          [fc]: e[dc],
          [li]: e[Kn],
          [Get]: e[jZe],
          [Vet]: e[FZe],
          [$et]: e[BZe],
          [or]: e[nr],
          [te]: e[ee],
          [Qet]: e[GZe],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let i = (0, p.map)({
        [di]: [, "UploadPartCopy"],
        [c3]: [
          (0, p.expectNonNull)(e.PartNumber, "PartNumber") != null,
          () => e[$o].toString(),
        ],
        [XT]: [, (0, p.expectNonNull)(e[Wo], "UploadId")],
      });
      return (
        r
          .m("PUT")
          .h(n)
          .q(i)
          .b(void 0),
        r.build()
      );
    }, "se_UploadPartCopyCommand"),
    MDr = v(async (e, t) => {
      let r = (0, X.requestBuilder)(e, t),
        n = (0, p.map)({}, p.isSerializableHeaderValue, {
          "x-amz-content-sha256": "UNSIGNED-PAYLOAD",
          "content-type": "application/octet-stream",
          [gGr]: e[bHr],
          [vGr]: e[PHr],
          [oGr]: [
            () => (0, p.isSerializableHeaderValue)(e[F7e]),
            () => e[F7e].toString(),
          ],
          [w3r]: e[nH],
          [O3r]: e[iH],
          [T3r]: e[gre],
          [A3r]: e[$b],
          [P3r]: e[zb],
          [R3r]: e[Kb],
          [I3r]: e[Wb],
          [Mg]: [
            () => (0, p.isSerializableHeaderValue)(e[qp]),
            () => e[qp].toString(),
          ],
          [x3r]: e[vre],
          [N3r]: e[Qb],
          [M3r]: e[_r],
          [q3r]: e[Er],
          [j3r]: e[br],
          [F3r]: e[Sr],
          [B3r]: e[Cr],
          [U3r]: [
            () => (0, p.isSerializableHeaderValue)(e[uc]),
            () => e[uc].toString(),
          ],
          [k3r]: e[cr],
          [D3r]: [
            () => (0, p.isSerializableHeaderValue)(e[Du]),
            () => (0, p.dateToUtcString)(e[Du]).toString(),
          ],
          [H3r]: e[uo],
          [L3r]: [
            () => (0, p.isSerializableHeaderValue)(e[nn]),
            () => (0, p.dateToUtcString)(e[nn]).toString(),
          ],
          [G3r]: [
            () => (0, p.isSerializableHeaderValue)(e[BH]),
            () => e[BH].toString(),
          ],
          [z3r]: e[eS],
          [$3r]: e[Bg],
          [K3r]: [
            () => (0, p.isSerializableHeaderValue)(e[Lu]),
            () => (0, p.serializeDateTime)(e[Lu]).toString(),
          ],
          [V3r]: [
            () => (0, p.isSerializableHeaderValue)(e[Fb]),
            () => e[Fb].toString(),
          ],
          [Y3r]: e[Cre],
          [Q3r]: e[Dr],
          [W3r]: e[wre],
          [J3r]: e[Ji],
          [tGr]: e[zn],
          [Z3r]: e[Li],
          [rGr]: e[Kn],
          [X3r]: e[st],
          [nGr]: [
            () => (0, p.isSerializableHeaderValue)(e[rre]),
            () => e[rre].toString(),
          ],
          [iGr]: e[dt],
          [eGr]: [
            () => (0, p.isSerializableHeaderValue)(e[xr]),
            () => e[xr].toString(),
          ],
          ...(e.Metadata !== void 0 &&
            Object.keys(e.Metadata).reduce(
              (s, u) => (
                (s[`x-amz-meta-${u.toLowerCase()}`] = e.Metadata[u]), s
              ),
              {},
            )),
        });
      r.bp("/WriteGetObjectResponse");
      let i, o;
      e.Body !== void 0 && ((o = e.Body), (i = o));
      let { hostname: a } = await t.endpoint();
      if (t.disableHostPrefix !== !0) {
        if (((a = "{RequestRoute}." + a), e.RequestRoute === void 0))
          throw new Error(
            "Empty value provided for input host prefix: RequestRoute.",
          );
        if (
          ((a = a.replace("{RequestRoute}", e.RequestRoute)),
          !(0, Tte.isValidHostname)(a))
        )
          throw new Error(
            "ValidationError: prefixed hostname must be hostname compatible.",
          );
      }
      return r.hn(a), r.m("POST").h(n).b(i), r.build();
    }, "se_WriteGetObjectResponseCommand"),
    qDr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_AbortMultipartUploadCommand"),
    jDr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
          $metadata: V(e),
          [uo]: [, e.headers[JT]],
          [Ji]: [, e.headers[_a]],
          [dt]: [, e.headers[Mu]],
          [Li]: [, e.headers[Ea]],
          [xr]: [
            () => e.headers[fn] !== void 0,
            () => (0, p.parseBoolean)(e.headers[fn]),
          ],
          [Dr]: [, e.headers[Fr]],
        }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[_t] != null && (r[_t] = (0, p.expectString)(n[_t])),
        n[_r] != null && (r[_r] = (0, p.expectString)(n[_r])),
        n[Er] != null && (r[Er] = (0, p.expectString)(n[Er])),
        n[br] != null && (r[br] = (0, p.expectString)(n[br])),
        n[Sr] != null && (r[Sr] = (0, p.expectString)(n[Sr])),
        n[Cr] != null && (r[Cr] = (0, p.expectString)(n[Cr])),
        n[wr] != null && (r[wr] = (0, p.expectString)(n[wr])),
        n[cr] != null && (r[cr] = (0, p.expectString)(n[cr])),
        n[ze] != null && (r[ze] = (0, p.expectString)(n[ze])),
        n[_g] != null && (r[_g] = (0, p.expectString)(n[_g])),
        r
      );
    }, "de_CompleteMultipartUploadCommand"),
    FDr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
          $metadata: V(e),
          [uo]: [, e.headers[JT]],
          [UZe]: [, e.headers[zet]],
          [dt]: [, e.headers[Mu]],
          [Ji]: [, e.headers[_a]],
          [zn]: [, e.headers[ui]],
          [Kn]: [, e.headers[li]],
          [Li]: [, e.headers[Ea]],
          [Bp]: [, e.headers[Up]],
          [xr]: [
            () => e.headers[fn] !== void 0,
            () => (0, p.parseBoolean)(e.headers[fn]),
          ],
          [Dr]: [, e.headers[Fr]],
        }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.CopyObjectResult = PFr(n, t)), r;
    }, "de_CopyObjectCommand"),
    BDr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [_g]: [, e.headers[_et]] });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_CreateBucketCommand"),
    UDr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_CreateBucketMetadataTableConfigurationCommand"),
    HDr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
          $metadata: V(e),
          [NZe]: [
            () => e.headers[$H] !== void 0,
            () =>
              (0, p.expectNonNull)((0, p.parseRfc7231DateTime)(e.headers[$H])),
          ],
          [kZe]: [, e.headers[Let]],
          [Ji]: [, e.headers[_a]],
          [zn]: [, e.headers[ui]],
          [Kn]: [, e.headers[li]],
          [Li]: [, e.headers[Ea]],
          [Bp]: [, e.headers[Up]],
          [xr]: [
            () => e.headers[fn] !== void 0,
            () => (0, p.parseBoolean)(e.headers[fn]),
          ],
          [Dr]: [, e.headers[Fr]],
          [lt]: [, e.headers[qre]],
          [wr]: [, e.headers[nS]],
        }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[_t] != null && (r[_t] = (0, p.expectString)(n[_t])),
        n[ze] != null && (r[ze] = (0, p.expectString)(n[ze])),
        n[Wo] != null && (r[Wo] = (0, p.expectString)(n[Wo])),
        r
      );
    }, "de_CreateMultipartUploadCommand"),
    GDr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
          $metadata: V(e),
          [Ji]: [, e.headers[_a]],
          [Li]: [, e.headers[Ea]],
          [Bp]: [, e.headers[Up]],
          [xr]: [
            () => e.headers[fn] !== void 0,
            () => (0, p.parseBoolean)(e.headers[fn]),
          ],
        }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return n[Jee] != null && (r[Jee] = dBr(n[Jee], t)), r;
    }, "de_CreateSessionCommand"),
    VDr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketCommand"),
    $Dr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketAnalyticsConfigurationCommand"),
    zDr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketCorsCommand"),
    KDr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketEncryptionCommand"),
    WDr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketIntelligentTieringConfigurationCommand"),
    QDr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketInventoryConfigurationCommand"),
    YDr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketLifecycleCommand"),
    XDr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketMetadataTableConfigurationCommand"),
    JDr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketMetricsConfigurationCommand"),
    ZDr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketOwnershipControlsCommand"),
    eLr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketPolicyCommand"),
    tLr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketReplicationCommand"),
    rLr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketTaggingCommand"),
    nLr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteBucketWebsiteCommand"),
    iLr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
        $metadata: V(e),
        [uc]: [
          () => e.headers[jp] !== void 0,
          () => (0, p.parseBoolean)(e.headers[jp]),
        ],
        [dt]: [, e.headers[Mu]],
        [Dr]: [, e.headers[Fr]],
      });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteObjectCommand"),
    oLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.Deleted === ""
          ? (r[YU] = [])
          : n[YU] != null &&
            (r[YU] = DFr((0, p.getArrayIfSingleItem)(n[YU]), t)),
        n.Error === ""
          ? (r[R7e] = [])
          : n[jT] != null &&
            (r[R7e] = VFr((0, p.getArrayIfSingleItem)(n[jT]), t)),
        r
      );
    }, "de_DeleteObjectsCommand"),
    aLr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [dt]: [, e.headers[Mu]] });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeleteObjectTaggingCommand"),
    sLr = v(async (e, t) => {
      if (e.statusCode !== 204 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_DeletePublicAccessBlockCommand"),
    cLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return n[ge] != null && (r[ge] = (0, p.expectString)(n[ge])), r;
    }, "de_GetBucketAccelerateConfigurationCommand"),
    uLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.AccessControlList === ""
          ? (r[BT] = [])
          : n[sg] != null &&
            n[sg][od] != null &&
            (r[BT] = wZe((0, p.getArrayIfSingleItem)(n[sg][od]), t)),
        n[Nt] != null && (r[Nt] = Fp(n[Nt], t)),
        r
      );
    }, "de_GetBucketAclCommand"),
    lLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.AnalyticsConfiguration = EZe(n, t)), r;
    }, "de_GetBucketAnalyticsConfigurationCommand"),
    dLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.CORSRule === ""
          ? (r[qte] = [])
          : n[Mte] != null &&
            (r[qte] = xFr((0, p.getArrayIfSingleItem)(n[Mte]), t)),
        r
      );
    }, "de_GetBucketCorsCommand"),
    fLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.ServerSideEncryptionConfiguration = cBr(n, t)), r;
    }, "de_GetBucketEncryptionCommand"),
    pLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.IntelligentTieringConfiguration = TZe(n, t)), r;
    }, "de_GetBucketIntelligentTieringConfigurationCommand"),
    mLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.InventoryConfiguration = AZe(n, t)), r;
    }, "de_GetBucketInventoryConfigurationCommand"),
    hLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Ore]: [, e.headers[Hre]] }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.Rule === ""
          ? (r[ws] = [])
          : n[zo] != null &&
            (r[ws] = g1r((0, p.getArrayIfSingleItem)(n[zo]), t)),
        r
      );
    }, "de_GetBucketLifecycleConfigurationCommand"),
    gLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return n[Ob] != null && (r[Ob] = (0, p.expectString)(n[Ob])), r;
    }, "de_GetBucketLocationCommand"),
    vLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return n[Eg] != null && (r[Eg] = v1r(n[Eg], t)), r;
    }, "de_GetBucketLoggingCommand"),
    yLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.GetBucketMetadataTableConfigurationResult = YFr(n, t)), r;
    }, "de_GetBucketMetadataTableConfigurationCommand"),
    _Lr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.MetricsConfiguration = PZe(n, t)), r;
    }, "de_GetBucketMetricsConfigurationCommand"),
    ELr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[pg] != null && (r[pg] = $Fr(n[pg], t)),
        n.CloudFunctionConfiguration === ""
          ? (r[$te] = [])
          : n[T7e] != null &&
            (r[$te] = d1r((0, p.getArrayIfSingleItem)(n[T7e]), t)),
        n.QueueConfiguration === ""
          ? (r[Xte] = [])
          : n[Yte] != null &&
            (r[Xte] = K1r((0, p.getArrayIfSingleItem)(n[Yte]), t)),
        n.TopicConfiguration === ""
          ? (r[ire] = [])
          : n[nre] != null &&
            (r[ire] = TBr((0, p.getArrayIfSingleItem)(n[nre]), t)),
        r
      );
    }, "de_GetBucketNotificationConfigurationCommand"),
    bLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.OwnershipControls = M1r(n, t)), r;
    }, "de_GetBucketOwnershipControlsCommand"),
    SLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = await RBr(e.body, t);
      return (r.Policy = (0, p.expectString)(n)), r;
    }, "de_GetBucketPolicyCommand"),
    CLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.PolicyStatus = G1r(n, t)), r;
    }, "de_GetBucketPolicyStatusCommand"),
    wLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.ReplicationConfiguration = X1r(n, t)), r;
    }, "de_GetBucketReplicationCommand"),
    OLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return n[gH] != null && (r[gH] = (0, p.expectString)(n[gH])), r;
    }, "de_GetBucketRequestPaymentCommand"),
    TLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.TagSet === ""
          ? (r[cc] = [])
          : n[cc] != null &&
            n[cc][rt] != null &&
            (r[cc] = Fg((0, p.getArrayIfSingleItem)(n[cc][rt]), t)),
        r
      );
    }, "de_GetBucketTaggingCommand"),
    ALr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[Kte] != null && (r[dH] = (0, p.expectString)(n[Kte])),
        n[ge] != null && (r[ge] = (0, p.expectString)(n[ge])),
        r
      );
    }, "de_GetBucketVersioningCommand"),
    PLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[hg] != null && (r[hg] = GFr(n[hg], t)),
        n[vg] != null && (r[vg] = ZFr(n[vg], t)),
        n[Og] != null && (r[Og] = Q1r(n[Og], t)),
        n.RoutingRules === ""
          ? (r[nb] = [])
          : n[nb] != null &&
            n[nb][HH] != null &&
            (r[nb] = iBr((0, p.getArrayIfSingleItem)(n[nb][HH]), t)),
        r
      );
    }, "de_GetBucketWebsiteCommand"),
    RLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
          $metadata: V(e),
          [uc]: [
            () => e.headers[jp] !== void 0,
            () => (0, p.parseBoolean)(e.headers[jp]),
          ],
          [gre]: [, e.headers[fet]],
          [uo]: [, e.headers[JT]],
          [wre]: [, e.headers[Ket]],
          [nn]: [
            () => e.headers[Bb] !== void 0,
            () =>
              (0, p.expectNonNull)((0, p.parseRfc7231DateTime)(e.headers[Bb])),
          ],
          [qp]: [
            () => e.headers[Mg] !== void 0,
            () => (0, p.strictParseLong)(e.headers[Mg]),
          ],
          [cr]: [, e.headers[n3]],
          [_r]: [, e.headers[Hg]],
          [Er]: [, e.headers[Gg]],
          [br]: [, e.headers[Vg]],
          [Sr]: [, e.headers[$g]],
          [Cr]: [, e.headers[zg]],
          [wr]: [, e.headers[nS]],
          [BH]: [
            () => e.headers[zH] !== void 0,
            () => (0, p.strictParseInt32)(e.headers[zH]),
          ],
          [dt]: [, e.headers[Mu]],
          [$b]: [, e.headers[VT]],
          [zb]: [, e.headers[$T]],
          [Kb]: [, e.headers[zT]],
          [Wb]: [, e.headers[KT]],
          [vre]: [, e.headers[pet]],
          [Qb]: [, e.headers[WT]],
          [Du]: [
            () => e.headers[qg] !== void 0,
            () =>
              (0, p.expectNonNull)((0, p.parseRfc7231DateTime)(e.headers[qg])),
          ],
          [HZe]: [, e.headers[met]],
          [GT]: [, e.headers[rA]],
          [Ji]: [, e.headers[_a]],
          [zn]: [, e.headers[ui]],
          [Kn]: [, e.headers[li]],
          [Li]: [, e.headers[Ea]],
          [xr]: [
            () => e.headers[fn] !== void 0,
            () => (0, p.parseBoolean)(e.headers[fn]),
          ],
          [st]: [, e.headers[tA]],
          [Dr]: [, e.headers[Fr]],
          [Cre]: [, e.headers[Wet]],
          [Fb]: [
            () => e.headers[KH] !== void 0,
            () => (0, p.strictParseInt32)(e.headers[KH]),
          ],
          [rre]: [
            () => e.headers[Q7e] !== void 0,
            () => (0, p.strictParseInt32)(e.headers[Q7e]),
          ],
          [eS]: [, e.headers[eA]],
          [Lu]: [
            () => e.headers[jg] !== void 0,
            () =>
              (0, p.expectNonNull)(
                (0, p.parseRfc3339DateTimeWithOffset)(e.headers[jg]),
              ),
          ],
          [Bg]: [, e.headers[ZT]],
          Metadata: [
            ,
            Object.keys(e.headers)
              .filter((i) => i.startsWith("x-amz-meta-"))
              .reduce((i, o) => ((i[o.substring(11)] = e.headers[o]), i), {}),
          ],
        }),
        n = e.body;
      return t.sdkStreamMixin(n), (r.Body = n), r;
    }, "de_GetObjectCommand"),
    ILr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.AccessControlList === ""
          ? (r[BT] = [])
          : n[sg] != null &&
            n[sg][od] != null &&
            (r[BT] = wZe((0, p.getArrayIfSingleItem)(n[sg][od]), t)),
        n[Nt] != null && (r[Nt] = Fp(n[Nt], t)),
        r
      );
    }, "de_GetObjectAclCommand"),
    xLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
          $metadata: V(e),
          [uc]: [
            () => e.headers[jp] !== void 0,
            () => (0, p.parseBoolean)(e.headers[jp]),
          ],
          [nn]: [
            () => e.headers[Bb] !== void 0,
            () =>
              (0, p.expectNonNull)((0, p.parseRfc7231DateTime)(e.headers[Bb])),
          ],
          [dt]: [, e.headers[Mu]],
          [Dr]: [, e.headers[Fr]],
        }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[tte] != null && (r[tte] = wFr(n[tte], t)),
        n[cr] != null && (r[cr] = (0, p.expectString)(n[cr])),
        n[gte] != null && (r[gte] = XFr(n[gte], t)),
        n[vte] != null && (r[vte] = (0, p.strictParseLong)(n[vte])),
        n[st] != null && (r[st] = (0, p.expectString)(n[st])),
        r
      );
    }, "de_GetObjectAttributesCommand"),
    NLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.LegalHold = I1r(n, t)), r;
    }, "de_GetObjectLegalHoldCommand"),
    kLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.ObjectLockConfiguration = R1r(n, t)), r;
    }, "de_GetObjectLockConfigurationCommand"),
    DLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.Retention = x1r(n, t)), r;
    }, "de_GetObjectRetentionCommand"),
    LLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [dt]: [, e.headers[Mu]] }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.TagSet === ""
          ? (r[cc] = [])
          : n[cc] != null &&
            n[cc][rt] != null &&
            (r[cc] = Fg((0, p.getArrayIfSingleItem)(n[cc][rt]), t)),
        r
      );
    }, "de_GetObjectTaggingCommand"),
    MLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] }),
        n = e.body;
      return t.sdkStreamMixin(n), (r.Body = n), r;
    }, "de_GetObjectTorrentCommand"),
    qLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.PublicAccessBlockConfiguration = $1r(n, t)), r;
    }, "de_GetPublicAccessBlockCommand"),
    jLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
        $metadata: V(e),
        [KBr]: [, e.headers[y3r]],
        [VBr]: [, e.headers[v3r]],
        [qT]: [, e.headers[E3r]],
        [MBr]: [
          () => e.headers[K7e] !== void 0,
          () => (0, p.parseBoolean)(e.headers[K7e]),
        ],
      });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_HeadBucketCommand"),
    FLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
        $metadata: V(e),
        [uc]: [
          () => e.headers[jp] !== void 0,
          () => (0, p.parseBoolean)(e.headers[jp]),
        ],
        [gre]: [, e.headers[fet]],
        [uo]: [, e.headers[JT]],
        [wre]: [, e.headers[Ket]],
        [qBr]: [, e.headers[g3r]],
        [nn]: [
          () => e.headers[Bb] !== void 0,
          () =>
            (0, p.expectNonNull)((0, p.parseRfc7231DateTime)(e.headers[Bb])),
        ],
        [qp]: [
          () => e.headers[Mg] !== void 0,
          () => (0, p.strictParseLong)(e.headers[Mg]),
        ],
        [_r]: [, e.headers[Hg]],
        [Er]: [, e.headers[Gg]],
        [br]: [, e.headers[Vg]],
        [Sr]: [, e.headers[$g]],
        [Cr]: [, e.headers[zg]],
        [wr]: [, e.headers[nS]],
        [cr]: [, e.headers[n3]],
        [BH]: [
          () => e.headers[zH] !== void 0,
          () => (0, p.strictParseInt32)(e.headers[zH]),
        ],
        [dt]: [, e.headers[Mu]],
        [$b]: [, e.headers[VT]],
        [zb]: [, e.headers[$T]],
        [Kb]: [, e.headers[zT]],
        [Wb]: [, e.headers[KT]],
        [Qb]: [, e.headers[WT]],
        [vre]: [, e.headers[pet]],
        [Du]: [
          () => e.headers[qg] !== void 0,
          () =>
            (0, p.expectNonNull)((0, p.parseRfc7231DateTime)(e.headers[qg])),
        ],
        [HZe]: [, e.headers[met]],
        [GT]: [, e.headers[rA]],
        [Ji]: [, e.headers[_a]],
        [zn]: [, e.headers[ui]],
        [Kn]: [, e.headers[li]],
        [Li]: [, e.headers[Ea]],
        [xr]: [
          () => e.headers[fn] !== void 0,
          () => (0, p.parseBoolean)(e.headers[fn]),
        ],
        [st]: [, e.headers[tA]],
        [Dr]: [, e.headers[Fr]],
        [Cre]: [, e.headers[Wet]],
        [Fb]: [
          () => e.headers[KH] !== void 0,
          () => (0, p.strictParseInt32)(e.headers[KH]),
        ],
        [eS]: [, e.headers[eA]],
        [Lu]: [
          () => e.headers[jg] !== void 0,
          () =>
            (0, p.expectNonNull)(
              (0, p.parseRfc3339DateTimeWithOffset)(e.headers[jg]),
            ),
        ],
        [Bg]: [, e.headers[ZT]],
        Metadata: [
          ,
          Object.keys(e.headers)
            .filter((n) => n.startsWith("x-amz-meta-"))
            .reduce((n, i) => ((n[i.substring(11)] = e.headers[i]), n), {}),
        ],
      });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_HeadObjectCommand"),
    BLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.AnalyticsConfiguration === ""
          ? (r[O7e] = [])
          : n[Pte] != null &&
            (r[O7e] = _Fr((0, p.getArrayIfSingleItem)(n[Pte]), t)),
        n[sr] != null && (r[sr] = (0, p.expectString)(n[sr])),
        n[Xt] != null && (r[Xt] = (0, p.parseBoolean)(n[Xt])),
        n[lo] != null && (r[lo] = (0, p.expectString)(n[lo])),
        r
      );
    }, "de_ListBucketAnalyticsConfigurationsCommand"),
    ULr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[sr] != null && (r[sr] = (0, p.expectString)(n[sr])),
        n.IntelligentTieringConfiguration === ""
          ? (r[D7e] = [])
          : n[Vte] != null &&
            (r[D7e] = t1r((0, p.getArrayIfSingleItem)(n[Vte]), t)),
        n[Xt] != null && (r[Xt] = (0, p.parseBoolean)(n[Xt])),
        n[lo] != null && (r[lo] = (0, p.expectString)(n[lo])),
        r
      );
    }, "de_ListBucketIntelligentTieringConfigurationsCommand"),
    HLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[sr] != null && (r[sr] = (0, p.expectString)(n[sr])),
        n.InventoryConfiguration === ""
          ? (r[I7e] = [])
          : n[Gte] != null &&
            (r[I7e] = n1r((0, p.getArrayIfSingleItem)(n[Gte]), t)),
        n[Xt] != null && (r[Xt] = (0, p.parseBoolean)(n[Xt])),
        n[lo] != null && (r[lo] = (0, p.expectString)(n[lo])),
        r
      );
    }, "de_ListBucketInventoryConfigurationsCommand"),
    GLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[sr] != null && (r[sr] = (0, p.expectString)(n[sr])),
        n[Xt] != null && (r[Xt] = (0, p.parseBoolean)(n[Xt])),
        n.MetricsConfiguration === ""
          ? (r[L7e] = [])
          : n[zte] != null &&
            (r[L7e] = b1r((0, p.getArrayIfSingleItem)(n[zte]), t)),
        n[lo] != null && (r[lo] = (0, p.expectString)(n[lo])),
        r
      );
    }, "de_ListBucketMetricsConfigurationsCommand"),
    VLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.Buckets === ""
          ? (r[xu] = [])
          : n[xu] != null &&
            n[xu][_t] != null &&
            (r[xu] = bZe((0, p.getArrayIfSingleItem)(n[xu][_t]), t)),
        n[sr] != null && (r[sr] = (0, p.expectString)(n[sr])),
        n[Nt] != null && (r[Nt] = Fp(n[Nt], t)),
        n[re] != null && (r[re] = (0, p.expectString)(n[re])),
        r
      );
    }, "de_ListBucketsCommand"),
    $Lr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.Buckets === ""
          ? (r[xu] = [])
          : n[xu] != null &&
            n[xu][_t] != null &&
            (r[xu] = bZe((0, p.getArrayIfSingleItem)(n[xu][_t]), t)),
        n[sr] != null && (r[sr] = (0, p.expectString)(n[sr])),
        r
      );
    }, "de_ListDirectoryBucketsCommand"),
    zLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[_t] != null && (r[_t] = (0, p.expectString)(n[_t])),
        n.CommonPrefixes === ""
          ? (r[Qi] = [])
          : n[Qi] != null &&
            (r[Qi] = YH((0, p.getArrayIfSingleItem)(n[Qi]), t)),
        n[Yi] != null && (r[Yi] = (0, p.expectString)(n[Yi])),
        n[Xi] != null && (r[Xi] = (0, p.expectString)(n[Xi])),
        n[Xt] != null && (r[Xt] = (0, p.parseBoolean)(n[Xt])),
        n[Dp] != null && (r[Dp] = (0, p.expectString)(n[Dp])),
        n[fH] != null && (r[fH] = (0, p.strictParseInt32)(n[fH])),
        n[Tb] != null && (r[Tb] = (0, p.expectString)(n[Tb])),
        n[mte] != null && (r[mte] = (0, p.expectString)(n[mte])),
        n[re] != null && (r[re] = (0, p.expectString)(n[re])),
        n[xH] != null && (r[xH] = (0, p.expectString)(n[xH])),
        n.Upload === ""
          ? (r[H7e] = [])
          : n[U7e] != null &&
            (r[H7e] = w1r((0, p.getArrayIfSingleItem)(n[U7e]), t)),
        r
      );
    }, "de_ListMultipartUploadsCommand"),
    KLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.CommonPrefixes === ""
          ? (r[Qi] = [])
          : n[Qi] != null &&
            (r[Qi] = YH((0, p.getArrayIfSingleItem)(n[Qi]), t)),
        n.Contents === ""
          ? (r[Np] = [])
          : n[Np] != null &&
            (r[Np] = RZe((0, p.getArrayIfSingleItem)(n[Np]), t)),
        n[Yi] != null && (r[Yi] = (0, p.expectString)(n[Yi])),
        n[Xi] != null && (r[Xi] = (0, p.expectString)(n[Xi])),
        n[Xt] != null && (r[Xt] = (0, p.parseBoolean)(n[Xt])),
        n[lH] != null && (r[lH] = (0, p.expectString)(n[lH])),
        n[vs] != null && (r[vs] = (0, p.strictParseInt32)(n[vs])),
        n[Qr] != null && (r[Qr] = (0, p.expectString)(n[Qr])),
        n[pte] != null && (r[pte] = (0, p.expectString)(n[pte])),
        n[re] != null && (r[re] = (0, p.expectString)(n[re])),
        r
      );
    }, "de_ListObjectsCommand"),
    WLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.CommonPrefixes === ""
          ? (r[Qi] = [])
          : n[Qi] != null &&
            (r[Qi] = YH((0, p.getArrayIfSingleItem)(n[Qi]), t)),
        n.Contents === ""
          ? (r[Np] = [])
          : n[Np] != null &&
            (r[Np] = RZe((0, p.getArrayIfSingleItem)(n[Np]), t)),
        n[sr] != null && (r[sr] = (0, p.expectString)(n[sr])),
        n[Yi] != null && (r[Yi] = (0, p.expectString)(n[Yi])),
        n[Xi] != null && (r[Xi] = (0, p.expectString)(n[Xi])),
        n[Xt] != null && (r[Xt] = (0, p.parseBoolean)(n[Xt])),
        n[ute] != null && (r[ute] = (0, p.strictParseInt32)(n[ute])),
        n[vs] != null && (r[vs] = (0, p.strictParseInt32)(n[vs])),
        n[Qr] != null && (r[Qr] = (0, p.expectString)(n[Qr])),
        n[lo] != null && (r[lo] = (0, p.expectString)(n[lo])),
        n[re] != null && (r[re] = (0, p.expectString)(n[re])),
        n[CH] != null && (r[CH] = (0, p.expectString)(n[CH])),
        r
      );
    }, "de_ListObjectsV2Command"),
    QLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n.CommonPrefixes === ""
          ? (r[Qi] = [])
          : n[Qi] != null &&
            (r[Qi] = YH((0, p.getArrayIfSingleItem)(n[Qi]), t)),
        n.DeleteMarker === ""
          ? (r[P7e] = [])
          : n[uc] != null &&
            (r[P7e] = qFr((0, p.getArrayIfSingleItem)(n[uc]), t)),
        n[Yi] != null && (r[Yi] = (0, p.expectString)(n[Yi])),
        n[Xi] != null && (r[Xi] = (0, p.expectString)(n[Xi])),
        n[Xt] != null && (r[Xt] = (0, p.parseBoolean)(n[Xt])),
        n[Dp] != null && (r[Dp] = (0, p.expectString)(n[Dp])),
        n[vs] != null && (r[vs] = (0, p.strictParseInt32)(n[vs])),
        n[Qr] != null && (r[Qr] = (0, p.expectString)(n[Qr])),
        n[Tb] != null && (r[Tb] = (0, p.expectString)(n[Tb])),
        n[hte] != null && (r[hte] = (0, p.expectString)(n[hte])),
        n[re] != null && (r[re] = (0, p.expectString)(n[re])),
        n[kH] != null && (r[kH] = (0, p.expectString)(n[kH])),
        n.Version === ""
          ? (r[V7e] = [])
          : n[G7e] != null &&
            (r[V7e] = L1r((0, p.getArrayIfSingleItem)(n[G7e]), t)),
        r
      );
    }, "de_ListObjectVersionsCommand"),
    YLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
          $metadata: V(e),
          [NZe]: [
            () => e.headers[$H] !== void 0,
            () =>
              (0, p.expectNonNull)((0, p.parseRfc7231DateTime)(e.headers[$H])),
          ],
          [kZe]: [, e.headers[Let]],
          [Dr]: [, e.headers[Fr]],
        }),
        n = (0, p.expectNonNull)(
          (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t)),
          "body",
        );
      return (
        n[_t] != null && (r[_t] = (0, p.expectString)(n[_t])),
        n[lt] != null && (r[lt] = (0, p.expectString)(n[lt])),
        n[wr] != null && (r[wr] = (0, p.expectString)(n[wr])),
        n[bb] != null && (r[bb] = OZe(n[bb], t)),
        n[Xt] != null && (r[Xt] = (0, p.parseBoolean)(n[Xt])),
        n[ze] != null && (r[ze] = (0, p.expectString)(n[ze])),
        n[nd] != null && (r[nd] = (0, p.strictParseInt32)(n[nd])),
        n[Ab] != null && (r[Ab] = (0, p.expectString)(n[Ab])),
        n[Nt] != null && (r[Nt] = Fp(n[Nt], t)),
        n[Lp] != null && (r[Lp] = (0, p.expectString)(n[Lp])),
        n.Part === ""
          ? (r[UT] = [])
          : n[UH] != null &&
            (r[UT] = U1r((0, p.getArrayIfSingleItem)(n[UH]), t)),
        n[st] != null && (r[st] = (0, p.expectString)(n[st])),
        n[Wo] != null && (r[Wo] = (0, p.expectString)(n[Wo])),
        r
      );
    }, "de_ListPartsCommand"),
    XLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketAccelerateConfigurationCommand"),
    JLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketAclCommand"),
    ZLr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketAnalyticsConfigurationCommand"),
    eMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketCorsCommand"),
    tMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketEncryptionCommand"),
    rMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketIntelligentTieringConfigurationCommand"),
    nMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketInventoryConfigurationCommand"),
    iMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Ore]: [, e.headers[Hre]] });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketLifecycleConfigurationCommand"),
    oMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketLoggingCommand"),
    aMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketMetricsConfigurationCommand"),
    sMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketNotificationConfigurationCommand"),
    cMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketOwnershipControlsCommand"),
    uMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketPolicyCommand"),
    lMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketReplicationCommand"),
    dMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketRequestPaymentCommand"),
    fMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketTaggingCommand"),
    pMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketVersioningCommand"),
    mMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutBucketWebsiteCommand"),
    hMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
        $metadata: V(e),
        [uo]: [, e.headers[JT]],
        [cr]: [, e.headers[n3]],
        [_r]: [, e.headers[Hg]],
        [Er]: [, e.headers[Gg]],
        [br]: [, e.headers[Vg]],
        [Sr]: [, e.headers[$g]],
        [Cr]: [, e.headers[zg]],
        [wr]: [, e.headers[nS]],
        [Ji]: [, e.headers[_a]],
        [dt]: [, e.headers[Mu]],
        [zn]: [, e.headers[ui]],
        [Kn]: [, e.headers[li]],
        [Li]: [, e.headers[Ea]],
        [Bp]: [, e.headers[Up]],
        [xr]: [
          () => e.headers[fn] !== void 0,
          () => (0, p.parseBoolean)(e.headers[fn]),
        ],
        [Di]: [
          () => e.headers[W7e] !== void 0,
          () => (0, p.strictParseLong)(e.headers[W7e]),
        ],
        [Dr]: [, e.headers[Fr]],
      });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutObjectCommand"),
    gMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutObjectAclCommand"),
    vMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutObjectLegalHoldCommand"),
    yMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutObjectLockConfigurationCommand"),
    _Mr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [Dr]: [, e.headers[Fr]] });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutObjectRetentionCommand"),
    EMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e), [dt]: [, e.headers[Mu]] });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutObjectTaggingCommand"),
    bMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_PutPublicAccessBlockCommand"),
    SMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
        $metadata: V(e),
        [Dr]: [, e.headers[Fr]],
        [_Hr]: [, e.headers[hGr]],
      });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_RestoreObjectCommand"),
    CMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) }),
        n = e.body;
      return (r.Payload = UMr(n, t)), r;
    }, "de_SelectObjectContentCommand"),
    wMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
        $metadata: V(e),
        [Ji]: [, e.headers[_a]],
        [cr]: [, e.headers[n3]],
        [_r]: [, e.headers[Hg]],
        [Er]: [, e.headers[Gg]],
        [br]: [, e.headers[Vg]],
        [Sr]: [, e.headers[$g]],
        [Cr]: [, e.headers[zg]],
        [zn]: [, e.headers[ui]],
        [Kn]: [, e.headers[li]],
        [Li]: [, e.headers[Ea]],
        [xr]: [
          () => e.headers[fn] !== void 0,
          () => (0, p.parseBoolean)(e.headers[fn]),
        ],
        [Dr]: [, e.headers[Fr]],
      });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_UploadPartCommand"),
    OMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({
          $metadata: V(e),
          [UZe]: [, e.headers[zet]],
          [Ji]: [, e.headers[_a]],
          [zn]: [, e.headers[ui]],
          [Kn]: [, e.headers[li]],
          [Li]: [, e.headers[Ea]],
          [xr]: [
            () => e.headers[fn] !== void 0,
            () => (0, p.parseBoolean)(e.headers[fn]),
          ],
          [Dr]: [, e.headers[Fr]],
        }),
        n = (0, p.expectObject)(await (0, Be.parseXmlBody)(e.body, t));
      return (r.CopyPartResult = RFr(n, t)), r;
    }, "de_UploadPartCopyCommand"),
    TMr = v(async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return J(e, t);
      let r = (0, p.map)({ $metadata: V(e) });
      return await (0, p.collectBody)(e.body, t), r;
    }, "de_WriteGetObjectResponseCommand"),
    J = v(async (e, t) => {
      let r = { ...e, body: await (0, Be.parseXmlErrorBody)(e.body, t) },
        n = (0, Be.loadRestXmlErrorCode)(e, r.body);
      switch (n) {
        case "NoSuchUpload":
        case "com.amazonaws.s3#NoSuchUpload":
          throw await MMr(r, t);
        case "ObjectNotInActiveTierError":
        case "com.amazonaws.s3#ObjectNotInActiveTierError":
          throw await FMr(r, t);
        case "BucketAlreadyExists":
        case "com.amazonaws.s3#BucketAlreadyExists":
          throw await PMr(r, t);
        case "BucketAlreadyOwnedByYou":
        case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
          throw await RMr(r, t);
        case "NoSuchBucket":
        case "com.amazonaws.s3#NoSuchBucket":
          throw await DMr(r, t);
        case "InvalidObjectState":
        case "com.amazonaws.s3#InvalidObjectState":
          throw await xMr(r, t);
        case "NoSuchKey":
        case "com.amazonaws.s3#NoSuchKey":
          throw await LMr(r, t);
        case "NotFound":
        case "com.amazonaws.s3#NotFound":
          throw await qMr(r, t);
        case "EncryptionTypeMismatch":
        case "com.amazonaws.s3#EncryptionTypeMismatch":
          throw await IMr(r, t);
        case "InvalidRequest":
        case "com.amazonaws.s3#InvalidRequest":
          throw await NMr(r, t);
        case "InvalidWriteOffset":
        case "com.amazonaws.s3#InvalidWriteOffset":
          throw await kMr(r, t);
        case "TooManyParts":
        case "com.amazonaws.s3#TooManyParts":
          throw await BMr(r, t);
        case "ObjectAlreadyInActiveTierError":
        case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
          throw await jMr(r, t);
        default:
          let i = r.body;
          return AMr({ output: e, parsedBody: i, errorCode: n });
      }
    }, "de_CommandError"),
    AMr = (0, p.withBaseException)(po),
    PMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new oJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_BucketAlreadyExistsRes"),
    RMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new sJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_BucketAlreadyOwnedByYouRes"),
    IMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new HJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_EncryptionTypeMismatchRes"),
    xMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body;
      n[rd] != null && (r[rd] = (0, p.expectString)(n[rd])),
        n[st] != null && (r[st] = (0, p.expectString)(n[st]));
      let i = new dJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_InvalidObjectStateRes"),
    NMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new VJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_InvalidRequestRes"),
    kMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new zJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_InvalidWriteOffsetRes"),
    DMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new uJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_NoSuchBucketRes"),
    LMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new pJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_NoSuchKeyRes"),
    MMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new tJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_NoSuchUploadRes"),
    qMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new hJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_NotFoundRes"),
    jMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new YJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_ObjectAlreadyInActiveTierErrorRes"),
    FMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new nJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_ObjectNotInActiveTierErrorRes"),
    BMr = v(async (e, t) => {
      let r = (0, p.map)({}),
        n = e.body,
        i = new WJe({ $metadata: V(e), ...r });
      return (0, p.decorateServiceException)(i, e.body);
    }, "de_TooManyPartsRes"),
    UMr = v(
      (e, t) =>
        t.eventStreamMarshaller.deserialize(e, async (r) =>
          r.Records != null
            ? { Records: await $Mr(r.Records, t) }
            : r.Stats != null
              ? { Stats: await zMr(r.Stats, t) }
              : r.Progress != null
                ? { Progress: await VMr(r.Progress, t) }
                : r.Cont != null
                  ? { Cont: await HMr(r.Cont, t) }
                  : r.End != null
                    ? { End: await GMr(r.End, t) }
                    : { $unknown: e },
        ),
      "de_SelectObjectContentEventStream",
    ),
    HMr = v(async (e, t) => {
      let r = {},
        n = await (0, Be.parseXmlBody)(e.body, t);
      return Object.assign(r, AFr(n, t)), r;
    }, "de_ContinuationEvent_event"),
    GMr = v(async (e, t) => {
      let r = {},
        n = await (0, Be.parseXmlBody)(e.body, t);
      return Object.assign(r, BFr(n, t)), r;
    }, "de_EndEvent_event"),
    VMr = v(async (e, t) => {
      let r = {},
        n = await (0, Be.parseXmlBody)(e.body, t);
      return (r.Details = V1r(n, t)), r;
    }, "de_ProgressEvent_event"),
    $Mr = v(async (e, t) => {
      let r = {};
      return (r.Payload = e.body), r;
    }, "de_RecordsEvent_event"),
    zMr = v(async (e, t) => {
      let r = {},
        n = await (0, Be.parseXmlBody)(e.body, t);
      return (r.Details = vBr(n, t)), r;
    }, "de_StatsEvent_event"),
    KMr = v((e, t) => {
      let r = new R.XmlNode(ug);
      return e[eg] != null && r.c(R.XmlNode.of(eg, String(e[eg])).n(eg)), r;
    }, "se_AbortIncompleteMultipartUpload"),
    WMr = v((e, t) => {
      let r = new R.XmlNode(NBr);
      return e[ge] != null && r.c(R.XmlNode.of(BBr, e[ge]).n(ge)), r;
    }, "se_AccelerateConfiguration"),
    mZe = v((e, t) => {
      let r = new R.XmlNode(xBr);
      return (
        r.lc(e, "Grants", "AccessControlList", () => gZe(e[BT], t)),
        e[Nt] != null && r.c(gjr(e[Nt], t).n(Nt)),
        r
      );
    }, "se_AccessControlPolicy"),
    QMr = v((e, t) => {
      let r = new R.XmlNode(cg);
      return e[Nt] != null && r.c(R.XmlNode.of(dHr, e[Nt]).n(Nt)), r;
    }, "se_AccessControlTranslation"),
    YMr = v(
      (e, t) =>
        e.filter((r) => r != null).map((r) => R.XmlNode.of(Rte, r).n(Wn)),
      "se_AllowedHeaders",
    ),
    XMr = v(
      (e, t) =>
        e.filter((r) => r != null).map((r) => R.XmlNode.of(xte, r).n(Wn)),
      "se_AllowedMethods",
    ),
    JMr = v(
      (e, t) =>
        e.filter((r) => r != null).map((r) => R.XmlNode.of(kte, r).n(Wn)),
      "se_AllowedOrigins",
    ),
    ZMr = v((e, t) => {
      let r = new R.XmlNode(IBr);
      return r.cc(e, re), r.l(e, "Tags", "Tag", () => Hb(e[fo], t)), r;
    }, "se_AnalyticsAndOperator"),
    eqr = v((e, t) => {
      let r = new R.XmlNode(Pte);
      return (
        e[je] != null && r.c(R.XmlNode.of(LBr, e[je]).n(je)),
        e[qe] != null && r.c(rqr(e[qe], t).n(qe)),
        e[Rg] != null && r.c(Zjr(e[Rg], t).n(Rg)),
        r
      );
    }, "se_AnalyticsConfiguration"),
    tqr = v((e, t) => {
      let r = new R.XmlNode(kBr);
      return e[Cs] != null && r.c(nqr(e[Cs], t).n(Cs)), r;
    }, "se_AnalyticsExportDestination"),
    rqr = v((e, t) => {
      let r = new R.XmlNode(DBr);
      return (
        DH.visit(e, {
          Prefix: v((n) => {
            e[re] != null && r.c(R.XmlNode.of(re, n).n(re));
          }, "Prefix"),
          Tag: v((n) => {
            e[rt] != null && r.c(Ub(n, t).n(rt));
          }, "Tag"),
          And: v((n) => {
            e[Nr] != null && r.c(ZMr(n, t).n(Nr));
          }, "And"),
          _: v((n, i) => {
            if (!(i instanceof R.XmlNode || i instanceof R.XmlText))
              throw new Error(
                "Unable to serialize unknown union members in XML.",
              );
            r.c(new R.XmlNode(n).c(i));
          }, "_"),
        }),
        r
      );
    }, "se_AnalyticsFilter"),
    nqr = v((e, t) => {
      let r = new R.XmlNode(jBr);
      return (
        e[gs] != null && r.c(R.XmlNode.of(FBr, e[gs]).n(gs)),
        e[cb] != null && r.c(R.XmlNode.of(ob, e[cb]).n(cb)),
        e[_t] != null && r.c(R.XmlNode.of(XH, e[_t]).n(_t)),
        r.cc(e, re),
        r
      );
    }, "se_AnalyticsS3BucketDestination"),
    iqr = v((e, t) => {
      let r = new R.XmlNode(UBr);
      return (
        r.cc(e, aUr), e[Ko] != null && r.c(R.XmlNode.of(WBr, e[Ko]).n(Ko)), r
      );
    }, "se_BucketInfo"),
    oqr = v((e, t) => {
      let r = new R.XmlNode(HBr);
      return r.l(e, "Rules", "Rule", () => Yqr(e[ws], t)), r;
    }, "se_BucketLifecycleConfiguration"),
    aqr = v((e, t) => {
      let r = new R.XmlNode(zBr);
      return e[Eg] != null && r.c(Jqr(e[Eg], t).n(Eg)), r;
    }, "se_BucketLoggingStatus"),
    sqr = v((e, t) => {
      let r = new R.XmlNode(XBr);
      return r.l(e, "Parts", "Part", () => uqr(e[UT], t)), r;
    }, "se_CompletedMultipartUpload"),
    cqr = v((e, t) => {
      let r = new R.XmlNode(ZBr);
      return (
        r.cc(e, cr),
        r.cc(e, _r),
        r.cc(e, Er),
        r.cc(e, br),
        r.cc(e, Sr),
        r.cc(e, Cr),
        e[$o] != null && r.c(R.XmlNode.of($o, String(e[$o])).n($o)),
        r
      );
    }, "se_CompletedPart"),
    uqr = v(
      (e, t) => e.filter((r) => r != null).map((r) => cqr(r, t).n(Wn)),
      "se_CompletedPartList",
    ),
    lqr = v((e, t) => {
      let r = new R.XmlNode(lg);
      return r.cc(e, aH), r.cc(e, cH), r;
    }, "se_Condition"),
    dqr = v((e, t) => {
      let r = new R.XmlNode(JBr);
      return r.l(e, "CORSRules", "CORSRule", () => pqr(e[qte], t)), r;
    }, "se_CORSConfiguration"),
    fqr = v((e, t) => {
      let r = new R.XmlNode(Mte);
      return (
        r.cc(e, rn),
        r.l(e, "AllowedHeaders", "AllowedHeader", () => YMr(e[Ite], t)),
        r.l(e, "AllowedMethods", "AllowedMethod", () => XMr(e[Nte], t)),
        r.l(e, "AllowedOrigins", "AllowedOrigin", () => JMr(e[Dte], t)),
        r.l(e, "ExposeHeaders", "ExposeHeader", () => Tqr(e[jte], t)),
        e[ng] != null && r.c(R.XmlNode.of(ng, String(e[ng])).n(ng)),
        r
      );
    }, "se_CORSRule"),
    pqr = v(
      (e, t) => e.filter((r) => r != null).map((r) => fqr(r, t).n(Wn)),
      "se_CORSRules",
    ),
    mqr = v((e, t) => {
      let r = new R.XmlNode(YBr);
      return (
        e[Ob] != null && r.c(R.XmlNode.of(GBr, e[Ob]).n(Ob)),
        e[_g] != null && r.c(Xqr(e[_g], t).n(_g)),
        e[_t] != null && r.c(iqr(e[_t], t).n(_t)),
        r
      );
    }, "se_CreateBucketConfiguration"),
    hqr = v((e, t) => {
      let r = new R.XmlNode(tUr);
      return (
        r.cc(e, fUr),
        r.cc(e, iUr),
        r.cc(e, JZe),
        r.cc(e, Sre),
        r.cc(e, zZe),
        r.cc(e, XZe),
        e[QU] != null && r.c(R.XmlNode.of(QU, String(e[QU])).n(QU)),
        r
      );
    }, "se_CSVInput"),
    gqr = v((e, t) => {
      let r = new R.XmlNode(rUr);
      return (
        r.cc(e, gHr), r.cc(e, JZe), r.cc(e, Sre), r.cc(e, zZe), r.cc(e, XZe), r
      );
    }, "se_CSVOutput"),
    vqr = v((e, t) => {
      let r = new R.XmlNode(fg);
      return (
        e[ys] != null && r.c(R.XmlNode.of(WZe, e[ys]).n(ys)),
        e[Dt] != null && r.c(R.XmlNode.of(Dt, String(e[Dt])).n(Dt)),
        e[ag] != null && r.c(R.XmlNode.of(ag, String(e[ag])).n(ag)),
        r
      );
    }, "se_DefaultRetention"),
    yqr = v((e, t) => {
      let r = new R.XmlNode(sUr);
      return (
        r.l(e, "Objects", "Object", () => ljr(e[pHr], t)),
        e[ZU] != null && r.c(R.XmlNode.of(ZU, String(e[ZU])).n(ZU)),
        r
      );
    }, "se_Delete"),
    _qr = v((e, t) => {
      let r = new R.XmlNode(dg);
      return e[ge] != null && r.c(R.XmlNode.of(oUr, e[ge]).n(ge)), r;
    }, "se_DeleteMarkerReplication"),
    Eqr = v((e, t) => {
      let r = new R.XmlNode($n);
      return (
        e[_t] != null && r.c(R.XmlNode.of(XH, e[_t]).n(_t)),
        e[sb] != null && r.c(R.XmlNode.of(ob, e[sb]).n(sb)),
        r.cc(e, st),
        e[cg] != null && r.c(QMr(e[cg], t).n(cg)),
        e[mg] != null && r.c(Sqr(e[mg], t).n(mg)),
        e[Ag] != null && r.c(kjr(e[Ag], t).n(Ag)),
        e[bg] != null && r.c(tjr(e[bg], t).n(bg)),
        r
      );
    }, "se_Destination"),
    bqr = v((e, t) => {
      let r = new R.XmlNode(Nu);
      return (
        e[ite] != null && r.c(R.XmlNode.of(Ji, e[ite]).n(ite)),
        e[lte] != null && r.c(R.XmlNode.of(Li, e[lte]).n(lte)),
        r.cc(e, LUr),
        r
      );
    }, "se_Encryption"),
    Sqr = v((e, t) => {
      let r = new R.XmlNode(mg);
      return r.cc(e, yH), r;
    }, "se_EncryptionConfiguration"),
    Cqr = v((e, t) => {
      let r = new R.XmlNode(hg);
      return e[ze] != null && r.c(R.XmlNode.of(bre, e[ze]).n(ze)), r;
    }, "se_ErrorDocument"),
    wqr = v((e, t) => new R.XmlNode(pg), "se_EventBridgeConfiguration"),
    dre = v(
      (e, t) =>
        e.filter((r) => r != null).map((r) => R.XmlNode.of(Lg, r).n(Wn)),
      "se_EventList",
    ),
    Oqr = v((e, t) => {
      let r = new R.XmlNode(gg);
      return e[ge] != null && r.c(R.XmlNode.of(uUr, e[ge]).n(ge)), r;
    }, "se_ExistingObjectReplication"),
    Tqr = v(
      (e, t) =>
        e.filter((r) => r != null).map((r) => R.XmlNode.of(Fte, r).n(Wn)),
      "se_ExposeHeaders",
    ),
    Aqr = v((e, t) => {
      let r = new R.XmlNode(Bte);
      return (
        e[Qr] != null && r.c(R.XmlNode.of(mUr, e[Qr]).n(Qr)),
        e[ya] != null && r.c(R.XmlNode.of(hUr, e[ya]).n(ya)),
        r
      );
    }, "se_FilterRule"),
    Pqr = v(
      (e, t) => e.filter((r) => r != null).map((r) => Aqr(r, t).n(Wn)),
      "se_FilterRuleList",
    ),
    Rqr = v((e, t) => {
      let r = new R.XmlNode(oH);
      return r.cc(e, set), r;
    }, "se_GlacierJobParameters"),
    Iqr = v((e, t) => {
      let r = new R.XmlNode(od);
      if (e[va] != null) {
        let n = hZe(e[va], t).n(va);
        n.a("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"), r.c(n);
      }
      return r.cc(e, ku), r;
    }, "se_Grant"),
    hZe = v((e, t) => {
      let r = new R.XmlNode(va);
      return (
        r.cc(e, lc),
        r.cc(e, rH),
        r.cc(e, rn),
        r.cc(e, NH),
        r.a("xsi:type", e[Ko]),
        r
      );
    }, "se_Grantee"),
    gZe = v(
      (e, t) => e.filter((r) => r != null).map((r) => Iqr(r, t).n(od)),
      "se_Grants",
    ),
    xqr = v((e, t) => {
      let r = new R.XmlNode(vg);
      return r.cc(e, AH), r;
    }, "se_IndexDocument"),
    vZe = v((e, t) => {
      let r = new R.XmlNode(yg);
      return (
        e[mb] != null && r.c(hqr(e[mb], t).n(mb)),
        r.cc(e, nUr),
        e[Sb] != null && r.c(Hqr(e[Sb], t).n(Sb)),
        e[yte] != null && r.c(Ejr(e[yte], t).n(yte)),
        r
      );
    }, "se_InputSerialization"),
    Nqr = v((e, t) => {
      let r = new R.XmlNode(TUr);
      return r.cc(e, re), r.l(e, "Tags", "Tag", () => Hb(e[fo], t)), r;
    }, "se_IntelligentTieringAndOperator"),
    kqr = v((e, t) => {
      let r = new R.XmlNode(Vte);
      return (
        e[je] != null && r.c(R.XmlNode.of(IUr, e[je]).n(je)),
        e[qe] != null && r.c(Dqr(e[qe], t).n(qe)),
        e[ge] != null && r.c(R.XmlNode.of(xUr, e[ge]).n(ge)),
        r.l(e, "Tierings", "Tiering", () => oFr(e[ore], t)),
        r
      );
    }, "se_IntelligentTieringConfiguration"),
    Dqr = v((e, t) => {
      let r = new R.XmlNode(RUr);
      return (
        r.cc(e, re),
        e[rt] != null && r.c(Ub(e[rt], t).n(rt)),
        e[Nr] != null && r.c(Nqr(e[Nr], t).n(Nr)),
        r
      );
    }, "se_IntelligentTieringFilter"),
    Lqr = v((e, t) => {
      let r = new R.XmlNode(Gte);
      return (
        e[$n] != null && r.c(Mqr(e[$n], t).n($n)),
        e[rg] != null && r.c(R.XmlNode.of(rg, String(e[rg])).n(rg)),
        e[qe] != null && r.c(jqr(e[qe], t).n(qe)),
        e[je] != null && r.c(R.XmlNode.of(bUr, e[je]).n(je)),
        e[_b] != null && r.c(R.XmlNode.of(SUr, e[_b]).n(_b)),
        r.lc(e, "OptionalFields", "OptionalFields", () => Fqr(e[rb], t)),
        e[kb] != null && r.c(Uqr(e[kb], t).n(kb)),
        r
      );
    }, "se_InventoryConfiguration"),
    Mqr = v((e, t) => {
      let r = new R.XmlNode(gUr);
      return e[Cs] != null && r.c(Bqr(e[Cs], t).n(Cs)), r;
    }, "se_InventoryDestination"),
    qqr = v((e, t) => {
      let r = new R.XmlNode(vUr);
      return (
        e[tre] != null && r.c(Jjr(e[tre], t).n(VH)),
        e[ere] != null && r.c(Yjr(e[ere], t).n(GH)),
        r
      );
    }, "se_InventoryEncryption"),
    jqr = v((e, t) => {
      let r = new R.XmlNode(yUr);
      return r.cc(e, re), r;
    }, "se_InventoryFilter"),
    Fqr = v(
      (e, t) =>
        e.filter((r) => r != null).map((r) => R.XmlNode.of(CUr, r).n(Hte)),
      "se_InventoryOptionalFields",
    ),
    Bqr = v((e, t) => {
      let r = new R.XmlNode(wUr);
      return (
        r.cc(e, ob),
        e[_t] != null && r.c(R.XmlNode.of(XH, e[_t]).n(_t)),
        e[gs] != null && r.c(R.XmlNode.of(_Ur, e[gs]).n(gs)),
        r.cc(e, re),
        e[Nu] != null && r.c(qqr(e[Nu], t).n(Nu)),
        r
      );
    }, "se_InventoryS3BucketDestination"),
    Uqr = v((e, t) => {
      let r = new R.XmlNode(OUr);
      return e[vb] != null && r.c(R.XmlNode.of(EUr, e[vb]).n(vb)), r;
    }, "se_InventorySchedule"),
    Hqr = v((e, t) => {
      let r = new R.XmlNode(NUr);
      return e[Ko] != null && r.c(R.XmlNode.of(DUr, e[Ko]).n(Ko)), r;
    }, "se_JSONInput"),
    Gqr = v((e, t) => {
      let r = new R.XmlNode(kUr);
      return r.cc(e, Sre), r;
    }, "se_JSONOutput"),
    Vqr = v((e, t) => {
      let r = new R.XmlNode(qUr);
      return (
        e[je] != null && r.c(R.XmlNode.of(Ere, e[je]).n(je)),
        e[uH] != null && r.c(R.XmlNode.of(uH, e[uH]).n(Lte)),
        r.l(e, "Events", "Event", () => dre(e[id], t)),
        e[qe] != null && r.c(fre(e[qe], t).n(qe)),
        r
      );
    }, "se_LambdaFunctionConfiguration"),
    $qr = v(
      (e, t) => e.filter((r) => r != null).map((r) => Vqr(r, t).n(Wn)),
      "se_LambdaFunctionConfigurationList",
    ),
    zqr = v((e, t) => {
      let r = new R.XmlNode(MUr);
      return (
        e[co] != null &&
          r.c(
            R.XmlNode.of(co, (0, p.serializeDateTime)(e[co]).toString()).n(co),
          ),
        e[Dt] != null && r.c(R.XmlNode.of(Dt, String(e[Dt])).n(Dt)),
        e[tg] != null && r.c(R.XmlNode.of(tg, String(e[tg])).n(tg)),
        r
      );
    }, "se_LifecycleExpiration"),
    Kqr = v((e, t) => {
      let r = new R.XmlNode(UUr);
      return (
        e[uo] != null && r.c(zqr(e[uo], t).n(uo)),
        r.cc(e, rn),
        r.cc(e, re),
        e[qe] != null && r.c(Qqr(e[qe], t).n(qe)),
        e[ge] != null && r.c(R.XmlNode.of(dUr, e[ge]).n(ge)),
        r.l(e, "Transitions", "Transition", () => uFr(e[cre], t)),
        r.l(
          e,
          "NoncurrentVersionTransitions",
          "NoncurrentVersionTransition",
          () => sjr(e[Wte], t),
        ),
        e[Sg] != null && r.c(ojr(e[Sg], t).n(Sg)),
        e[ug] != null && r.c(KMr(e[ug], t).n(ug)),
        r
      );
    }, "se_LifecycleRule"),
    Wqr = v((e, t) => {
      let r = new R.XmlNode(HUr);
      return (
        r.cc(e, re),
        r.l(e, "Tags", "Tag", () => Hb(e[fo], t)),
        e[bs] != null && r.c(R.XmlNode.of(QZe, String(e[bs])).n(bs)),
        e[Ss] != null && r.c(R.XmlNode.of(YZe, String(e[Ss])).n(Ss)),
        r
      );
    }, "se_LifecycleRuleAndOperator"),
    Qqr = v((e, t) => {
      let r = new R.XmlNode(GUr);
      return (
        r.cc(e, re),
        e[rt] != null && r.c(Ub(e[rt], t).n(rt)),
        e[bs] != null && r.c(R.XmlNode.of(QZe, String(e[bs])).n(bs)),
        e[Ss] != null && r.c(R.XmlNode.of(YZe, String(e[Ss])).n(Ss)),
        e[Nr] != null && r.c(Wqr(e[Nr], t).n(Nr)),
        r
      );
    }, "se_LifecycleRuleFilter"),
    Yqr = v(
      (e, t) => e.filter((r) => r != null).map((r) => Kqr(r, t).n(Wn)),
      "se_LifecycleRules",
    ),
    Xqr = v((e, t) => {
      let r = new R.XmlNode(jUr);
      return (
        e[Ko] != null && r.c(R.XmlNode.of(VUr, e[Ko]).n(Ko)),
        e[Qr] != null && r.c(R.XmlNode.of(FUr, e[Qr]).n(Qr)),
        r
      );
    }, "se_LocationInfo"),
    Jqr = v((e, t) => {
      let r = new R.XmlNode(Eg);
      return (
        r.cc(e, RH),
        r.lc(e, "TargetGrants", "TargetGrants", () => rFr(e[ib], t)),
        r.cc(e, IH),
        e[Dg] != null && r.c(nFr(e[Dg], t).n(Dg)),
        r
      );
    }, "se_LoggingEnabled"),
    Zqr = v((e, t) => {
      let r = new R.XmlNode(KZe);
      return (
        e[Qr] != null && r.c(R.XmlNode.of(XUr, e[Qr]).n(Qr)),
        e[ya] != null && r.c(R.XmlNode.of(eHr, e[ya]).n(ya)),
        r
      );
    }, "se_MetadataEntry"),
    ejr = v((e, t) => {
      let r = new R.XmlNode(ZUr);
      return e[TH] != null && r.c(Ujr(e[TH], t).n(TH)), r;
    }, "se_MetadataTableConfiguration"),
    tjr = v((e, t) => {
      let r = new R.XmlNode(bg);
      return (
        e[ge] != null && r.c(R.XmlNode.of(JUr, e[ge]).n(ge)),
        e[gb] != null && r.c(_Ze(e[gb], t).n(gb)),
        r
      );
    }, "se_Metrics"),
    rjr = v((e, t) => {
      let r = new R.XmlNode($Ur);
      return (
        r.cc(e, re), r.l(e, "Tags", "Tag", () => Hb(e[fo], t)), r.cc(e, td), r
      );
    }, "se_MetricsAndOperator"),
    njr = v((e, t) => {
      let r = new R.XmlNode(zte);
      return (
        e[je] != null && r.c(R.XmlNode.of(YUr, e[je]).n(je)),
        e[qe] != null && r.c(ijr(e[qe], t).n(qe)),
        r
      );
    }, "se_MetricsConfiguration"),
    ijr = v((e, t) => {
      let r = new R.XmlNode(QUr);
      return (
        LH.visit(e, {
          Prefix: v((n) => {
            e[re] != null && r.c(R.XmlNode.of(re, n).n(re));
          }, "Prefix"),
          Tag: v((n) => {
            e[rt] != null && r.c(Ub(n, t).n(rt));
          }, "Tag"),
          AccessPointArn: v((n) => {
            e[td] != null && r.c(R.XmlNode.of(td, n).n(td));
          }, "AccessPointArn"),
          And: v((n) => {
            e[Nr] != null && r.c(rjr(n, t).n(Nr));
          }, "And"),
          _: v((n, i) => {
            if (!(i instanceof R.XmlNode || i instanceof R.XmlText))
              throw new Error(
                "Unable to serialize unknown union members in XML.",
              );
            r.c(new R.XmlNode(n).c(i));
          }, "_"),
        }),
        r
      );
    }, "se_MetricsFilter"),
    ojr = v((e, t) => {
      let r = new R.XmlNode(Sg);
      return (
        e[_s] != null && r.c(R.XmlNode.of(Dt, String(e[_s])).n(_s)),
        e[Es] != null && r.c(R.XmlNode.of(uet, String(e[Es])).n(Es)),
        r
      );
    }, "se_NoncurrentVersionExpiration"),
    ajr = v((e, t) => {
      let r = new R.XmlNode(Qte);
      return (
        e[_s] != null && r.c(R.XmlNode.of(Dt, String(e[_s])).n(_s)),
        e[st] != null && r.c(R.XmlNode.of(aet, e[st]).n(st)),
        e[Es] != null && r.c(R.XmlNode.of(uet, String(e[Es])).n(Es)),
        r
      );
    }, "se_NoncurrentVersionTransition"),
    sjr = v(
      (e, t) => e.filter((r) => r != null).map((r) => ajr(r, t).n(Wn)),
      "se_NoncurrentVersionTransitionList",
    ),
    cjr = v((e, t) => {
      let r = new R.XmlNode(tHr);
      return (
        r.l(e, "TopicConfigurations", "TopicConfiguration", () =>
          sFr(e[ire], t),
        ),
        r.l(e, "QueueConfigurations", "QueueConfiguration", () =>
          wjr(e[Xte], t),
        ),
        r.l(
          e,
          "LambdaFunctionConfigurations",
          "CloudFunctionConfiguration",
          () => $qr(e[$te], t),
        ),
        e[pg] != null && r.c(wqr(e[pg], t).n(pg)),
        r
      );
    }, "se_NotificationConfiguration"),
    fre = v((e, t) => {
      let r = new R.XmlNode(rHr);
      return e[ze] != null && r.c(Fjr(e[ze], t).n(Zte)), r;
    }, "se_NotificationConfigurationFilter"),
    ujr = v((e, t) => {
      let r = new R.XmlNode(aHr);
      return (
        e[ze] != null && r.c(R.XmlNode.of(bre, e[ze]).n(ze)),
        e[dt] != null && r.c(R.XmlNode.of(fHr, e[dt]).n(dt)),
        r.cc(e, cr),
        e[JU] != null &&
          r.c(R.XmlNode.of(JU, (0, p.dateToUtcString)(e[JU]).toString()).n(JU)),
        e[Di] != null && r.c(R.XmlNode.of(Di, String(e[Di])).n(Di)),
        r
      );
    }, "se_ObjectIdentifier"),
    ljr = v(
      (e, t) => e.filter((r) => r != null).map((r) => ujr(r, t).n(Wn)),
      "se_ObjectIdentifierList",
    ),
    djr = v((e, t) => {
      let r = new R.XmlNode(sHr);
      return r.cc(e, mH), e[zo] != null && r.c(mjr(e[zo], t).n(zo)), r;
    }, "se_ObjectLockConfiguration"),
    fjr = v((e, t) => {
      let r = new R.XmlNode(cHr);
      return e[ge] != null && r.c(R.XmlNode.of(Bg, e[ge]).n(ge)), r;
    }, "se_ObjectLockLegalHold"),
    pjr = v((e, t) => {
      let r = new R.XmlNode(uHr);
      return (
        e[ys] != null && r.c(R.XmlNode.of(WZe, e[ys]).n(ys)),
        e[xb] != null &&
          r.c(
            R.XmlNode.of(co, (0, p.serializeDateTime)(e[xb]).toString()).n(xb),
          ),
        r
      );
    }, "se_ObjectLockRetention"),
    mjr = v((e, t) => {
      let r = new R.XmlNode(lHr);
      return e[fg] != null && r.c(vqr(e[fg], t).n(fg)), r;
    }, "se_ObjectLockRule"),
    hjr = v((e, t) => {
      let r = new R.XmlNode(pH);
      return e[Cte] != null && r.c(Bjr(e[Cte], t).n(Cte)), r;
    }, "se_OutputLocation"),
    yZe = v((e, t) => {
      let r = new R.XmlNode(Cg);
      return (
        e[mb] != null && r.c(gqr(e[mb], t).n(mb)),
        e[Sb] != null && r.c(Gqr(e[Sb], t).n(Sb)),
        r
      );
    }, "se_OutputSerialization"),
    gjr = v((e, t) => {
      let r = new R.XmlNode(Nt);
      return r.cc(e, lc), r.cc(e, rn), r;
    }, "se_Owner"),
    vjr = v((e, t) => {
      let r = new R.XmlNode(nHr);
      return r.l(e, "Rules", "Rule", () => _jr(e[ws], t)), r;
    }, "se_OwnershipControls"),
    yjr = v((e, t) => {
      let r = new R.XmlNode(oHr);
      return r.cc(e, FT), r;
    }, "se_OwnershipControlsRule"),
    _jr = v(
      (e, t) => e.filter((r) => r != null).map((r) => yjr(r, t).n(Wn)),
      "se_OwnershipControlsRules",
    ),
    Ejr = v((e, t) => new R.XmlNode(hHr), "se_ParquetInput"),
    bjr = v((e, t) => {
      let r = new R.XmlNode(wg);
      return r.cc(e, hH), r;
    }, "se_PartitionedPrefix"),
    Sjr = v((e, t) => {
      let r = new R.XmlNode(mHr);
      return (
        e[lb] != null && r.c(R.XmlNode.of(eH, String(e[lb])).n(lb)),
        e[Eb] != null && r.c(R.XmlNode.of(eH, String(e[Eb])).n(Eb)),
        e[db] != null && r.c(R.XmlNode.of(eH, String(e[db])).n(db)),
        e[Rb] != null && r.c(R.XmlNode.of(eH, String(e[Rb])).n(Rb)),
        r
      );
    }, "se_PublicAccessBlockConfiguration"),
    Cjr = v((e, t) => {
      let r = new R.XmlNode(Yte);
      return (
        e[je] != null && r.c(R.XmlNode.of(Ere, e[je]).n(je)),
        e[vH] != null && r.c(R.XmlNode.of(vH, e[vH]).n(Jte)),
        r.l(e, "Events", "Event", () => dre(e[id], t)),
        e[qe] != null && r.c(fre(e[qe], t).n(qe)),
        r
      );
    }, "se_QueueConfiguration"),
    wjr = v(
      (e, t) => e.filter((r) => r != null).map((r) => Cjr(r, t).n(Wn)),
      "se_QueueConfigurationList",
    ),
    Ojr = v((e, t) => {
      let r = new R.XmlNode(Pg);
      return r.cc(e, kp), r.cc(e, sH), r.cc(e, Mp), r.cc(e, _H), r.cc(e, EH), r;
    }, "se_Redirect"),
    Tjr = v((e, t) => {
      let r = new R.XmlNode(Og);
      return r.cc(e, kp), r.cc(e, Mp), r;
    }, "se_RedirectAllRequestsTo"),
    Ajr = v((e, t) => {
      let r = new R.XmlNode(Tg);
      return e[ge] != null && r.c(R.XmlNode.of(yHr, e[ge]).n(ge)), r;
    }, "se_ReplicaModifications"),
    Pjr = v((e, t) => {
      let r = new R.XmlNode(vHr);
      return r.cc(e, SH), r.l(e, "Rules", "Rule", () => Njr(e[ws], t)), r;
    }, "se_ReplicationConfiguration"),
    Rjr = v((e, t) => {
      let r = new R.XmlNode(THr);
      return (
        r.cc(e, rn),
        e[og] != null && r.c(R.XmlNode.of(og, String(e[og])).n(og)),
        r.cc(e, re),
        e[qe] != null && r.c(xjr(e[qe], t).n(qe)),
        e[ge] != null && r.c(R.XmlNode.of(wHr, e[ge]).n(ge)),
        e[Ng] != null && r.c(Qjr(e[Ng], t).n(Ng)),
        e[gg] != null && r.c(Oqr(e[gg], t).n(gg)),
        e[$n] != null && r.c(Eqr(e[$n], t).n($n)),
        e[dg] != null && r.c(_qr(e[dg], t).n(dg)),
        r
      );
    }, "se_ReplicationRule"),
    Ijr = v((e, t) => {
      let r = new R.XmlNode(SHr);
      return r.cc(e, re), r.l(e, "Tags", "Tag", () => Hb(e[fo], t)), r;
    }, "se_ReplicationRuleAndOperator"),
    xjr = v((e, t) => {
      let r = new R.XmlNode(CHr);
      return (
        r.cc(e, re),
        e[rt] != null && r.c(Ub(e[rt], t).n(rt)),
        e[Nr] != null && r.c(Ijr(e[Nr], t).n(Nr)),
        r
      );
    }, "se_ReplicationRuleFilter"),
    Njr = v(
      (e, t) => e.filter((r) => r != null).map((r) => Rjr(r, t).n(Wn)),
      "se_ReplicationRules",
    ),
    kjr = v((e, t) => {
      let r = new R.XmlNode(Ag);
      return (
        e[ge] != null && r.c(R.XmlNode.of(RHr, e[ge]).n(ge)),
        e[Mb] != null && r.c(_Ze(e[Mb], t).n(Mb)),
        r
      );
    }, "se_ReplicationTime"),
    _Ze = v((e, t) => {
      let r = new R.XmlNode(IHr);
      return e[ig] != null && r.c(R.XmlNode.of(ig, String(e[ig])).n(ig)), r;
    }, "se_ReplicationTimeValue"),
    Djr = v((e, t) => {
      let r = new R.XmlNode(EHr);
      return r.cc(e, gH), r;
    }, "se_RequestPaymentConfiguration"),
    Ljr = v((e, t) => {
      let r = new R.XmlNode(bH);
      return e[ote] != null && r.c(R.XmlNode.of(lUr, String(e[ote])).n(ote)), r;
    }, "se_RequestProgress"),
    Mjr = v((e, t) => {
      let r = new R.XmlNode(AHr);
      return (
        e[Dt] != null && r.c(R.XmlNode.of(Dt, String(e[Dt])).n(Dt)),
        e[oH] != null && r.c(Rqr(e[oH], t).n(oH)),
        e[Ko] != null && r.c(R.XmlNode.of(OHr, e[Ko]).n(Ko)),
        r.cc(e, set),
        r.cc(e, cUr),
        e[wH] != null && r.c(Gjr(e[wH], t).n(wH)),
        e[pH] != null && r.c(hjr(e[pH], t).n(pH)),
        r
      );
    }, "se_RestoreRequest"),
    qjr = v((e, t) => {
      let r = new R.XmlNode(HH);
      return (
        e[lg] != null && r.c(lqr(e[lg], t).n(lg)),
        e[Pg] != null && r.c(Ojr(e[Pg], t).n(Pg)),
        r
      );
    }, "se_RoutingRule"),
    jjr = v(
      (e, t) => e.filter((r) => r != null).map((r) => qjr(r, t).n(HH)),
      "se_RoutingRules",
    ),
    Fjr = v((e, t) => {
      let r = new R.XmlNode(DHr);
      return r.l(e, "FilterRules", "FilterRule", () => Pqr(e[Ute], t)), r;
    }, "se_S3KeyFilter"),
    Bjr = v((e, t) => {
      let r = new R.XmlNode(LHr);
      return (
        r.cc(e, XH),
        e[re] != null && r.c(R.XmlNode.of(BUr, e[re]).n(re)),
        e[Nu] != null && r.c(bqr(e[Nu], t).n(Nu)),
        e[Zee] != null && r.c(R.XmlNode.of(iHr, e[Zee]).n(Zee)),
        r.lc(e, "AccessControlList", "AccessControlList", () => gZe(e[sg], t)),
        e[kg] != null && r.c(pre(e[kg], t).n(kg)),
        r.lc(e, "UserMetadata", "UserMetadata", () => lFr(e[zHr], t)),
        r.cc(e, st),
        r
      );
    }, "se_S3Location"),
    Ujr = v((e, t) => {
      let r = new R.XmlNode(TH);
      return (
        e[Db] != null && r.c(R.XmlNode.of(UHr, e[Db]).n(Db)),
        e[Lb] != null && r.c(R.XmlNode.of(HHr, e[Lb]).n(Lb)),
        r
      );
    }, "se_S3TablesDestination"),
    Hjr = v((e, t) => {
      let r = new R.XmlNode(OH);
      return (
        e[tH] != null && r.c(R.XmlNode.of(tH, String(e[tH])).n(tH)),
        e[XU] != null && r.c(R.XmlNode.of(XU, String(e[XU])).n(XU)),
        r
      );
    }, "se_ScanRange"),
    Gjr = v((e, t) => {
      let r = new R.XmlNode(wH);
      return (
        e[yg] != null && r.c(vZe(e[yg], t).n(yg)),
        r.cc(e, VZe),
        r.cc(e, $Ze),
        e[Cg] != null && r.c(yZe(e[Cg], t).n(Cg)),
        r
      );
    }, "se_SelectParameters"),
    Vjr = v((e, t) => {
      let r = new R.XmlNode(jHr);
      return (
        e[Nb] != null && r.c(R.XmlNode.of(Ji, e[Nb]).n(Nb)),
        e[wb] != null && r.c(R.XmlNode.of(Li, e[wb]).n(wb)),
        r
      );
    }, "se_ServerSideEncryptionByDefault"),
    $jr = v((e, t) => {
      let r = new R.XmlNode(FHr);
      return r.l(e, "Rules", "Rule", () => Kjr(e[ws], t)), r;
    }, "se_ServerSideEncryptionConfiguration"),
    zjr = v((e, t) => {
      let r = new R.XmlNode(BHr);
      return (
        e[ab] != null && r.c(Vjr(e[ab], t).n(ab)),
        e[xr] != null && r.c(R.XmlNode.of(xr, String(e[xr])).n(xr)),
        r
      );
    }, "se_ServerSideEncryptionRule"),
    Kjr = v(
      (e, t) => e.filter((r) => r != null).map((r) => zjr(r, t).n(Wn)),
      "se_ServerSideEncryptionRules",
    ),
    Wjr = v((e, t) => new R.XmlNode(xg), "se_SimplePrefix"),
    Qjr = v((e, t) => {
      let r = new R.XmlNode(Ng);
      return (
        e[Ig] != null && r.c(Xjr(e[Ig], t).n(Ig)),
        e[Tg] != null && r.c(Ajr(e[Tg], t).n(Tg)),
        r
      );
    }, "se_SourceSelectionCriteria"),
    Yjr = v((e, t) => {
      let r = new R.XmlNode(GH);
      return e[Cb] != null && r.c(R.XmlNode.of(Li, e[Cb]).n(Cb)), r;
    }, "se_SSEKMS"),
    Xjr = v((e, t) => {
      let r = new R.XmlNode(Ig);
      return e[ge] != null && r.c(R.XmlNode.of(kHr, e[ge]).n(ge)), r;
    }, "se_SseKmsEncryptedObjects"),
    Jjr = v((e, t) => new R.XmlNode(VH), "se_SSES3"),
    Zjr = v((e, t) => {
      let r = new R.XmlNode(Rg);
      return e[hb] != null && r.c(eFr(e[hb], t).n(hb)), r;
    }, "se_StorageClassAnalysis"),
    eFr = v((e, t) => {
      let r = new R.XmlNode(xHr);
      return (
        e[Pb] != null && r.c(R.XmlNode.of(NHr, e[Pb]).n(Pb)),
        e[$n] != null && r.c(tqr(e[$n], t).n($n)),
        r
      );
    }, "se_StorageClassAnalysisDataExport"),
    Ub = v((e, t) => {
      let r = new R.XmlNode(rt);
      return (
        e[ze] != null && r.c(R.XmlNode.of(bre, e[ze]).n(ze)), r.cc(e, ya), r
      );
    }, "se_Tag"),
    pre = v((e, t) => {
      let r = new R.XmlNode(kg);
      return r.lc(e, "TagSet", "TagSet", () => Hb(e[cc], t)), r;
    }, "se_Tagging"),
    Hb = v(
      (e, t) => e.filter((r) => r != null).map((r) => Ub(r, t).n(rt)),
      "se_TagSet",
    ),
    tFr = v((e, t) => {
      let r = new R.XmlNode(VHr);
      if (e[va] != null) {
        let n = hZe(e[va], t).n(va);
        n.a("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"), r.c(n);
      }
      return e[ku] != null && r.c(R.XmlNode.of($Br, e[ku]).n(ku)), r;
    }, "se_TargetGrant"),
    rFr = v(
      (e, t) => e.filter((r) => r != null).map((r) => tFr(r, t).n(od)),
      "se_TargetGrants",
    ),
    nFr = v((e, t) => {
      let r = new R.XmlNode(Dg);
      return (
        e[xg] != null && r.c(Wjr(e[xg], t).n(xg)),
        e[wg] != null && r.c(bjr(e[wg], t).n(wg)),
        r
      );
    }, "se_TargetObjectKeyFormat"),
    iFr = v((e, t) => {
      let r = new R.XmlNode(are);
      return (
        e[Dt] != null && r.c(R.XmlNode.of(PUr, String(e[Dt])).n(Dt)),
        e[rd] != null && r.c(R.XmlNode.of(AUr, e[rd]).n(rd)),
        r
      );
    }, "se_Tiering"),
    oFr = v(
      (e, t) => e.filter((r) => r != null).map((r) => iFr(r, t).n(Wn)),
      "se_TieringList",
    ),
    aFr = v((e, t) => {
      let r = new R.XmlNode(nre);
      return (
        e[je] != null && r.c(R.XmlNode.of(Ere, e[je]).n(je)),
        e[PH] != null && r.c(R.XmlNode.of(PH, e[PH]).n(sre)),
        r.l(e, "Events", "Event", () => dre(e[id], t)),
        e[qe] != null && r.c(fre(e[qe], t).n(qe)),
        r
      );
    }, "se_TopicConfiguration"),
    sFr = v(
      (e, t) => e.filter((r) => r != null).map((r) => aFr(r, t).n(Wn)),
      "se_TopicConfigurationList",
    ),
    cFr = v((e, t) => {
      let r = new R.XmlNode(ure);
      return (
        e[co] != null &&
          r.c(
            R.XmlNode.of(co, (0, p.serializeDateTime)(e[co]).toString()).n(co),
          ),
        e[Dt] != null && r.c(R.XmlNode.of(Dt, String(e[Dt])).n(Dt)),
        e[st] != null && r.c(R.XmlNode.of(aet, e[st]).n(st)),
        r
      );
    }, "se_Transition"),
    uFr = v(
      (e, t) => e.filter((r) => r != null).map((r) => cFr(r, t).n(Wn)),
      "se_TransitionList",
    ),
    lFr = v(
      (e, t) => e.filter((r) => r != null).map((r) => Zqr(r, t).n(KZe)),
      "se_UserMetadata",
    ),
    dFr = v((e, t) => {
      let r = new R.XmlNode(KHr);
      return (
        e[dH] != null && r.c(R.XmlNode.of(dH, e[dH]).n(Kte)),
        e[ge] != null && r.c(R.XmlNode.of(QBr, e[ge]).n(ge)),
        r
      );
    }, "se_VersioningConfiguration"),
    fFr = v((e, t) => {
      let r = new R.XmlNode(WHr);
      return (
        e[hg] != null && r.c(Cqr(e[hg], t).n(hg)),
        e[vg] != null && r.c(xqr(e[vg], t).n(vg)),
        e[Og] != null && r.c(Tjr(e[Og], t).n(Og)),
        r.lc(e, "RoutingRules", "RoutingRules", () => jjr(e[nb], t)),
        r
      );
    }, "se_WebsiteConfiguration"),
    pFr = v((e, t) => {
      let r = {};
      return e[eg] != null && (r[eg] = (0, p.strictParseInt32)(e[eg])), r;
    }, "de_AbortIncompleteMultipartUpload"),
    mFr = v((e, t) => {
      let r = {};
      return e[Nt] != null && (r[Nt] = (0, p.expectString)(e[Nt])), r;
    }, "de_AccessControlTranslation"),
    hFr = v(
      (e, t) =>
        (e || []).filter((r) => r != null).map((r) => (0, p.expectString)(r)),
      "de_AllowedHeaders",
    ),
    gFr = v(
      (e, t) =>
        (e || []).filter((r) => r != null).map((r) => (0, p.expectString)(r)),
      "de_AllowedMethods",
    ),
    vFr = v(
      (e, t) =>
        (e || []).filter((r) => r != null).map((r) => (0, p.expectString)(r)),
      "de_AllowedOrigins",
    ),
    yFr = v((e, t) => {
      let r = {};
      return (
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e.Tag === ""
          ? (r[fo] = [])
          : e[rt] != null &&
            (r[fo] = Fg((0, p.getArrayIfSingleItem)(e[rt]), t)),
        r
      );
    }, "de_AnalyticsAndOperator"),
    EZe = v((e, t) => {
      let r = {};
      return (
        e[je] != null && (r[je] = (0, p.expectString)(e[je])),
        e.Filter === "" ||
          (e[qe] != null && (r[qe] = bFr((0, p.expectUnion)(e[qe]), t))),
        e[Rg] != null && (r[Rg] = yBr(e[Rg], t)),
        r
      );
    }, "de_AnalyticsConfiguration"),
    _Fr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => EZe(r, t)),
      "de_AnalyticsConfigurationList",
    ),
    EFr = v((e, t) => {
      let r = {};
      return e[Cs] != null && (r[Cs] = SFr(e[Cs], t)), r;
    }, "de_AnalyticsExportDestination"),
    bFr = v(
      (e, t) =>
        e[re] != null
          ? { Prefix: (0, p.expectString)(e[re]) }
          : e[rt] != null
            ? { Tag: Gb(e[rt], t) }
            : e[Nr] != null
              ? { And: yFr(e[Nr], t) }
              : { $unknown: Object.entries(e)[0] },
      "de_AnalyticsFilter",
    ),
    SFr = v((e, t) => {
      let r = {};
      return (
        e[gs] != null && (r[gs] = (0, p.expectString)(e[gs])),
        e[cb] != null && (r[cb] = (0, p.expectString)(e[cb])),
        e[_t] != null && (r[_t] = (0, p.expectString)(e[_t])),
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        r
      );
    }, "de_AnalyticsS3BucketDestination"),
    CFr = v((e, t) => {
      let r = {};
      return (
        e[Qr] != null && (r[Qr] = (0, p.expectString)(e[Qr])),
        e[ete] != null &&
          (r[ete] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[ete]),
          )),
        e[qT] != null && (r[qT] = (0, p.expectString)(e[qT])),
        r
      );
    }, "de_Bucket"),
    bZe = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => CFr(r, t)),
      "de_Buckets",
    ),
    wFr = v((e, t) => {
      let r = {};
      return (
        e[_r] != null && (r[_r] = (0, p.expectString)(e[_r])),
        e[Er] != null && (r[Er] = (0, p.expectString)(e[Er])),
        e[br] != null && (r[br] = (0, p.expectString)(e[br])),
        e[Sr] != null && (r[Sr] = (0, p.expectString)(e[Sr])),
        e[Cr] != null && (r[Cr] = (0, p.expectString)(e[Cr])),
        e[wr] != null && (r[wr] = (0, p.expectString)(e[wr])),
        r
      );
    }, "de_Checksum"),
    SZe = v(
      (e, t) =>
        (e || []).filter((r) => r != null).map((r) => (0, p.expectString)(r)),
      "de_ChecksumAlgorithmList",
    ),
    OFr = v((e, t) => {
      let r = {};
      return e[re] != null && (r[re] = (0, p.expectString)(e[re])), r;
    }, "de_CommonPrefix"),
    YH = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => OFr(r, t)),
      "de_CommonPrefixList",
    ),
    TFr = v((e, t) => {
      let r = {};
      return (
        e[aH] != null && (r[aH] = (0, p.expectString)(e[aH])),
        e[cH] != null && (r[cH] = (0, p.expectString)(e[cH])),
        r
      );
    }, "de_Condition"),
    AFr = v((e, t) => ({}), "de_ContinuationEvent"),
    PFr = v((e, t) => {
      let r = {};
      return (
        e[cr] != null && (r[cr] = (0, p.expectString)(e[cr])),
        e[nn] != null &&
          (r[nn] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[nn]),
          )),
        e[wr] != null && (r[wr] = (0, p.expectString)(e[wr])),
        e[_r] != null && (r[_r] = (0, p.expectString)(e[_r])),
        e[Er] != null && (r[Er] = (0, p.expectString)(e[Er])),
        e[br] != null && (r[br] = (0, p.expectString)(e[br])),
        e[Sr] != null && (r[Sr] = (0, p.expectString)(e[Sr])),
        e[Cr] != null && (r[Cr] = (0, p.expectString)(e[Cr])),
        r
      );
    }, "de_CopyObjectResult"),
    RFr = v((e, t) => {
      let r = {};
      return (
        e[cr] != null && (r[cr] = (0, p.expectString)(e[cr])),
        e[nn] != null &&
          (r[nn] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[nn]),
          )),
        e[_r] != null && (r[_r] = (0, p.expectString)(e[_r])),
        e[Er] != null && (r[Er] = (0, p.expectString)(e[Er])),
        e[br] != null && (r[br] = (0, p.expectString)(e[br])),
        e[Sr] != null && (r[Sr] = (0, p.expectString)(e[Sr])),
        e[Cr] != null && (r[Cr] = (0, p.expectString)(e[Cr])),
        r
      );
    }, "de_CopyPartResult"),
    IFr = v((e, t) => {
      let r = {};
      return (
        e[rn] != null && (r[rn] = (0, p.expectString)(e[rn])),
        e.AllowedHeader === ""
          ? (r[Ite] = [])
          : e[Rte] != null &&
            (r[Ite] = hFr((0, p.getArrayIfSingleItem)(e[Rte]), t)),
        e.AllowedMethod === ""
          ? (r[Nte] = [])
          : e[xte] != null &&
            (r[Nte] = gFr((0, p.getArrayIfSingleItem)(e[xte]), t)),
        e.AllowedOrigin === ""
          ? (r[Dte] = [])
          : e[kte] != null &&
            (r[Dte] = vFr((0, p.getArrayIfSingleItem)(e[kte]), t)),
        e.ExposeHeader === ""
          ? (r[jte] = [])
          : e[Fte] != null &&
            (r[jte] = KFr((0, p.getArrayIfSingleItem)(e[Fte]), t)),
        e[ng] != null && (r[ng] = (0, p.strictParseInt32)(e[ng])),
        r
      );
    }, "de_CORSRule"),
    xFr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => IFr(r, t)),
      "de_CORSRules",
    ),
    NFr = v((e, t) => {
      let r = {};
      return (
        e[ys] != null && (r[ys] = (0, p.expectString)(e[ys])),
        e[Dt] != null && (r[Dt] = (0, p.strictParseInt32)(e[Dt])),
        e[ag] != null && (r[ag] = (0, p.strictParseInt32)(e[ag])),
        r
      );
    }, "de_DefaultRetention"),
    kFr = v((e, t) => {
      let r = {};
      return (
        e[ze] != null && (r[ze] = (0, p.expectString)(e[ze])),
        e[dt] != null && (r[dt] = (0, p.expectString)(e[dt])),
        e[uc] != null && (r[uc] = (0, p.parseBoolean)(e[uc])),
        e[nte] != null && (r[nte] = (0, p.expectString)(e[nte])),
        r
      );
    }, "de_DeletedObject"),
    DFr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => kFr(r, t)),
      "de_DeletedObjects",
    ),
    LFr = v((e, t) => {
      let r = {};
      return (
        e[Nt] != null && (r[Nt] = Fp(e[Nt], t)),
        e[ze] != null && (r[ze] = (0, p.expectString)(e[ze])),
        e[dt] != null && (r[dt] = (0, p.expectString)(e[dt])),
        e[yb] != null && (r[yb] = (0, p.parseBoolean)(e[yb])),
        e[nn] != null &&
          (r[nn] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[nn]),
          )),
        r
      );
    }, "de_DeleteMarkerEntry"),
    MFr = v((e, t) => {
      let r = {};
      return e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])), r;
    }, "de_DeleteMarkerReplication"),
    qFr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => LFr(r, t)),
      "de_DeleteMarkers",
    ),
    jFr = v((e, t) => {
      let r = {};
      return (
        e[_t] != null && (r[_t] = (0, p.expectString)(e[_t])),
        e[sb] != null && (r[sb] = (0, p.expectString)(e[sb])),
        e[st] != null && (r[st] = (0, p.expectString)(e[st])),
        e[cg] != null && (r[cg] = mFr(e[cg], t)),
        e[mg] != null && (r[mg] = FFr(e[mg], t)),
        e[Ag] != null && (r[Ag] = rBr(e[Ag], t)),
        e[bg] != null && (r[bg] = _1r(e[bg], t)),
        r
      );
    }, "de_Destination"),
    FFr = v((e, t) => {
      let r = {};
      return e[yH] != null && (r[yH] = (0, p.expectString)(e[yH])), r;
    }, "de_EncryptionConfiguration"),
    BFr = v((e, t) => ({}), "de_EndEvent"),
    UFr = v((e, t) => {
      let r = {};
      return (
        e[ze] != null && (r[ze] = (0, p.expectString)(e[ze])),
        e[dt] != null && (r[dt] = (0, p.expectString)(e[dt])),
        e[rte] != null && (r[rte] = (0, p.expectString)(e[rte])),
        e[fte] != null && (r[fte] = (0, p.expectString)(e[fte])),
        r
      );
    }, "de__Error"),
    HFr = v((e, t) => {
      let r = {};
      return (
        e[nH] != null && (r[nH] = (0, p.expectString)(e[nH])),
        e[iH] != null && (r[iH] = (0, p.expectString)(e[iH])),
        r
      );
    }, "de_ErrorDetails"),
    GFr = v((e, t) => {
      let r = {};
      return e[ze] != null && (r[ze] = (0, p.expectString)(e[ze])), r;
    }, "de_ErrorDocument"),
    VFr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => UFr(r, t)),
      "de_Errors",
    ),
    $Fr = v((e, t) => ({}), "de_EventBridgeConfiguration"),
    mre = v(
      (e, t) =>
        (e || []).filter((r) => r != null).map((r) => (0, p.expectString)(r)),
      "de_EventList",
    ),
    zFr = v((e, t) => {
      let r = {};
      return e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])), r;
    }, "de_ExistingObjectReplication"),
    KFr = v(
      (e, t) =>
        (e || []).filter((r) => r != null).map((r) => (0, p.expectString)(r)),
      "de_ExposeHeaders",
    ),
    WFr = v((e, t) => {
      let r = {};
      return (
        e[Qr] != null && (r[Qr] = (0, p.expectString)(e[Qr])),
        e[ya] != null && (r[ya] = (0, p.expectString)(e[ya])),
        r
      );
    }, "de_FilterRule"),
    QFr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => WFr(r, t)),
      "de_FilterRuleList",
    ),
    YFr = v((e, t) => {
      let r = {};
      return (
        e[dte] != null && (r[dte] = y1r(e[dte], t)),
        e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])),
        e[jT] != null && (r[jT] = HFr(e[jT], t)),
        r
      );
    }, "de_GetBucketMetadataTableConfigurationResult"),
    XFr = v((e, t) => {
      let r = {};
      return (
        e[Fb] != null && (r[$Hr] = (0, p.strictParseInt32)(e[Fb])),
        e[Lp] != null && (r[Lp] = (0, p.expectString)(e[Lp])),
        e[Ab] != null && (r[Ab] = (0, p.expectString)(e[Ab])),
        e[nd] != null && (r[nd] = (0, p.strictParseInt32)(e[nd])),
        e[Xt] != null && (r[Xt] = (0, p.parseBoolean)(e[Xt])),
        e.Part === ""
          ? (r[UT] = [])
          : e[UH] != null &&
            (r[UT] = H1r((0, p.getArrayIfSingleItem)(e[UH]), t)),
        r
      );
    }, "de_GetObjectAttributesParts"),
    JFr = v((e, t) => {
      let r = {};
      return (
        e[va] != null && (r[va] = CZe(e[va], t)),
        e[ku] != null && (r[ku] = (0, p.expectString)(e[ku])),
        r
      );
    }, "de_Grant"),
    CZe = v((e, t) => {
      let r = {};
      return (
        e[lc] != null && (r[lc] = (0, p.expectString)(e[lc])),
        e[rH] != null && (r[rH] = (0, p.expectString)(e[rH])),
        e[rn] != null && (r[rn] = (0, p.expectString)(e[rn])),
        e[NH] != null && (r[NH] = (0, p.expectString)(e[NH])),
        e[z7e] != null && (r[Ko] = (0, p.expectString)(e[z7e])),
        r
      );
    }, "de_Grantee"),
    wZe = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => JFr(r, t)),
      "de_Grants",
    ),
    ZFr = v((e, t) => {
      let r = {};
      return e[AH] != null && (r[AH] = (0, p.expectString)(e[AH])), r;
    }, "de_IndexDocument"),
    OZe = v((e, t) => {
      let r = {};
      return (
        e[rn] != null && (r[rn] = (0, p.expectString)(e[rn])),
        e[lc] != null && (r[lc] = (0, p.expectString)(e[lc])),
        r
      );
    }, "de_Initiator"),
    e1r = v((e, t) => {
      let r = {};
      return (
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e.Tag === ""
          ? (r[fo] = [])
          : e[rt] != null &&
            (r[fo] = Fg((0, p.getArrayIfSingleItem)(e[rt]), t)),
        r
      );
    }, "de_IntelligentTieringAndOperator"),
    TZe = v((e, t) => {
      let r = {};
      return (
        e[je] != null && (r[je] = (0, p.expectString)(e[je])),
        e[qe] != null && (r[qe] = r1r(e[qe], t)),
        e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])),
        e.Tiering === ""
          ? (r[ore] = [])
          : e[are] != null &&
            (r[ore] = wBr((0, p.getArrayIfSingleItem)(e[are]), t)),
        r
      );
    }, "de_IntelligentTieringConfiguration"),
    t1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => TZe(r, t)),
      "de_IntelligentTieringConfigurationList",
    ),
    r1r = v((e, t) => {
      let r = {};
      return (
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e[rt] != null && (r[rt] = Gb(e[rt], t)),
        e[Nr] != null && (r[Nr] = e1r(e[Nr], t)),
        r
      );
    }, "de_IntelligentTieringFilter"),
    AZe = v((e, t) => {
      let r = {};
      return (
        e[$n] != null && (r[$n] = i1r(e[$n], t)),
        e[rg] != null && (r[rg] = (0, p.parseBoolean)(e[rg])),
        e[qe] != null && (r[qe] = a1r(e[qe], t)),
        e[je] != null && (r[je] = (0, p.expectString)(e[je])),
        e[_b] != null && (r[_b] = (0, p.expectString)(e[_b])),
        e.OptionalFields === ""
          ? (r[rb] = [])
          : e[rb] != null &&
            e[rb][Hte] != null &&
            (r[rb] = s1r((0, p.getArrayIfSingleItem)(e[rb][Hte]), t)),
        e[kb] != null && (r[kb] = u1r(e[kb], t)),
        r
      );
    }, "de_InventoryConfiguration"),
    n1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => AZe(r, t)),
      "de_InventoryConfigurationList",
    ),
    i1r = v((e, t) => {
      let r = {};
      return e[Cs] != null && (r[Cs] = c1r(e[Cs], t)), r;
    }, "de_InventoryDestination"),
    o1r = v((e, t) => {
      let r = {};
      return (
        e[VH] != null && (r[tre] = gBr(e[VH], t)),
        e[GH] != null && (r[ere] = mBr(e[GH], t)),
        r
      );
    }, "de_InventoryEncryption"),
    a1r = v((e, t) => {
      let r = {};
      return e[re] != null && (r[re] = (0, p.expectString)(e[re])), r;
    }, "de_InventoryFilter"),
    s1r = v(
      (e, t) =>
        (e || []).filter((r) => r != null).map((r) => (0, p.expectString)(r)),
      "de_InventoryOptionalFields",
    ),
    c1r = v((e, t) => {
      let r = {};
      return (
        e[ob] != null && (r[ob] = (0, p.expectString)(e[ob])),
        e[_t] != null && (r[_t] = (0, p.expectString)(e[_t])),
        e[gs] != null && (r[gs] = (0, p.expectString)(e[gs])),
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e[Nu] != null && (r[Nu] = o1r(e[Nu], t)),
        r
      );
    }, "de_InventoryS3BucketDestination"),
    u1r = v((e, t) => {
      let r = {};
      return e[vb] != null && (r[vb] = (0, p.expectString)(e[vb])), r;
    }, "de_InventorySchedule"),
    l1r = v((e, t) => {
      let r = {};
      return (
        e[je] != null && (r[je] = (0, p.expectString)(e[je])),
        e[Lte] != null && (r[uH] = (0, p.expectString)(e[Lte])),
        e.Event === ""
          ? (r[id] = [])
          : e[Lg] != null &&
            (r[id] = mre((0, p.getArrayIfSingleItem)(e[Lg]), t)),
        e[qe] != null && (r[qe] = hre(e[qe], t)),
        r
      );
    }, "de_LambdaFunctionConfiguration"),
    d1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => l1r(r, t)),
      "de_LambdaFunctionConfigurationList",
    ),
    f1r = v((e, t) => {
      let r = {};
      return (
        e[co] != null &&
          (r[co] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[co]),
          )),
        e[Dt] != null && (r[Dt] = (0, p.strictParseInt32)(e[Dt])),
        e[tg] != null && (r[tg] = (0, p.parseBoolean)(e[tg])),
        r
      );
    }, "de_LifecycleExpiration"),
    p1r = v((e, t) => {
      let r = {};
      return (
        e[uo] != null && (r[uo] = f1r(e[uo], t)),
        e[rn] != null && (r[rn] = (0, p.expectString)(e[rn])),
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e[qe] != null && (r[qe] = h1r(e[qe], t)),
        e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])),
        e.Transition === ""
          ? (r[cre] = [])
          : e[ure] != null &&
            (r[cre] = PBr((0, p.getArrayIfSingleItem)(e[ure]), t)),
        e.NoncurrentVersionTransition === ""
          ? (r[Wte] = [])
          : e[Qte] != null &&
            (r[Wte] = A1r((0, p.getArrayIfSingleItem)(e[Qte]), t)),
        e[Sg] != null && (r[Sg] = O1r(e[Sg], t)),
        e[ug] != null && (r[ug] = pFr(e[ug], t)),
        r
      );
    }, "de_LifecycleRule"),
    m1r = v((e, t) => {
      let r = {};
      return (
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e.Tag === ""
          ? (r[fo] = [])
          : e[rt] != null &&
            (r[fo] = Fg((0, p.getArrayIfSingleItem)(e[rt]), t)),
        e[bs] != null && (r[bs] = (0, p.strictParseLong)(e[bs])),
        e[Ss] != null && (r[Ss] = (0, p.strictParseLong)(e[Ss])),
        r
      );
    }, "de_LifecycleRuleAndOperator"),
    h1r = v((e, t) => {
      let r = {};
      return (
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e[rt] != null && (r[rt] = Gb(e[rt], t)),
        e[bs] != null && (r[bs] = (0, p.strictParseLong)(e[bs])),
        e[Ss] != null && (r[Ss] = (0, p.strictParseLong)(e[Ss])),
        e[Nr] != null && (r[Nr] = m1r(e[Nr], t)),
        r
      );
    }, "de_LifecycleRuleFilter"),
    g1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => p1r(r, t)),
      "de_LifecycleRules",
    ),
    v1r = v((e, t) => {
      let r = {};
      return (
        e[RH] != null && (r[RH] = (0, p.expectString)(e[RH])),
        e.TargetGrants === ""
          ? (r[ib] = [])
          : e[ib] != null &&
            e[ib][od] != null &&
            (r[ib] = bBr((0, p.getArrayIfSingleItem)(e[ib][od]), t)),
        e[IH] != null && (r[IH] = (0, p.expectString)(e[IH])),
        e[Dg] != null && (r[Dg] = SBr(e[Dg], t)),
        r
      );
    }, "de_LoggingEnabled"),
    y1r = v((e, t) => {
      let r = {};
      return e[Ste] != null && (r[Ste] = aBr(e[Ste], t)), r;
    }, "de_MetadataTableConfigurationResult"),
    _1r = v((e, t) => {
      let r = {};
      return (
        e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])),
        e[gb] != null && (r[gb] = IZe(e[gb], t)),
        r
      );
    }, "de_Metrics"),
    E1r = v((e, t) => {
      let r = {};
      return (
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e.Tag === ""
          ? (r[fo] = [])
          : e[rt] != null &&
            (r[fo] = Fg((0, p.getArrayIfSingleItem)(e[rt]), t)),
        e[td] != null && (r[td] = (0, p.expectString)(e[td])),
        r
      );
    }, "de_MetricsAndOperator"),
    PZe = v((e, t) => {
      let r = {};
      return (
        e[je] != null && (r[je] = (0, p.expectString)(e[je])),
        e.Filter === "" ||
          (e[qe] != null && (r[qe] = S1r((0, p.expectUnion)(e[qe]), t))),
        r
      );
    }, "de_MetricsConfiguration"),
    b1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => PZe(r, t)),
      "de_MetricsConfigurationList",
    ),
    S1r = v(
      (e, t) =>
        e[re] != null
          ? { Prefix: (0, p.expectString)(e[re]) }
          : e[rt] != null
            ? { Tag: Gb(e[rt], t) }
            : e[td] != null
              ? { AccessPointArn: (0, p.expectString)(e[td]) }
              : e[Nr] != null
                ? { And: E1r(e[Nr], t) }
                : { $unknown: Object.entries(e)[0] },
      "de_MetricsFilter",
    ),
    C1r = v((e, t) => {
      let r = {};
      return (
        e[Wo] != null && (r[Wo] = (0, p.expectString)(e[Wo])),
        e[ze] != null && (r[ze] = (0, p.expectString)(e[ze])),
        e[cte] != null &&
          (r[cte] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[cte]),
          )),
        e[st] != null && (r[st] = (0, p.expectString)(e[st])),
        e[Nt] != null && (r[Nt] = Fp(e[Nt], t)),
        e[bb] != null && (r[bb] = OZe(e[bb], t)),
        e[lt] != null && (r[lt] = (0, p.expectString)(e[lt])),
        e[wr] != null && (r[wr] = (0, p.expectString)(e[wr])),
        r
      );
    }, "de_MultipartUpload"),
    w1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => C1r(r, t)),
      "de_MultipartUploadList",
    ),
    O1r = v((e, t) => {
      let r = {};
      return (
        e[_s] != null && (r[_s] = (0, p.strictParseInt32)(e[_s])),
        e[Es] != null && (r[Es] = (0, p.strictParseInt32)(e[Es])),
        r
      );
    }, "de_NoncurrentVersionExpiration"),
    T1r = v((e, t) => {
      let r = {};
      return (
        e[_s] != null && (r[_s] = (0, p.strictParseInt32)(e[_s])),
        e[st] != null && (r[st] = (0, p.expectString)(e[st])),
        e[Es] != null && (r[Es] = (0, p.strictParseInt32)(e[Es])),
        r
      );
    }, "de_NoncurrentVersionTransition"),
    A1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => T1r(r, t)),
      "de_NoncurrentVersionTransitionList",
    ),
    hre = v((e, t) => {
      let r = {};
      return e[Zte] != null && (r[ze] = oBr(e[Zte], t)), r;
    }, "de_NotificationConfigurationFilter"),
    P1r = v((e, t) => {
      let r = {};
      return (
        e[ze] != null && (r[ze] = (0, p.expectString)(e[ze])),
        e[nn] != null &&
          (r[nn] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[nn]),
          )),
        e[cr] != null && (r[cr] = (0, p.expectString)(e[cr])),
        e.ChecksumAlgorithm === ""
          ? (r[lt] = [])
          : e[lt] != null &&
            (r[lt] = SZe((0, p.getArrayIfSingleItem)(e[lt]), t)),
        e[wr] != null && (r[wr] = (0, p.expectString)(e[wr])),
        e[Di] != null && (r[Di] = (0, p.strictParseLong)(e[Di])),
        e[st] != null && (r[st] = (0, p.expectString)(e[st])),
        e[Nt] != null && (r[Nt] = Fp(e[Nt], t)),
        e[Ib] != null && (r[Ib] = xZe(e[Ib], t)),
        r
      );
    }, "de__Object"),
    RZe = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => P1r(r, t)),
      "de_ObjectList",
    ),
    R1r = v((e, t) => {
      let r = {};
      return (
        e[mH] != null && (r[mH] = (0, p.expectString)(e[mH])),
        e[zo] != null && (r[zo] = N1r(e[zo], t)),
        r
      );
    }, "de_ObjectLockConfiguration"),
    I1r = v((e, t) => {
      let r = {};
      return e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])), r;
    }, "de_ObjectLockLegalHold"),
    x1r = v((e, t) => {
      let r = {};
      return (
        e[ys] != null && (r[ys] = (0, p.expectString)(e[ys])),
        e[xb] != null &&
          (r[xb] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[xb]),
          )),
        r
      );
    }, "de_ObjectLockRetention"),
    N1r = v((e, t) => {
      let r = {};
      return e[fg] != null && (r[fg] = NFr(e[fg], t)), r;
    }, "de_ObjectLockRule"),
    k1r = v((e, t) => {
      let r = {};
      return (
        e[$o] != null && (r[$o] = (0, p.strictParseInt32)(e[$o])),
        e[Di] != null && (r[Di] = (0, p.strictParseLong)(e[Di])),
        e[_r] != null && (r[_r] = (0, p.expectString)(e[_r])),
        e[Er] != null && (r[Er] = (0, p.expectString)(e[Er])),
        e[br] != null && (r[br] = (0, p.expectString)(e[br])),
        e[Sr] != null && (r[Sr] = (0, p.expectString)(e[Sr])),
        e[Cr] != null && (r[Cr] = (0, p.expectString)(e[Cr])),
        r
      );
    }, "de_ObjectPart"),
    D1r = v((e, t) => {
      let r = {};
      return (
        e[cr] != null && (r[cr] = (0, p.expectString)(e[cr])),
        e.ChecksumAlgorithm === ""
          ? (r[lt] = [])
          : e[lt] != null &&
            (r[lt] = SZe((0, p.getArrayIfSingleItem)(e[lt]), t)),
        e[wr] != null && (r[wr] = (0, p.expectString)(e[wr])),
        e[Di] != null && (r[Di] = (0, p.strictParseLong)(e[Di])),
        e[st] != null && (r[st] = (0, p.expectString)(e[st])),
        e[ze] != null && (r[ze] = (0, p.expectString)(e[ze])),
        e[dt] != null && (r[dt] = (0, p.expectString)(e[dt])),
        e[yb] != null && (r[yb] = (0, p.parseBoolean)(e[yb])),
        e[nn] != null &&
          (r[nn] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[nn]),
          )),
        e[Nt] != null && (r[Nt] = Fp(e[Nt], t)),
        e[Ib] != null && (r[Ib] = xZe(e[Ib], t)),
        r
      );
    }, "de_ObjectVersion"),
    L1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => D1r(r, t)),
      "de_ObjectVersionList",
    ),
    Fp = v((e, t) => {
      let r = {};
      return (
        e[lc] != null && (r[lc] = (0, p.expectString)(e[lc])),
        e[rn] != null && (r[rn] = (0, p.expectString)(e[rn])),
        r
      );
    }, "de_Owner"),
    M1r = v((e, t) => {
      let r = {};
      return (
        e.Rule === ""
          ? (r[ws] = [])
          : e[zo] != null &&
            (r[ws] = j1r((0, p.getArrayIfSingleItem)(e[zo]), t)),
        r
      );
    }, "de_OwnershipControls"),
    q1r = v((e, t) => {
      let r = {};
      return e[FT] != null && (r[FT] = (0, p.expectString)(e[FT])), r;
    }, "de_OwnershipControlsRule"),
    j1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => q1r(r, t)),
      "de_OwnershipControlsRules",
    ),
    F1r = v((e, t) => {
      let r = {};
      return (
        e[$o] != null && (r[$o] = (0, p.strictParseInt32)(e[$o])),
        e[nn] != null &&
          (r[nn] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[nn]),
          )),
        e[cr] != null && (r[cr] = (0, p.expectString)(e[cr])),
        e[Di] != null && (r[Di] = (0, p.strictParseLong)(e[Di])),
        e[_r] != null && (r[_r] = (0, p.expectString)(e[_r])),
        e[Er] != null && (r[Er] = (0, p.expectString)(e[Er])),
        e[br] != null && (r[br] = (0, p.expectString)(e[br])),
        e[Sr] != null && (r[Sr] = (0, p.expectString)(e[Sr])),
        e[Cr] != null && (r[Cr] = (0, p.expectString)(e[Cr])),
        r
      );
    }, "de_Part"),
    B1r = v((e, t) => {
      let r = {};
      return e[hH] != null && (r[hH] = (0, p.expectString)(e[hH])), r;
    }, "de_PartitionedPrefix"),
    U1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => F1r(r, t)),
      "de_Parts",
    ),
    H1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => k1r(r, t)),
      "de_PartsList",
    ),
    G1r = v((e, t) => {
      let r = {};
      return e[ate] != null && (r[ate] = (0, p.parseBoolean)(e[ate])), r;
    }, "de_PolicyStatus"),
    V1r = v((e, t) => {
      let r = {};
      return (
        e[pb] != null && (r[pb] = (0, p.strictParseLong)(e[pb])),
        e[ub] != null && (r[ub] = (0, p.strictParseLong)(e[ub])),
        e[fb] != null && (r[fb] = (0, p.strictParseLong)(e[fb])),
        r
      );
    }, "de_Progress"),
    $1r = v((e, t) => {
      let r = {};
      return (
        e[lb] != null && (r[lb] = (0, p.parseBoolean)(e[lb])),
        e[Eb] != null && (r[Eb] = (0, p.parseBoolean)(e[Eb])),
        e[db] != null && (r[db] = (0, p.parseBoolean)(e[db])),
        e[Rb] != null && (r[Rb] = (0, p.parseBoolean)(e[Rb])),
        r
      );
    }, "de_PublicAccessBlockConfiguration"),
    z1r = v((e, t) => {
      let r = {};
      return (
        e[je] != null && (r[je] = (0, p.expectString)(e[je])),
        e[Jte] != null && (r[vH] = (0, p.expectString)(e[Jte])),
        e.Event === ""
          ? (r[id] = [])
          : e[Lg] != null &&
            (r[id] = mre((0, p.getArrayIfSingleItem)(e[Lg]), t)),
        e[qe] != null && (r[qe] = hre(e[qe], t)),
        r
      );
    }, "de_QueueConfiguration"),
    K1r = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => z1r(r, t)),
      "de_QueueConfigurationList",
    ),
    W1r = v((e, t) => {
      let r = {};
      return (
        e[kp] != null && (r[kp] = (0, p.expectString)(e[kp])),
        e[sH] != null && (r[sH] = (0, p.expectString)(e[sH])),
        e[Mp] != null && (r[Mp] = (0, p.expectString)(e[Mp])),
        e[_H] != null && (r[_H] = (0, p.expectString)(e[_H])),
        e[EH] != null && (r[EH] = (0, p.expectString)(e[EH])),
        r
      );
    }, "de_Redirect"),
    Q1r = v((e, t) => {
      let r = {};
      return (
        e[kp] != null && (r[kp] = (0, p.expectString)(e[kp])),
        e[Mp] != null && (r[Mp] = (0, p.expectString)(e[Mp])),
        r
      );
    }, "de_RedirectAllRequestsTo"),
    Y1r = v((e, t) => {
      let r = {};
      return e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])), r;
    }, "de_ReplicaModifications"),
    X1r = v((e, t) => {
      let r = {};
      return (
        e[SH] != null && (r[SH] = (0, p.expectString)(e[SH])),
        e.Rule === ""
          ? (r[ws] = [])
          : e[zo] != null &&
            (r[ws] = tBr((0, p.getArrayIfSingleItem)(e[zo]), t)),
        r
      );
    }, "de_ReplicationConfiguration"),
    J1r = v((e, t) => {
      let r = {};
      return (
        e[rn] != null && (r[rn] = (0, p.expectString)(e[rn])),
        e[og] != null && (r[og] = (0, p.strictParseInt32)(e[og])),
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e[qe] != null && (r[qe] = eBr(e[qe], t)),
        e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])),
        e[Ng] != null && (r[Ng] = pBr(e[Ng], t)),
        e[gg] != null && (r[gg] = zFr(e[gg], t)),
        e[$n] != null && (r[$n] = jFr(e[$n], t)),
        e[dg] != null && (r[dg] = MFr(e[dg], t)),
        r
      );
    }, "de_ReplicationRule"),
    Z1r = v((e, t) => {
      let r = {};
      return (
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e.Tag === ""
          ? (r[fo] = [])
          : e[rt] != null &&
            (r[fo] = Fg((0, p.getArrayIfSingleItem)(e[rt]), t)),
        r
      );
    }, "de_ReplicationRuleAndOperator"),
    eBr = v((e, t) => {
      let r = {};
      return (
        e[re] != null && (r[re] = (0, p.expectString)(e[re])),
        e[rt] != null && (r[rt] = Gb(e[rt], t)),
        e[Nr] != null && (r[Nr] = Z1r(e[Nr], t)),
        r
      );
    }, "de_ReplicationRuleFilter"),
    tBr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => J1r(r, t)),
      "de_ReplicationRules",
    ),
    rBr = v((e, t) => {
      let r = {};
      return (
        e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])),
        e[Mb] != null && (r[Mb] = IZe(e[Mb], t)),
        r
      );
    }, "de_ReplicationTime"),
    IZe = v((e, t) => {
      let r = {};
      return e[ig] != null && (r[ig] = (0, p.strictParseInt32)(e[ig])), r;
    }, "de_ReplicationTimeValue"),
    xZe = v((e, t) => {
      let r = {};
      return (
        e[ste] != null && (r[ste] = (0, p.parseBoolean)(e[ste])),
        e[_te] != null &&
          (r[_te] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[_te]),
          )),
        r
      );
    }, "de_RestoreStatus"),
    nBr = v((e, t) => {
      let r = {};
      return (
        e[lg] != null && (r[lg] = TFr(e[lg], t)),
        e[Pg] != null && (r[Pg] = W1r(e[Pg], t)),
        r
      );
    }, "de_RoutingRule"),
    iBr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => nBr(r, t)),
      "de_RoutingRules",
    ),
    oBr = v((e, t) => {
      let r = {};
      return (
        e.FilterRule === ""
          ? (r[Ute] = [])
          : e[Bte] != null &&
            (r[Ute] = QFr((0, p.getArrayIfSingleItem)(e[Bte]), t)),
        r
      );
    }, "de_S3KeyFilter"),
    aBr = v((e, t) => {
      let r = {};
      return (
        e[Db] != null && (r[Db] = (0, p.expectString)(e[Db])),
        e[Lb] != null && (r[Lb] = (0, p.expectString)(e[Lb])),
        e[wte] != null && (r[wte] = (0, p.expectString)(e[wte])),
        e[Ote] != null && (r[Ote] = (0, p.expectString)(e[Ote])),
        r
      );
    }, "de_S3TablesDestinationResult"),
    sBr = v((e, t) => {
      let r = {};
      return (
        e[Nb] != null && (r[Nb] = (0, p.expectString)(e[Nb])),
        e[wb] != null && (r[wb] = (0, p.expectString)(e[wb])),
        r
      );
    }, "de_ServerSideEncryptionByDefault"),
    cBr = v((e, t) => {
      let r = {};
      return (
        e.Rule === ""
          ? (r[ws] = [])
          : e[zo] != null &&
            (r[ws] = lBr((0, p.getArrayIfSingleItem)(e[zo]), t)),
        r
      );
    }, "de_ServerSideEncryptionConfiguration"),
    uBr = v((e, t) => {
      let r = {};
      return (
        e[ab] != null && (r[ab] = sBr(e[ab], t)),
        e[xr] != null && (r[xr] = (0, p.parseBoolean)(e[xr])),
        r
      );
    }, "de_ServerSideEncryptionRule"),
    lBr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => uBr(r, t)),
      "de_ServerSideEncryptionRules",
    ),
    dBr = v((e, t) => {
      let r = {};
      return (
        e[Xee] != null && (r[Xee] = (0, p.expectString)(e[Xee])),
        e[Ete] != null && (r[Ete] = (0, p.expectString)(e[Ete])),
        e[bte] != null && (r[bte] = (0, p.expectString)(e[bte])),
        e[uo] != null &&
          (r[uo] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[uo]),
          )),
        r
      );
    }, "de_SessionCredentials"),
    fBr = v((e, t) => ({}), "de_SimplePrefix"),
    pBr = v((e, t) => {
      let r = {};
      return (
        e[Ig] != null && (r[Ig] = hBr(e[Ig], t)),
        e[Tg] != null && (r[Tg] = Y1r(e[Tg], t)),
        r
      );
    }, "de_SourceSelectionCriteria"),
    mBr = v((e, t) => {
      let r = {};
      return e[Cb] != null && (r[Cb] = (0, p.expectString)(e[Cb])), r;
    }, "de_SSEKMS"),
    hBr = v((e, t) => {
      let r = {};
      return e[ge] != null && (r[ge] = (0, p.expectString)(e[ge])), r;
    }, "de_SseKmsEncryptedObjects"),
    gBr = v((e, t) => ({}), "de_SSES3"),
    vBr = v((e, t) => {
      let r = {};
      return (
        e[pb] != null && (r[pb] = (0, p.strictParseLong)(e[pb])),
        e[ub] != null && (r[ub] = (0, p.strictParseLong)(e[ub])),
        e[fb] != null && (r[fb] = (0, p.strictParseLong)(e[fb])),
        r
      );
    }, "de_Stats"),
    yBr = v((e, t) => {
      let r = {};
      return e[hb] != null && (r[hb] = _Br(e[hb], t)), r;
    }, "de_StorageClassAnalysis"),
    _Br = v((e, t) => {
      let r = {};
      return (
        e[Pb] != null && (r[Pb] = (0, p.expectString)(e[Pb])),
        e[$n] != null && (r[$n] = EFr(e[$n], t)),
        r
      );
    }, "de_StorageClassAnalysisDataExport"),
    Gb = v((e, t) => {
      let r = {};
      return (
        e[ze] != null && (r[ze] = (0, p.expectString)(e[ze])),
        e[ya] != null && (r[ya] = (0, p.expectString)(e[ya])),
        r
      );
    }, "de_Tag"),
    Fg = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => Gb(r, t)),
      "de_TagSet",
    ),
    EBr = v((e, t) => {
      let r = {};
      return (
        e[va] != null && (r[va] = CZe(e[va], t)),
        e[ku] != null && (r[ku] = (0, p.expectString)(e[ku])),
        r
      );
    }, "de_TargetGrant"),
    bBr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => EBr(r, t)),
      "de_TargetGrants",
    ),
    SBr = v((e, t) => {
      let r = {};
      return (
        e[xg] != null && (r[xg] = fBr(e[xg], t)),
        e[wg] != null && (r[wg] = B1r(e[wg], t)),
        r
      );
    }, "de_TargetObjectKeyFormat"),
    CBr = v((e, t) => {
      let r = {};
      return (
        e[Dt] != null && (r[Dt] = (0, p.strictParseInt32)(e[Dt])),
        e[rd] != null && (r[rd] = (0, p.expectString)(e[rd])),
        r
      );
    }, "de_Tiering"),
    wBr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => CBr(r, t)),
      "de_TieringList",
    ),
    OBr = v((e, t) => {
      let r = {};
      return (
        e[je] != null && (r[je] = (0, p.expectString)(e[je])),
        e[sre] != null && (r[PH] = (0, p.expectString)(e[sre])),
        e.Event === ""
          ? (r[id] = [])
          : e[Lg] != null &&
            (r[id] = mre((0, p.getArrayIfSingleItem)(e[Lg]), t)),
        e[qe] != null && (r[qe] = hre(e[qe], t)),
        r
      );
    }, "de_TopicConfiguration"),
    TBr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => OBr(r, t)),
      "de_TopicConfigurationList",
    ),
    ABr = v((e, t) => {
      let r = {};
      return (
        e[co] != null &&
          (r[co] = (0, p.expectNonNull)(
            (0, p.parseRfc3339DateTimeWithOffset)(e[co]),
          )),
        e[Dt] != null && (r[Dt] = (0, p.strictParseInt32)(e[Dt])),
        e[st] != null && (r[st] = (0, p.expectString)(e[st])),
        r
      );
    }, "de_Transition"),
    PBr = v(
      (e, t) => (e || []).filter((r) => r != null).map((r) => ABr(r, t)),
      "de_TransitionList",
    ),
    V = v(
      (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }),
      "deserializeMetadata",
    ),
    RBr = v(
      (e, t) => (0, p.collectBody)(e, t).then((r) => t.utf8Encoder(r)),
      "collectBodyString",
    ),
    Nr = "And",
    IBr = "AnalyticsAndOperator",
    Pte = "AnalyticsConfiguration",
    Vb = "ACL",
    sg = "AccessControlList",
    O7e = "AnalyticsConfigurationList",
    xBr = "AccessControlPolicy",
    cg = "AccessControlTranslation",
    NBr = "AccelerateConfiguration",
    NZe = "AbortDate",
    kBr = "AnalyticsExportDestination",
    DBr = "AnalyticsFilter",
    Rte = "AllowedHeader",
    Ite = "AllowedHeaders",
    LBr = "AnalyticsId",
    ug = "AbortIncompleteMultipartUpload",
    ob = "AccountId",
    Xee = "AccessKeyId",
    xte = "AllowedMethod",
    Nte = "AllowedMethods",
    kte = "AllowedOrigin",
    Dte = "AllowedOrigins",
    MBr = "AccessPointAlias",
    td = "AccessPointArn",
    QU = "AllowQuotedRecordDelimiter",
    gre = "AcceptRanges",
    kZe = "AbortRuleId",
    qBr = "ArchiveStatus",
    jBr = "AnalyticsS3BucketDestination",
    FBr = "AnalyticsS3ExportFileFormat",
    ab = "ApplyServerSideEncryptionByDefault",
    rd = "AccessTier",
    sb = "Account",
    _t = "Bucket",
    cb = "BucketAccountId",
    BBr = "BucketAccelerateStatus",
    qb = "BypassGovernanceRetention",
    UBr = "BucketInfo",
    xr = "BucketKeyEnabled",
    HBr = "BucketLifecycleConfiguration",
    GBr = "BucketLocationConstraint",
    VBr = "BucketLocationName",
    $Br = "BucketLogsPermission",
    zBr = "BucketLoggingStatus",
    KBr = "BucketLocationType",
    XH = "BucketName",
    ub = "BytesProcessed",
    lb = "BlockPublicAcls",
    db = "BlockPublicPolicy",
    qT = "BucketRegion",
    fb = "BytesReturned",
    pb = "BytesScanned",
    WBr = "BucketType",
    QBr = "BucketVersioningStatus",
    xu = "Buckets",
    Jee = "Credentials",
    lt = "ChecksumAlgorithm",
    Zee = "CannedACL",
    YBr = "CreateBucketConfiguration",
    $b = "CacheControl",
    _r = "ChecksumCRC32",
    Er = "ChecksumCRC32C",
    br = "ChecksumCRC64NVME",
    zb = "ContentDisposition",
    ete = "CreationDate",
    Kb = "ContentEncoding",
    Lte = "CloudFunction",
    T7e = "CloudFunctionConfiguration",
    Wb = "ContentLanguage",
    qp = "ContentLength",
    DZe = "ChecksumMode",
    Mn = "ContentMD5",
    XBr = "CompletedMultipartUpload",
    JBr = "CORSConfiguration",
    Mte = "CORSRule",
    qte = "CORSRules",
    Qi = "CommonPrefixes",
    ZBr = "CompletedPart",
    vre = "ContentRange",
    A7e = "ConfirmRemoveSelfBucketAccess",
    LZe = "CopySource",
    Sr = "ChecksumSHA1",
    Cr = "ChecksumSHA256",
    MZe = "CopySourceIfMatch",
    MH = "CopySourceIfModifiedSince",
    qZe = "CopySourceIfNoneMatch",
    qH = "CopySourceIfUnmodifiedSince",
    eUr = "CopySourceRange",
    jZe = "CopySourceSSECustomerAlgorithm",
    FZe = "CopySourceSSECustomerKey",
    BZe = "CopySourceSSECustomerKeyMD5",
    mb = "CSV",
    UZe = "CopySourceVersionId",
    tUr = "CSVInput",
    rUr = "CSVOutput",
    wr = "ChecksumType",
    Qb = "ContentType",
    nUr = "CompressionType",
    sr = "ContinuationToken",
    tte = "Checksum",
    Np = "Contents",
    rte = "Code",
    iUr = "Comments",
    lg = "Condition",
    Yi = "Delimiter",
    eg = "DaysAfterInitiation",
    hb = "DataExport",
    uc = "DeleteMarker",
    dg = "DeleteMarkerReplication",
    oUr = "DeleteMarkerReplicationStatus",
    nte = "DeleteMarkerVersionId",
    P7e = "DeleteMarkers",
    lc = "DisplayName",
    aUr = "DataRedundancy",
    fg = "DefaultRetention",
    Dt = "Days",
    co = "Date",
    YU = "Deleted",
    sUr = "Delete",
    $n = "Destination",
    cUr = "Description",
    Du = "Expires",
    rH = "EmailAddress",
    pg = "EventBridgeConfiguration",
    ee = "ExpectedBucketOwner",
    nH = "ErrorCode",
    mg = "EncryptionConfiguration",
    hg = "ErrorDocument",
    jte = "ExposeHeaders",
    Fte = "ExposeHeader",
    iH = "ErrorMessage",
    tg = "ExpiredObjectDeleteMarker",
    gg = "ExistingObjectReplication",
    uUr = "ExistingObjectReplicationStatus",
    lUr = "EnableRequestProgress",
    HZe = "ExpiresString",
    GZe = "ExpectedSourceBucketOwner",
    dUr = "ExpirationStatus",
    Xi = "EncodingType",
    cr = "ETag",
    ite = "EncryptionType",
    gb = "EventThreshold",
    VZe = "ExpressionType",
    Nu = "Encryption",
    ote = "Enabled",
    XU = "End",
    jT = "Error",
    R7e = "Errors",
    Lg = "Event",
    id = "Events",
    $Ze = "Expression",
    uo = "Expiration",
    qe = "Filter",
    zZe = "FieldDelimiter",
    fUr = "FileHeaderInfo",
    pUr = "FetchOwner",
    Bte = "FilterRule",
    mUr = "FilterRuleName",
    hUr = "FilterRuleValue",
    Ute = "FilterRules",
    Hte = "Field",
    gs = "Format",
    vb = "Frequency",
    od = "Grant",
    Yb = "GrantFullControl",
    oH = "GlacierJobParameters",
    Xb = "GrantRead",
    Jb = "GrantReadACP",
    yre = "GrantWrite",
    Zb = "GrantWriteACP",
    BT = "Grants",
    va = "Grantee",
    aH = "HttpErrorCodeReturnedEquals",
    kp = "HostName",
    sH = "HttpRedirectCode",
    je = "Id",
    Gte = "InventoryConfiguration",
    I7e = "InventoryConfigurationList",
    vg = "IndexDocument",
    rn = "ID",
    gUr = "InventoryDestination",
    rg = "IsEnabled",
    vUr = "InventoryEncryption",
    yUr = "InventoryFilter",
    _Ur = "InventoryFormat",
    EUr = "InventoryFrequency",
    bUr = "InventoryId",
    SUr = "InventoryIncludedObjectVersions",
    yb = "IsLatest",
    HT = "IfMatch",
    x7e = "IfMatchInitiatedTime",
    N7e = "IfMatchLastModifiedTime",
    k7e = "IfMatchSize",
    jH = "IfModifiedSince",
    JH = "IfNoneMatch",
    CUr = "InventoryOptionalField",
    _b = "IncludedObjectVersions",
    ate = "IsPublic",
    Eb = "IgnorePublicAcls",
    ste = "IsRestoreInProgress",
    yg = "InputSerialization",
    wUr = "InventoryS3BucketDestination",
    OUr = "InventorySchedule",
    Xt = "IsTruncated",
    TUr = "IntelligentTieringAndOperator",
    AUr = "IntelligentTieringAccessTier",
    Vte = "IntelligentTieringConfiguration",
    D7e = "IntelligentTieringConfigurationList",
    PUr = "IntelligentTieringDays",
    RUr = "IntelligentTieringFilter",
    IUr = "IntelligentTieringId",
    xUr = "IntelligentTieringStatus",
    FH = "IfUnmodifiedSince",
    bb = "Initiator",
    cte = "Initiated",
    Sb = "JSON",
    NUr = "JSONInput",
    kUr = "JSONOutput",
    DUr = "JSONType",
    ze = "Key",
    ute = "KeyCount",
    Cb = "KeyId",
    Dp = "KeyMarker",
    LUr = "KMSContext",
    lte = "KMSKeyId",
    wb = "KMSMasterKeyID",
    cH = "KeyPrefixEquals",
    _g = "Location",
    Ob = "LocationConstraint",
    Eg = "LoggingEnabled",
    MUr = "LifecycleExpiration",
    uH = "LambdaFunctionArn",
    $te = "LambdaFunctionConfigurations",
    qUr = "LambdaFunctionConfiguration",
    jUr = "LocationInfo",
    nn = "LastModified",
    JU = "LastModifiedTime",
    FUr = "LocationNameAsString",
    BUr = "LocationPrefix",
    UUr = "LifecycleRule",
    HUr = "LifecycleRuleAndOperator",
    GUr = "LifecycleRuleFilter",
    VUr = "LocationType",
    lH = "Marker",
    $Ur = "MetricsAndOperator",
    ng = "MaxAgeSeconds",
    zUr = "MaxBuckets",
    zte = "MetricsConfiguration",
    L7e = "MetricsConfigurationList",
    KUr = "MetadataDirective",
    WUr = "MaxDirectoryBuckets",
    Kte = "MfaDelete",
    KZe = "MetadataEntry",
    QUr = "MetricsFilter",
    _re = "MFA",
    dH = "MFADelete",
    YUr = "MetricsId",
    vs = "MaxKeys",
    XUr = "MetadataKey",
    BH = "MissingMeta",
    M7e = "MpuObjectSize",
    nd = "MaxParts",
    JUr = "MetricsStatus",
    ZUr = "MetadataTableConfiguration",
    dte = "MetadataTableConfigurationResult",
    fH = "MaxUploads",
    eHr = "MetadataValue",
    bg = "Metrics",
    fte = "Message",
    ig = "Minutes",
    ys = "Mode",
    Qr = "Name",
    tHr = "NotificationConfiguration",
    rHr = "NotificationConfigurationFilter",
    lo = "NextContinuationToken",
    _s = "NoncurrentDays",
    Ere = "NotificationId",
    Tb = "NextKeyMarker",
    pte = "NextMarker",
    Es = "NewerNoncurrentVersions",
    Ab = "NextPartNumberMarker",
    mte = "NextUploadIdMarker",
    Sg = "NoncurrentVersionExpiration",
    hte = "NextVersionIdMarker",
    Wte = "NoncurrentVersionTransitions",
    Qte = "NoncurrentVersionTransition",
    Nt = "Owner",
    q7e = "ObjectAttributes",
    nHr = "OwnershipControls",
    iHr = "ObjectCannedACL",
    oHr = "OwnershipControlsRule",
    rb = "OptionalFields",
    aHr = "ObjectIdentifier",
    bre = "ObjectKey",
    pH = "OutputLocation",
    sHr = "ObjectLockConfiguration",
    mH = "ObjectLockEnabled",
    j7e = "ObjectLockEnabledForBucket",
    cHr = "ObjectLockLegalHold",
    Bg = "ObjectLockLegalHoldStatus",
    eS = "ObjectLockMode",
    uHr = "ObjectLockRetention",
    WZe = "ObjectLockRetentionMode",
    Lu = "ObjectLockRetainUntilDate",
    lHr = "ObjectLockRule",
    FT = "ObjectOwnership",
    jb = "OptionalObjectAttributes",
    dHr = "OwnerOverride",
    gte = "ObjectParts",
    Cg = "OutputSerialization",
    bs = "ObjectSizeGreaterThan",
    QZe = "ObjectSizeGreaterThanBytes",
    Ss = "ObjectSizeLessThan",
    YZe = "ObjectSizeLessThanBytes",
    Pb = "OutputSchemaVersion",
    vte = "ObjectSize",
    fHr = "ObjectVersionId",
    pHr = "Objects",
    re = "Prefix",
    mHr = "PublicAccessBlockConfiguration",
    Fb = "PartsCount",
    hH = "PartitionDateSource",
    hHr = "ParquetInput",
    $o = "PartNumber",
    Lp = "PartNumberMarker",
    wg = "PartitionedPrefix",
    gH = "Payer",
    UH = "Part",
    yte = "Parquet",
    UT = "Parts",
    ku = "Permission",
    Mp = "Protocol",
    og = "Priority",
    ZU = "Quiet",
    vH = "QueueArn",
    Yte = "QueueConfiguration",
    Xte = "QueueConfigurations",
    XZe = "QuoteCharacter",
    JZe = "QuoteEscapeCharacter",
    gHr = "QuoteFields",
    Jte = "Queue",
    ZZe = "Range",
    Og = "RedirectAllRequestsTo",
    Dr = "RequestCharged",
    eet = "ResponseCacheControl",
    tet = "ResponseContentDisposition",
    ret = "ResponseContentEncoding",
    net = "ResponseContentLanguage",
    iet = "ResponseContentType",
    vHr = "ReplicationConfiguration",
    Sre = "RecordDelimiter",
    oet = "ResponseExpires",
    _te = "RestoreExpiryDate",
    yH = "ReplicaKmsKeyID",
    _H = "ReplaceKeyPrefixWith",
    EH = "ReplaceKeyWith",
    Tg = "ReplicaModifications",
    yHr = "ReplicaModificationsStatus",
    _Hr = "RestoreOutputPath",
    nr = "RequestPayer",
    Rb = "RestrictPublicBuckets",
    EHr = "RequestPaymentConfiguration",
    bH = "RequestProgress",
    bHr = "RequestRoute",
    SHr = "ReplicationRuleAndOperator",
    CHr = "ReplicationRuleFilter",
    wHr = "ReplicationRuleStatus",
    OHr = "RestoreRequestType",
    THr = "ReplicationRule",
    AHr = "RestoreRequest",
    nb = "RoutingRules",
    HH = "RoutingRule",
    Cre = "ReplicationStatus",
    Ib = "RestoreStatus",
    PHr = "RequestToken",
    RHr = "ReplicationTimeStatus",
    IHr = "ReplicationTimeValue",
    Ag = "ReplicationTime",
    xb = "RetainUntilDate",
    wre = "Restore",
    Pg = "Redirect",
    SH = "Role",
    zo = "Rule",
    ws = "Rules",
    ge = "Status",
    CH = "StartAfter",
    Ete = "SecretAccessKey",
    Cs = "S3BucketDestination",
    st = "StorageClass",
    Rg = "StorageClassAnalysis",
    xHr = "StorageClassAnalysisDataExport",
    NHr = "StorageClassAnalysisSchemaVersion",
    F7e = "StatusCode",
    B7e = "SkipDestinationValidation",
    GH = "SSE-KMS",
    Ig = "SseKmsEncryptedObjects",
    kHr = "SseKmsEncryptedObjectsStatus",
    DHr = "S3KeyFilter",
    Zte = "S3Key",
    LHr = "S3Location",
    MHr = "SessionMode",
    qHr = "SelectObjectContentRequest",
    wH = "SelectParameters",
    xg = "SimplePrefix",
    OH = "ScanRange",
    VH = "SSE-S3",
    Ng = "SourceSelectionCriteria",
    Ji = "ServerSideEncryption",
    Nb = "SSEAlgorithm",
    jHr = "ServerSideEncryptionByDefault",
    FHr = "ServerSideEncryptionConfiguration",
    zn = "SSECustomerAlgorithm",
    dc = "SSECustomerKey",
    Kn = "SSECustomerKeyMD5",
    ere = "SSEKMS",
    Bp = "SSEKMSEncryptionContext",
    Li = "SSEKMSKeyId",
    BHr = "ServerSideEncryptionRule",
    tre = "SSES3",
    bte = "SessionToken",
    UHr = "S3TablesBucketArn",
    TH = "S3TablesDestination",
    Ste = "S3TablesDestinationResult",
    HHr = "S3TablesName",
    Cte = "S3",
    kb = "Schedule",
    eH = "Setting",
    Di = "Size",
    tH = "Start",
    AH = "Suffix",
    kg = "Tagging",
    PH = "TopicArn",
    wte = "TableArn",
    RH = "TargetBucket",
    Db = "TableBucketArn",
    rre = "TagCount",
    nre = "TopicConfiguration",
    ire = "TopicConfigurations",
    GHr = "TaggingDirective",
    Ore = "TransitionDefaultMinimumObjectSize",
    ib = "TargetGrants",
    VHr = "TargetGrant",
    Lb = "TableName",
    Ote = "TableNamespace",
    Dg = "TargetObjectKeyFormat",
    IH = "TargetPrefix",
    $Hr = "TotalPartsCount",
    cc = "TagSet",
    aet = "TransitionStorageClass",
    rt = "Tag",
    fo = "Tags",
    set = "Tier",
    ore = "Tierings",
    are = "Tiering",
    Mb = "Time",
    cet = "Token",
    sre = "Topic",
    cre = "Transitions",
    ure = "Transition",
    Ko = "Type",
    U7e = "Upload",
    Wo = "UploadId",
    xH = "UploadIdMarker",
    zHr = "UserMetadata",
    NH = "URI",
    H7e = "Uploads",
    G7e = "Version",
    uet = "VersionCount",
    KHr = "VersioningConfiguration",
    dt = "VersionId",
    kH = "VersionIdMarker",
    ya = "Value",
    V7e = "Versions",
    WHr = "WebsiteConfiguration",
    $7e = "WriteOffsetBytes",
    GT = "WebsiteRedirectLocation",
    ag = "Years",
    ZH = "analytics",
    det = "accelerate",
    e3 = "acl",
    fet = "accept-ranges",
    QHr = "attributes",
    YHr = "bucket-region",
    Tre = "cors",
    VT = "cache-control",
    $T = "content-disposition",
    zT = "content-encoding",
    KT = "content-language",
    Mg = "content-length",
    qn = "content-md5",
    pet = "content-range",
    WT = "content-type",
    Ug = "continuation-token",
    XHr = "delete",
    t3 = "delimiter",
    qg = "expires",
    Are = "encryption",
    r3 = "encoding-type",
    n3 = "etag",
    met = "expiresstring",
    JHr = "fetch-owner",
    Os = "id",
    QT = "if-match",
    het = "if-modified-since",
    i3 = "inventory",
    o3 = "if-none-match",
    a3 = "intelligent-tiering",
    get = "if-unmodified-since",
    vet = "key-marker",
    Pre = "lifecycle",
    yet = "legal-hold",
    Bb = "last-modified",
    _et = "location",
    Eet = "logging",
    ZHr = "list-type",
    s3 = "metrics",
    Rre = "metadataTable",
    e3r = "marker",
    t3r = "max-buckets",
    r3r = "max-directory-buckets",
    Wn = "member",
    Ire = "max-keys",
    n3r = "max-parts",
    i3r = "max-uploads",
    bet = "notification",
    xre = "ownershipControls",
    Cet = "object-lock",
    Nre = "policy",
    kre = "publicAccessBlock",
    c3 = "partNumber",
    o3r = "policyStatus",
    a3r = "part-number-marker",
    YT = "prefix",
    Dre = "replication",
    wet = "requestPayment",
    Oet = "range",
    Tet = "response-cache-control",
    Aet = "response-content-disposition",
    Pet = "response-content-encoding",
    Ret = "response-content-language",
    Iet = "response-content-type",
    xet = "response-expires",
    s3r = "restore",
    Net = "retention",
    c3r = "session",
    u3r = "start-after",
    l3r = "select",
    d3r = "select-type",
    tS = "tagging",
    f3r = "torrent",
    ket = "uploads",
    XT = "uploadId",
    p3r = "upload-id-marker",
    Det = "versioning",
    Qo = "versionId",
    ir = '<?xml version="1.0" encoding="UTF-8"?>',
    m3r = "versions",
    h3r = "version-id-marker",
    Lre = "website",
    z7e = "xsi:type",
    rS = "x-amz-acl",
    $H = "x-amz-abort-date",
    K7e = "x-amz-access-point-alias",
    Let = "x-amz-abort-rule-id",
    g3r = "x-amz-archive-status",
    Mre = "x-amz-bypass-governance-retention",
    v3r = "x-amz-bucket-location-name",
    y3r = "x-amz-bucket-location-type",
    _3r = "x-amz-bucket-object-lock-enabled",
    Met = "x-amz-bucket-object-lock-token",
    E3r = "x-amz-bucket-region",
    qre = "x-amz-checksum-algorithm",
    Hg = "x-amz-checksum-crc32",
    Gg = "x-amz-checksum-crc32c",
    Vg = "x-amz-checksum-crc64nvme",
    qet = "x-amz-checksum-mode",
    b3r = "x-amz-confirm-remove-self-bucket-access",
    $g = "x-amz-checksum-sha1",
    zg = "x-amz-checksum-sha256",
    jet = "x-amz-copy-source",
    Fet = "x-amz-copy-source-if-match",
    Bet = "x-amz-copy-source-if-modified-since",
    Uet = "x-amz-copy-source-if-none-match",
    Het = "x-amz-copy-source-if-unmodified-since",
    S3r = "x-amz-create-session-mode",
    C3r = "x-amz-copy-source-range",
    Get = "x-amz-copy-source-server-side-encryption-customer-algorithm",
    Vet = "x-amz-copy-source-server-side-encryption-customer-key",
    $et = "x-amz-copy-source-server-side-encryption-customer-key-md5",
    zet = "x-amz-copy-source-version-id",
    nS = "x-amz-checksum-type",
    jp = "x-amz-delete-marker",
    JT = "x-amz-expiration",
    te = "x-amz-expected-bucket-owner",
    w3r = "x-amz-fwd-error-code",
    O3r = "x-amz-fwd-error-message",
    T3r = "x-amz-fwd-header-accept-ranges",
    A3r = "x-amz-fwd-header-cache-control",
    P3r = "x-amz-fwd-header-content-disposition",
    R3r = "x-amz-fwd-header-content-encoding",
    I3r = "x-amz-fwd-header-content-language",
    x3r = "x-amz-fwd-header-content-range",
    N3r = "x-amz-fwd-header-content-type",
    k3r = "x-amz-fwd-header-etag",
    D3r = "x-amz-fwd-header-expires",
    L3r = "x-amz-fwd-header-last-modified",
    M3r = "x-amz-fwd-header-x-amz-checksum-crc32",
    q3r = "x-amz-fwd-header-x-amz-checksum-crc32c",
    j3r = "x-amz-fwd-header-x-amz-checksum-crc64nvme",
    F3r = "x-amz-fwd-header-x-amz-checksum-sha1",
    B3r = "x-amz-fwd-header-x-amz-checksum-sha256",
    U3r = "x-amz-fwd-header-x-amz-delete-marker",
    H3r = "x-amz-fwd-header-x-amz-expiration",
    G3r = "x-amz-fwd-header-x-amz-missing-meta",
    V3r = "x-amz-fwd-header-x-amz-mp-parts-count",
    $3r = "x-amz-fwd-header-x-amz-object-lock-legal-hold",
    z3r = "x-amz-fwd-header-x-amz-object-lock-mode",
    K3r = "x-amz-fwd-header-x-amz-object-lock-retain-until-date",
    W3r = "x-amz-fwd-header-x-amz-restore",
    Q3r = "x-amz-fwd-header-x-amz-request-charged",
    Y3r = "x-amz-fwd-header-x-amz-replication-status",
    X3r = "x-amz-fwd-header-x-amz-storage-class",
    J3r = "x-amz-fwd-header-x-amz-server-side-encryption",
    Z3r = "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id",
    eGr = "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled",
    tGr = "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm",
    rGr = "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-md5",
    nGr = "x-amz-fwd-header-x-amz-tagging-count",
    iGr = "x-amz-fwd-header-x-amz-version-id",
    oGr = "x-amz-fwd-status",
    iS = "x-amz-grant-full-control",
    oS = "x-amz-grant-read",
    aS = "x-amz-grant-read-acp",
    jre = "x-amz-grant-write",
    sS = "x-amz-grant-write-acp",
    aGr = "x-amz-if-match-initiated-time",
    sGr = "x-amz-if-match-last-modified-time",
    cGr = "x-amz-if-match-size",
    Fre = "x-amz-mfa",
    uGr = "x-amz-metadata-directive",
    zH = "x-amz-missing-meta",
    lGr = "x-amz-mp-object-size",
    dGr = "x-amz-max-parts",
    KH = "x-amz-mp-parts-count",
    fGr = "x-amz-object-attributes",
    ZT = "x-amz-object-lock-legal-hold",
    eA = "x-amz-object-lock-mode",
    jg = "x-amz-object-lock-retain-until-date",
    pGr = "x-amz-object-ownership",
    Bre = "x-amz-optional-object-attributes",
    W7e = "x-amz-object-size",
    mGr = "x-amz-part-number-marker",
    Ket = "x-amz-restore",
    Fr = "x-amz-request-charged",
    hGr = "x-amz-restore-output-path",
    or = "x-amz-request-payer",
    gGr = "x-amz-request-route",
    Wet = "x-amz-replication-status",
    vGr = "x-amz-request-token",
    tA = "x-amz-storage-class",
    on = "x-amz-sdk-checksum-algorithm",
    yGr = "x-amz-skip-destination-validation",
    Qet = "x-amz-source-expected-bucket-owner",
    _a = "x-amz-server-side-encryption",
    Ea = "x-amz-server-side-encryption-aws-kms-key-id",
    fn = "x-amz-server-side-encryption-bucket-key-enabled",
    Up = "x-amz-server-side-encryption-context",
    ui = "x-amz-server-side-encryption-customer-algorithm",
    fc = "x-amz-server-side-encryption-customer-key",
    li = "x-amz-server-side-encryption-customer-key-md5",
    Ure = "x-amz-tagging",
    Q7e = "x-amz-tagging-count",
    _Gr = "x-amz-tagging-directive",
    Hre = "x-amz-transition-default-minimum-object-size",
    Mu = "x-amz-version-id",
    EGr = "x-amz-write-offset-bytes",
    rA = "x-amz-website-redirect-location",
    di = "x-id",
    Gre = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        DisableS3ExpressSessionAuth: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, Nxr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "CreateSession", {})
      .n("S3Client", "CreateSessionCommand")
      .f(OJe, wJe)
      .ser(ZNr)
      .de(GDr)
      .build() {
      static {
        v(this, "CreateSessionCommand");
      }
    },
    bGr = o7e(),
    Y7e = tT(),
    SGr = v((e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        n = e.credentials;
      return {
        setHttpAuthScheme(i) {
          let o = t.findIndex((a) => a.schemeId === i.schemeId);
          o === -1 ? t.push(i) : t.splice(o, 1, i);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(i) {
          r = i;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(i) {
          n = i;
        },
        credentials() {
          return n;
        },
      };
    }, "getHttpAuthExtensionConfiguration"),
    CGr = v(
      (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }),
      "resolveHttpAuthRuntimeConfig",
    ),
    wGr = v((e, t) => {
      let r = Object.assign(
        (0, Y7e.getAwsRegionExtensionConfiguration)(e),
        (0, p.getDefaultExtensionConfiguration)(e),
        (0, Tte.getHttpHandlerExtensionConfiguration)(e),
        SGr(e),
      );
      return (
        t.forEach((n) => n.configure(r)),
        Object.assign(
          e,
          (0, Y7e.resolveAwsRegionExtensionConfiguration)(r),
          (0, p.resolveDefaultRuntimeConfig)(r),
          (0, Tte.resolveHttpHandlerRuntimeConfig)(r),
          CGr(r),
        )
      );
    }, "resolveRuntimeExtensions"),
    cS = class extends p.Client {
      static {
        v(this, "S3Client");
      }
      config;
      constructor(...[e]) {
        let t = (0, bGr.getRuntimeConfig)(e || {});
        super(t), (this.initConfig = t);
        let r = kxr(t),
          n = (0, S7e.resolveUserAgentConfig)(r),
          i = (0, kr.resolveFlexibleChecksumsConfig)(n),
          o = (0, C7e.resolveRetryConfig)(i),
          a = (0, Rxr.resolveRegionConfig)(o),
          s = (0, b7e.resolveHostHeaderConfig)(a),
          u = (0, W.resolveEndpointConfig)(s),
          l = (0, Ixr.resolveEventStreamSerdeConfig)(u),
          d = (0, w7e.resolveHttpAuthSchemeConfig)(l),
          f = (0, MT.resolveS3Config)(d, { session: [() => this, Gre] }),
          m = wGr(f, e?.extensions || []);
        (this.config = m),
          this.middlewareStack.use((0, S7e.getUserAgentPlugin)(this.config)),
          this.middlewareStack.use((0, C7e.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, xxr.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, b7e.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, Axr.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, Pxr.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use(
            (0, Yee.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
              httpAuthSchemeParametersProvider:
                w7e.defaultS3HttpAuthSchemeParametersProvider,
              identityProviderConfigProvider: v(
                async (h) =>
                  new Yee.DefaultIdentityProviderConfig({
                    "aws.auth#sigv4": h.credentials,
                    "aws.auth#sigv4a": h.credentials,
                  }),
                "identityProviderConfigProvider",
              ),
            }),
          ),
          this.middlewareStack.use((0, Yee.getHttpSigningPlugin)(this.config)),
          this.middlewareStack.use(
            (0, MT.getValidateBucketNamePlugin)(this.config),
          ),
          this.middlewareStack.use(
            (0, Txr.getAddExpectContinuePlugin)(this.config),
          ),
          this.middlewareStack.use(
            (0, MT.getRegionRedirectMiddlewarePlugin)(this.config),
          ),
          this.middlewareStack.use((0, MT.getS3ExpressPlugin)(this.config)),
          this.middlewareStack.use(
            (0, MT.getS3ExpressHttpSigningPlugin)(this.config),
          );
      }
      destroy() {
        super.destroy();
      }
    },
    OGr = Te(),
    Yet = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, OGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "AbortMultipartUpload", {})
      .n("S3Client", "AbortMultipartUploadCommand")
      .f(void 0, void 0)
      .ser(KNr)
      .de(qDr)
      .build() {
      static {
        v(this, "AbortMultipartUploadCommand");
      }
    },
    TGr = Te(),
    pc = u7e(),
    Xet = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, TGr.getThrow200ExceptionsPlugin)(r),
          (0, pc.getSsecPlugin)(r),
        ];
      })
      .s("AmazonS3", "CompleteMultipartUpload", {})
      .n("S3Client", "CompleteMultipartUploadCommand")
      .f(yJe, vJe)
      .ser(WNr)
      .de(jDr)
      .build() {
      static {
        v(this, "CompleteMultipartUploadCommand");
      }
    },
    AGr = Te(),
    Jet = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        DisableS3ExpressSessionAuth: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
        CopySource: { type: "contextParams", name: "CopySource" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, AGr.getThrow200ExceptionsPlugin)(r),
          (0, pc.getSsecPlugin)(r),
        ];
      })
      .s("AmazonS3", "CopyObject", {})
      .n("S3Client", "CopyObjectCommand")
      .f(EJe, _Je)
      .ser(QNr)
      .de(FDr)
      .build() {
      static {
        v(this, "CopyObjectCommand");
      }
    },
    PGr = p7e(),
    RGr = Te(),
    Zet = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        DisableAccessPoints: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, RGr.getThrow200ExceptionsPlugin)(r),
          (0, PGr.getLocationConstraintPlugin)(r),
        ];
      })
      .s("AmazonS3", "CreateBucket", {})
      .n("S3Client", "CreateBucketCommand")
      .f(void 0, void 0)
      .ser(YNr)
      .de(BDr)
      .build() {
      static {
        v(this, "CreateBucketCommand");
      }
    },
    ett = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "CreateBucketMetadataTableConfiguration", {})
      .n("S3Client", "CreateBucketMetadataTableConfigurationCommand")
      .f(void 0, void 0)
      .ser(XNr)
      .de(UDr)
      .build() {
      static {
        v(this, "CreateBucketMetadataTableConfigurationCommand");
      }
    },
    IGr = Te(),
    ttt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, IGr.getThrow200ExceptionsPlugin)(r),
          (0, pc.getSsecPlugin)(r),
        ];
      })
      .s("AmazonS3", "CreateMultipartUpload", {})
      .n("S3Client", "CreateMultipartUploadCommand")
      .f(SJe, bJe)
      .ser(JNr)
      .de(HDr)
      .build() {
      static {
        v(this, "CreateMultipartUploadCommand");
      }
    },
    rtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketAnalyticsConfiguration", {})
      .n("S3Client", "DeleteBucketAnalyticsConfigurationCommand")
      .f(void 0, void 0)
      .ser(tkr)
      .de($Dr)
      .build() {
      static {
        v(this, "DeleteBucketAnalyticsConfigurationCommand");
      }
    },
    ntt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucket", {})
      .n("S3Client", "DeleteBucketCommand")
      .f(void 0, void 0)
      .ser(ekr)
      .de(VDr)
      .build() {
      static {
        v(this, "DeleteBucketCommand");
      }
    },
    itt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketCors", {})
      .n("S3Client", "DeleteBucketCorsCommand")
      .f(void 0, void 0)
      .ser(rkr)
      .de(zDr)
      .build() {
      static {
        v(this, "DeleteBucketCorsCommand");
      }
    },
    ott = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketEncryption", {})
      .n("S3Client", "DeleteBucketEncryptionCommand")
      .f(void 0, void 0)
      .ser(nkr)
      .de(KDr)
      .build() {
      static {
        v(this, "DeleteBucketEncryptionCommand");
      }
    },
    att = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketIntelligentTieringConfiguration", {})
      .n("S3Client", "DeleteBucketIntelligentTieringConfigurationCommand")
      .f(void 0, void 0)
      .ser(ikr)
      .de(WDr)
      .build() {
      static {
        v(this, "DeleteBucketIntelligentTieringConfigurationCommand");
      }
    },
    stt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketInventoryConfiguration", {})
      .n("S3Client", "DeleteBucketInventoryConfigurationCommand")
      .f(void 0, void 0)
      .ser(okr)
      .de(QDr)
      .build() {
      static {
        v(this, "DeleteBucketInventoryConfigurationCommand");
      }
    },
    ctt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketLifecycle", {})
      .n("S3Client", "DeleteBucketLifecycleCommand")
      .f(void 0, void 0)
      .ser(akr)
      .de(YDr)
      .build() {
      static {
        v(this, "DeleteBucketLifecycleCommand");
      }
    },
    utt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketMetadataTableConfiguration", {})
      .n("S3Client", "DeleteBucketMetadataTableConfigurationCommand")
      .f(void 0, void 0)
      .ser(skr)
      .de(XDr)
      .build() {
      static {
        v(this, "DeleteBucketMetadataTableConfigurationCommand");
      }
    },
    ltt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketMetricsConfiguration", {})
      .n("S3Client", "DeleteBucketMetricsConfigurationCommand")
      .f(void 0, void 0)
      .ser(ckr)
      .de(JDr)
      .build() {
      static {
        v(this, "DeleteBucketMetricsConfigurationCommand");
      }
    },
    dtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketOwnershipControls", {})
      .n("S3Client", "DeleteBucketOwnershipControlsCommand")
      .f(void 0, void 0)
      .ser(ukr)
      .de(ZDr)
      .build() {
      static {
        v(this, "DeleteBucketOwnershipControlsCommand");
      }
    },
    ftt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketPolicy", {})
      .n("S3Client", "DeleteBucketPolicyCommand")
      .f(void 0, void 0)
      .ser(lkr)
      .de(eLr)
      .build() {
      static {
        v(this, "DeleteBucketPolicyCommand");
      }
    },
    ptt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketReplication", {})
      .n("S3Client", "DeleteBucketReplicationCommand")
      .f(void 0, void 0)
      .ser(dkr)
      .de(tLr)
      .build() {
      static {
        v(this, "DeleteBucketReplicationCommand");
      }
    },
    mtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketTagging", {})
      .n("S3Client", "DeleteBucketTaggingCommand")
      .f(void 0, void 0)
      .ser(fkr)
      .de(rLr)
      .build() {
      static {
        v(this, "DeleteBucketTaggingCommand");
      }
    },
    htt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeleteBucketWebsite", {})
      .n("S3Client", "DeleteBucketWebsiteCommand")
      .f(void 0, void 0)
      .ser(pkr)
      .de(nLr)
      .build() {
      static {
        v(this, "DeleteBucketWebsiteCommand");
      }
    },
    xGr = Te(),
    gtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, xGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "DeleteObject", {})
      .n("S3Client", "DeleteObjectCommand")
      .f(void 0, void 0)
      .ser(mkr)
      .de(iLr)
      .build() {
      static {
        v(this, "DeleteObjectCommand");
      }
    },
    NGr = Te(),
    vtt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
          (0, NGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "DeleteObjects", {})
      .n("S3Client", "DeleteObjectsCommand")
      .f(void 0, void 0)
      .ser(hkr)
      .de(oLr)
      .build() {
      static {
        v(this, "DeleteObjectsCommand");
      }
    },
    kGr = Te(),
    ytt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "DeleteObjectTagging", {})
      .n("S3Client", "DeleteObjectTaggingCommand")
      .f(void 0, void 0)
      .ser(gkr)
      .de(aLr)
      .build() {
      static {
        v(this, "DeleteObjectTaggingCommand");
      }
    },
    _tt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "DeletePublicAccessBlock", {})
      .n("S3Client", "DeletePublicAccessBlockCommand")
      .f(void 0, void 0)
      .ser(vkr)
      .de(sLr)
      .build() {
      static {
        v(this, "DeletePublicAccessBlockCommand");
      }
    },
    DGr = Te(),
    Ett = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, DGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketAccelerateConfiguration", {})
      .n("S3Client", "GetBucketAccelerateConfigurationCommand")
      .f(void 0, void 0)
      .ser(ykr)
      .de(cLr)
      .build() {
      static {
        v(this, "GetBucketAccelerateConfigurationCommand");
      }
    },
    LGr = Te(),
    btt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, LGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketAcl", {})
      .n("S3Client", "GetBucketAclCommand")
      .f(void 0, void 0)
      .ser(_kr)
      .de(uLr)
      .build() {
      static {
        v(this, "GetBucketAclCommand");
      }
    },
    MGr = Te(),
    Stt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, MGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketAnalyticsConfiguration", {})
      .n("S3Client", "GetBucketAnalyticsConfigurationCommand")
      .f(void 0, void 0)
      .ser(Ekr)
      .de(lLr)
      .build() {
      static {
        v(this, "GetBucketAnalyticsConfigurationCommand");
      }
    },
    qGr = Te(),
    Ctt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, qGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketCors", {})
      .n("S3Client", "GetBucketCorsCommand")
      .f(void 0, void 0)
      .ser(bkr)
      .de(dLr)
      .build() {
      static {
        v(this, "GetBucketCorsCommand");
      }
    },
    jGr = Te(),
    wtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, jGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketEncryption", {})
      .n("S3Client", "GetBucketEncryptionCommand")
      .f(void 0, PJe)
      .ser(Skr)
      .de(fLr)
      .build() {
      static {
        v(this, "GetBucketEncryptionCommand");
      }
    },
    FGr = Te(),
    Ott = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, FGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketIntelligentTieringConfiguration", {})
      .n("S3Client", "GetBucketIntelligentTieringConfigurationCommand")
      .f(void 0, void 0)
      .ser(Ckr)
      .de(pLr)
      .build() {
      static {
        v(this, "GetBucketIntelligentTieringConfigurationCommand");
      }
    },
    BGr = Te(),
    Ttt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, BGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketInventoryConfiguration", {})
      .n("S3Client", "GetBucketInventoryConfigurationCommand")
      .f(void 0, kJe)
      .ser(wkr)
      .de(mLr)
      .build() {
      static {
        v(this, "GetBucketInventoryConfigurationCommand");
      }
    },
    UGr = Te(),
    Att = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, UGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketLifecycleConfiguration", {})
      .n("S3Client", "GetBucketLifecycleConfigurationCommand")
      .f(void 0, void 0)
      .ser(Okr)
      .de(hLr)
      .build() {
      static {
        v(this, "GetBucketLifecycleConfigurationCommand");
      }
    },
    HGr = Te(),
    Ptt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, HGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketLocation", {})
      .n("S3Client", "GetBucketLocationCommand")
      .f(void 0, void 0)
      .ser(Tkr)
      .de(gLr)
      .build() {
      static {
        v(this, "GetBucketLocationCommand");
      }
    },
    GGr = Te(),
    Rtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, GGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketLogging", {})
      .n("S3Client", "GetBucketLoggingCommand")
      .f(void 0, void 0)
      .ser(Akr)
      .de(vLr)
      .build() {
      static {
        v(this, "GetBucketLoggingCommand");
      }
    },
    VGr = Te(),
    Itt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, VGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketMetadataTableConfiguration", {})
      .n("S3Client", "GetBucketMetadataTableConfigurationCommand")
      .f(void 0, void 0)
      .ser(Pkr)
      .de(yLr)
      .build() {
      static {
        v(this, "GetBucketMetadataTableConfigurationCommand");
      }
    },
    $Gr = Te(),
    xtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, $Gr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketMetricsConfiguration", {})
      .n("S3Client", "GetBucketMetricsConfigurationCommand")
      .f(void 0, void 0)
      .ser(Rkr)
      .de(_Lr)
      .build() {
      static {
        v(this, "GetBucketMetricsConfigurationCommand");
      }
    },
    zGr = Te(),
    Ntt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, zGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketNotificationConfiguration", {})
      .n("S3Client", "GetBucketNotificationConfigurationCommand")
      .f(void 0, void 0)
      .ser(Ikr)
      .de(ELr)
      .build() {
      static {
        v(this, "GetBucketNotificationConfigurationCommand");
      }
    },
    KGr = Te(),
    ktt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, KGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketOwnershipControls", {})
      .n("S3Client", "GetBucketOwnershipControlsCommand")
      .f(void 0, void 0)
      .ser(xkr)
      .de(bLr)
      .build() {
      static {
        v(this, "GetBucketOwnershipControlsCommand");
      }
    },
    WGr = Te(),
    Dtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, WGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketPolicy", {})
      .n("S3Client", "GetBucketPolicyCommand")
      .f(void 0, void 0)
      .ser(Nkr)
      .de(SLr)
      .build() {
      static {
        v(this, "GetBucketPolicyCommand");
      }
    },
    QGr = Te(),
    Ltt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, QGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketPolicyStatus", {})
      .n("S3Client", "GetBucketPolicyStatusCommand")
      .f(void 0, void 0)
      .ser(kkr)
      .de(CLr)
      .build() {
      static {
        v(this, "GetBucketPolicyStatusCommand");
      }
    },
    YGr = Te(),
    Mtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, YGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketReplication", {})
      .n("S3Client", "GetBucketReplicationCommand")
      .f(void 0, void 0)
      .ser(Dkr)
      .de(wLr)
      .build() {
      static {
        v(this, "GetBucketReplicationCommand");
      }
    },
    XGr = Te(),
    qtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, XGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketRequestPayment", {})
      .n("S3Client", "GetBucketRequestPaymentCommand")
      .f(void 0, void 0)
      .ser(Lkr)
      .de(OLr)
      .build() {
      static {
        v(this, "GetBucketRequestPaymentCommand");
      }
    },
    JGr = Te(),
    jtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, JGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketTagging", {})
      .n("S3Client", "GetBucketTaggingCommand")
      .f(void 0, void 0)
      .ser(Mkr)
      .de(TLr)
      .build() {
      static {
        v(this, "GetBucketTaggingCommand");
      }
    },
    ZGr = Te(),
    Ftt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, ZGr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketVersioning", {})
      .n("S3Client", "GetBucketVersioningCommand")
      .f(void 0, void 0)
      .ser(qkr)
      .de(ALr)
      .build() {
      static {
        v(this, "GetBucketVersioningCommand");
      }
    },
    eVr = Te(),
    Btt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, eVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetBucketWebsite", {})
      .n("S3Client", "GetBucketWebsiteCommand")
      .f(void 0, void 0)
      .ser(jkr)
      .de(PLr)
      .build() {
      static {
        v(this, "GetBucketWebsiteCommand");
      }
    },
    tVr = Te(),
    Utt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, tVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetObjectAcl", {})
      .n("S3Client", "GetObjectAclCommand")
      .f(void 0, void 0)
      .ser(Bkr)
      .de(ILr)
      .build() {
      static {
        v(this, "GetObjectAclCommand");
      }
    },
    rVr = Te(),
    Htt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, rVr.getThrow200ExceptionsPlugin)(r),
          (0, pc.getSsecPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetObjectAttributes", {})
      .n("S3Client", "GetObjectAttributesCommand")
      .f(MJe, void 0)
      .ser(Ukr)
      .de(xLr)
      .build() {
      static {
        v(this, "GetObjectAttributesCommand");
      }
    },
    nVr = Te(),
    Gtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestChecksumRequired: !1,
            requestValidationModeMember: "ChecksumMode",
            responseAlgorithms: [
              "CRC64NVME",
              "CRC32",
              "CRC32C",
              "SHA256",
              "SHA1",
            ],
          }),
          (0, pc.getSsecPlugin)(r),
          (0, nVr.getS3ExpiresMiddlewarePlugin)(r),
        ];
      })
      .s("AmazonS3", "GetObject", {})
      .n("S3Client", "GetObjectCommand")
      .f(LJe, DJe)
      .ser(Fkr)
      .de(RLr)
      .build() {
      static {
        v(this, "GetObjectCommand");
      }
    },
    iVr = Te(),
    Vtt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, iVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetObjectLegalHold", {})
      .n("S3Client", "GetObjectLegalHoldCommand")
      .f(void 0, void 0)
      .ser(Hkr)
      .de(NLr)
      .build() {
      static {
        v(this, "GetObjectLegalHoldCommand");
      }
    },
    oVr = Te(),
    $tt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, oVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetObjectLockConfiguration", {})
      .n("S3Client", "GetObjectLockConfigurationCommand")
      .f(void 0, void 0)
      .ser(Gkr)
      .de(kLr)
      .build() {
      static {
        v(this, "GetObjectLockConfigurationCommand");
      }
    },
    aVr = Te(),
    ztt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, aVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetObjectRetention", {})
      .n("S3Client", "GetObjectRetentionCommand")
      .f(void 0, void 0)
      .ser(Vkr)
      .de(DLr)
      .build() {
      static {
        v(this, "GetObjectRetentionCommand");
      }
    },
    sVr = Te(),
    Ktt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, sVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetObjectTagging", {})
      .n("S3Client", "GetObjectTaggingCommand")
      .f(void 0, void 0)
      .ser($kr)
      .de(LLr)
      .build() {
      static {
        v(this, "GetObjectTaggingCommand");
      }
    },
    Wtt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "GetObjectTorrent", {})
      .n("S3Client", "GetObjectTorrentCommand")
      .f(void 0, qJe)
      .ser(zkr)
      .de(MLr)
      .build() {
      static {
        v(this, "GetObjectTorrentCommand");
      }
    },
    cVr = Te(),
    Qtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, cVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "GetPublicAccessBlock", {})
      .n("S3Client", "GetPublicAccessBlockCommand")
      .f(void 0, void 0)
      .ser(Kkr)
      .de(qLr)
      .build() {
      static {
        v(this, "GetPublicAccessBlockCommand");
      }
    },
    uVr = Te(),
    u3 = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, uVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "HeadBucket", {})
      .n("S3Client", "HeadBucketCommand")
      .f(void 0, void 0)
      .ser(Wkr)
      .de(jLr)
      .build() {
      static {
        v(this, "HeadBucketCommand");
      }
    },
    X7e = Te(),
    l3 = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, X7e.getThrow200ExceptionsPlugin)(r),
          (0, pc.getSsecPlugin)(r),
          (0, X7e.getS3ExpiresMiddlewarePlugin)(r),
        ];
      })
      .s("AmazonS3", "HeadObject", {})
      .n("S3Client", "HeadObjectCommand")
      .f(FJe, jJe)
      .ser(Qkr)
      .de(FLr)
      .build() {
      static {
        v(this, "HeadObjectCommand");
      }
    },
    lVr = Te(),
    Ytt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, lVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListBucketAnalyticsConfigurations", {})
      .n("S3Client", "ListBucketAnalyticsConfigurationsCommand")
      .f(void 0, void 0)
      .ser(Ykr)
      .de(BLr)
      .build() {
      static {
        v(this, "ListBucketAnalyticsConfigurationsCommand");
      }
    },
    dVr = Te(),
    Xtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, dVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListBucketIntelligentTieringConfigurations", {})
      .n("S3Client", "ListBucketIntelligentTieringConfigurationsCommand")
      .f(void 0, void 0)
      .ser(Xkr)
      .de(ULr)
      .build() {
      static {
        v(this, "ListBucketIntelligentTieringConfigurationsCommand");
      }
    },
    fVr = Te(),
    Jtt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, fVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListBucketInventoryConfigurations", {})
      .n("S3Client", "ListBucketInventoryConfigurationsCommand")
      .f(void 0, BJe)
      .ser(Jkr)
      .de(HLr)
      .build() {
      static {
        v(this, "ListBucketInventoryConfigurationsCommand");
      }
    },
    pVr = Te(),
    Ztt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, pVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListBucketMetricsConfigurations", {})
      .n("S3Client", "ListBucketMetricsConfigurationsCommand")
      .f(void 0, void 0)
      .ser(Zkr)
      .de(GLr)
      .build() {
      static {
        v(this, "ListBucketMetricsConfigurationsCommand");
      }
    },
    mVr = Te(),
    Vre = class extends p.Command.classBuilder()
      .ep(Y)
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, mVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListBuckets", {})
      .n("S3Client", "ListBucketsCommand")
      .f(void 0, void 0)
      .ser(eDr)
      .de(VLr)
      .build() {
      static {
        v(this, "ListBucketsCommand");
      }
    },
    hVr = Te(),
    $re = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, hVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListDirectoryBuckets", {})
      .n("S3Client", "ListDirectoryBucketsCommand")
      .f(void 0, void 0)
      .ser(tDr)
      .de($Lr)
      .build() {
      static {
        v(this, "ListDirectoryBucketsCommand");
      }
    },
    gVr = Te(),
    ert = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Prefix: { type: "contextParams", name: "Prefix" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, gVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListMultipartUploads", {})
      .n("S3Client", "ListMultipartUploadsCommand")
      .f(void 0, void 0)
      .ser(rDr)
      .de(zLr)
      .build() {
      static {
        v(this, "ListMultipartUploadsCommand");
      }
    },
    vVr = Te(),
    trt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Prefix: { type: "contextParams", name: "Prefix" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, vVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListObjects", {})
      .n("S3Client", "ListObjectsCommand")
      .f(void 0, void 0)
      .ser(nDr)
      .de(KLr)
      .build() {
      static {
        v(this, "ListObjectsCommand");
      }
    },
    yVr = Te(),
    zre = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Prefix: { type: "contextParams", name: "Prefix" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, yVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListObjectsV2", {})
      .n("S3Client", "ListObjectsV2Command")
      .f(void 0, void 0)
      .ser(iDr)
      .de(WLr)
      .build() {
      static {
        v(this, "ListObjectsV2Command");
      }
    },
    _Vr = Te(),
    rrt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Prefix: { type: "contextParams", name: "Prefix" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, _Vr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListObjectVersions", {})
      .n("S3Client", "ListObjectVersionsCommand")
      .f(void 0, void 0)
      .ser(oDr)
      .de(QLr)
      .build() {
      static {
        v(this, "ListObjectVersionsCommand");
      }
    },
    EVr = Te(),
    Kre = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, EVr.getThrow200ExceptionsPlugin)(r),
          (0, pc.getSsecPlugin)(r),
        ];
      })
      .s("AmazonS3", "ListParts", {})
      .n("S3Client", "ListPartsCommand")
      .f(UJe, void 0)
      .ser(aDr)
      .de(YLr)
      .build() {
      static {
        v(this, "ListPartsCommand");
      }
    },
    nrt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !1,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketAccelerateConfiguration", {})
      .n("S3Client", "PutBucketAccelerateConfigurationCommand")
      .f(void 0, void 0)
      .ser(sDr)
      .de(XLr)
      .build() {
      static {
        v(this, "PutBucketAccelerateConfigurationCommand");
      }
    },
    irt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketAcl", {})
      .n("S3Client", "PutBucketAclCommand")
      .f(void 0, void 0)
      .ser(cDr)
      .de(JLr)
      .build() {
      static {
        v(this, "PutBucketAclCommand");
      }
    },
    ort = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "PutBucketAnalyticsConfiguration", {})
      .n("S3Client", "PutBucketAnalyticsConfigurationCommand")
      .f(void 0, void 0)
      .ser(uDr)
      .de(ZLr)
      .build() {
      static {
        v(this, "PutBucketAnalyticsConfigurationCommand");
      }
    },
    art = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketCors", {})
      .n("S3Client", "PutBucketCorsCommand")
      .f(void 0, void 0)
      .ser(lDr)
      .de(eMr)
      .build() {
      static {
        v(this, "PutBucketCorsCommand");
      }
    },
    srt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketEncryption", {})
      .n("S3Client", "PutBucketEncryptionCommand")
      .f(JJe, void 0)
      .ser(dDr)
      .de(tMr)
      .build() {
      static {
        v(this, "PutBucketEncryptionCommand");
      }
    },
    crt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "PutBucketIntelligentTieringConfiguration", {})
      .n("S3Client", "PutBucketIntelligentTieringConfigurationCommand")
      .f(void 0, void 0)
      .ser(fDr)
      .de(rMr)
      .build() {
      static {
        v(this, "PutBucketIntelligentTieringConfigurationCommand");
      }
    },
    urt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "PutBucketInventoryConfiguration", {})
      .n("S3Client", "PutBucketInventoryConfigurationCommand")
      .f(ZJe, void 0)
      .ser(pDr)
      .de(nMr)
      .build() {
      static {
        v(this, "PutBucketInventoryConfigurationCommand");
      }
    },
    bVr = Te(),
    lrt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
          (0, bVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "PutBucketLifecycleConfiguration", {})
      .n("S3Client", "PutBucketLifecycleConfigurationCommand")
      .f(void 0, void 0)
      .ser(mDr)
      .de(iMr)
      .build() {
      static {
        v(this, "PutBucketLifecycleConfigurationCommand");
      }
    },
    drt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketLogging", {})
      .n("S3Client", "PutBucketLoggingCommand")
      .f(void 0, void 0)
      .ser(hDr)
      .de(oMr)
      .build() {
      static {
        v(this, "PutBucketLoggingCommand");
      }
    },
    frt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "PutBucketMetricsConfiguration", {})
      .n("S3Client", "PutBucketMetricsConfigurationCommand")
      .f(void 0, void 0)
      .ser(gDr)
      .de(aMr)
      .build() {
      static {
        v(this, "PutBucketMetricsConfigurationCommand");
      }
    },
    prt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "PutBucketNotificationConfiguration", {})
      .n("S3Client", "PutBucketNotificationConfigurationCommand")
      .f(void 0, void 0)
      .ser(vDr)
      .de(sMr)
      .build() {
      static {
        v(this, "PutBucketNotificationConfigurationCommand");
      }
    },
    mrt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketOwnershipControls", {})
      .n("S3Client", "PutBucketOwnershipControlsCommand")
      .f(void 0, void 0)
      .ser(yDr)
      .de(cMr)
      .build() {
      static {
        v(this, "PutBucketOwnershipControlsCommand");
      }
    },
    hrt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketPolicy", {})
      .n("S3Client", "PutBucketPolicyCommand")
      .f(void 0, void 0)
      .ser(_Dr)
      .de(uMr)
      .build() {
      static {
        v(this, "PutBucketPolicyCommand");
      }
    },
    grt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketReplication", {})
      .n("S3Client", "PutBucketReplicationCommand")
      .f(void 0, void 0)
      .ser(EDr)
      .de(lMr)
      .build() {
      static {
        v(this, "PutBucketReplicationCommand");
      }
    },
    vrt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketRequestPayment", {})
      .n("S3Client", "PutBucketRequestPaymentCommand")
      .f(void 0, void 0)
      .ser(bDr)
      .de(dMr)
      .build() {
      static {
        v(this, "PutBucketRequestPaymentCommand");
      }
    },
    yrt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketTagging", {})
      .n("S3Client", "PutBucketTaggingCommand")
      .f(void 0, void 0)
      .ser(SDr)
      .de(fMr)
      .build() {
      static {
        v(this, "PutBucketTaggingCommand");
      }
    },
    _rt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketVersioning", {})
      .n("S3Client", "PutBucketVersioningCommand")
      .f(void 0, void 0)
      .ser(CDr)
      .de(pMr)
      .build() {
      static {
        v(this, "PutBucketVersioningCommand");
      }
    },
    Ert = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutBucketWebsite", {})
      .n("S3Client", "PutBucketWebsiteCommand")
      .f(void 0, void 0)
      .ser(wDr)
      .de(mMr)
      .build() {
      static {
        v(this, "PutBucketWebsiteCommand");
      }
    },
    SVr = Te(),
    brt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
          (0, SVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "PutObjectAcl", {})
      .n("S3Client", "PutObjectAclCommand")
      .f(void 0, void 0)
      .ser(TDr)
      .de(gMr)
      .build() {
      static {
        v(this, "PutObjectAclCommand");
      }
    },
    J7e = Te(),
    Srt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !1,
          }),
          (0, J7e.getCheckContentLengthHeaderPlugin)(r),
          (0, J7e.getThrow200ExceptionsPlugin)(r),
          (0, pc.getSsecPlugin)(r),
        ];
      })
      .s("AmazonS3", "PutObject", {})
      .n("S3Client", "PutObjectCommand")
      .f(tZe, eZe)
      .ser(ODr)
      .de(hMr)
      .build() {
      static {
        v(this, "PutObjectCommand");
      }
    },
    CVr = Te(),
    Crt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
          (0, CVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "PutObjectLegalHold", {})
      .n("S3Client", "PutObjectLegalHoldCommand")
      .f(void 0, void 0)
      .ser(ADr)
      .de(vMr)
      .build() {
      static {
        v(this, "PutObjectLegalHoldCommand");
      }
    },
    wVr = Te(),
    wrt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
          (0, wVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "PutObjectLockConfiguration", {})
      .n("S3Client", "PutObjectLockConfigurationCommand")
      .f(void 0, void 0)
      .ser(PDr)
      .de(yMr)
      .build() {
      static {
        v(this, "PutObjectLockConfigurationCommand");
      }
    },
    OVr = Te(),
    Ort = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
          (0, OVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "PutObjectRetention", {})
      .n("S3Client", "PutObjectRetentionCommand")
      .f(void 0, void 0)
      .ser(RDr)
      .de(_Mr)
      .build() {
      static {
        v(this, "PutObjectRetentionCommand");
      }
    },
    TVr = Te(),
    Trt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
          (0, TVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "PutObjectTagging", {})
      .n("S3Client", "PutObjectTaggingCommand")
      .f(void 0, void 0)
      .ser(IDr)
      .de(EMr)
      .build() {
      static {
        v(this, "PutObjectTaggingCommand");
      }
    },
    Art = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !0,
          }),
        ];
      })
      .s("AmazonS3", "PutPublicAccessBlock", {})
      .n("S3Client", "PutPublicAccessBlockCommand")
      .f(void 0, void 0)
      .ser(xDr)
      .de(bMr)
      .build() {
      static {
        v(this, "PutPublicAccessBlockCommand");
      }
    },
    AVr = Te(),
    Prt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !1,
          }),
          (0, AVr.getThrow200ExceptionsPlugin)(r),
        ];
      })
      .s("AmazonS3", "RestoreObject", {})
      .n("S3Client", "RestoreObjectCommand")
      .f(aZe, void 0)
      .ser(NDr)
      .de(SMr)
      .build() {
      static {
        v(this, "RestoreObjectCommand");
      }
    },
    PVr = Te(),
    Rrt = class extends p.Command.classBuilder()
      .ep({ ...Y, Bucket: { type: "contextParams", name: "Bucket" } })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, PVr.getThrow200ExceptionsPlugin)(r),
          (0, pc.getSsecPlugin)(r),
        ];
      })
      .s("AmazonS3", "SelectObjectContent", { eventStream: { output: !0 } })
      .n("S3Client", "SelectObjectContentCommand")
      .f(cZe, sZe)
      .ser(kDr)
      .de(CMr)
      .build() {
      static {
        v(this, "SelectObjectContentCommand");
      }
    },
    RVr = Te(),
    Irt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        Bucket: { type: "contextParams", name: "Bucket" },
        Key: { type: "contextParams", name: "Key" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, kr.getFlexibleChecksumsPlugin)(r, {
            requestAlgorithmMember: {
              httpHeader: "x-amz-sdk-checksum-algorithm",
              name: "ChecksumAlgorithm",
            },
            requestChecksumRequired: !1,
          }),
          (0, RVr.getThrow200ExceptionsPlugin)(r),
          (0, pc.getSsecPlugin)(r),
        ];
      })
      .s("AmazonS3", "UploadPart", {})
      .n("S3Client", "UploadPartCommand")
      .f(lZe, uZe)
      .ser(DDr)
      .de(wMr)
      .build() {
      static {
        v(this, "UploadPartCommand");
      }
    },
    IVr = Te(),
    xrt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        DisableS3ExpressSessionAuth: { type: "staticContextParams", value: !0 },
        Bucket: { type: "contextParams", name: "Bucket" },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
          (0, IVr.getThrow200ExceptionsPlugin)(r),
          (0, pc.getSsecPlugin)(r),
        ];
      })
      .s("AmazonS3", "UploadPartCopy", {})
      .n("S3Client", "UploadPartCopyCommand")
      .f(fZe, dZe)
      .ser(LDr)
      .de(OMr)
      .build() {
      static {
        v(this, "UploadPartCopyCommand");
      }
    },
    Nrt = class extends p.Command.classBuilder()
      .ep({
        ...Y,
        UseObjectLambdaEndpoint: { type: "staticContextParams", value: !0 },
      })
      .m(function (e, t, r, n) {
        return [
          (0, Q.getSerdePlugin)(r, this.serialize, this.deserialize),
          (0, W.getEndpointPlugin)(r, e.getEndpointParameterInstructions()),
        ];
      })
      .s("AmazonS3", "WriteGetObjectResponse", {})
      .n("S3Client", "WriteGetObjectResponseCommand")
      .f(pZe, void 0)
      .ser(MDr)
      .de(TMr)
      .build() {
      static {
        v(this, "WriteGetObjectResponseCommand");
      }
    },
    xVr = {
      AbortMultipartUploadCommand: Yet,
      CompleteMultipartUploadCommand: Xet,
      CopyObjectCommand: Jet,
      CreateBucketCommand: Zet,
      CreateBucketMetadataTableConfigurationCommand: ett,
      CreateMultipartUploadCommand: ttt,
      CreateSessionCommand: Gre,
      DeleteBucketCommand: ntt,
      DeleteBucketAnalyticsConfigurationCommand: rtt,
      DeleteBucketCorsCommand: itt,
      DeleteBucketEncryptionCommand: ott,
      DeleteBucketIntelligentTieringConfigurationCommand: att,
      DeleteBucketInventoryConfigurationCommand: stt,
      DeleteBucketLifecycleCommand: ctt,
      DeleteBucketMetadataTableConfigurationCommand: utt,
      DeleteBucketMetricsConfigurationCommand: ltt,
      DeleteBucketOwnershipControlsCommand: dtt,
      DeleteBucketPolicyCommand: ftt,
      DeleteBucketReplicationCommand: ptt,
      DeleteBucketTaggingCommand: mtt,
      DeleteBucketWebsiteCommand: htt,
      DeleteObjectCommand: gtt,
      DeleteObjectsCommand: vtt,
      DeleteObjectTaggingCommand: ytt,
      DeletePublicAccessBlockCommand: _tt,
      GetBucketAccelerateConfigurationCommand: Ett,
      GetBucketAclCommand: btt,
      GetBucketAnalyticsConfigurationCommand: Stt,
      GetBucketCorsCommand: Ctt,
      GetBucketEncryptionCommand: wtt,
      GetBucketIntelligentTieringConfigurationCommand: Ott,
      GetBucketInventoryConfigurationCommand: Ttt,
      GetBucketLifecycleConfigurationCommand: Att,
      GetBucketLocationCommand: Ptt,
      GetBucketLoggingCommand: Rtt,
      GetBucketMetadataTableConfigurationCommand: Itt,
      GetBucketMetricsConfigurationCommand: xtt,
      GetBucketNotificationConfigurationCommand: Ntt,
      GetBucketOwnershipControlsCommand: ktt,
      GetBucketPolicyCommand: Dtt,
      GetBucketPolicyStatusCommand: Ltt,
      GetBucketReplicationCommand: Mtt,
      GetBucketRequestPaymentCommand: qtt,
      GetBucketTaggingCommand: jtt,
      GetBucketVersioningCommand: Ftt,
      GetBucketWebsiteCommand: Btt,
      GetObjectCommand: Gtt,
      GetObjectAclCommand: Utt,
      GetObjectAttributesCommand: Htt,
      GetObjectLegalHoldCommand: Vtt,
      GetObjectLockConfigurationCommand: $tt,
      GetObjectRetentionCommand: ztt,
      GetObjectTaggingCommand: Ktt,
      GetObjectTorrentCommand: Wtt,
      GetPublicAccessBlockCommand: Qtt,
      HeadBucketCommand: u3,
      HeadObjectCommand: l3,
      ListBucketAnalyticsConfigurationsCommand: Ytt,
      ListBucketIntelligentTieringConfigurationsCommand: Xtt,
      ListBucketInventoryConfigurationsCommand: Jtt,
      ListBucketMetricsConfigurationsCommand: Ztt,
      ListBucketsCommand: Vre,
      ListDirectoryBucketsCommand: $re,
      ListMultipartUploadsCommand: ert,
      ListObjectsCommand: trt,
      ListObjectsV2Command: zre,
      ListObjectVersionsCommand: rrt,
      ListPartsCommand: Kre,
      PutBucketAccelerateConfigurationCommand: nrt,
      PutBucketAclCommand: irt,
      PutBucketAnalyticsConfigurationCommand: ort,
      PutBucketCorsCommand: art,
      PutBucketEncryptionCommand: srt,
      PutBucketIntelligentTieringConfigurationCommand: crt,
      PutBucketInventoryConfigurationCommand: urt,
      PutBucketLifecycleConfigurationCommand: lrt,
      PutBucketLoggingCommand: drt,
      PutBucketMetricsConfigurationCommand: frt,
      PutBucketNotificationConfigurationCommand: prt,
      PutBucketOwnershipControlsCommand: mrt,
      PutBucketPolicyCommand: hrt,
      PutBucketReplicationCommand: grt,
      PutBucketRequestPaymentCommand: vrt,
      PutBucketTaggingCommand: yrt,
      PutBucketVersioningCommand: _rt,
      PutBucketWebsiteCommand: Ert,
      PutObjectCommand: Srt,
      PutObjectAclCommand: brt,
      PutObjectLegalHoldCommand: Crt,
      PutObjectLockConfigurationCommand: wrt,
      PutObjectRetentionCommand: Ort,
      PutObjectTaggingCommand: Trt,
      PutPublicAccessBlockCommand: Art,
      RestoreObjectCommand: Prt,
      SelectObjectContentCommand: Rrt,
      UploadPartCommand: Irt,
      UploadPartCopyCommand: xrt,
      WriteGetObjectResponseCommand: Nrt,
    },
    krt = class extends cS {
      static {
        v(this, "S3");
      }
    };
  (0, p.createAggregatedClient)(xVr, krt);
  var NVr = (Gn(), ue(rc)),
    kVr = (0, NVr.createPaginator)(
      cS,
      Vre,
      "ContinuationToken",
      "ContinuationToken",
      "MaxBuckets",
    ),
    DVr = (Gn(), ue(rc)),
    LVr = (0, DVr.createPaginator)(
      cS,
      $re,
      "ContinuationToken",
      "ContinuationToken",
      "MaxDirectoryBuckets",
    ),
    MVr = (Gn(), ue(rc)),
    qVr = (0, MVr.createPaginator)(
      cS,
      zre,
      "ContinuationToken",
      "NextContinuationToken",
      "MaxKeys",
    ),
    jVr = (Gn(), ue(rc)),
    FVr = (0, jVr.createPaginator)(
      cS,
      Kre,
      "PartNumberMarker",
      "NextPartNumberMarker",
      "MaxParts",
    ),
    dn = E7e(),
    Drt = v(async (e, t) => {
      let r;
      try {
        return (
          (r = await e.send(new u3(t))),
          { state: dn.WaiterState.SUCCESS, reason: r }
        );
      } catch (n) {
        if (((r = n), n.name && n.name == "NotFound"))
          return { state: dn.WaiterState.RETRY, reason: r };
      }
      return { state: dn.WaiterState.RETRY, reason: r };
    }, "checkState"),
    BVr = v(async (e, t) => {
      let r = { minDelay: 5, maxDelay: 120 };
      return (0, dn.createWaiter)({ ...r, ...e }, t, Drt);
    }, "waitForBucketExists"),
    UVr = v(async (e, t) => {
      let r = { minDelay: 5, maxDelay: 120 },
        n = await (0, dn.createWaiter)({ ...r, ...e }, t, Drt);
      return (0, dn.checkExceptions)(n);
    }, "waitUntilBucketExists"),
    Lrt = v(async (e, t) => {
      let r;
      try {
        r = await e.send(new u3(t));
      } catch (n) {
        if (((r = n), n.name && n.name == "NotFound"))
          return { state: dn.WaiterState.SUCCESS, reason: r };
      }
      return { state: dn.WaiterState.RETRY, reason: r };
    }, "checkState"),
    HVr = v(async (e, t) => {
      let r = { minDelay: 5, maxDelay: 120 };
      return (0, dn.createWaiter)({ ...r, ...e }, t, Lrt);
    }, "waitForBucketNotExists"),
    GVr = v(async (e, t) => {
      let r = { minDelay: 5, maxDelay: 120 },
        n = await (0, dn.createWaiter)({ ...r, ...e }, t, Lrt);
      return (0, dn.checkExceptions)(n);
    }, "waitUntilBucketNotExists"),
    Mrt = v(async (e, t) => {
      let r;
      try {
        return (
          (r = await e.send(new l3(t))),
          { state: dn.WaiterState.SUCCESS, reason: r }
        );
      } catch (n) {
        if (((r = n), n.name && n.name == "NotFound"))
          return { state: dn.WaiterState.RETRY, reason: r };
      }
      return { state: dn.WaiterState.RETRY, reason: r };
    }, "checkState"),
    VVr = v(async (e, t) => {
      let r = { minDelay: 5, maxDelay: 120 };
      return (0, dn.createWaiter)({ ...r, ...e }, t, Mrt);
    }, "waitForObjectExists"),
    $Vr = v(async (e, t) => {
      let r = { minDelay: 5, maxDelay: 120 },
        n = await (0, dn.createWaiter)({ ...r, ...e }, t, Mrt);
      return (0, dn.checkExceptions)(n);
    }, "waitUntilObjectExists"),
    qrt = v(async (e, t) => {
      let r;
      try {
        r = await e.send(new l3(t));
      } catch (n) {
        if (((r = n), n.name && n.name == "NotFound"))
          return { state: dn.WaiterState.SUCCESS, reason: r };
      }
      return { state: dn.WaiterState.RETRY, reason: r };
    }, "checkState"),
    zVr = v(async (e, t) => {
      let r = { minDelay: 5, maxDelay: 120 };
      return (0, dn.createWaiter)({ ...r, ...e }, t, qrt);
    }, "waitForObjectNotExists"),
    KVr = v(async (e, t) => {
      let r = { minDelay: 5, maxDelay: 120 },
        n = await (0, dn.createWaiter)({ ...r, ...e }, t, qrt);
      return (0, dn.checkExceptions)(n);
    }, "waitUntilObjectNotExists");
});
c();
c();
c();
c();
c();
c();
c();
var Zre = "Logging",
  hS = "x-amz-user-agent",
  ene = "NoHubcallbackProvidedException";
c();
var mo;
(function (e) {
  (e.DEBUG = "DEBUG"),
    (e.ERROR = "ERROR"),
    (e.INFO = "INFO"),
    (e.WARN = "WARN"),
    (e.VERBOSE = "VERBOSE"),
    (e.NONE = "NONE");
})(mo || (mo = {}));
var tne = { VERBOSE: 1, DEBUG: 2, INFO: 3, WARN: 4, ERROR: 5, NONE: 6 },
  Ot = class e {
    constructor(t, r = mo.WARN) {
      (this.name = t), (this.level = r), (this._pluggables = []);
    }
    _padding(t) {
      return t < 10 ? "0" + t : "" + t;
    }
    _ts() {
      let t = new Date();
      return (
        [this._padding(t.getMinutes()), this._padding(t.getSeconds())].join(
          ":",
        ) +
        "." +
        t.getMilliseconds()
      );
    }
    configure(t) {
      return t ? ((this._config = t), this._config) : this._config;
    }
    _log(t, ...r) {
      let n = this.level;
      e.LOG_LEVEL && (n = e.LOG_LEVEL),
        typeof window < "u" && window.LOG_LEVEL && (n = window.LOG_LEVEL);
      let i = tne[n];
      if (!(tne[t] >= i)) return;
      let a = console.log.bind(console);
      t === mo.ERROR && console.error && (a = console.error.bind(console)),
        t === mo.WARN && console.warn && (a = console.warn.bind(console)),
        e.BIND_ALL_LOG_LEVELS &&
          (t === mo.INFO && console.info && (a = console.info.bind(console)),
          t === mo.DEBUG && console.debug && (a = console.debug.bind(console)));
      let s = `[${t}] ${this._ts()} ${this.name}`,
        u = "";
      if (r.length === 1 && typeof r[0] == "string")
        (u = `${s} - ${r[0]}`), a(u);
      else if (r.length === 1) (u = `${s} ${r[0]}`), a(s, r[0]);
      else if (typeof r[0] == "string") {
        let l = r.slice(1);
        l.length === 1 && (l = l[0]),
          (u = `${s} - ${r[0]} ${l}`),
          a(`${s} - ${r[0]}`, l);
      } else (u = `${s} ${r}`), a(s, r);
      for (let l of this._pluggables) {
        let d = { message: u, timestamp: Date.now() };
        l.pushLogs([d]);
      }
    }
    log(...t) {
      this._log(mo.INFO, ...t);
    }
    info(...t) {
      this._log(mo.INFO, ...t);
    }
    warn(...t) {
      this._log(mo.WARN, ...t);
    }
    error(...t) {
      this._log(mo.ERROR, ...t);
    }
    debug(...t) {
      this._log(mo.DEBUG, ...t);
    }
    verbose(...t) {
      this._log(mo.VERBOSE, ...t);
    }
    addPluggable(t) {
      t &&
        t.getCategoryName() === Zre &&
        (this._pluggables.push(t), t.configure(this._config));
    }
    listPluggables() {
      return this._pluggables;
    }
  };
Ot.LOG_LEVEL = null;
Ot.BIND_ALL_LOG_LEVELS = !1;
c();
var Br = class e extends Error {
  constructor({
    message: t,
    name: r,
    recoverySuggestion: n,
    underlyingError: i,
    metadata: o,
  }) {
    if (
      (super(t),
      (this.name = r),
      (this.underlyingError = i),
      (this.recoverySuggestion = n),
      o)
    ) {
      let { extendedRequestId: a, httpStatusCode: s, requestId: u } = o;
      this.metadata = { extendedRequestId: a, httpStatusCode: s, requestId: u };
    }
    (this.constructor = e), Object.setPrototypeOf(this, e.prototype);
  }
};
c();
var Xo;
(function (e) {
  (e.NoEndpointId = "NoEndpointId"),
    (e.PlatformNotSupported = "PlatformNotSupported"),
    (e.Unknown = "Unknown"),
    (e.NetworkError = "NetworkError");
})(Xo || (Xo = {}));
c();
var ju =
  (e, t = Br) =>
  (r, n, i) => {
    let { message: o, recoverySuggestion: a } = e[n];
    if (!r)
      throw new t({
        name: n,
        message: i ? `${o} ${i}` : o,
        recoverySuggestion: a,
      });
  };
var Mi = typeof Symbol < "u" ? Symbol("amplify_default") : "@@amplify_default",
  gS = new Ot("Hub"),
  cA = class {
    constructor(t) {
      (this.listeners = new Map()),
        (this.protectedChannels = [
          "core",
          "auth",
          "api",
          "analytics",
          "interactions",
          "pubsub",
          "storage",
          "ui",
          "xr",
        ]),
        (this.name = t);
    }
    _remove(t, r) {
      let n = this.listeners.get(t);
      if (!n) {
        gS.warn(`No listeners for ${t}`);
        return;
      }
      this.listeners.set(t, [...n.filter(({ callback: i }) => i !== r)]);
    }
    dispatch(t, r, n, i) {
      typeof t == "string" &&
        this.protectedChannels.indexOf(t) > -1 &&
        (i === Mi ||
          gS.warn(
            `WARNING: ${t} is protected and dispatching on it can have unintended consequences`,
          ));
      let o = { channel: t, payload: { ...r }, source: n, patternInfo: [] };
      try {
        this._toListeners(o);
      } catch (a) {
        gS.error(a);
      }
    }
    listen(t, r, n = "noname") {
      let i;
      if (typeof r != "function")
        throw new Br({ name: ene, message: "No callback supplied to Hub" });
      i = r;
      let o = this.listeners.get(t);
      return (
        o || ((o = []), this.listeners.set(t, o)),
        o.push({ name: n, callback: i }),
        () => {
          this._remove(t, i);
        }
      );
    }
    _toListeners(t) {
      let { channel: r, payload: n } = t,
        i = this.listeners.get(r);
      i &&
        i.forEach((o) => {
          gS.debug(`Dispatching to ${r} with `, n);
          try {
            o.callback(t);
          } catch (a) {
            gS.error(a);
          }
        });
    }
  },
  fi = new cA("__default__"),
  tnt = new cA("internal-hub");
c();
c();
c();
var rne = () => {
    if (typeof window < "u" && typeof window.btoa == "function")
      return window.btoa;
    if (typeof btoa == "function") return btoa;
    throw new Br({
      name: "Base64EncoderError",
      message: "Cannot resolve the `btoa` function from the environment.",
    });
  },
  nne = () => {
    if (typeof window < "u" && typeof window.atob == "function")
      return window.atob;
    if (typeof atob == "function") return atob;
    throw new Br({
      name: "Base64EncoderError",
      message: "Cannot resolve the `atob` function from the environment.",
    });
  };
var ine = {
  convert(e, t) {
    let r = e;
    return (
      t?.urlSafe && (r = r.replace(/-/g, "+").replace(/_/g, "/")), nne()(r)
    );
  },
};
c();
var As;
(function (e) {
  (e.AuthTokenConfigException = "AuthTokenConfigException"),
    (e.AuthUserPoolAndIdentityPoolException =
      "AuthUserPoolAndIdentityPoolException"),
    (e.AuthUserPoolException = "AuthUserPoolException"),
    (e.InvalidIdentityPoolIdException = "InvalidIdentityPoolIdException"),
    (e.OAuthNotConfigureException = "OAuthNotConfigureException");
})(As || (As = {}));
var rnt = {
    [As.AuthTokenConfigException]: {
      message: "Auth Token Provider not configured.",
      recoverySuggestion: "Make sure to call Amplify.configure in your app.",
    },
    [As.AuthUserPoolAndIdentityPoolException]: {
      message: "Auth UserPool or IdentityPool not configured.",
      recoverySuggestion:
        "Make sure to call Amplify.configure in your app with UserPoolId and IdentityPoolId.",
    },
    [As.AuthUserPoolException]: {
      message: "Auth UserPool not configured.",
      recoverySuggestion:
        "Make sure to call Amplify.configure in your app with userPoolId and userPoolClientId.",
    },
    [As.InvalidIdentityPoolIdException]: {
      message: "Invalid identity pool id provided.",
      recoverySuggestion:
        "Make sure a valid identityPoolId is given in the config.",
    },
    [As.OAuthNotConfigureException]: {
      message: "oauth param not configured.",
      recoverySuggestion:
        "Make sure to call Amplify.configure with oauth parameter in your app.",
    },
  },
  uA = ju(rnt);
function Yr(e) {
  let t = !0;
  e ? (t = !!e.userPoolId && !!e.userPoolClientId) : (t = !1),
    uA(t, As.AuthUserPoolException);
}
function p3(e) {
  let t =
    !!e?.loginWith?.oauth?.domain &&
    !!e?.loginWith?.oauth?.redirectSignOut &&
    !!e?.loginWith?.oauth?.redirectSignIn &&
    !!e?.loginWith?.oauth?.responseType;
  uA(t, As.OAuthNotConfigureException);
}
function Gp(e) {
  let t = !!e?.identityPoolId;
  uA(t, As.InvalidIdentityPoolIdException);
}
function qi(e) {
  let t = e.split(".");
  if (t.length !== 3) throw new Error("Invalid token");
  try {
    let n = t[1].replace(/-/g, "+").replace(/_/g, "/"),
      i = decodeURIComponent(
        ine
          .convert(n)
          .split("")
          .map((a) => `%${`00${a.charCodeAt(0).toString(16)}`.slice(-2)}`)
          .join(""),
      ),
      o = JSON.parse(i);
    return { toString: () => e, payload: o };
  } catch {
    throw new Error("Invalid token payload");
  }
}
c();
c();
c();
var vS = (e) => e && e["nonRetryable"];
var lA = new Ot("retryUtil");
async function one(e, t, r, n) {
  if (typeof e != "function") throw Error("functionToRetry must be a function");
  return new Promise(async (i, o) => {
    let a = 0,
      s = !1,
      u,
      l = () => {},
      d;
    for (
      n &&
      n.then(() => {
        (s = !0), clearTimeout(u), l();
      });
      !s;

    ) {
      a++,
        lA.debug(
          `${e.name} attempt #${a} with this vars: ${JSON.stringify(t)}`,
        );
      try {
        i(await e(...t));
        return;
      } catch (f) {
        if (((d = f), lA.debug(`error on ${e.name}`, f), vS(f))) {
          lA.debug(`${e.name} non retryable error`, f), o(f);
          return;
        }
        let m = r(a, t, f);
        if ((lA.debug(`${e.name} retrying in ${m} ms`), m === !1 || s)) {
          o(f);
          return;
        } else
          await new Promise((h) => {
            (l = h), (u = setTimeout(l, m));
          });
      }
    }
    o(d);
  });
}
c();
var m3 = (e) => {
  let t = Reflect.ownKeys(e);
  for (let r of t) {
    let n = e[r];
    ((n && typeof n == "object") || typeof n == "function") && m3(n);
  }
  return Object.freeze(e);
};
c();
var nnt = new Ot("parseAWSExports"),
  int = {
    API_KEY: "apiKey",
    AWS_IAM: "iam",
    AMAZON_COGNITO_USER_POOLS: "userPool",
    OPENID_CONNECT: "oidc",
    NONE: "none",
    AWS_LAMBDA: "lambda",
    LAMBDA: "lambda",
  },
  sne = (e = {}) => {
    if (!Object.prototype.hasOwnProperty.call(e, "aws_project_region"))
      throw new Br({
        name: "InvalidParameterException",
        message: "Invalid config parameter.",
        recoverySuggestion:
          "Ensure passing the config object imported from  `amplifyconfiguration.json`.",
      });
    let {
        aws_appsync_apiKey: t,
        aws_appsync_authenticationType: r,
        aws_appsync_graphqlEndpoint: n,
        aws_appsync_region: i,
        aws_bots_config: o,
        aws_cognito_identity_pool_id: a,
        aws_cognito_sign_up_verification_method: s,
        aws_cognito_mfa_configuration: u,
        aws_cognito_mfa_types: l,
        aws_cognito_password_protection_settings: d,
        aws_cognito_verification_mechanisms: f,
        aws_cognito_signup_attributes: m,
        aws_cognito_social_providers: h,
        aws_cognito_username_attributes: y,
        aws_mandatory_sign_in: _,
        aws_mobile_analytics_app_id: E,
        aws_mobile_analytics_app_region: b,
        aws_user_files_s3_bucket: O,
        aws_user_files_s3_bucket_region: C,
        aws_user_files_s3_dangerously_connect_to_http_endpoint_for_testing: P,
        aws_user_pools_id: k,
        aws_user_pools_web_client_id: H,
        geo: B,
        oauth: L,
        predictions: Z,
        aws_cloud_logic_custom: ft,
        Notifications: Ct,
        modelIntrospection: j,
      } = e,
      ce = {};
    E && (ce.Analytics = { Pinpoint: { appId: E, region: b } });
    let { InAppMessaging: Ve, Push: $t } = Ct ?? {};
    if (Ve?.AWSPinpoint || $t?.AWSPinpoint) {
      if (Ve?.AWSPinpoint) {
        let { appId: ur, region: qu } = Ve.AWSPinpoint;
        ce.Notifications = {
          InAppMessaging: { Pinpoint: { appId: ur, region: qu } },
        };
      }
      if ($t?.AWSPinpoint) {
        let { appId: ur, region: qu } = $t.AWSPinpoint;
        ce.Notifications = {
          ...ce.Notifications,
          PushNotification: { Pinpoint: { appId: ur, region: qu } },
        };
      }
    }
    if (
      (Array.isArray(o) &&
        (ce.Interactions = {
          LexV1: Object.fromEntries(o.map((ur) => [ur.name, ur])),
        }),
      n)
    ) {
      let ur = int[r];
      ur || nnt.debug(`Invalid authentication type ${r}. Falling back to IAM.`),
        (ce.API = {
          GraphQL: {
            endpoint: n,
            apiKey: t,
            region: i,
            defaultAuthMode: ur ?? "iam",
          },
        }),
        j && (ce.API.GraphQL.modelIntrospection = j);
    }
    let Yo = u
        ? {
            status: u && u.toLowerCase(),
            totpEnabled: l?.includes("TOTP") ?? !1,
            smsEnabled: l?.includes("SMS") ?? !1,
          }
        : void 0,
      Ts = d
        ? {
            minLength: d.passwordPolicyMinLength,
            requireLowercase:
              d.passwordPolicyCharacters?.includes("REQUIRES_LOWERCASE") ?? !1,
            requireUppercase:
              d.passwordPolicyCharacters?.includes("REQUIRES_UPPERCASE") ?? !1,
            requireNumbers:
              d.passwordPolicyCharacters?.includes("REQUIRES_NUMBERS") ?? !1,
            requireSpecialCharacters:
              d.passwordPolicyCharacters?.includes("REQUIRES_SYMBOLS") ?? !1,
          }
        : void 0,
      f3 = Array.from(new Set([...(f ?? []), ...(m ?? [])])).reduce(
        (ur, qu) => ({ ...ur, [qu.toLowerCase()]: { required: !0 } }),
        {},
      ),
      uS = y?.includes("EMAIL") ?? !1,
      lS = y?.includes("PHONE_NUMBER") ?? !1;
    (a || k) &&
      (ce.Auth = {
        Cognito: {
          identityPoolId: a,
          allowGuestAccess: _ !== "enable",
          signUpVerificationMethod: s,
          userAttributes: f3,
          userPoolClientId: H,
          userPoolId: k,
          mfa: Yo,
          passwordFormat: Ts,
          loginWith: { username: !(uS || lS), email: uS, phone: lS },
        },
      });
    let iA = L ? Object.keys(L).length > 0 : !1,
      Kg = h ? h.length > 0 : !1;
    if (
      (ce.Auth &&
        iA &&
        (ce.Auth.Cognito.loginWith = {
          ...ce.Auth.Cognito.loginWith,
          oauth: { ...ont(L), ...(Kg && { providers: ant(h) }) },
        }),
      O &&
        (ce.Storage = {
          S3: {
            bucket: O,
            region: C,
            dangerouslyConnectToHttpEndpointForTesting: P,
          },
        }),
      B)
    ) {
      let { amazon_location_service: ur } = B;
      ce.Geo = {
        LocationService: {
          maps: ur.maps,
          geofenceCollections: ur.geofenceCollections,
          searchIndices: ur.search_indices,
          region: ur.region,
        },
      };
    }
    if (
      (ft &&
        (ce.API = {
          ...ce.API,
          REST: ft.reduce((ur, qu) => {
            let { name: Wg, endpoint: oA, region: dS, service: fS } = qu;
            return {
              ...ur,
              [Wg]: {
                endpoint: oA,
                ...(fS ? { service: fS } : void 0),
                ...(dS ? { region: dS } : void 0),
              },
            };
          }, {}),
        }),
      Z)
    ) {
      let { VoiceId: ur } = Z?.convert?.speechGenerator?.defaults ?? {};
      ce.Predictions = ur
        ? {
            ...Z,
            convert: {
              ...Z.convert,
              speechGenerator: {
                ...Z.convert.speechGenerator,
                defaults: { voiceId: ur },
              },
            },
          }
        : Z;
    }
    return ce;
  },
  ane = (e) => e?.split(",") ?? [],
  ont = ({
    domain: e,
    scope: t,
    redirectSignIn: r,
    redirectSignOut: n,
    responseType: i,
  }) => ({
    domain: e,
    scopes: t,
    redirectSignIn: ane(r),
    redirectSignOut: ane(n),
    responseType: i,
  }),
  ant = (e) =>
    e.map((t) => {
      let r = t.toLowerCase();
      return r.charAt(0).toUpperCase() + r.slice(1);
    });
c();
var yS = Symbol("oauth-listener");
c();
c();
import snt from "crypto";
var fA = new Uint8Array(256),
  dA = fA.length;
function h3() {
  return (
    dA > fA.length - 16 && (snt.randomFillSync(fA), (dA = 0)),
    fA.slice(dA, (dA += 16))
  );
}
c();
var pi = [];
for (let e = 0; e < 256; ++e) pi.push((e + 256).toString(16).slice(1));
function cne(e, t = 0) {
  return (
    pi[e[t + 0]] +
    pi[e[t + 1]] +
    pi[e[t + 2]] +
    pi[e[t + 3]] +
    "-" +
    pi[e[t + 4]] +
    pi[e[t + 5]] +
    "-" +
    pi[e[t + 6]] +
    pi[e[t + 7]] +
    "-" +
    pi[e[t + 8]] +
    pi[e[t + 9]] +
    "-" +
    pi[e[t + 10]] +
    pi[e[t + 11]] +
    pi[e[t + 12]] +
    pi[e[t + 13]] +
    pi[e[t + 14]] +
    pi[e[t + 15]]
  );
}
c();
c();
import cnt from "crypto";
var g3 = { randomUUID: cnt.randomUUID };
function unt(e, t, r) {
  if (g3.randomUUID && !t && !e) return g3.randomUUID();
  e = e || {};
  let n = e.random || (e.rng || h3)();
  if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), t)) {
    r = r || 0;
    for (let i = 0; i < 16; ++i) t[r + i] = n[i];
    return t;
  }
  return cne(n);
}
var v3 = unt;
c();
c();
function lne(e) {
  let { version: t } = e;
  return t ? t.startsWith("1") : !1;
}
function lnt(e) {
  if (!e) return;
  let { bucket_name: t, aws_region: r, buckets: n } = e;
  return { S3: { bucket: t, region: r, buckets: n && Ent(n) } };
}
function dnt(e) {
  if (!e) return;
  let {
      user_pool_id: t,
      user_pool_client_id: r,
      identity_pool_id: n,
      password_policy: i,
      mfa_configuration: o,
      mfa_methods: a,
      unauthenticated_identities_enabled: s,
      oauth: u,
      username_attributes: l,
      standard_required_attributes: d,
      groups: f,
    } = e,
    m = { Cognito: { userPoolId: t, userPoolClientId: r, groups: f } };
  return (
    n && (m.Cognito = { ...m.Cognito, identityPoolId: n }),
    i &&
      (m.Cognito.passwordFormat = {
        requireLowercase: i.require_lowercase,
        requireNumbers: i.require_numbers,
        requireUppercase: i.require_uppercase,
        requireSpecialCharacters: i.require_symbols,
        minLength: i.min_length ?? 6,
      }),
    o &&
      (m.Cognito.mfa = {
        status: _nt(o),
        smsEnabled: a?.includes("SMS"),
        totpEnabled: a?.includes("TOTP"),
      }),
    s && (m.Cognito.allowGuestAccess = s),
    u &&
      (m.Cognito.loginWith = {
        oauth: {
          domain: u.domain,
          redirectSignIn: u.redirect_sign_in_uri,
          redirectSignOut: u.redirect_sign_out_uri,
          responseType: u.response_type === "token" ? "token" : "code",
          scopes: u.scopes,
          providers: ynt(u.identity_providers),
        },
      }),
    l &&
      (m.Cognito.loginWith = {
        ...m.Cognito.loginWith,
        email: l.includes("email"),
        phone: l.includes("phone_number"),
        username: l.includes("username"),
      }),
    d &&
      (m.Cognito.userAttributes = d.reduce(
        (h, y) => ({ ...h, [y]: { required: !0 } }),
        {},
      )),
    m
  );
}
function fnt(e) {
  if (!e?.amazon_pinpoint) return;
  let { amazon_pinpoint: t } = e;
  return { Pinpoint: { appId: t.app_id, region: t.aws_region } };
}
function pnt(e) {
  if (!e) return;
  let {
    aws_region: t,
    geofence_collections: r,
    maps: n,
    search_indices: i,
  } = e;
  return {
    LocationService: {
      region: t,
      searchIndices: i,
      geofenceCollections: r,
      maps: n,
    },
  };
}
function mnt(e) {
  if (!e) return;
  let {
    aws_region: t,
    default_authorization_type: r,
    url: n,
    api_key: i,
    model_introspection: o,
  } = e;
  return {
    GraphQL: {
      endpoint: n,
      defaultAuthMode: fne(r),
      region: t,
      apiKey: i,
      modelIntrospection: o,
    },
  };
}
function hnt(e) {
  if (!e?.events) return;
  let {
    url: t,
    aws_region: r,
    api_key: n,
    default_authorization_type: i,
  } = e.events;
  return {
    Events: { endpoint: t, defaultAuthMode: fne(i), region: r, apiKey: n },
  };
}
function gnt(e) {
  if (!e) return;
  let { aws_region: t, channels: r, amazon_pinpoint_app_id: n } = e,
    i = r.includes("IN_APP_MESSAGING"),
    o = r.includes("APNS") || r.includes("FCM");
  if (!(i || o)) return;
  let a = {};
  return (
    i && (a.InAppMessaging = { Pinpoint: { appId: n, region: t } }),
    o && (a.PushNotification = { Pinpoint: { appId: n, region: t } }),
    a
  );
}
function dne(e) {
  let t = {};
  if (
    (e.storage && (t.Storage = lnt(e.storage)),
    e.auth && (t.Auth = dnt(e.auth)),
    e.analytics && (t.Analytics = fnt(e.analytics)),
    e.geo && (t.Geo = pnt(e.geo)),
    e.data && (t.API = mnt(e.data)),
    e.custom)
  ) {
    let r = hnt(e.custom);
    r && "Events" in r && (t.API = { ...t.API, ...r });
  }
  return e.notifications && (t.Notifications = gnt(e.notifications)), t;
}
var vnt = {
  AMAZON_COGNITO_USER_POOLS: "userPool",
  API_KEY: "apiKey",
  AWS_IAM: "iam",
  AWS_LAMBDA: "lambda",
  OPENID_CONNECT: "oidc",
};
function fne(e) {
  return vnt[e];
}
var une = {
  GOOGLE: "Google",
  LOGIN_WITH_AMAZON: "Amazon",
  FACEBOOK: "Facebook",
  SIGN_IN_WITH_APPLE: "Apple",
};
function ynt(e = []) {
  return e.reduce((t, r) => (une[r] !== void 0 && t.push(une[r]), t), []);
}
function _nt(e) {
  return e === "OPTIONAL" ? "optional" : e === "REQUIRED" ? "on" : "off";
}
function Ent(e) {
  let t = {};
  return (
    e.forEach(({ name: r, bucket_name: n, aws_region: i, paths: o }) => {
      if (r in t)
        throw new Error(
          `Duplicate friendly name found: ${r}. Name must be unique.`,
        );
      let a = o
        ? Object.entries(o).reduce(
            (s, [u, l]) => (l !== void 0 && (s[u] = l), s),
            {},
          )
        : void 0;
      t[r] = { bucketName: n, region: i, paths: a };
    }),
    t
  );
}
var _S = (e) =>
  Object.keys(e).some((t) => t.startsWith("aws_"))
    ? sne(e)
    : lne(e)
      ? dne(e)
      : e;
var wYr = A(ad(), 1),
  OYr = A(sd(), 1);
c();
c();
var Or;
(function (e) {
  (e.WebUnknown = "0"),
    (e.React = "1"),
    (e.NextJs = "2"),
    (e.Angular = "3"),
    (e.VueJs = "4"),
    (e.Nuxt = "5"),
    (e.Svelte = "6"),
    (e.ServerSideUnknown = "100"),
    (e.ReactSSR = "101"),
    (e.NextJsSSR = "102"),
    (e.AngularSSR = "103"),
    (e.VueJsSSR = "104"),
    (e.NuxtSSR = "105"),
    (e.SvelteSSR = "106"),
    (e.ReactNative = "201"),
    (e.Expo = "202");
})(Or || (Or = {}));
var $p;
(function (e) {
  (e.AI = "ai"),
    (e.API = "api"),
    (e.Auth = "auth"),
    (e.Analytics = "analytics"),
    (e.DataStore = "datastore"),
    (e.Geo = "geo"),
    (e.InAppMessaging = "inappmessaging"),
    (e.Interactions = "interactions"),
    (e.Predictions = "predictions"),
    (e.PubSub = "pubsub"),
    (e.PushNotification = "pushnotification"),
    (e.Storage = "storage");
})($p || ($p = {}));
var A3;
(function (e) {
  (e.CreateConversation = "1"),
    (e.GetConversation = "2"),
    (e.ListConversations = "3"),
    (e.DeleteConversation = "4"),
    (e.SendMessage = "5"),
    (e.ListMessages = "6"),
    (e.OnMessage = "7"),
    (e.Generation = "8"),
    (e.UpdateConversation = "9");
})(A3 || (A3 = {}));
var P3;
(function (e) {
  (e.Record = "1"), (e.IdentifyUser = "2");
})(P3 || (P3 = {}));
var ES;
(function (e) {
  (e.GraphQl = "1"),
    (e.Get = "2"),
    (e.Post = "3"),
    (e.Put = "4"),
    (e.Patch = "5"),
    (e.Del = "6"),
    (e.Head = "7");
})(ES || (ES = {}));
var bS;
(function (e) {
  (e.SignUp = "1"),
    (e.ConfirmSignUp = "2"),
    (e.ResendSignUpCode = "3"),
    (e.SignIn = "4"),
    (e.FetchMFAPreference = "6"),
    (e.UpdateMFAPreference = "7"),
    (e.SetUpTOTP = "10"),
    (e.VerifyTOTPSetup = "11"),
    (e.ConfirmSignIn = "12"),
    (e.DeleteUserAttributes = "15"),
    (e.DeleteUser = "16"),
    (e.UpdateUserAttributes = "17"),
    (e.FetchUserAttributes = "18"),
    (e.ConfirmUserAttribute = "22"),
    (e.SignOut = "26"),
    (e.UpdatePassword = "27"),
    (e.ResetPassword = "28"),
    (e.ConfirmResetPassword = "29"),
    (e.FederatedSignIn = "30"),
    (e.RememberDevice = "32"),
    (e.ForgetDevice = "33"),
    (e.FetchDevices = "34"),
    (e.SendUserAttributeVerificationCode = "35"),
    (e.SignInWithRedirect = "36"),
    (e.StartWebAuthnRegistration = "37"),
    (e.CompleteWebAuthnRegistration = "38"),
    (e.ListWebAuthnCredentials = "39"),
    (e.DeleteWebAuthnCredential = "40");
})(bS || (bS = {}));
var R3;
(function (e) {
  (e.Subscribe = "1"), (e.GraphQl = "2");
})(R3 || (R3 = {}));
var I3;
(function (e) {
  (e.SearchByText = "0"),
    (e.SearchByCoordinates = "1"),
    (e.SearchForSuggestions = "2"),
    (e.SearchByPlaceId = "3"),
    (e.SaveGeofences = "4"),
    (e.GetGeofence = "5"),
    (e.ListGeofences = "6"),
    (e.DeleteGeofences = "7");
})(I3 || (I3 = {}));
var x3;
(function (e) {
  (e.SyncMessages = "1"),
    (e.IdentifyUser = "2"),
    (e.NotifyMessageInteraction = "3");
})(x3 || (x3 = {}));
var N3;
(function (e) {
  e.None = "0";
})(N3 || (N3 = {}));
var k3;
(function (e) {
  (e.Convert = "1"), (e.Identify = "2"), (e.Interpret = "3");
})(k3 || (k3 = {}));
var D3;
(function (e) {
  e.Subscribe = "1";
})(D3 || (D3 = {}));
var L3;
(function (e) {
  (e.InitializePushNotifications = "1"), (e.IdentifyUser = "2");
})(L3 || (L3 = {}));
var M3;
(function (e) {
  (e.UploadData = "1"),
    (e.DownloadData = "2"),
    (e.List = "3"),
    (e.Copy = "4"),
    (e.Remove = "5"),
    (e.GetProperties = "6"),
    (e.GetUrl = "7"),
    (e.GetDataAccess = "8"),
    (e.ListCallerAccessGrants = "9");
})(M3 || (M3 = {}));
c();
var q3 = "6.14.4";
c();
c();
c();
c();
var cd = () => typeof global < "u";
var Ca = () => typeof window < "u",
  AA = () => typeof document < "u",
  Xg = () => typeof process < "u",
  ud = (e, t) => !!Object.keys(e).find((r) => r.startsWith(t));
function aie() {
  let e = (n) => n.startsWith("_react") || n.startsWith("__react"),
    t = (n) => Object.keys(n).find(e),
    r = () => Array.from(document.querySelectorAll("[id]"));
  return AA() && r().some(t);
}
function sie() {
  return (
    Xg() &&
    typeof process.env < "u" &&
    !!Object.keys(process.env).find((e) => e.includes("react"))
  );
}
c();
function cie() {
  return Ca() && ud(window, "__VUE");
}
function uie() {
  return cd() && ud(global, "__VUE");
}
c();
function lie() {
  return Ca() && ud(window, "__SVELTE");
}
function die() {
  return (
    Xg() &&
    typeof process.env < "u" &&
    !!Object.keys(process.env).find((e) => e.includes("svelte"))
  );
}
c();
function fie() {
  return Ca() && window.next && typeof window.next == "object";
}
function pie() {
  return cd() && (ud(global, "__next") || ud(global, "__NEXT"));
}
c();
function mie() {
  return Ca() && (window.__NUXT__ !== void 0 || window.$nuxt !== void 0);
}
function hie() {
  return cd() && typeof global.__NUXT_PATHS__ < "u";
}
c();
function gie() {
  let e = !!(AA() && document.querySelector("[ng-version]")),
    t = !!(Ca() && typeof window.ng < "u");
  return e || t;
}
function vie() {
  return (
    (Xg() &&
      typeof process.env == "object" &&
      process.env.npm_lifecycle_script?.startsWith("ng ")) ||
    !1
  );
}
c();
function yie() {
  return (
    typeof navigator < "u" &&
    typeof navigator.product < "u" &&
    navigator.product === "ReactNative"
  );
}
c();
function _ie() {
  return cd() && typeof global.expo < "u";
}
c();
function Eie() {
  return Ca();
}
var dit = [
  { platform: Or.Expo, detectionMethod: _ie },
  { platform: Or.ReactNative, detectionMethod: yie },
  { platform: Or.NextJs, detectionMethod: fie },
  { platform: Or.Nuxt, detectionMethod: mie },
  { platform: Or.Angular, detectionMethod: gie },
  { platform: Or.React, detectionMethod: aie },
  { platform: Or.VueJs, detectionMethod: cie },
  { platform: Or.Svelte, detectionMethod: lie },
  { platform: Or.WebUnknown, detectionMethod: Eie },
  { platform: Or.NextJsSSR, detectionMethod: pie },
  { platform: Or.NuxtSSR, detectionMethod: hie },
  { platform: Or.ReactSSR, detectionMethod: sie },
  { platform: Or.VueJsSSR, detectionMethod: uie },
  { platform: Or.AngularSSR, detectionMethod: vie },
  { platform: Or.SvelteSSR, detectionMethod: die },
];
function bie() {
  return dit.find((e) => e.detectionMethod())?.platform || Or.ServerSideUnknown;
}
var SS,
  PA = [],
  RA = !1,
  fit = 10,
  pit = 10,
  mit = 1e3,
  IA = () => {
    if (!SS) {
      if (((SS = bie()), RA)) for (; PA.length; ) PA.pop()?.();
      else
        PA.forEach((e) => {
          e();
        });
      Sie(Or.ServerSideUnknown, fit), Sie(Or.WebUnknown, pit);
    }
    return SS;
  },
  xA = (e) => {
    RA || PA.push(e);
  };
function hit() {
  SS = void 0;
}
function Sie(e, t) {
  SS === e &&
    !RA &&
    setTimeout(() => {
      hit(), (RA = !0), setTimeout(IA, mit);
    }, t);
}
c();
var git = {};
var Cie = (e, t) => git[e]?.[t]?.additionalDetails;
var wie = "aws-amplify",
  Oie = (e) => e.replace(/\+.*/, ""),
  j3 = class {
    constructor() {
      this.userAgent = `${wie}/${Oie(q3)}`;
    }
    get framework() {
      return IA();
    }
    get isReactNative() {
      return this.framework === Or.ReactNative || this.framework === Or.Expo;
    }
    observeFrameworkChanges(t) {
      xA(t);
    }
  },
  vit = new j3(),
  Tie = ({ category: e, action: t } = {}) => {
    let r = [[wie, Oie(q3)]];
    if ((e && r.push([e, t]), r.push(["framework", IA()]), e && t)) {
      let n = Cie(e, t);
      n &&
        n.forEach((i) => {
          r.push(i);
        });
    }
    return r;
  },
  wa = (e) =>
    Tie(e)
      .map(([n, i]) => (n && i ? `${n}/${i}` : n))
      .join(" ");
c();
var UI = A(kd(), 1);
c();
var Zce = () => {
  if (typeof self > "u") return !1;
  let e = self;
  return (
    typeof e.WorkerGlobalScope < "u" && self instanceof e.WorkerGlobalScope
  );
};
var Mv = class e {
  networkMonitor(t) {
    let r = Zce() ? self : typeof window < "u" && window;
    return r
      ? new UI.Observable((n) => {
          n.next({ online: r.navigator.onLine });
          let i = () => {
              n.next({ online: !0 });
            },
            o = () => {
              n.next({ online: !1 });
            };
          return (
            r.addEventListener("online", i),
            r.addEventListener("offline", o),
            e._observers.push(n),
            () => {
              r.removeEventListener("online", i),
                r.removeEventListener("offline", o),
                (e._observers = e._observers.filter((a) => a !== n));
            }
          );
        })
      : (0, UI.from)([{ online: !0 }]);
  }
  static _observerOverride(t) {
    for (let r of this._observers) {
      if (r.closed) {
        this._observers = this._observers.filter((n) => n !== r);
        continue;
      }
      r?.next && r.next(t);
    }
  }
};
Mv._observers = [];
c();
var FS = () => typeof window < "u" && typeof window.document < "u";
c();
var HI = class {
  configure(t, r) {
    (this.authConfig = t), (this.authOptions = r);
  }
  async fetchAuthSession(t = {}) {
    let r,
      n,
      i = await this.getTokens(t);
    return (
      i
        ? ((n = i.accessToken?.payload?.sub),
          (r =
            await this.authOptions?.credentialsProvider?.getCredentialsAndIdentityId(
              {
                authConfig: this.authConfig,
                tokens: i,
                authenticated: !0,
                forceRefresh: t.forceRefresh,
              },
            )))
        : (r =
            await this.authOptions?.credentialsProvider?.getCredentialsAndIdentityId(
              {
                authConfig: this.authConfig,
                authenticated: !1,
                forceRefresh: t.forceRefresh,
              },
            )),
      {
        tokens: i,
        credentials: r?.credentials,
        identityId: r?.identityId,
        userSub: n,
      }
    );
  }
  async clearCredentials() {
    await this.authOptions?.credentialsProvider?.clearCredentialsAndIdentityId();
  }
  async getTokens(t) {
    return (await this.authOptions?.tokenProvider?.getTokens(t)) ?? void 0;
  }
};
var GI = class {
    constructor() {
      (this.oAuthListener = void 0),
        (this.resourcesConfig = {}),
        (this.libraryOptions = {}),
        (this.Auth = new HI());
    }
    configure(t, r) {
      let n = _S(t);
      (this.resourcesConfig = n),
        r && (this.libraryOptions = r),
        (this.resourcesConfig = m3(this.resourcesConfig)),
        this.Auth.configure(
          this.resourcesConfig.Auth,
          this.libraryOptions.Auth,
        ),
        fi.dispatch(
          "core",
          { event: "configure", data: this.resourcesConfig },
          "Configure",
          Mi,
        ),
        this.notifyOAuthListener();
    }
    getConfig() {
      return this.resourcesConfig;
    }
    [yS](t) {
      this.resourcesConfig.Auth?.Cognito.loginWith?.oauth
        ? t(this.resourcesConfig.Auth?.Cognito)
        : (this.oAuthListener = t);
    }
    notifyOAuthListener() {
      !this.resourcesConfig.Auth?.Cognito.loginWith?.oauth ||
        !this.oAuthListener ||
        (this.oAuthListener(this.resourcesConfig.Auth?.Cognito),
        (this.oAuthListener = void 0));
    }
  },
  Qn = new GI();
c();
c();
var eue = (e, t) => e.Auth.fetchAuthSession(t);
var VI = (e) => eue(Qn, e);
c();
var e7r = A(ad(), 1),
  t7r = A(sd(), 1);
c();
var rm = (e) => {
    let { headers: t, statusCode: r } = e;
    return {
      ...(Pbt(e) ? e.$metadata : {}),
      httpStatusCode: r,
      requestId:
        t["x-amzn-requestid"] ??
        t["x-amzn-request-id"] ??
        t["x-amz-request-id"],
      extendedRequestId: t["x-amz-id-2"],
      cfId: t["x-amz-cf-id"],
    };
  },
  Pbt = (e) => typeof e?.$metadata == "object";
c();
var Zo = async (e) => {
    if (!e || e.statusCode < 300) return;
    let t = await Dd(e),
      n = ((a) => {
        let [s] = a.toString().split(/[,:]+/);
        return s.includes("#") ? s.split("#")[1] : s;
      })(e.headers["x-amzn-errortype"] ?? t.code ?? t.__type ?? "UnknownError"),
      i = t.message ?? t.Message ?? "Unknown error",
      o = new Error(i);
    return Object.assign(o, { name: n, $metadata: rm(e) });
  },
  Dd = async (e) => {
    if (!e.body) throw new Error("Missing response payload");
    let t = await e.body.json();
    return Object.assign(t, { $metadata: rm(e) });
  };
c();
var nm = (e, t, r, n) => async (i, o) => {
  let a = { ...n, ...i },
    s = await a.endpointResolver(a, o),
    u = await t(o, s),
    l = await e(u, { ...a });
  return r(l);
};
c();
c();
c();
var ZG = {
    id: "aws",
    outputs: { dnsSuffix: "amazonaws.com" },
    regionRegex: "^(us|eu|ap|sa|ca|me|af)\\-\\w+\\-\\d+$",
    regions: ["aws-global"],
  },
  tue = {
    partitions: [
      ZG,
      {
        id: "aws-cn",
        outputs: { dnsSuffix: "amazonaws.com.cn" },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: ["aws-cn-global"],
      },
    ],
  };
var BS = (e) => {
  let { partitions: t } = tue;
  for (let { regions: r, outputs: n, regionRegex: i } of t) {
    let o = new RegExp(i);
    if (r.includes(e) || o.test(e)) return n.dnsSuffix;
  }
  return ZG.outputs.dnsSuffix;
};
c();
c();
c();
var eV = "amz-sdk-invocation-id",
  rue = "amz-sdk-request";
var im = ({
    maxAttempts: e = 3,
    retryDecider: t,
    computeDelay: r,
    abortSignal: n,
  }) => {
    if (e < 1) throw new Error("maxAttempts must be greater than 0");
    return (i, o) =>
      async function (s) {
        let u,
          l = o.attemptsCount ?? 0,
          d,
          f = () => {
            if (d) return nue(d, l), d;
            throw (nue(u, l), u);
          };
        for (; !n?.aborted && l < e; ) {
          try {
            (d = await i(s)), (u = void 0);
          } catch (y) {
            (u = y), (d = void 0);
          }
          (l = (o.attemptsCount ?? 0) > l ? (o.attemptsCount ?? 0) : l + 1),
            (o.attemptsCount = l);
          let { isCredentialsExpiredError: m, retryable: h } = await t(d, u, o);
          if (h) {
            if (((o.isCredentialsExpired = !!m), !n?.aborted && l < e)) {
              let y = r(l);
              await Rbt(y, n);
            }
            continue;
          } else return f();
        }
        if (n?.aborted) throw new Error("Request aborted.");
        return f();
      };
  },
  Rbt = (e, t) => {
    if (t?.aborted) return Promise.resolve();
    let r,
      n,
      i = new Promise((o) => {
        (n = o), (r = setTimeout(o, e));
      });
    return (
      t?.addEventListener("abort", function o(a) {
        clearTimeout(r), t?.removeEventListener("abort", o), n();
      }),
      i
    );
  },
  nue = (e, t) => {
    Object.prototype.toString.call(e) === "[object Object]" &&
      (e.$metadata = { ...(e.$metadata ?? {}), attempts: t });
  };
c();
c();
var qv = v3;
var tXr = A(ad(), 1),
  rXr = A(sd(), 1);
var oue = () => (e) =>
  async function (r) {
    return r.headers[eV] || (r.headers[eV] = qv()), e(r);
  };
c();
var aue =
  ({ maxAttempts: e = 3 }) =>
  (t, r) =>
    async function (i) {
      let o = r.attemptsCount ?? 0;
      return (i.headers[rue] = `attempt=${o + 1}; max=${e}`), t(i);
    };
c();
var om =
  ({ userAgentHeader: e = "x-amz-user-agent", userAgentValue: t = "" }) =>
  (r) =>
    async function (i) {
      if (t.trim().length === 0) return await r(i);
      {
        let o = e.toLowerCase();
        return (
          (i.headers[o] = i.headers[o] ? `${i.headers[o]} ${t}` : t), await r(i)
        );
      }
    };
c();
var xs = (e, t) => (r, n) => {
  let i = {},
    o = (a) => e(a, n);
  for (let a = t.length - 1; a >= 0; a--) {
    let s = t[a];
    o = s(n)(o, i);
  }
  return o(r);
};
c();
c();
var $I = (e) => {
  let t;
  return () => (t || (t = e()), t);
};
var Ibt = (e) => !["HEAD", "GET", "DELETE"].includes(e.toUpperCase()),
  am = async (
    { url: e, method: t, headers: r, body: n },
    { abortSignal: i, cache: o, withCrossDomainCredentials: a },
  ) => {
    let s;
    try {
      s = await fetch(e, {
        method: t,
        headers: r,
        body: Ibt(t) ? n : void 0,
        signal: i,
        cache: o,
        credentials: a ? "include" : "same-origin",
      });
    } catch (f) {
      throw f instanceof TypeError
        ? new Br({
            name: Xo.NetworkError,
            message: "A network error has occurred.",
            underlyingError: f,
          })
        : f;
    }
    let u = {};
    s.headers?.forEach((f, m) => {
      u[m.toLowerCase()] = f;
    });
    let l = { statusCode: s.status, headers: u, body: null },
      d = Object.assign(s.body ?? {}, {
        text: $I(() => s.text()),
        blob: $I(() => s.blob()),
        json: $I(() => s.json()),
      });
    return { ...l, body: d };
  };
var US = xs(am, [om, oue, im, aue]);
c();
c();
function zI(e = 3e5) {
  return (n) => {
    let i = 2 ** n * 100 + 100 * Math.random();
    return i > e ? !1 : i;
  };
}
var sm = (e) => {
  let r = zI(3e5)(e);
  return r === !1 ? 3e5 : r;
};
c();
c();
var kbt = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch",
    "BadRequestException",
  ],
  sue = (e) => !!e && kbt.includes(e);
var cm = (e) => async (t, r) => {
    let n = r ?? (await e(t)) ?? void 0,
      i = n?.code || n?.name,
      o = t?.statusCode;
    return { retryable: qbt(r) || Mbt(o, i) || sue(i) || jbt(o, i) };
  },
  Dbt = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
  ],
  Lbt = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"],
  Mbt = (e, t) => e === 429 || (!!t && Dbt.includes(t)),
  qbt = (e) => [Xo.NetworkError, "ERR_NETWORK"].includes(e?.name),
  jbt = (e, t) =>
    (!!e && [500, 502, 503, 504].includes(e)) || (!!t && Lbt.includes(t));
c();
var jn = URL,
  KI = URLSearchParams;
var zXr = A(ad(), 1),
  KXr = A(sd(), 1);
var Fbt = "cognito-identity",
  Bbt = ({ region: e }) => ({
    url: new jn(`https://cognito-identity.${e}.${BS(e)}`),
  }),
  Ubt = () => (e) =>
    async function (r) {
      return (r.headers["cache-control"] = "no-store"), e(r);
    },
  WI = xs(US, [Ubt]),
  HS = {
    service: Fbt,
    endpointResolver: Bbt,
    retryDecider: cm(Zo),
    computeDelay: sm,
    userAgentValue: wa(),
    cache: "no-store",
  };
xA(() => {
  HS.userAgentValue = wa();
});
var QI = (e) => ({
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": `AWSCognitoIdentityService.${e}`,
  }),
  YI = ({ url: e }, t, r) => ({ headers: t, url: e, body: r, method: "POST" });
var Hbt = (e, t) => {
    let r = QI("GetId"),
      n = JSON.stringify(e);
    return YI(t, r, n);
  },
  Gbt = async (e) => {
    if (e.statusCode >= 300) throw await Zo(e);
    return { IdentityId: (await Dd(e)).IdentityId, $metadata: rm(e) };
  },
  tV = nm(WI, Hbt, Gbt, HS);
c();
var c7r = A(ad(), 1),
  u7r = A(sd(), 1);
var Vbt = (e, t) => {
    let r = QI("GetCredentialsForIdentity"),
      n = JSON.stringify(e);
    return YI(t, r, n);
  },
  $bt = async (e) => {
    if (e.statusCode >= 300) throw await Zo(e);
    {
      let t = await Dd(e);
      return {
        IdentityId: t.IdentityId,
        Credentials: zbt(t.Credentials),
        $metadata: rm(e),
      };
    }
  },
  zbt = ({
    AccessKeyId: e,
    SecretKey: t,
    SessionToken: r,
    Expiration: n,
  } = {}) => ({
    AccessKeyId: e,
    SecretKey: t,
    SessionToken: r,
    Expiration: n && new Date(n * 1e3),
  }),
  XI = nm(WI, Vbt, $bt, HS);
c();
c();
c();
c();
var Vu = class extends Br {
  constructor() {
    super({
      name: Xo.PlatformNotSupported,
      message: "Function not supported on current platform",
    });
  }
};
var bc = class {
  constructor(t) {
    this.storage = t;
  }
  async setItem(t, r) {
    if (!this.storage) throw new Vu();
    this.storage.setItem(t, r);
  }
  async getItem(t) {
    if (!this.storage) throw new Vu();
    return this.storage.getItem(t);
  }
  async removeItem(t) {
    if (!this.storage) throw new Vu();
    this.storage.removeItem(t);
  }
  async clear() {
    if (!this.storage) throw new Vu();
    this.storage.clear();
  }
};
c();
c();
var um = class {
  constructor() {
    this.storage = new Map();
  }
  get length() {
    return this.storage.size;
  }
  key(t) {
    return t > this.length - 1 ? null : Array.from(this.storage.keys())[t];
  }
  setItem(t, r) {
    this.storage.set(t, r);
  }
  getItem(t) {
    return this.storage.get(t) ?? null;
  }
  removeItem(t) {
    this.storage.delete(t);
  }
  clear() {
    this.storage.clear();
  }
};
var cue = new Ot("CoreStorageUtils"),
  JI = () => {
    try {
      if (typeof window < "u" && window.localStorage)
        return window.localStorage;
    } catch {
      cue.info(
        "localStorage not found. InMemoryStorage is used as a fallback.",
      );
    }
    return new um();
  },
  ZI = () => {
    try {
      if (typeof window < "u" && window.sessionStorage)
        return window.sessionStorage.getItem("test"), window.sessionStorage;
      throw new Error("sessionStorage is not defined");
    } catch {
      return (
        cue.info(
          "sessionStorage not found. InMemoryStorage is used as a fallback.",
        ),
        new um()
      );
    }
  };
var ex = class extends bc {
  constructor() {
    super(JI());
  }
};
c();
var tx = class extends bc {
  constructor() {
    super(ZI());
  }
};
c();
c();
var rx = class {
  constructor(t) {
    this._storage = t;
  }
  get storage() {
    if (!this._storage) throw new Vu();
    return this._storage;
  }
  setItem(t, r) {
    this.storage.setItem(t, r);
  }
  getItem(t) {
    return this.storage.getItem(t);
  }
  removeItem(t) {
    this.storage.removeItem(t);
  }
  clear() {
    this.storage.clear();
  }
};
var nx = class extends rx {
  constructor() {
    super(ZI());
  }
};
c();
c();
function ix(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t];
    for (var n in r) e[n] = r[n];
  }
  return e;
}
var Kbt = {
  read: function (e) {
    return (
      e[0] === '"' && (e = e.slice(1, -1)),
      e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
    );
  },
  write: function (e) {
    return encodeURIComponent(e).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent,
    );
  },
};
function rV(e, t) {
  function r(i, o, a) {
    if (!(typeof document > "u")) {
      (a = ix({}, t, a)),
        typeof a.expires == "number" &&
          (a.expires = new Date(Date.now() + a.expires * 864e5)),
        a.expires && (a.expires = a.expires.toUTCString()),
        (i = encodeURIComponent(i)
          .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
          .replace(/[()]/g, escape));
      var s = "";
      for (var u in a)
        a[u] &&
          ((s += "; " + u), a[u] !== !0 && (s += "=" + a[u].split(";")[0]));
      return (document.cookie = i + "=" + e.write(o, i) + s);
    }
  }
  function n(i) {
    if (!(typeof document > "u" || (arguments.length && !i))) {
      for (
        var o = document.cookie ? document.cookie.split("; ") : [],
          a = {},
          s = 0;
        s < o.length;
        s++
      ) {
        var u = o[s].split("="),
          l = u.slice(1).join("=");
        try {
          var d = decodeURIComponent(u[0]);
          if (((a[d] = e.read(l, d)), i === d)) break;
        } catch {}
      }
      return i ? a[i] : a;
    }
  }
  return Object.create(
    {
      set: r,
      get: n,
      remove: function (i, o) {
        r(i, "", ix({}, o, { expires: -1 }));
      },
      withAttributes: function (i) {
        return rV(this.converter, ix({}, this.attributes, i));
      },
      withConverter: function (i) {
        return rV(ix({}, this.converter, i), this.attributes);
      },
    },
    {
      attributes: { value: Object.freeze(t) },
      converter: { value: Object.freeze(e) },
    },
  );
}
var GS = rV(Kbt, { path: "/" });
var VS = class {
  constructor(t = {}) {
    let { path: r, domain: n, expires: i, sameSite: o, secure: a } = t;
    if (
      ((this.domain = n),
      (this.path = r || "/"),
      (this.expires = Object.prototype.hasOwnProperty.call(t, "expires")
        ? i
        : 365),
      (this.secure = Object.prototype.hasOwnProperty.call(t, "secure")
        ? a
        : !0),
      Object.prototype.hasOwnProperty.call(t, "sameSite"))
    ) {
      if (!o || !["strict", "lax", "none"].includes(o))
        throw new Error(
          'The sameSite value of cookieStorage must be "lax", "strict" or "none".',
        );
      if (o === "none" && !this.secure)
        throw new Error(
          "sameSite = None requires the Secure attribute in latest browser versions.",
        );
      this.sameSite = o;
    }
  }
  async setItem(t, r) {
    GS.set(t, r, this.getData());
  }
  async getItem(t) {
    return GS.get(t) ?? null;
  }
  async removeItem(t) {
    GS.remove(t, this.getData());
  }
  async clear() {
    let t = GS.get(),
      r = Object.keys(t).map((n) => this.removeItem(n));
    await Promise.all(r);
  }
  getData() {
    return {
      path: this.path,
      expires: this.expires,
      domain: this.domain,
      secure: this.secure,
      ...(this.sameSite && { sameSite: this.sameSite }),
    };
  }
};
var $u = new ex(),
  Wbt = new tx(),
  Qbt = new nx(),
  Ybt = new bc(new um());
c();
c();
c();
var Ld = {
    keyPrefix: "aws-amplify-cache",
    capacityInBytes: 1048576,
    itemMaxSize: 21e4,
    defaultTTL: 2592e5,
    defaultPriority: 5,
    warningThreshold: 0.8,
  },
  zu = "CurSize";
c();
c();
function nV(e) {
  let t = 0;
  t = e.length;
  for (let r = e.length; r >= 0; r -= 1) {
    let n = e.charCodeAt(r);
    n > 127 && n <= 2047 ? (t += 1) : n > 2047 && n <= 65535 && (t += 2),
      n >= 56320 && n <= 57343 && (r -= 1);
  }
  return t;
}
function Md() {
  return new Date().getTime();
}
var lm = (e) => `${e}${zu}`;
c();
var qd;
(function (e) {
  (e.NoCacheItem = "NoCacheItem"),
    (e.NullNextNode = "NullNextNode"),
    (e.NullPreviousNode = "NullPreviousNode");
})(qd || (qd = {}));
var Xbt = {
    [qd.NoCacheItem]: { message: "Item not found in the cache storage." },
    [qd.NullNextNode]: { message: "Next node is null." },
    [qd.NullPreviousNode]: { message: "Previous node is null." },
  },
  iV = ju(Xbt);
var an = new Ot("StorageCache"),
  ox = class {
    constructor({ config: t, keyValueStorage: r }) {
      (this.config = { ...Ld, ...t }),
        (this.keyValueStorage = r),
        this.sanitizeConfig();
    }
    getModuleName() {
      return "Cache";
    }
    configure(t) {
      return (
        t &&
          (t.keyPrefix &&
            an.warn(
              "keyPrefix can not be re-configured on an existing Cache instance.",
            ),
          (this.config = { ...this.config, ...t })),
        this.sanitizeConfig(),
        this.config
      );
    }
    async getCurrentCacheSize() {
      let t = await this.getStorage().getItem(lm(this.config.keyPrefix));
      return (
        t ||
          (await this.getStorage().setItem(lm(this.config.keyPrefix), "0"),
          (t = "0")),
        Number(t)
      );
    }
    async setItem(t, r, n) {
      if (
        (an.debug(`Set item: key is ${t}, value is ${r} with options: ${n}`),
        !t || t === zu)
      ) {
        an.warn(`Invalid key: should not be empty or reserved key: '${zu}'`);
        return;
      }
      if (typeof r > "u") {
        an.warn("The value of item should not be undefined!");
        return;
      }
      let i = {
        priority:
          n?.priority !== void 0 ? n.priority : this.config.defaultPriority,
        expires:
          n?.expires !== void 0 ? n.expires : this.config.defaultTTL + Md(),
      };
      if (i.priority < 1 || i.priority > 5) {
        an.warn(
          "Invalid parameter: priority due to out or range. It should be within 1 and 5.",
        );
        return;
      }
      let o = `${this.config.keyPrefix}${t}`,
        a = this.fillCacheItem(o, r, i);
      if (a.byteSize > this.config.itemMaxSize) {
        an.warn(`Item with key: ${t} you are trying to put into is too big!`);
        return;
      }
      try {
        let s = await this.getStorage().getItem(o);
        if (
          (s && (await this.removeCacheItem(o, JSON.parse(s).byteSize)),
          await this.isCacheFull(a.byteSize))
        ) {
          let u = await this.clearInvalidAndGetRemainingKeys();
          if (await this.isCacheFull(a.byteSize)) {
            let l = await this.sizeToPop(a.byteSize);
            await this.popOutItems(u, l);
          }
        }
        return this.setCacheItem(o, a);
      } catch (s) {
        an.warn(`setItem failed! ${s}`);
      }
    }
    async getItem(t, r) {
      an.debug(`Get item: key is ${t} with options ${r}`);
      let n;
      if (!t || t === zu)
        return (
          an.warn(`Invalid key: should not be empty or reserved key: '${zu}'`),
          null
        );
      let i = `${this.config.keyPrefix}${t}`;
      try {
        if (((n = await this.getStorage().getItem(i)), n != null))
          if (await this.isExpired(i))
            await this.removeCacheItem(i, JSON.parse(n).byteSize);
          else return (await this.updateVisitedTime(JSON.parse(n), i)).data;
        if (r?.callback) {
          let o = r.callback();
          return o !== null && (await this.setItem(t, o, r)), o;
        }
        return null;
      } catch (o) {
        return an.warn(`getItem failed! ${o}`), null;
      }
    }
    async removeItem(t) {
      if ((an.debug(`Remove item: key is ${t}`), !t || t === zu)) {
        an.warn(`Invalid key: should not be empty or reserved key: '${zu}'`);
        return;
      }
      let r = `${this.config.keyPrefix}${t}`;
      try {
        let n = await this.getStorage().getItem(r);
        n && (await this.removeCacheItem(r, JSON.parse(n).byteSize));
      } catch (n) {
        an.warn(`removeItem failed! ${n}`);
      }
    }
    async getAllKeys() {
      try {
        return await this.getAllCacheKeys();
      } catch (t) {
        return an.warn(`getAllkeys failed! ${t}`), [];
      }
    }
    getStorage() {
      return this.keyValueStorage;
    }
    async isExpired(t) {
      let r = await this.getStorage().getItem(t);
      iV(r !== null, qd.NoCacheItem, `Key: ${t}`);
      let n = JSON.parse(r);
      return Md() >= n.expires;
    }
    async removeCacheItem(t, r) {
      let n = await this.getStorage().getItem(t);
      iV(n !== null, qd.NoCacheItem, `Key: ${t}`);
      let i = r ?? JSON.parse(n).byteSize;
      await this.decreaseCurrentSizeInBytes(i);
      try {
        await this.getStorage().removeItem(t);
      } catch (o) {
        await this.increaseCurrentSizeInBytes(i),
          an.error(`Failed to remove item: ${o}`);
      }
    }
    fillCacheItem(t, r, n) {
      let i = {
        key: t,
        data: r,
        timestamp: Md(),
        visitedTime: Md(),
        priority: n.priority ?? 0,
        expires: n.expires ?? 0,
        type: typeof r,
        byteSize: 0,
      };
      return (
        (i.byteSize = nV(JSON.stringify(i))),
        (i.byteSize = nV(JSON.stringify(i))),
        i
      );
    }
    sanitizeConfig() {
      this.config.itemMaxSize > this.config.capacityInBytes &&
        (an.error(
          "Invalid parameter: itemMaxSize. It should be smaller than capacityInBytes. Setting back to default.",
        ),
        (this.config.itemMaxSize = Ld.itemMaxSize)),
        (this.config.defaultPriority > 5 || this.config.defaultPriority < 1) &&
          (an.error(
            "Invalid parameter: defaultPriority. It should be between 1 and 5. Setting back to default.",
          ),
          (this.config.defaultPriority = Ld.defaultPriority)),
        (Number(this.config.warningThreshold) > 1 ||
          Number(this.config.warningThreshold) < 0) &&
          (an.error(
            "Invalid parameter: warningThreshold. It should be between 0 and 1. Setting back to default.",
          ),
          (this.config.warningThreshold = Ld.warningThreshold));
      let t = 5 * 1024 * 1024;
      this.config.capacityInBytes > t &&
        (an.error(
          "Cache Capacity should be less than 5MB. Setting back to default. Setting back to default.",
        ),
        (this.config.capacityInBytes = Ld.capacityInBytes));
    }
    async increaseCurrentSizeInBytes(t) {
      let r = await this.getCurrentCacheSize();
      await this.getStorage().setItem(
        lm(this.config.keyPrefix),
        (r + t).toString(),
      );
    }
    async decreaseCurrentSizeInBytes(t) {
      let r = await this.getCurrentCacheSize();
      await this.getStorage().setItem(
        lm(this.config.keyPrefix),
        (r - t).toString(),
      );
    }
    async updateVisitedTime(t, r) {
      return (
        (t.visitedTime = Md()),
        await this.getStorage().setItem(r, JSON.stringify(t)),
        t
      );
    }
    async setCacheItem(t, r) {
      await this.increaseCurrentSizeInBytes(r.byteSize);
      try {
        await this.getStorage().setItem(t, JSON.stringify(r));
      } catch (n) {
        await this.decreaseCurrentSizeInBytes(r.byteSize),
          an.error(`Failed to set item ${n}`);
      }
    }
    async sizeToPop(t) {
      let n =
          (await this.getCurrentCacheSize()) + t - this.config.capacityInBytes,
        i = (1 - this.config.warningThreshold) * this.config.capacityInBytes;
      return n > i ? n : i;
    }
    async isCacheFull(t) {
      let r = await this.getCurrentCacheSize();
      return t + r > this.config.capacityInBytes;
    }
    async popOutItems(t, r) {
      let n = [],
        i = r;
      for (let o of t) {
        let a = await this.getStorage().getItem(o);
        if (a != null) {
          let s = JSON.parse(a);
          n.push(s);
        }
      }
      n.sort((o, a) =>
        o.priority > a.priority
          ? -1
          : o.priority < a.priority
            ? 1
            : o.visitedTime < a.visitedTime
              ? -1
              : 1,
      );
      for (let o of n)
        if (
          (await this.removeCacheItem(o.key, o.byteSize),
          (i -= o.byteSize),
          i <= 0)
        )
          return;
    }
    async clearInvalidAndGetRemainingKeys() {
      let t = [],
        r = await this.getAllCacheKeys({ omitSizeKey: !0 });
      for (let n of r)
        (await this.isExpired(n)) ? await this.removeCacheItem(n) : t.push(n);
      return t;
    }
    async clear() {
      an.debug("Clear Cache");
      try {
        let t = await this.getAllKeys();
        for (let r of t) {
          let n = `${this.config.keyPrefix}${r}`;
          await this.getStorage().removeItem(n);
        }
      } catch (t) {
        an.warn(`clear failed! ${t}`);
      }
    }
  };
var Jbt = new Ot("StorageCache"),
  ax = class e extends ox {
    constructor(t) {
      let r = JI();
      super({ config: t, keyValueStorage: new bc(r) }),
        (this.storage = r),
        (this.getItem = this.getItem.bind(this)),
        (this.setItem = this.setItem.bind(this)),
        (this.removeItem = this.removeItem.bind(this));
    }
    async getAllCacheKeys(t) {
      let { omitSizeKey: r } = t ?? {},
        n = [];
      for (let i = 0; i < this.storage.length; i++) {
        let o = this.storage.key(i);
        (r && o === lm(this.config.keyPrefix)) ||
          (o?.startsWith(this.config.keyPrefix) &&
            n.push(o.substring(this.config.keyPrefix.length)));
      }
      return n;
    }
    createInstance(t) {
      return (
        (!t.keyPrefix || t.keyPrefix === Ld.keyPrefix) &&
          (Jbt.error("invalid keyPrefix, setting keyPrefix with timeStamp"),
          (t.keyPrefix = Md.toString())),
        new e(t)
      );
    }
  };
var Zbt = new ax();
c();
c();
var eSt = new Ot("I18n"),
  uue = class {
    constructor() {
      (this._options = null), (this._lang = null), (this._dict = {});
    }
    setDefaultLanguage() {
      !this._lang &&
        typeof window < "u" &&
        window &&
        window.navigator &&
        (this._lang = window.navigator.language),
        eSt.debug(this._lang);
    }
    setLanguage(t) {
      this._lang = t;
    }
    get(t, r = void 0) {
      if ((this.setDefaultLanguage(), !this._lang))
        return typeof r < "u" ? r : t;
      let n = this._lang,
        i = this.getByLanguage(t, n);
      return i ||
        (n.indexOf("-") > 0 && (i = this.getByLanguage(t, n.split("-")[0])), i)
        ? i
        : typeof r < "u"
          ? r
          : t;
    }
    getByLanguage(t, r, n = null) {
      if (!r) return n;
      let i = this._dict[r];
      return i ? i[t] : n;
    }
    putVocabulariesForLanguage(t, r) {
      let n = this._dict[t];
      n || (n = this._dict[t] = {}), (this._dict[t] = { ...n, ...r });
    }
    putVocabularies(t) {
      Object.keys(t).forEach((r) => {
        this.putVocabulariesForLanguage(r, t[r]);
      });
    }
  };
c();
var jd;
(function (e) {
  e.NotConfigured = "NotConfigured";
})(jd || (jd = {}));
var tSt = { [jd.NotConfigured]: { message: "i18n is not configured." } },
  $S = ju(tSt);
var lue = new Ot("I18n"),
  sx = { language: null },
  Ns = null,
  cx = class e {
    static configure(t) {
      return (
        lue.debug("configure I18n"),
        t && ((sx = Object.assign({}, sx, t.I18n || t)), e.createInstance()),
        sx
      );
    }
    static getModuleName() {
      return "I18n";
    }
    static createInstance() {
      lue.debug("create I18n instance"), !Ns && (Ns = new uue());
    }
    static setLanguage(t) {
      e.checkConfig(), $S(!!Ns, jd.NotConfigured), Ns.setLanguage(t);
    }
    static get(t, r) {
      return e.checkConfig()
        ? ($S(!!Ns, jd.NotConfigured), Ns.get(t, r))
        : typeof r > "u"
          ? t
          : r;
    }
    static putVocabulariesForLanguage(t, r) {
      e.checkConfig(),
        $S(!!Ns, jd.NotConfigured),
        Ns.putVocabulariesForLanguage(t, r);
    }
    static putVocabularies(t) {
      e.checkConfig(), $S(!!Ns, jd.NotConfigured), Ns.putVocabularies(t);
    }
    static checkConfig() {
      return Ns || e.createInstance(), !0;
    }
  };
cx.createInstance();
c();
c();
c();
var ux = (e) =>
  Object.keys(e)
    .map((t) => t.toLowerCase())
    .sort()
    .join(";");
c();
c();
c();
var rSt = "X-Amz-Date";
var nSt = "X-Amz-Security-Token",
  due = "authorization",
  fue = "host",
  pue = rSt.toLowerCase(),
  mue = nSt.toLowerCase(),
  lx = "aws4_request",
  dx = "AWS4-HMAC-SHA256",
  hue = "AWS4",
  gue = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
  vue = "UNSIGNED-PAYLOAD";
var yue = (e, t, r) => `${e}/${t}/${r}/${lx}`;
c();
var _ue = (e) => {
  let t = e.toISOString().replace(/[:-]|\.\d{3}/g, "");
  return { longDate: t, shortDate: t.slice(0, 8) };
};
var Eue = ({
  credentials: e,
  signingDate: t = new Date(),
  signingRegion: r,
  signingService: n,
  uriEscapePath: i = !0,
}) => {
  let { accessKeyId: o, secretAccessKey: a, sessionToken: s } = e,
    { longDate: u, shortDate: l } = _ue(t),
    d = yue(l, r, n);
  return {
    accessKeyId: o,
    credentialScope: d,
    longDate: u,
    secretAccessKey: a,
    sessionToken: s,
    shortDate: l,
    signingRegion: r,
    signingService: n,
    uriEscapePath: i,
  };
};
c();
c();
var bue = A(ad(), 1),
  Sue = A(sd(), 1),
  jv = (e, t) => {
    let r = new bue.Sha256(e ?? void 0);
    return r.update(t), r.digestSync();
  },
  zS = (e, t) => {
    let r = jv(e, t);
    return (0, Sue.toHex)(r);
  };
c();
c();
var Cue = (e) =>
  Object.entries(e)
    .map(([t, r]) => ({
      key: t.toLowerCase(),
      value: r?.trim().replace(/\s+/g, " ") ?? "",
    }))
    .sort((t, r) => (t.key < r.key ? -1 : 1))
    .map(
      (t) => `${t.key}:${t.value}
`,
    )
    .join("");
c();
var Oue = (e) =>
    Array.from(e)
      .sort(([t, r], [n, i]) => (t === n ? (r < i ? -1 : 1) : t < n ? -1 : 1))
      .map(([t, r]) => `${wue(t)}=${wue(r)}`)
      .join("&"),
  wue = (e) => encodeURIComponent(e).replace(/[!'()*]/g, iSt),
  iSt = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`;
c();
var Tue = (e, t = !0) =>
  e ? (t ? encodeURIComponent(e).replace(/%2F/g, "/") : e) : "/";
c();
var Aue = (e) => (e == null ? gue : oSt(e) ? zS(null, e) : vue),
  oSt = (e) => typeof e == "string" || ArrayBuffer.isView(e) || aSt(e),
  aSt = (e) =>
    (typeof ArrayBuffer == "function" && e instanceof ArrayBuffer) ||
    Object.prototype.toString.call(e) === "[object ArrayBuffer]";
var Pue = ({ body: e, headers: t, method: r, url: n }, i = !0) =>
  [r, Tue(n.pathname, i), Oue(n.searchParams), Cue(t), ux(t), Aue(e)].join(`
`);
c();
var Rue = (e, t, r, n) => {
  let i = `${hue}${e}`,
    o = jv(i, t),
    a = jv(o, r),
    s = jv(a, n);
  return jv(s, lx);
};
c();
var Iue = (e, t, r) =>
  [dx, e, t, r].join(`
`);
var xue = (
  e,
  {
    credentialScope: t,
    longDate: r,
    secretAccessKey: n,
    shortDate: i,
    signingRegion: o,
    signingService: a,
    uriEscapePath: s,
  },
) => {
  let u = Pue(e, s),
    l = zS(null, u),
    d = Iue(r, t, l);
  return zS(Rue(n, i, o, a), d);
};
var KS = (e, t) => {
  let r = Eue(t),
    { accessKeyId: n, credentialScope: i, longDate: o, sessionToken: a } = r,
    s = { ...e.headers };
  (s[fue] = e.url.host), (s[pue] = o), a && (s[mue] = a);
  let u = { ...e, headers: s },
    l = xue(u, r),
    d = `Credential=${n}/${i}`,
    f = `SignedHeaders=${ux(s)}`,
    m = `Signature=${l}`;
  return (s[due] = `${dx} ${d}, ${f}, ${m}`), u;
};
var $Zr = A(ad(), 1),
  zZr = A(sd(), 1);
c();
var fx = (e) => new Date(Date.now() + e);
c();
c();
var sSt = 5 * 60 * 1e3,
  Nue = (e, t) => Math.abs(fx(t).getTime() - e) >= sSt;
var kue = (e, t) => (Nue(e, t) ? e - Date.now() : t);
var oV = ({ credentials: e, region: t, service: r, uriEscapePath: n = !0 }) => {
    let i;
    return (o, a) =>
      async function (u) {
        i = i ?? 0;
        let l = {
            credentials:
              typeof e == "function"
                ? await e({ forceRefresh: !!a?.isCredentialsExpired })
                : e,
            signingDate: fx(i),
            signingRegion: t,
            signingService: r,
            uriEscapePath: n,
          },
          d = await KS(u, l),
          f = await o(d),
          m = cSt(f);
        return m && (i = kue(Date.parse(m), i)), f;
      };
  },
  cSt = ({ headers: e } = {}) => e?.date ?? e?.Date ?? e?.["x-amz-date"];
c();
c();
var WS = class extends Error {
  constructor() {
    super(...arguments), (this.nonRetryable = !0);
  }
};
c();
var aV = (e, t, r = 3e5, n) => one(e, t, zI(r), n);
c();
function sV(e) {
  return (e.match(/.{2}/g) || [])
    .map((r) => String.fromCharCode(parseInt(r, 16)))
    .join("");
}
c();
var cV = (e) => {
  let t;
  return async (...r) =>
    t ||
    ((t = new Promise((n, i) => {
      e(...r)
        .then((o) => {
          n(o);
        })
        .catch((o) => {
          i(o);
        })
        .finally(() => {
          t = void 0;
        });
    })),
    t);
};
c();
function px({ expiresAt: e, clockDrift: t, tolerance: r = 5e3 }) {
  return Date.now() + t + r > e;
}
c();
var QS = class e extends Br {
    get response() {
      return this._response ? uSt(this._response) : void 0;
    }
    constructor(t) {
      super(t),
        (this.constructor = e),
        Object.setPrototypeOf(this, e.prototype),
        t.response && (this._response = t.response);
    }
  },
  uSt = (e) => ({ ...e, headers: { ...e.headers } });
c();
c();
function Due(e) {
  return Array.from(e, (t) => String.fromCodePoint(t)).join("");
}
var uV = {
  convert(e, t = { urlSafe: !1, skipPadding: !1 }) {
    let r = typeof e == "string" ? e : Due(e),
      n = rne()(r);
    return (
      t.urlSafe && (n = n.replace(/\+/g, "-").replace(/\//g, "_")),
      t.skipPadding && (n = n.replace(/=/g, "")),
      n
    );
  },
};
c();
c();
c();
var Sn;
(function (e) {
  (e.EmptySignInUsername = "EmptySignInUsername"),
    (e.EmptySignInPassword = "EmptySignInPassword"),
    (e.CustomAuthSignInPassword = "CustomAuthSignInPassword"),
    (e.EmptySignUpUsername = "EmptySignUpUsername"),
    (e.EmptySignUpPassword = "EmptySignUpPassword"),
    (e.EmptyConfirmSignUpUsername = "EmptyConfirmSignUpUsername"),
    (e.EmptyConfirmSignUpCode = "EmptyConfirmSignUpCode"),
    (e.EmptyResendSignUpCodeUsername = "EmptyresendSignUpCodeUsername"),
    (e.EmptyChallengeResponse = "EmptyChallengeResponse"),
    (e.EmptyConfirmResetPasswordUsername = "EmptyConfirmResetPasswordUsername"),
    (e.EmptyConfirmResetPasswordNewPassword =
      "EmptyConfirmResetPasswordNewPassword"),
    (e.EmptyConfirmResetPasswordConfirmationCode =
      "EmptyConfirmResetPasswordConfirmationCode"),
    (e.EmptyResetPasswordUsername = "EmptyResetPasswordUsername"),
    (e.EmptyVerifyTOTPSetupCode = "EmptyVerifyTOTPSetupCode"),
    (e.EmptyConfirmUserAttributeCode = "EmptyConfirmUserAttributeCode"),
    (e.IncorrectMFAMethod = "IncorrectMFAMethod"),
    (e.EmptyUpdatePassword = "EmptyUpdatePassword");
})(Sn || (Sn = {}));
var itn = {
    [Sn.EmptyChallengeResponse]: {
      message: "challengeResponse is required to confirmSignIn",
    },
    [Sn.EmptyConfirmResetPasswordUsername]: {
      message: "username is required to confirmResetPassword",
    },
    [Sn.EmptyConfirmSignUpCode]: {
      message: "code is required to confirmSignUp",
    },
    [Sn.EmptyConfirmSignUpUsername]: {
      message: "username is required to confirmSignUp",
    },
    [Sn.EmptyConfirmResetPasswordConfirmationCode]: {
      message: "confirmationCode is required to confirmResetPassword",
    },
    [Sn.EmptyConfirmResetPasswordNewPassword]: {
      message: "newPassword is required to confirmResetPassword",
    },
    [Sn.EmptyResendSignUpCodeUsername]: {
      message: "username is required to confirmSignUp",
    },
    [Sn.EmptyResetPasswordUsername]: {
      message: "username is required to resetPassword",
    },
    [Sn.EmptySignInPassword]: { message: "password is required to signIn" },
    [Sn.EmptySignInUsername]: { message: "username is required to signIn" },
    [Sn.EmptySignUpPassword]: { message: "password is required to signUp" },
    [Sn.EmptySignUpUsername]: { message: "username is required to signUp" },
    [Sn.CustomAuthSignInPassword]: {
      message:
        "A password is not needed when signing in with CUSTOM_WITHOUT_SRP",
      recoverySuggestion: "Do not include a password in your signIn call.",
    },
    [Sn.IncorrectMFAMethod]: {
      message:
        "Incorrect MFA method was chosen. It should be either SMS, TOTP, or EMAIL",
      recoverySuggestion:
        "Try to pass SMS, TOTP, or EMAIL as the challengeResponse",
    },
    [Sn.EmptyVerifyTOTPSetupCode]: {
      message: "code is required to verifyTotpSetup",
    },
    [Sn.EmptyUpdatePassword]: {
      message: "oldPassword and newPassword are required to changePassword",
    },
    [Sn.EmptyConfirmUserAttributeCode]: {
      message: "confirmation code is required to confirmUserAttribute",
    },
  },
  Fn;
(function (e) {
  (e.DEFAULT_MSG = "Authentication Error"),
    (e.EMPTY_EMAIL = "Email cannot be empty"),
    (e.EMPTY_PHONE = "Phone number cannot be empty"),
    (e.EMPTY_USERNAME = "Username cannot be empty"),
    (e.INVALID_USERNAME =
      "The username should either be a string or one of the sign in types"),
    (e.EMPTY_PASSWORD = "Password cannot be empty"),
    (e.EMPTY_CODE = "Confirmation code cannot be empty"),
    (e.SIGN_UP_ERROR = "Error creating account"),
    (e.NO_MFA = "No valid MFA method provided"),
    (e.INVALID_MFA = "Invalid MFA type"),
    (e.EMPTY_CHALLENGE = "Challenge response cannot be empty"),
    (e.NO_USER_SESSION = "Failed to get the session because the user is empty"),
    (e.NETWORK_ERROR = "Network Error"),
    (e.DEVICE_CONFIG =
      "Device tracking has not been configured in this User Pool"),
    (e.AUTOSIGNIN_ERROR = "Please use your credentials to sign in"),
    (e.OAUTH_ERROR =
      "Couldn't finish OAuth flow, check your User Pool HostedUI settings");
})(Fn || (Fn = {}));
var mx;
(function (e) {
  (e.SignInException = "SignInException"),
    (e.OAuthSignInError = "OAuthSignInException");
})(mx || (mx = {}));
c();
var Ye = class e extends Br {
  constructor(t) {
    super(t), (this.constructor = e), Object.setPrototypeOf(this, e.prototype);
  }
};
c();
function Lue(e) {
  let t = e?.split("_")[0];
  if (!e || e.indexOf("_") < 0 || !t || typeof t != "string")
    throw new Ye({
      name: "InvalidUserPoolId",
      message: "Invalid user pool id provided.",
    });
  return t;
}
function YS(e) {
  if (!e || !e.includes(":"))
    throw new Ye({
      name: "InvalidIdentityPoolIdException",
      message: "Invalid identity pool id provided.",
      recoverySuggestion:
        "Make sure a valid identityPoolId is given in the config.",
    });
  return e.split(":")[0];
}
c();
var Fv = "UserUnAuthenticatedException";
var lSt = "InvalidRedirectException",
  dSt = "InvalidAppSchemeException",
  fSt = "InvalidPreferredRedirectUrlException",
  Mue = new Ye({
    name: lSt,
    message:
      "signInRedirect or signOutRedirect had an invalid format or was not found.",
    recoverySuggestion:
      "Please make sure the signIn/Out redirect in your oauth config is valid.",
  }),
  mtn = new Ye({
    name: dSt,
    message: "A valid non-http app scheme was not found in the config.",
    recoverySuggestion:
      "Please make sure a valid custom app scheme is present in the config.",
  }),
  que = new Ye({
    name: fSt,
    message:
      "The given preferredRedirectUrl does not match any items in the redirectSignOutUrls array from the config.",
    recoverySuggestion:
      "Please make sure a matching preferredRedirectUrl is provided.",
  }),
  pSt = "InvalidOriginException",
  jue = new Ye({
    name: pSt,
    message:
      "redirect is coming from a different origin. The oauth flow needs to be initiated from the same origin",
    recoverySuggestion: "Please call signInWithRedirect from the same origin.",
  });
var Fue = "TokenRefreshException",
  Bue = "UnexpectedSignInInterruptionException";
c();
c();
c();
function Uue(e) {
  if (!e || !e.accessToken)
    throw new Ye({
      name: Fv,
      message: "User needs to be authenticated to call this API.",
      recoverySuggestion: "Sign in before calling this API again.",
    });
}
function Hue(e) {
  if (!e || !e.idToken)
    throw new Ye({
      name: Fv,
      message: "User needs to be authenticated to call this API.",
      recoverySuggestion: "Sign in before calling this API again.",
    });
}
var mSt = new Ye({
    name: Fue,
    message: `Token refresh is not supported when authenticated with the 'implicit grant' (token) oauth flow. 
	Please change your oauth configuration to use 'code grant' flow.`,
    recoverySuggestion: `Please logout and change your Amplify configuration to use "code grant" flow. 
	E.g { responseType: 'code' }`,
  }),
  hSt = new Ye({
    name: Fv,
    message: "User needs to be authenticated to call this API.",
    recoverySuggestion: "Sign in before calling this API again.",
  });
function Gue(e) {
  if (vSt(e)) throw mSt;
  if (!gSt(e)) throw hSt;
}
var Vue = {
  inflightOAuth: "inflightOAuth",
  oauthSignIn: "oauthSignIn",
  oauthPKCE: "oauthPKCE",
  oauthState: "oauthState",
};
function $ue(e) {
  return e?.accessToken || e?.idToken;
}
function gSt(e) {
  return $ue(e) && e?.refreshToken;
}
function vSt(e) {
  return $ue(e) && !e?.refreshToken;
}
var zue = async (e) => {
  let t = e.getConfig().Auth?.Cognito;
  Yr(t);
  let r = await e.Auth.getTokens({ forceRefresh: !1 });
  Uue(r);
  let { "cognito:username": n, sub: i } = r.idToken?.payload ?? {},
    o = { username: n, userId: i },
    a = ySt(r);
  return a && (o.signInDetails = a), o;
};
function ySt(e) {
  return e?.signInDetails;
}
var Kue = async () => zue(Qn);
c();
var Wue = (e, t) => wa({ category: $p.Auth, action: e, ...t });
c();
c();
c();
var Que = (e) => (t, r) => {
    let n = _St(e),
      i = JSON.stringify(t);
    return ESt(r, n, i);
  },
  _St = (e) => ({
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": `AWSCognitoIdentityProviderService.${e}`,
  }),
  ESt = ({ url: e }, t, r) => ({ headers: t, url: e, body: r, method: "POST" });
c();
c();
c();
function Ku(e) {
  if (!e || e.name === "Error" || e instanceof TypeError)
    throw new Ye({
      name: Xo.Unknown,
      message: "An unknown error has occurred.",
      underlyingError: e,
    });
}
var Yue = () => async (e) => {
  if (e.statusCode >= 300) {
    let t = await Zo(e);
    throw (
      (Ku(t),
      new Ye({ name: t.name, message: t.message, metadata: t.$metadata }))
    );
  }
  return Dd(e);
};
c();
var bSt = () => (e, t) =>
    async function (n) {
      return (n.headers["cache-control"] = "no-store"), e(n);
    },
  Xue = xs(US, [bSt]);
c();
c();
var hx = "cognito-idp";
var Jue = {
  service: hx,
  retryDecider: cm(Zo),
  computeDelay: sm,
  userAgentValue: wa(),
  cache: "no-store",
};
var Zue = (e) => nm(Xue, Que("InitiateAuth"), Yue(), { ...Jue, ...e });
c();
c();
var ele = ({ region: e }) => ({ url: new jn(`https://${hx}.${e}.${BS(e)}`) });
var tle =
  ({ endpointOverride: e }) =>
  (t) =>
    e ? { url: new jn(e) } : ele(t);
c();
c();
c();
c();
c();
function rle({ username: e, userPoolId: t, userPoolClientId: r }) {
  if (typeof window > "u") return;
  let n = window.AmazonCognitoAdvancedSecurityData;
  if (typeof n > "u") return;
  let i = n.getData(e, t, r);
  return i ? { EncodedData: i } : {};
}
var SSt = async ({ tokens: e, authConfig: t, username: r }) => {
    Yr(t?.Cognito);
    let { userPoolId: n, userPoolClientId: i, userPoolEndpoint: o } = t.Cognito,
      a = Lue(n);
    Gue(e);
    let s = e.refreshToken,
      u = { REFRESH_TOKEN: s };
    e.deviceMetadata?.deviceKey && (u.DEVICE_KEY = e.deviceMetadata.deviceKey);
    let l = rle({ username: r, userPoolId: n, userPoolClientId: i }),
      d = Zue({ endpointResolver: tle({ endpointOverride: o }) }),
      { AuthenticationResult: f } = await d(
        { region: a },
        {
          ClientId: i,
          AuthFlow: "REFRESH_TOKEN_AUTH",
          AuthParameters: u,
          UserContextData: l,
        },
      ),
      m = qi(f?.AccessToken ?? ""),
      h = f?.IdToken ? qi(f.IdToken) : void 0,
      { iat: y } = m.payload;
    if (!y)
      throw new Ye({
        name: "iatNotFoundException",
        message: "iat not found in access token",
      });
    let _ = y * 1e3 - new Date().getTime();
    return {
      accessToken: m,
      idToken: h,
      clockDrift: _,
      refreshToken: s,
      username: r,
    };
  },
  nle = cV(SSt);
c();
c();
var ile = {
  accessToken: "accessToken",
  idToken: "idToken",
  oidcProvider: "oidcProvider",
  clockDrift: "clockDrift",
  refreshToken: "refreshToken",
  deviceKey: "deviceKey",
  randomPasswordKey: "randomPasswordKey",
  deviceGroupKey: "deviceGroupKey",
  signInDetails: "signInDetails",
  oauthMetadata: "oauthMetadata",
};
c();
var XS;
(function (e) {
  e.InvalidAuthTokens = "InvalidAuthTokens";
})(XS || (XS = {}));
var CSt = {
    [XS.InvalidAuthTokens]: {
      message: "Invalid tokens.",
      recoverySuggestion: "Make sure the tokens are valid.",
    },
  },
  ole = ju(CSt);
c();
var lV = "CognitoIdentityServiceProvider";
var gx = class {
    getKeyValueStorage() {
      if (!this.keyValueStorage)
        throw new Ye({
          name: "KeyValueStorageNotFoundException",
          message: "KeyValueStorage was not found in TokenStore",
        });
      return this.keyValueStorage;
    }
    setKeyValueStorage(t) {
      this.keyValueStorage = t;
    }
    setAuthConfig(t) {
      this.authConfig = t;
    }
    async loadTokens() {
      try {
        let t = await this.getAuthKeys(),
          r = await this.getKeyValueStorage().getItem(t.accessToken);
        if (!r)
          throw new Ye({
            name: "NoSessionFoundException",
            message: "Auth session was not found. Make sure to call signIn.",
          });
        let n = qi(r),
          i = await this.getKeyValueStorage().getItem(t.idToken),
          o = i ? qi(i) : void 0,
          a =
            (await this.getKeyValueStorage().getItem(t.refreshToken)) ?? void 0,
          s = (await this.getKeyValueStorage().getItem(t.clockDrift)) ?? "0",
          u = Number.parseInt(s),
          l = await this.getKeyValueStorage().getItem(t.signInDetails),
          d = {
            accessToken: n,
            idToken: o,
            refreshToken: a,
            deviceMetadata: (await this.getDeviceMetadata()) ?? void 0,
            clockDrift: u,
            username: await this.getLastAuthUser(),
          };
        return l && (d.signInDetails = JSON.parse(l)), d;
      } catch {
        return null;
      }
    }
    async storeTokens(t) {
      ole(t !== void 0, XS.InvalidAuthTokens);
      let r = t.username;
      await this.getKeyValueStorage().setItem(this.getLastAuthUserKey(), r);
      let n = await this.getAuthKeys();
      await this.getKeyValueStorage().setItem(
        n.accessToken,
        t.accessToken.toString(),
      ),
        t.idToken
          ? await this.getKeyValueStorage().setItem(
              n.idToken,
              t.idToken.toString(),
            )
          : await this.getKeyValueStorage().removeItem(n.idToken),
        t.refreshToken
          ? await this.getKeyValueStorage().setItem(
              n.refreshToken,
              t.refreshToken,
            )
          : await this.getKeyValueStorage().removeItem(n.refreshToken),
        t.deviceMetadata &&
          (t.deviceMetadata.deviceKey &&
            (await this.getKeyValueStorage().setItem(
              n.deviceKey,
              t.deviceMetadata.deviceKey,
            )),
          t.deviceMetadata.deviceGroupKey &&
            (await this.getKeyValueStorage().setItem(
              n.deviceGroupKey,
              t.deviceMetadata.deviceGroupKey,
            )),
          await this.getKeyValueStorage().setItem(
            n.randomPasswordKey,
            t.deviceMetadata.randomPassword,
          )),
        t.signInDetails
          ? await this.getKeyValueStorage().setItem(
              n.signInDetails,
              JSON.stringify(t.signInDetails),
            )
          : await this.getKeyValueStorage().removeItem(n.signInDetails),
        await this.getKeyValueStorage().setItem(
          n.clockDrift,
          `${t.clockDrift}`,
        );
    }
    async clearTokens() {
      let t = await this.getAuthKeys();
      await Promise.all([
        this.getKeyValueStorage().removeItem(t.accessToken),
        this.getKeyValueStorage().removeItem(t.idToken),
        this.getKeyValueStorage().removeItem(t.clockDrift),
        this.getKeyValueStorage().removeItem(t.refreshToken),
        this.getKeyValueStorage().removeItem(t.signInDetails),
        this.getKeyValueStorage().removeItem(this.getLastAuthUserKey()),
        this.getKeyValueStorage().removeItem(t.oauthMetadata),
      ]);
    }
    async getDeviceMetadata(t) {
      let r = await this.getAuthKeys(t),
        n = await this.getKeyValueStorage().getItem(r.deviceKey),
        i = await this.getKeyValueStorage().getItem(r.deviceGroupKey),
        o = await this.getKeyValueStorage().getItem(r.randomPasswordKey);
      return o && i && n
        ? { deviceKey: n, deviceGroupKey: i, randomPassword: o }
        : null;
    }
    async clearDeviceMetadata(t) {
      let r = await this.getAuthKeys(t);
      await Promise.all([
        this.getKeyValueStorage().removeItem(r.deviceKey),
        this.getKeyValueStorage().removeItem(r.deviceGroupKey),
        this.getKeyValueStorage().removeItem(r.randomPasswordKey),
      ]);
    }
    async getAuthKeys(t) {
      Yr(this.authConfig?.Cognito);
      let r = t ?? (await this.getLastAuthUser());
      return wSt(lV, `${this.authConfig.Cognito.userPoolClientId}.${r}`);
    }
    getLastAuthUserKey() {
      Yr(this.authConfig?.Cognito);
      let t = this.authConfig.Cognito.userPoolClientId;
      return `${lV}.${t}.LastAuthUser`;
    }
    async getLastAuthUser() {
      return (
        (await this.getKeyValueStorage().getItem(this.getLastAuthUserKey())) ??
        "username"
      );
    }
    async setOAuthMetadata(t) {
      let { oauthMetadata: r } = await this.getAuthKeys();
      await this.getKeyValueStorage().setItem(r, JSON.stringify(t));
    }
    async getOAuthMetadata() {
      let { oauthMetadata: t } = await this.getAuthKeys(),
        r = await this.getKeyValueStorage().getItem(t);
      return r && JSON.parse(r);
    }
  },
  wSt = (e, t) => JS(ile)(`${e}`, t);
function JS(e) {
  let t = Object.values({ ...e });
  return (r, n) => t.reduce((i, o) => ({ ...i, [o]: `${r}.${n}.${o}` }), {});
}
c();
c();
c();
var ale = "amplify-signin-with-hostedUI",
  Sc = "CognitoIdentityServiceProvider",
  vx = class {
    constructor(t) {
      this.keyValueStorage = t;
    }
    async clearOAuthInflightData() {
      Yr(this.cognitoConfig);
      let t = Cc(Sc, this.cognitoConfig.userPoolClientId);
      await Promise.all([
        this.keyValueStorage.removeItem(t.inflightOAuth),
        this.keyValueStorage.removeItem(t.oauthPKCE),
        this.keyValueStorage.removeItem(t.oauthState),
      ]);
    }
    async clearOAuthData() {
      Yr(this.cognitoConfig);
      let t = Cc(Sc, this.cognitoConfig.userPoolClientId);
      return (
        await this.clearOAuthInflightData(),
        await this.keyValueStorage.removeItem(ale),
        this.keyValueStorage.removeItem(t.oauthSignIn)
      );
    }
    loadOAuthState() {
      Yr(this.cognitoConfig);
      let t = Cc(Sc, this.cognitoConfig.userPoolClientId);
      return this.keyValueStorage.getItem(t.oauthState);
    }
    storeOAuthState(t) {
      Yr(this.cognitoConfig);
      let r = Cc(Sc, this.cognitoConfig.userPoolClientId);
      return this.keyValueStorage.setItem(r.oauthState, t);
    }
    loadPKCE() {
      Yr(this.cognitoConfig);
      let t = Cc(Sc, this.cognitoConfig.userPoolClientId);
      return this.keyValueStorage.getItem(t.oauthPKCE);
    }
    storePKCE(t) {
      Yr(this.cognitoConfig);
      let r = Cc(Sc, this.cognitoConfig.userPoolClientId);
      return this.keyValueStorage.setItem(r.oauthPKCE, t);
    }
    setAuthConfig(t) {
      this.cognitoConfig = t;
    }
    async loadOAuthInFlight() {
      Yr(this.cognitoConfig);
      let t = Cc(Sc, this.cognitoConfig.userPoolClientId);
      return (await this.keyValueStorage.getItem(t.inflightOAuth)) === "true";
    }
    async storeOAuthInFlight(t) {
      Yr(this.cognitoConfig);
      let r = Cc(Sc, this.cognitoConfig.userPoolClientId);
      await this.keyValueStorage.setItem(r.inflightOAuth, `${t}`);
    }
    async loadOAuthSignIn() {
      Yr(this.cognitoConfig);
      let t = Cc(Sc, this.cognitoConfig.userPoolClientId),
        r = await this.keyValueStorage.getItem(ale),
        [n, i] =
          (await this.keyValueStorage.getItem(t.oauthSignIn))?.split(",") ?? [];
      return {
        isOAuthSignIn: n === "true" || r === "true",
        preferPrivateSession: i === "true",
      };
    }
    async storeOAuthSignIn(t, r = !1) {
      Yr(this.cognitoConfig);
      let n = Cc(Sc, this.cognitoConfig.userPoolClientId);
      await this.keyValueStorage.setItem(n.oauthSignIn, `${t},${r}`);
    }
  },
  Cc = (e, t) => JS(Vue)(e, t);
var Eo = new vx($u);
c();
var dV = [],
  sle = (e) => {
    dV.push(e);
  },
  yx = () => {
    for (; dV.length; ) dV.pop()?.();
  };
var _x = class {
  constructor() {
    this.waitForInflightOAuth = FS()
      ? async () => {
          if (await Eo.loadOAuthInFlight())
            return this.inflightPromise
              ? this.inflightPromise
              : ((this.inflightPromise = new Promise((t, r) => {
                  sle(t);
                })),
                this.inflightPromise);
        }
      : async () => {};
  }
  setAuthConfig(t) {
    Eo.setAuthConfig(t.Cognito), (this.authConfig = t);
  }
  setTokenRefresher(t) {
    this.tokenRefresher = t;
  }
  setAuthTokenStore(t) {
    this.tokenStore = t;
  }
  getTokenStore() {
    if (!this.tokenStore)
      throw new Ye({
        name: "EmptyTokenStoreException",
        message: "TokenStore not set",
      });
    return this.tokenStore;
  }
  getTokenRefresher() {
    if (!this.tokenRefresher)
      throw new Ye({
        name: "EmptyTokenRefresherException",
        message: "TokenRefresher not set",
      });
    return this.tokenRefresher;
  }
  async getTokens(t) {
    let r;
    try {
      Yr(this.authConfig?.Cognito);
    } catch {
      return null;
    }
    await this.waitForInflightOAuth(),
      (this.inflightPromise = void 0),
      (r = await this.getTokenStore().loadTokens());
    let n = await this.getTokenStore().getLastAuthUser();
    if (r === null) return null;
    let i =
        !!r?.idToken &&
        px({
          expiresAt: (r.idToken?.payload?.exp ?? 0) * 1e3,
          clockDrift: r.clockDrift ?? 0,
        }),
      o = px({
        expiresAt: (r.accessToken?.payload?.exp ?? 0) * 1e3,
        clockDrift: r.clockDrift ?? 0,
      });
    return (t?.forceRefresh || i || o) &&
      ((r = await this.refreshTokens({ tokens: r, username: n })), r === null)
      ? null
      : {
          accessToken: r?.accessToken,
          idToken: r?.idToken,
          signInDetails: r?.signInDetails,
        };
  }
  async refreshTokens({ tokens: t, username: r }) {
    try {
      let { signInDetails: n } = t,
        i = await this.getTokenRefresher()({
          tokens: t,
          authConfig: this.authConfig,
          username: r,
        });
      return (
        (i.signInDetails = n),
        await this.setTokens({ tokens: i }),
        fi.dispatch("auth", { event: "tokenRefresh" }, "Auth", Mi),
        i
      );
    } catch (n) {
      return this.handleErrors(n);
    }
  }
  handleErrors(t) {
    if (
      (Ku(t),
      t.name !== Xo.NetworkError && this.clearTokens(),
      fi.dispatch(
        "auth",
        { event: "tokenRefresh_failure", data: { error: t } },
        "Auth",
        Mi,
      ),
      t.name.startsWith("NotAuthorizedException"))
    )
      return null;
    throw t;
  }
  async setTokens({ tokens: t }) {
    return this.getTokenStore().storeTokens(t);
  }
  async clearTokens() {
    return this.getTokenStore().clearTokens();
  }
  getDeviceMetadata(t) {
    return this.getTokenStore().getDeviceMetadata(t);
  }
  clearDeviceMetadata(t) {
    return this.getTokenStore().clearDeviceMetadata(t);
  }
  setOAuthMetadata(t) {
    return this.getTokenStore().setOAuthMetadata(t);
  }
  getOAuthMetadata() {
    return this.getTokenStore().getOAuthMetadata();
  }
};
var Ex = class {
  constructor() {
    (this.authTokenStore = new gx()),
      this.authTokenStore.setKeyValueStorage($u),
      (this.tokenOrchestrator = new _x()),
      this.tokenOrchestrator.setAuthTokenStore(this.authTokenStore),
      this.tokenOrchestrator.setTokenRefresher(nle);
  }
  getTokens({ forceRefresh: t } = { forceRefresh: !1 }) {
    return this.tokenOrchestrator.getTokens({ forceRefresh: t });
  }
  setKeyValueStorage(t) {
    this.authTokenStore.setKeyValueStorage(t);
  }
  setAuthConfig(t) {
    this.authTokenStore.setAuthConfig(t),
      this.tokenOrchestrator.setAuthConfig(t);
  }
};
var dm = new Ex(),
  { tokenOrchestrator: bx } = dm;
async function fV(e) {
  if (e.AccessToken) {
    let t = qi(e.AccessToken),
      r = (t.payload.iat || 0) * 1e3,
      n = new Date().getTime(),
      i = r > 0 ? r - n : 0,
      o,
      a,
      s;
    e.RefreshToken && (a = e.RefreshToken),
      e.IdToken && (o = qi(e.IdToken)),
      e?.NewDeviceMetadata && (s = e.NewDeviceMetadata);
    let u = {
      accessToken: t,
      idToken: o,
      refreshToken: a,
      clockDrift: i,
      deviceMetadata: s,
      username: e.username,
    };
    e?.signInDetails && (u.signInDetails = e.signInDetails),
      await bx.setTokens({ tokens: u });
  } else
    throw new Br({
      message: "Invalid tokens",
      name: "InvalidTokens",
      recoverySuggestion: "Check Cognito UserPool settings",
    });
}
c();
var OSt = "Unable to get user session following successful sign-in.",
  cle = async () => {
    try {
      fi.dispatch("auth", { event: "signedIn", data: await Kue() }, "Auth", Mi);
    } catch (e) {
      throw e.name === Fv
        ? new Ye({
            name: Bue,
            message: OSt,
            recoverySuggestion:
              "This most likely is due to auth tokens not being persisted. If you are using cookie store, please ensure cookies can be correctly set from your server.",
          })
        : e;
    }
  };
c();
c();
c();
c();
c();
c();
var $nn = new Ot("AuthError");
var ule = {
  oauthSignInError: {
    message: Fn.OAUTH_ERROR,
    log: "Make sure Cognito Hosted UI has been configured correctly",
  },
  noConfig: {
    message: Fn.DEFAULT_MSG,
    log: `
            Error: Amplify has not been configured correctly.
            This error is typically caused by one of the following scenarios:

            1. Make sure you're passing the awsconfig object to Amplify.configure() in your app's entry point
                See https://aws-amplify.github.io/docs/js/authentication#configure-your-app for more information
            
            2. There might be multiple conflicting versions of amplify packages in your node_modules.
				Refer to our docs site for help upgrading Amplify packages (https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js)
        `,
  },
  missingAuthConfig: {
    message: Fn.DEFAULT_MSG,
    log: `
            Error: Amplify has not been configured correctly. 
            The configuration object is missing required auth properties.
            This error is typically caused by one of the following scenarios:

            1. Did you run \`amplify push\` after adding auth via \`amplify add auth\`?
                See https://aws-amplify.github.io/docs/js/authentication#amplify-project-setup for more information

            2. This could also be caused by multiple conflicting versions of amplify packages, see (https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js) for help upgrading Amplify packages.
        `,
  },
  emptyUsername: { message: Fn.EMPTY_USERNAME },
  invalidUsername: { message: Fn.INVALID_USERNAME },
  emptyPassword: { message: Fn.EMPTY_PASSWORD },
  emptyCode: { message: Fn.EMPTY_CODE },
  signUpError: {
    message: Fn.SIGN_UP_ERROR,
    log: "The first parameter should either be non-null string or object",
  },
  noMFA: { message: Fn.NO_MFA },
  invalidMFA: { message: Fn.INVALID_MFA },
  emptyChallengeResponse: { message: Fn.EMPTY_CHALLENGE },
  noUserSession: { message: Fn.NO_USER_SESSION },
  deviceConfig: { message: Fn.DEVICE_CONFIG },
  networkError: { message: Fn.NETWORK_ERROR },
  autoSignInError: { message: Fn.AUTOSIGNIN_ERROR },
  default: { message: Fn.DEFAULT_MSG },
};
var Bv = (e, t) =>
  new Ye({
    message: e ?? "An error has occurred during the oauth process.",
    name: mx.OAuthSignInError,
    recoverySuggestion: t ?? ule.oauthSignInError.log,
  });
c();
c();
var Sx;
(function (e) {
  (e.NoConfig = "noConfig"),
    (e.MissingAuthConfig = "missingAuthConfig"),
    (e.EmptyUsername = "emptyUsername"),
    (e.InvalidUsername = "invalidUsername"),
    (e.EmptyPassword = "emptyPassword"),
    (e.EmptyCode = "emptyCode"),
    (e.SignUpError = "signUpError"),
    (e.NoMFA = "noMFA"),
    (e.InvalidMFA = "invalidMFA"),
    (e.EmptyChallengeResponse = "emptyChallengeResponse"),
    (e.NoUserSession = "noUserSession"),
    (e.Default = "default"),
    (e.DeviceConfig = "deviceConfig"),
    (e.NetworkError = "networkError"),
    (e.AutoSignInError = "autoSignInError"),
    (e.OAuthSignInError = "oauthSignInError");
})(Sx || (Sx = {}));
var TSt = "`signInWithRedirect` has been canceled.",
  ASt = "An error occurred while validating the state.",
  PSt = "Try to initiate an OAuth flow from Amplify",
  pV = async (e) => {
    let t = await Eo.loadOAuthState(),
      r = e === t ? t : void 0;
    if (!r)
      throw new Ye({
        name: Sx.OAuthSignInError,
        message: e === null ? TSt : ASt,
        recoverySuggestion: e === null ? void 0 : PSt,
      });
    return r;
  };
var lle = async ({
    currentUrl: e,
    userAgentValue: t,
    clientId: r,
    redirectUri: n,
    responseType: i,
    domain: o,
    preferPrivateSession: a,
  }) => {
    let s = new jn(e),
      u = s.searchParams.get("error"),
      l = s.searchParams.get("error_description");
    if (u) throw Bv(l ?? u);
    return i === "code"
      ? RSt({
          currentUrl: e,
          userAgentValue: t,
          clientId: r,
          redirectUri: n,
          domain: o,
          preferPrivateSession: a,
        })
      : ISt({ currentUrl: e, redirectUri: n, preferPrivateSession: a });
  },
  RSt = async ({
    currentUrl: e,
    userAgentValue: t,
    clientId: r,
    redirectUri: n,
    domain: i,
    preferPrivateSession: o,
  }) => {
    let a = new jn(e),
      s = a.searchParams.get("code"),
      u = a.searchParams.get("state");
    if (!s || !u) throw Bv("User cancelled OAuth flow.");
    let l = await pV(u),
      d = "https://" + i + "/oauth2/token",
      f = await Eo.loadPKCE(),
      m = {
        grant_type: "authorization_code",
        code: s,
        client_id: r,
        redirect_uri: n,
        ...(f ? { code_verifier: f } : {}),
      },
      h = Object.entries(m)
        .map(([H, B]) => `${encodeURIComponent(H)}=${encodeURIComponent(B)}`)
        .join("&"),
      {
        access_token: y,
        refresh_token: _,
        id_token: E,
        error: b,
        error_message: O,
        token_type: C,
        expires_in: P,
      } = await (
        await fetch(d, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            [hS]: t,
          },
          body: h,
        })
      ).json();
    if (b) throw Bv(O ?? b);
    let k = (y && qi(y).payload.username) ?? "username";
    return (
      await fV({ username: k, AccessToken: y, IdToken: E, RefreshToken: _ }),
      dle({ redirectUri: n, state: l, preferPrivateSession: o })
    );
  },
  ISt = async ({ currentUrl: e, redirectUri: t, preferPrivateSession: r }) => {
    let n = new jn(e),
      {
        id_token: i,
        access_token: o,
        state: a,
        token_type: s,
        expires_in: u,
        error_description: l,
        error: d,
      } = (n.hash ?? "#")
        .substring(1)
        .split("&")
        .map((h) => h.split("="))
        .reduce((h, [y, _]) => ({ ...h, [y]: _ }), {
          id_token: void 0,
          access_token: void 0,
          state: void 0,
          token_type: void 0,
          expires_in: void 0,
          error_description: void 0,
          error: void 0,
        });
    if (d) throw Bv(l ?? d);
    if (!o) throw Bv("No access token returned from OAuth flow.");
    let f = await pV(a),
      m = (o && qi(o).payload.username) ?? "username";
    return (
      await fV({ username: m, AccessToken: o, IdToken: i }),
      dle({ redirectUri: t, state: f, preferPrivateSession: r })
    );
  },
  dle = async ({ redirectUri: e, state: t, preferPrivateSession: r }) => {
    await bx.setOAuthMetadata({ oauthSignIn: !0 }),
      await Eo.clearOAuthData(),
      await Eo.storeOAuthSignIn(!0, r),
      yx(),
      kSt(e),
      xSt(t) &&
        fi.dispatch(
          "auth",
          { event: "customOAuthState", data: sV(NSt(t)) },
          "Auth",
          Mi,
        ),
      fi.dispatch("auth", { event: "signInWithRedirect" }, "Auth", Mi),
      await cle();
  },
  xSt = (e) => /-/.test(e),
  NSt = (e) => e.split("-").splice(1).join("-"),
  kSt = (e) => {
    typeof window < "u" &&
      typeof window.history < "u" &&
      window.history.replaceState(window.history.state, "", e);
  };
c();
function fle(e, t) {
  if (t) {
    let r = e?.find((n) => n === t);
    if (!r) throw que;
    return r;
  } else {
    let r = e?.find(DSt) ?? e?.find(LSt),
      n = e?.find(qSt) ?? e?.find(MSt);
    if (r) return r;
    throw n ? jue : Mue;
  }
}
var DSt = (e) =>
    e.startsWith(String(window.location.origin + window.location.pathname)),
  LSt = (e) => e.includes(String(window.location.hostname)),
  MSt = (e) => e.startsWith("http://"),
  qSt = (e) => e.startsWith("https://");
c();
var ple = async (e) => {
  yx(),
    await Eo.clearOAuthInflightData(),
    fi.dispatch(
      "auth",
      { event: "signInWithRedirect_failure", data: { error: e } },
      "Auth",
      Mi,
    );
};
var mle = async (e) => {
  try {
    Yr(e), p3(e), Eo.setAuthConfig(e);
  } catch {
    return;
  }
  if (await Eo.loadOAuthInFlight())
    try {
      let t = window.location.href,
        { loginWith: r, userPoolClientId: n } = e,
        { domain: i, redirectSignIn: o, responseType: a } = r.oauth,
        s = fle(o);
      await lle({
        currentUrl: t,
        clientId: n,
        domain: i,
        redirectUri: s,
        responseType: a,
        userAgentValue: Wue(bS.SignInWithRedirect),
      });
    } catch (t) {
      await ple(t);
    }
};
FS() && Qn[yS](mle);
c();
c();
c();
var hle = { identityId: "identityId" };
var jSt = new Ot("DefaultIdentityIdStore"),
  fm = class {
    setAuthConfig(t) {
      Gp(t.Cognito),
        (this.authConfig = t),
        (this._authKeys = FSt("Cognito", t.Cognito.identityPoolId));
    }
    constructor(t) {
      (this._authKeys = {}),
        (this._hasGuestIdentityId = !1),
        (this.keyValueStorage = t);
    }
    async loadIdentityId() {
      Gp(this.authConfig?.Cognito);
      try {
        if (this._primaryIdentityId)
          return { id: this._primaryIdentityId, type: "primary" };
        {
          let t = await this.keyValueStorage.getItem(this._authKeys.identityId);
          return t
            ? ((this._hasGuestIdentityId = !0), { id: t, type: "guest" })
            : null;
        }
      } catch (t) {
        return jSt.log("Error getting stored IdentityId.", t), null;
      }
    }
    async storeIdentityId(t) {
      Gp(this.authConfig?.Cognito),
        t.type === "guest"
          ? (this.keyValueStorage.setItem(this._authKeys.identityId, t.id),
            (this._primaryIdentityId = void 0),
            (this._hasGuestIdentityId = !0))
          : ((this._primaryIdentityId = t.id),
            this._hasGuestIdentityId &&
              (this.keyValueStorage.removeItem(this._authKeys.identityId),
              (this._hasGuestIdentityId = !1)));
    }
    async clearIdentityId() {
      (this._primaryIdentityId = void 0),
        await this.keyValueStorage.removeItem(this._authKeys.identityId);
    }
  },
  FSt = (e, t) => JS(hle)(`com.amplify.${e}`, t);
c();
c();
c();
function Cx(e) {
  let t = qi(e).payload.iss,
    r = {};
  if (!t)
    throw new Ye({
      name: "InvalidIdTokenException",
      message: "Invalid Idtoken.",
    });
  let n = t.replace(/(^\w+:|^)\/\//, "");
  return (r[n] = e), r;
}
async function gle({ tokens: e, authConfig: t, identityIdStore: r }) {
  r.setAuthConfig({ Cognito: t });
  let n = await r.loadIdentityId();
  if (n) return n.id;
  let i = e?.idToken ? Cx(e.idToken.toString()) : {},
    o = await BSt(i, t);
  return r.storeIdentityId({ id: o, type: e ? "primary" : "guest" }), o;
}
async function BSt(e, t) {
  let r = t?.identityPoolId,
    n = YS(r),
    i;
  try {
    i = (await tV({ region: n }, { IdentityPoolId: r, Logins: e })).IdentityId;
  } catch (o) {
    throw (Ku(o), new Ye(o));
  }
  if (!i)
    throw new Ye({
      name: "GetIdResponseException",
      message: "Received undefined response from getId operation",
      recoverySuggestion:
        "Make sure to pass a valid identityPoolId in the configuration.",
    });
  return i;
}
var wx = new Ot("CognitoCredentialsProvider"),
  vle = 50 * 60 * 1e3,
  pm = class {
    constructor(t) {
      (this._nextCredentialsRefresh = 0), (this._identityIdStore = t);
    }
    async clearCredentialsAndIdentityId() {
      wx.debug("Clearing out credentials and identityId"),
        (this._credentialsAndIdentityId = void 0),
        await this._identityIdStore.clearIdentityId();
    }
    async clearCredentials() {
      wx.debug("Clearing out in-memory credentials"),
        (this._credentialsAndIdentityId = void 0);
    }
    async getCredentialsAndIdentityId(t) {
      let r = t.authenticated,
        { tokens: n } = t,
        { authConfig: i } = t;
      try {
        Gp(i?.Cognito);
      } catch {
        return;
      }
      if (!r && !i.Cognito.allowGuestAccess) return;
      let { forceRefresh: o } = t,
        a = this.hasTokenChanged(n),
        s = await gle({
          tokens: n,
          authConfig: i.Cognito,
          identityIdStore: this._identityIdStore,
        });
      return (
        (o || a) && this.clearCredentials(),
        r
          ? (Hue(n), this.credsForOIDCTokens(i.Cognito, n, s))
          : this.getGuestCredentials(s, i.Cognito)
      );
    }
    async getGuestCredentials(t, r) {
      if (
        this._credentialsAndIdentityId &&
        !this.isPastTTL() &&
        this._credentialsAndIdentityId.isAuthenticatedCreds === !1
      )
        return (
          wx.info(
            "returning stored credentials as they neither past TTL nor expired.",
          ),
          this._credentialsAndIdentityId
        );
      this.clearCredentials();
      let n = YS(r.identityPoolId),
        i;
      try {
        i = await XI({ region: n }, { IdentityId: t });
      } catch (o) {
        throw (Ku(o), new Ye(o));
      }
      if (i?.Credentials?.AccessKeyId && i?.Credentials?.SecretKey) {
        this._nextCredentialsRefresh = new Date().getTime() + vle;
        let o = {
          credentials: {
            accessKeyId: i.Credentials.AccessKeyId,
            secretAccessKey: i.Credentials.SecretKey,
            sessionToken: i.Credentials.SessionToken,
            expiration: i.Credentials.Expiration,
          },
          identityId: t,
        };
        return (
          i.IdentityId &&
            ((o.identityId = i.IdentityId),
            this._identityIdStore.storeIdentityId({
              id: i.IdentityId,
              type: "guest",
            })),
          (this._credentialsAndIdentityId = { ...o, isAuthenticatedCreds: !1 }),
          o
        );
      } else
        throw new Ye({
          name: "CredentialsNotFoundException",
          message:
            "Cognito did not respond with either Credentials, AccessKeyId or SecretKey.",
        });
    }
    async credsForOIDCTokens(t, r, n) {
      if (
        this._credentialsAndIdentityId &&
        !this.isPastTTL() &&
        this._credentialsAndIdentityId.isAuthenticatedCreds === !0
      )
        return (
          wx.debug(
            "returning stored credentials as they neither past TTL nor expired.",
          ),
          this._credentialsAndIdentityId
        );
      this.clearCredentials();
      let i = r.idToken ? Cx(r.idToken.toString()) : {},
        o = YS(t.identityPoolId),
        a;
      try {
        a = await XI({ region: o }, { IdentityId: n, Logins: i });
      } catch (s) {
        throw (Ku(s), new Ye(s));
      }
      if (a?.Credentials?.AccessKeyId && a?.Credentials?.SecretKey) {
        this._nextCredentialsRefresh = new Date().getTime() + vle;
        let s = {
          credentials: {
            accessKeyId: a.Credentials.AccessKeyId,
            secretAccessKey: a.Credentials.SecretKey,
            sessionToken: a.Credentials.SessionToken,
            expiration: a.Credentials.Expiration,
          },
          identityId: n,
        };
        return (
          a.IdentityId &&
            ((s.identityId = a.IdentityId),
            this._identityIdStore.storeIdentityId({
              id: a.IdentityId,
              type: "primary",
            })),
          (this._credentialsAndIdentityId = {
            ...s,
            isAuthenticatedCreds: !0,
            associatedIdToken: r.idToken?.toString(),
          }),
          s
        );
      } else
        throw new Ye({
          name: "CredentialsException",
          message:
            "Cognito did not respond with either Credentials, AccessKeyId or SecretKey.",
        });
    }
    isPastTTL() {
      return this._nextCredentialsRefresh === void 0
        ? !0
        : this._nextCredentialsRefresh <= Date.now();
    }
    hasTokenChanged(t) {
      return (
        !!t &&
        !!this._credentialsAndIdentityId?.associatedIdToken &&
        t.idToken?.toString() !==
          this._credentialsAndIdentityId.associatedIdToken
      );
    }
  };
var mV = new pm(new fm($u));
var hV = {
  configure(e, t) {
    let r = _S(e),
      n = new VS({ sameSite: "lax" }),
      i = t?.ssr ? n : $u,
      o = t?.ssr ? new pm(new fm(n)) : mV;
    if (!r.Auth) {
      Qn.configure(r, t);
      return;
    }
    if (t?.Auth) {
      Qn.configure(r, t);
      return;
    }
    if (!Qn.libraryOptions.Auth) {
      dm.setAuthConfig(r.Auth),
        dm.setKeyValueStorage(i),
        Qn.configure(r, {
          ...t,
          Auth: { tokenProvider: dm, credentialsProvider: o },
        });
      return;
    }
    if (t) {
      let a = Qn.libraryOptions.Auth;
      t.ssr !== void 0 &&
        (dm.setKeyValueStorage(i), (a.credentialsProvider = o)),
        Qn.configure(r, { Auth: a, ...t });
      return;
    }
    Qn.configure(r);
  },
  getConfig() {
    return Qn.getConfig();
  },
};
c();
c();
c();
c();
var Lc = A(XN(), 1),
  Ghe = A(kd(), 1);
c();
c();
c();
var rf = class e extends QS {
  constructor(t) {
    super(t), (this.constructor = e), Object.setPrototypeOf(this, e.prototype);
  }
};
var Y0 = class e extends rf {
    constructor(t = {}) {
      super({
        name: "CanceledError",
        message: "Request is canceled by user",
        ...t,
      }),
        (this.constructor = e),
        Object.setPrototypeOf(this, e.prototype);
    }
  },
  JN = (e) => !!e && e instanceof Y0;
c();
c();
c();
c();
var ZN;
(function (e) {
  e.InvalidApiName = "InvalidApiName";
})(ZN || (ZN = {}));
var ohe = {
  [ZN.InvalidApiName]: {
    message: "API name is invalid.",
    recoverySuggestion:
      "Check if the API name matches the one in your configuration or `aws-exports.js`",
  },
};
c();
var ek = async (e) => {
    if (!e) return;
    let t = await Zo($Nt(e));
    if (t) {
      let r = await e.body?.text();
      return zNt(t, { statusCode: e.statusCode, headers: e.headers, body: r });
    }
  },
  $Nt = (e) => {
    let t,
      r = new Proxy(e.body, {
        get(i, o, a) {
          return o === "json"
            ? async () => {
                t || (t = i.text());
                try {
                  return JSON.parse(await t);
                } catch {
                  return {};
                }
              }
            : o === "text"
              ? async () => (t || (t = i.text()), t)
              : Reflect.get(i, o, a);
        },
      });
    return new Proxy(e, {
      get(i, o, a) {
        return o === "body" ? r : Reflect.get(i, o, a);
      },
    });
  },
  zNt = (e, t) => {
    let r = new rf({
      name: e?.name,
      message: e.message,
      underlyingError: e,
      response: t,
    });
    return Object.assign(r, { $metadata: e.$metadata });
  };
c();
var _y = new Ot("RestApis");
function Q2(e, t) {
  let r = (u) => !!t,
    n = new AbortController(),
    i = n.signal,
    o = t?.signal,
    a,
    s = async () => {
      try {
        let u = await (r(e) ? e() : e(i));
        if (u.statusCode >= 300) throw await ek(u);
        return u;
      } catch (u) {
        let l = o ?? i,
          d = a ?? l.reason;
        if (u.name === "AbortError" || l?.aborted === !0) {
          let f = new Y0({
            ...(d && { message: d }),
            underlyingError: u,
            recoverySuggestion:
              "The API request was explicitly canceled. If this is not intended, validate if you called the `cancel()` function on the API request erroneously.",
          });
          throw (_y.debug(u), f);
        }
        throw (_y.debug(u), u);
      }
    };
  if (r()) return s();
  {
    let u = (l) => {
      i.aborted !== !0 && (n.abort(l), l && i.reason !== l && (a = l));
    };
    return { response: s(), cancel: u };
  }
}
c();
c();
var Y2 = "execute-api";
var ahe = "us-east-1",
  she = /^.+\.([a-z0-9-]+)\.([a-z0-9-]+)\.amazonaws\.com/;
var X2 = (e, t) => {
  let { service: r = Y2, region: n = ahe } =
      t?.amplify.getConfig()?.API?.REST?.[t?.apiName] ?? {},
    { hostname: i } = e,
    [, o, a] = she.exec(i) ?? [];
  return o === Y2
    ? { service: o, region: a ?? n }
    : o === "appsync-api"
      ? { service: "appsync", region: a ?? n }
      : { service: r, region: n };
};
c();
c();
c();
var che = ({ headers: e }, t) => !e.authorization && !e["x-api-key"] && !!t;
c();
c();
var uhe = (e, t) => {
  let r = {};
  for (let n in e) r[n.toLowerCase()] = e[n];
  return (
    t &&
      ((r["content-type"] = "application/json; charset=UTF-8"),
      t instanceof FormData && delete r["content-type"]),
    r
  );
};
c();
var lhe = xs(am, [om, im, oV]);
c();
var dhe = xs(am, [om, im]);
var J2 = async (e, t, r, n) => {
    let {
        url: i,
        method: o,
        headers: a,
        body: s,
        withCredentials: u,
        abortSignal: l,
        retryStrategy: d,
      } = t,
      f = s ? (s instanceof FormData ? s : JSON.stringify(s ?? "")) : void 0,
      m = uhe(a, s),
      h = { url: i, headers: m, method: o, body: f },
      y = {
        retryDecider: KNt(d ?? e?.libraryOptions?.API?.REST?.retryStrategy),
        computeDelay: sm,
        withCrossDomainCredentials: u,
        abortSignal: l,
      },
      _ = r(h, n),
      E,
      b = await WNt(e);
    if (_ && b) {
      let O = X2(i),
        C = n?.service ?? O.service,
        P = n?.region ?? O.region;
      E = await lhe(h, { ...y, credentials: b, region: P, service: C });
    } else E = await dhe(h, { ...y });
    return { statusCode: E.statusCode, headers: E.headers, body: E.body };
  },
  KNt = (e) =>
    e?.strategy === "no-retry"
      ? () => Promise.resolve({ retryable: !1 })
      : cm(ek),
  WNt = async (e) => {
    try {
      let { credentials: t } = await e.Auth.fetchAuthSession();
      if (t) return t;
    } catch {
      _y.debug("No credentials available, the request will be unsigned.");
    }
    return null;
  };
c();
c();
var Z2 = new WeakMap(),
  eK = (e, { url: t, options: r, abortController: n }) => {
    let i = n ?? new AbortController(),
      a = Q2(
        async () =>
          J2(
            e,
            {
              url: t,
              method: "POST",
              ...r,
              abortSignal: i.signal,
              retryStrategy: { strategy: "jittered-exponential-backoff" },
            },
            che,
            r?.signingServiceInfo,
          ),
        i,
      ).finally(() => {
        Z2.delete(a);
      });
    return a;
  },
  tK = (e, t) => {
    let r = Z2.get(e);
    return r
      ? (r.abort(t), t && r.signal.reason !== t && (r.signal.reason = t), !0)
      : !1;
  },
  rK = (e, t) => {
    Z2.set(e, t);
  };
c();
c();
var fhe = 5e3,
  phe = [400, 401, 403],
  mhe = ["BadRequestException", "UnauthorizedException"],
  hhe = "ConnectionStateChange",
  wo;
(function (e) {
  (e.GQL_CONNECTION_INIT = "connection_init"),
    (e.GQL_CONNECTION_ERROR = "connection_error"),
    (e.GQL_CONNECTION_ACK = "connection_ack"),
    (e.GQL_START = "start"),
    (e.GQL_START_ACK = "start_ack"),
    (e.DATA = "data"),
    (e.GQL_CONNECTION_KEEP_ALIVE = "ka"),
    (e.GQL_STOP = "stop"),
    (e.GQL_COMPLETE = "complete"),
    (e.GQL_ERROR = "error"),
    (e.EVENT_SUBSCRIBE = "subscribe"),
    (e.EVENT_PUBLISH = "publish"),
    (e.EVENT_SUBSCRIBE_ACK = "subscribe_success"),
    (e.EVENT_PUBLISH_ACK = "publish_success"),
    (e.EVENT_STOP = "unsubscribe"),
    (e.EVENT_COMPLETE = "unsubscribe_success");
})(wo || (wo = {}));
var Dc;
(function (e) {
  (e[(e.PENDING = 0)] = "PENDING"),
    (e[(e.CONNECTED = 1)] = "CONNECTED"),
    (e[(e.FAILED = 2)] = "FAILED");
})(Dc || (Dc = {}));
var Bi;
(function (e) {
  (e[(e.CLOSED = 0)] = "CLOSED"),
    (e[(e.READY = 1)] = "READY"),
    (e[(e.CONNECTING = 2)] = "CONNECTING");
})(Bi || (Bi = {}));
var ghe = {
    accept: "application/json, text/javascript",
    "content-encoding": "amz-1.0",
    "content-type": "application/json; charset=UTF-8",
  },
  nK = 15e3,
  vhe = 15e3,
  yhe = 5 * 60 * 1e3,
  _he = 5 * 1e3,
  Ehe = 65 * 1e3,
  bhe = 5 * 1e3,
  She = 60 * 1e3;
c();
var oK = A(kd(), 1),
  ok = A(XN(), 1);
c();
var ka;
(function (e) {
  (e.CONNECTION_CLOSED = "Connection closed"),
    (e.CONNECTION_FAILED = "Connection failed"),
    (e.REALTIME_SUBSCRIPTION_INIT_ERROR =
      "AppSync Realtime subscription init error"),
    (e.SUBSCRIPTION_ACK = "Subscription ack"),
    (e.TIMEOUT_DISCONNECT = "Timeout disconnect");
})(ka || (ka = {}));
var On;
(function (e) {
  (e.Connected = "Connected"),
    (e.ConnectedPendingNetwork = "ConnectedPendingNetwork"),
    (e.ConnectionDisrupted = "ConnectionDisrupted"),
    (e.ConnectionDisruptedPendingNetwork = "ConnectionDisruptedPendingNetwork"),
    (e.Connecting = "Connecting"),
    (e.ConnectedPendingDisconnect = "ConnectedPendingDisconnect"),
    (e.Disconnected = "Disconnected"),
    (e.ConnectedPendingKeepAlive = "ConnectedPendingKeepAlive");
})(On || (On = {}));
c();
var Ey = A(kd(), 1);
c();
var iK = () => new Mv().networkMonitor();
var aa = {
    KEEP_ALIVE_MISSED: { keepAliveState: "unhealthy" },
    KEEP_ALIVE: { keepAliveState: "healthy" },
    CONNECTION_ESTABLISHED: { connectionState: "connected" },
    CONNECTION_FAILED: {
      intendedConnectionState: "disconnected",
      connectionState: "disconnected",
    },
    CLOSING_CONNECTION: { intendedConnectionState: "disconnected" },
    OPENING_CONNECTION: {
      intendedConnectionState: "connected",
      connectionState: "connecting",
    },
    CLOSED: { connectionState: "disconnected" },
    ONLINE: { networkState: "connected" },
    OFFLINE: { networkState: "disconnected" },
  },
  tk = class {
    constructor() {
      (this._networkMonitoringSubscription = void 0),
        (this._linkedConnectionState = {
          networkState: "connected",
          connectionState: "disconnected",
          intendedConnectionState: "disconnected",
          keepAliveState: "healthy",
        }),
        (this._initialNetworkStateSubscription = iK().subscribe(
          ({ online: t }) => {
            this.record(t ? aa.ONLINE : aa.OFFLINE),
              this._initialNetworkStateSubscription?.unsubscribe();
          },
        )),
        (this._linkedConnectionStateObservable = new Ey.Observable((t) => {
          t.next(this._linkedConnectionState),
            (this._linkedConnectionStateObserver = t);
        }));
    }
    enableNetworkMonitoring() {
      this._initialNetworkStateSubscription?.unsubscribe(),
        this._networkMonitoringSubscription === void 0 &&
          (this._networkMonitoringSubscription = iK().subscribe(
            ({ online: t }) => {
              this.record(t ? aa.ONLINE : aa.OFFLINE);
            },
          ));
    }
    disableNetworkMonitoring() {
      this._networkMonitoringSubscription?.unsubscribe(),
        (this._networkMonitoringSubscription = void 0);
    }
    get connectionStateObservable() {
      let t;
      return this._linkedConnectionStateObservable
        .pipe((0, Ey.map)((r) => this.connectionStatesTranslator(r)))
        .pipe(
          (0, Ey.filter)((r) => {
            let n = r !== t;
            return (t = r), n;
          }),
        );
    }
    record(t) {
      t.intendedConnectionState === "connected"
        ? this.enableNetworkMonitoring()
        : t.intendedConnectionState === "disconnected" &&
          this.disableNetworkMonitoring();
      let r = { ...this._linkedConnectionState, ...t };
      (this._linkedConnectionState = { ...r }),
        this._linkedConnectionStateObserver?.next(this._linkedConnectionState);
    }
    connectionStatesTranslator({
      connectionState: t,
      networkState: r,
      intendedConnectionState: n,
      keepAliveState: i,
    }) {
      return t === "connected" && r === "disconnected"
        ? On.ConnectedPendingNetwork
        : t === "connected" && n === "disconnected"
          ? On.ConnectedPendingDisconnect
          : t === "disconnected" && n === "connected" && r === "disconnected"
            ? On.ConnectionDisruptedPendingNetwork
            : t === "disconnected" && n === "connected"
              ? On.ConnectionDisrupted
              : t === "connected" && i === "unhealthy"
                ? On.ConnectedPendingKeepAlive
                : t === "connecting"
                  ? On.Connecting
                  : t === "disconnected"
                    ? On.Disconnected
                    : On.Connected;
    }
  };
c();
var Lm;
(function (e) {
  (e.START_RECONNECT = "START_RECONNECT"),
    (e.HALT_RECONNECT = "HALT_RECONNECT");
})(Lm || (Lm = {}));
var rk = class {
  constructor() {
    this.reconnectObservers = [];
  }
  addObserver(t) {
    this.reconnectObservers.push(t);
  }
  record(t) {
    t === Lm.START_RECONNECT &&
      this.reconnectSetTimeoutId === void 0 &&
      this.reconnectIntervalId === void 0 &&
      (this.reconnectSetTimeoutId = setTimeout(() => {
        this._triggerReconnect(),
          (this.reconnectIntervalId = setInterval(() => {
            this._triggerReconnect();
          }, She));
      }, bhe)),
      t === Lm.HALT_RECONNECT &&
        (this.reconnectIntervalId &&
          (clearInterval(this.reconnectIntervalId),
          (this.reconnectIntervalId = void 0)),
        this.reconnectSetTimeoutId &&
          (clearTimeout(this.reconnectSetTimeoutId),
          (this.reconnectSetTimeoutId = void 0)));
  }
  close() {
    this.reconnectObservers.forEach((t) => {
      t.complete?.();
    });
  }
  _triggerReconnect() {
    this.reconnectObservers.forEach((t) => {
      t.next?.();
    });
  }
};
c();
var Che = "wss://",
  tkt =
    /^https:\/\/\w{26}\.appsync-api\.\w{2}(?:(?:-\w{2,})+)-\d\.amazonaws.com(?:\.cn)?\/graphql$/i,
  rkt =
    /^https:\/\/\w{26}\.\w+-api\.\w{2}(?:(?:-\w{2,})+)-\d\.amazonaws.com(?:\.cn)?\/event$/i,
  whe = "/realtime",
  nkt = (e) => e.match(tkt) === null,
  ikt = (e) => e.match(rkt) !== null,
  okt = (e) => {
    let t = e ?? "";
    return (
      ikt(t)
        ? (t = t
            .concat(whe)
            .replace("ddpg-api", "grt-gamma")
            .replace("appsync-api", "appsync-realtime-api"))
        : nkt(t)
          ? (t = t.concat(whe))
          : (t = t
              .replace("appsync-api", "appsync-realtime-api")
              .replace("gogi-beta", "grt-beta")
              .replace("ddpg-api", "grt-gamma")),
      (t = t.replace("https://", Che).replace("http://", Che)),
      new jn(t)
    );
  },
  akt = (e) => {
    if (!e) return {};
    if ("Authorization" in e) {
      let { Authorization: t, ...r } = e;
      return r;
    }
    return e;
  },
  Ohe = (e) => {
    let t = akt(e),
      r = new KI();
    return (
      Object.entries(t).forEach(([n, i]) => {
        r.append(n, i);
      }),
      r
    );
  },
  The = (e, t) => {
    let r = okt(e),
      n = new KI(r.search);
    for (let [i, o] of t.entries()) n.append(i, o);
    return (r.search = n.toString()), r.toString();
  },
  nk = async (e) => {
    let {
        appSyncGraphqlEndpoint: t,
        query: r,
        libraryConfigHeaders: n = () => ({}),
        additionalHeaders: i = {},
        authToken: o,
      } = e,
      a = {},
      s = await n();
    return (
      typeof i == "function"
        ? (a = await i({ url: t || "", queryString: r || "" }))
        : (a = i),
      o && (a = { ...a, Authorization: o }),
      { additionalCustomHeaders: a, libraryConfigHeaders: s }
    );
  };
c();
var Ahe = new Ot("AWSAppSyncRealTimeProvider Auth"),
  Phe = async ({ host: e }) => ({
    Authorization: (await VI())?.tokens?.accessToken?.toString(),
    host: e,
  }),
  skt = async ({ apiKey: e, host: t }) => {
    let n = new Date().toISOString().replace(/[:-]|\.\d{3}/g, "");
    return { host: t, "x-amz-date": n, "x-api-key": e };
  },
  ckt = async ({
    payload: e,
    canonicalUri: t,
    appSyncGraphqlEndpoint: r,
    region: n,
  }) => {
    let i = { region: n, service: "appsync" },
      o = (await VI()).credentials,
      a = { url: `${r}${t}`, data: e, method: "POST", headers: { ...ghe } };
    return KS(
      {
        headers: a.headers,
        method: a.method,
        url: new jn(a.url),
        body: a.data,
      },
      { credentials: o, signingRegion: i.region, signingService: i.service },
    ).headers;
  },
  Rhe = async ({ host: e, additionalCustomHeaders: t }) => {
    if (!t?.Authorization) throw new Error("No auth token specified");
    return { Authorization: t.Authorization, host: e };
  },
  ik = async ({
    apiKey: e,
    authenticationType: t,
    canonicalUri: r,
    appSyncGraphqlEndpoint: n,
    region: i,
    additionalCustomHeaders: o,
    payload: a,
  }) => {
    let s = {
      apiKey: skt,
      iam: ckt,
      oidc: Phe,
      userPool: Phe,
      lambda: Rhe,
      none: Rhe,
    };
    if (!t || !s[t]) {
      Ahe.debug(`Authentication type ${t} not supported`);
      return;
    } else {
      let u = s[t],
        l = n ? new jn(n).host : void 0,
        d = t === "apiKey" ? e : void 0;
      return (
        Ahe.debug(`Authenticating with ${JSON.stringify(t)}`),
        await u({
          payload: a,
          canonicalUri: r,
          appSyncGraphqlEndpoint: n,
          apiKey: d,
          region: i,
          host: l,
          additionalCustomHeaders: o,
        })
      );
    }
  };
var Ihe = (e) => {
    fi.dispatch("api", e, "PubSub", Mi);
  },
  ak = class {
    constructor(t) {
      (this.subscriptionObserverMap = new Map()),
        (this.allowNoSubscriptions = !1),
        (this.socketStatus = Bi.CLOSED),
        (this.keepAliveTimestamp = Date.now()),
        (this.promiseArray = []),
        (this.connectionStateMonitor = new tk()),
        (this.reconnectionMonitor = new rk()),
        (this._establishConnection = async (r, n) => {
          this.logger.debug(`Establishing WebSocket connection to ${r}`);
          try {
            await this._openConnection(r, n), await this._initiateHandshake();
          } catch (i) {
            let { errorType: o, errorCode: a } = i;
            throw phe.includes(a) || mhe.includes(o)
              ? new WS(o)
              : o
                ? new Error(o)
                : i;
          }
        }),
        (this.logger = new Ot(t.providerName)),
        (this.wsProtocolName = t.wsProtocolName),
        (this.wsConnectUri = t.connectUri),
        (this.connectionStateMonitorSubscription =
          this._startConnectionStateMonitoring());
    }
    close() {
      return (
        (this.socketStatus = Bi.CLOSED),
        this.connectionStateMonitor.record(aa.CONNECTION_FAILED),
        this.connectionStateMonitorSubscription.unsubscribe(),
        this.reconnectionMonitor.close(),
        new Promise((t, r) => {
          this.awsRealTimeSocket
            ? ((this.awsRealTimeSocket.onclose = (n) => {
                this._closeSocket(),
                  (this.subscriptionObserverMap = new Map()),
                  (this.awsRealTimeSocket = void 0),
                  t();
              }),
              (this.awsRealTimeSocket.onerror = (n) => {
                r(n);
              }),
              this.awsRealTimeSocket.close())
            : t();
        })
      );
    }
    subscribe(t, r) {
      return new oK.Observable((n) => {
        if (!t?.appSyncGraphqlEndpoint) {
          n.error({
            errors: [
              {
                ...new ok.GraphQLError(
                  "Subscribe only available for AWS AppSync endpoint",
                ),
              },
            ],
          }),
            n.complete();
          return;
        }
        let i = !1,
          o = qv(),
          a = () => {
            i ||
              ((i = !0),
              this._startSubscriptionWithAWSAppSyncRealTime({
                options: t,
                observer: n,
                subscriptionId: o,
                customUserAgentDetails: r,
              })
                .catch((u) => {
                  this.logger.debug(
                    `${ka.REALTIME_SUBSCRIPTION_INIT_ERROR}: ${u}`,
                  ),
                    this._closeSocket();
                })
                .finally(() => {
                  i = !1;
                }));
          },
          s = new oK.Observable((u) => {
            this.reconnectionMonitor.addObserver(u);
          }).subscribe(() => {
            a();
          });
        return (
          a(),
          async () => {
            await this._cleanupSubscription(o, s);
          }
        );
      });
    }
    async connect(t) {
      this.socketStatus !== Bi.READY && (await this._connectWebSocket(t));
    }
    async publish(t, r) {
      if (this.socketStatus !== Bi.READY)
        throw new Error("Subscription has not been initialized");
      return this._publishMessage(t, r);
    }
    async _connectWebSocket(t) {
      let {
          apiKey: r,
          appSyncGraphqlEndpoint: n,
          authenticationType: i,
          region: o,
        } = t,
        { additionalCustomHeaders: a } = await nk(t);
      this.connectionStateMonitor.record(aa.OPENING_CONNECTION),
        await this._initializeWebSocketConnection({
          apiKey: r,
          appSyncGraphqlEndpoint: n,
          authenticationType: i,
          region: o,
          additionalCustomHeaders: a,
        });
    }
    async _publishMessage(t, r) {
      let n = qv(),
        { additionalCustomHeaders: i, libraryConfigHeaders: o } = await nk(t),
        a = await this._prepareSubscriptionPayload({
          options: t,
          subscriptionId: n,
          customUserAgentDetails: r,
          additionalCustomHeaders: i,
          libraryConfigHeaders: o,
          publish: !0,
        });
      return new Promise((s, u) => {
        if (this.awsRealTimeSocket) {
          let l = (h) => {
              let y = JSON.parse(h.data);
              if (
                (y.id === n &&
                  y.type === "publish_success" &&
                  (this.awsRealTimeSocket &&
                    this.awsRealTimeSocket.removeEventListener("message", l),
                  m(),
                  s()),
                y.errors && y.errors.length > 0)
              ) {
                let _ = y.errors.map((E) => E.errorType);
                m(), u(new Error(`Publish errors: ${_.join(", ")}`));
              }
            },
            d = (h) => {
              m(), u(new Error(`WebSocket error: ${h}`));
            },
            f = () => {
              m(), u(new Error("WebSocket is closed"));
            },
            m = () => {
              this.awsRealTimeSocket?.removeEventListener("message", l),
                this.awsRealTimeSocket?.removeEventListener("error", d),
                this.awsRealTimeSocket?.removeEventListener("close", f);
            };
          this.awsRealTimeSocket.addEventListener("message", l),
            this.awsRealTimeSocket.addEventListener("error", d),
            this.awsRealTimeSocket.addEventListener("close", f),
            this.awsRealTimeSocket.send(a);
        } else u(new Error("WebSocket is not connected"));
      });
    }
    async _cleanupSubscription(t, r) {
      r?.unsubscribe();
      try {
        await this._waitForSubscriptionToBeConnected(t);
        let { subscriptionState: n } =
          this.subscriptionObserverMap.get(t) || {};
        if (!n) return;
        if (n === Dc.CONNECTED) this._sendUnsubscriptionMessage(t);
        else throw new Error("Subscription never connected");
      } catch (n) {
        this.logger.debug(`Error while unsubscribing ${n}`);
      } finally {
        this._removeSubscriptionObserver(t);
      }
    }
    _startConnectionStateMonitoring() {
      return this.connectionStateMonitor.connectionStateObservable.subscribe(
        (t) => {
          Ihe({
            event: hhe,
            data: { provider: this, connectionState: t },
            message: `Connection state is ${t}`,
          }),
            (this.connectionState = t),
            t === On.ConnectionDisrupted &&
              this.reconnectionMonitor.record(Lm.START_RECONNECT),
            [
              On.Connected,
              On.ConnectedPendingDisconnect,
              On.ConnectedPendingKeepAlive,
              On.ConnectedPendingNetwork,
              On.ConnectionDisruptedPendingNetwork,
              On.Disconnected,
            ].includes(t) && this.reconnectionMonitor.record(Lm.HALT_RECONNECT);
        },
      );
    }
    async _startSubscriptionWithAWSAppSyncRealTime({
      options: t,
      observer: r,
      subscriptionId: n,
      customUserAgentDetails: i,
    }) {
      let { query: o, variables: a } = t;
      this.subscriptionObserverMap.set(n, {
        observer: r,
        query: o ?? "",
        variables: a ?? {},
        subscriptionState: Dc.PENDING,
        startAckTimeoutId: void 0,
      });
      let { additionalCustomHeaders: s, libraryConfigHeaders: u } = await nk(t),
        l = await this._prepareSubscriptionPayload({
          options: t,
          subscriptionId: n,
          customUserAgentDetails: i,
          additionalCustomHeaders: s,
          libraryConfigHeaders: u,
        });
      try {
        await this._connectWebSocket(t);
      } catch (m) {
        this._logStartSubscriptionError(n, r, m);
        return;
      }
      let { subscriptionFailedCallback: d, subscriptionReadyCallback: f } =
        this.subscriptionObserverMap.get(n) ?? {};
      this.subscriptionObserverMap.set(n, {
        observer: r,
        subscriptionState: Dc.PENDING,
        query: o ?? "",
        variables: a ?? {},
        subscriptionReadyCallback: f,
        subscriptionFailedCallback: d,
        startAckTimeoutId: setTimeout(() => {
          this._timeoutStartSubscriptionAck(n);
        }, vhe),
      }),
        this.awsRealTimeSocket && this.awsRealTimeSocket.send(l);
    }
    _logStartSubscriptionError(t, r, n) {
      this.logger.debug({ err: n });
      let i = String(n.message ?? "");
      if (
        (this._closeSocket(),
        this.connectionState !== On.ConnectionDisruptedPendingNetwork)
      ) {
        vS(n)
          ? r.error({
              errors: [
                { ...new ok.GraphQLError(`${ka.CONNECTION_FAILED}: ${i}`) },
              ],
            })
          : this.logger.debug(`${ka.CONNECTION_FAILED}: ${i}`);
        let { subscriptionFailedCallback: o } =
          this.subscriptionObserverMap.get(t) || {};
        typeof o == "function" && o();
      }
    }
    async _waitForSubscriptionToBeConnected(t) {
      let r = this.subscriptionObserverMap.get(t);
      if (r) {
        let { subscriptionState: n } = r;
        if (n === Dc.PENDING)
          return new Promise((i, o) => {
            let {
              observer: a,
              subscriptionState: s,
              variables: u,
              query: l,
            } = r;
            this.subscriptionObserverMap.set(t, {
              observer: a,
              subscriptionState: s,
              variables: u,
              query: l,
              subscriptionReadyCallback: i,
              subscriptionFailedCallback: o,
            });
          });
      }
    }
    _sendUnsubscriptionMessage(t) {
      try {
        if (
          this.awsRealTimeSocket &&
          this.awsRealTimeSocket.readyState === WebSocket.OPEN &&
          this.socketStatus === Bi.READY
        ) {
          let r = this._unsubscribeMessage(t),
            n = JSON.stringify(r);
          this.awsRealTimeSocket.send(n);
        }
      } catch (r) {
        this.logger.debug({ err: r });
      }
    }
    _removeSubscriptionObserver(t) {
      this.subscriptionObserverMap.delete(t),
        this.allowNoSubscriptions ||
          setTimeout(this._closeSocketIfRequired.bind(this), 1e3);
    }
    _closeSocketIfRequired() {
      if (!(this.subscriptionObserverMap.size > 0)) {
        if (!this.awsRealTimeSocket) {
          this.socketStatus = Bi.CLOSED;
          return;
        }
        if (
          (this.connectionStateMonitor.record(aa.CLOSING_CONNECTION),
          this.awsRealTimeSocket.bufferedAmount > 0)
        )
          setTimeout(this._closeSocketIfRequired.bind(this), 1e3);
        else {
          this.logger.debug("closing WebSocket...");
          let t = this.awsRealTimeSocket;
          (t.onclose = null),
            (t.onerror = null),
            t.close(1e3),
            (this.awsRealTimeSocket = void 0),
            (this.socketStatus = Bi.CLOSED),
            this._closeSocket();
        }
      }
    }
    maintainKeepAlive() {
      this.keepAliveTimestamp = Date.now();
    }
    keepAliveHeartbeat(t) {
      let r = Date.now();
      r - this.keepAliveTimestamp > Ehe
        ? this.connectionStateMonitor.record(aa.KEEP_ALIVE_MISSED)
        : this.connectionStateMonitor.record(aa.KEEP_ALIVE),
        r - this.keepAliveTimestamp > t &&
          this._errorDisconnect(ka.TIMEOUT_DISCONNECT);
    }
    _handleIncomingSubscriptionMessage(t) {
      if (typeof t.data != "string") return;
      let [r, n] = this._handleSubscriptionData(t);
      if (r) {
        this.maintainKeepAlive();
        return;
      }
      let { type: i, id: o, payload: a } = n,
        {
          observer: s = null,
          query: u = "",
          variables: l = {},
          startAckTimeoutId: d,
          subscriptionReadyCallback: f,
          subscriptionFailedCallback: m,
        } = this.subscriptionObserverMap.get(o) || {};
      if (i === wo.GQL_START_ACK || i === wo.EVENT_SUBSCRIBE_ACK) {
        this.logger.debug(
          `subscription ready for ${JSON.stringify({ query: u, variables: l })}`,
        ),
          typeof f == "function" && f(),
          d && clearTimeout(d),
          Ihe({
            event: ka.SUBSCRIPTION_ACK,
            data: { query: u, variables: l },
            message: "Connection established for subscription",
          });
        let h = Dc.CONNECTED;
        s &&
          this.subscriptionObserverMap.set(o, {
            observer: s,
            query: u,
            variables: l,
            startAckTimeoutId: void 0,
            subscriptionState: h,
            subscriptionReadyCallback: f,
            subscriptionFailedCallback: m,
          }),
          this.connectionStateMonitor.record(aa.CONNECTION_ESTABLISHED);
        return;
      }
      if (i === wo.GQL_CONNECTION_KEEP_ALIVE) {
        this.maintainKeepAlive();
        return;
      }
      if (i === wo.GQL_ERROR) {
        let h = Dc.FAILED;
        s &&
          (this.subscriptionObserverMap.set(o, {
            observer: s,
            query: u,
            variables: l,
            startAckTimeoutId: d,
            subscriptionReadyCallback: f,
            subscriptionFailedCallback: m,
            subscriptionState: h,
          }),
          this.logger.debug(
            `${ka.CONNECTION_FAILED}: ${JSON.stringify(a ?? n)}`,
          ),
          s.error({
            errors: [
              {
                ...new ok.GraphQLError(
                  `${ka.CONNECTION_FAILED}: ${JSON.stringify(a ?? n)}`,
                ),
              },
            ],
          }),
          d && clearTimeout(d),
          typeof m == "function" && m());
      }
    }
    _errorDisconnect(t) {
      this.logger.debug(`Disconnect error: ${t}`),
        this.awsRealTimeSocket &&
          (this._closeSocket(), this.awsRealTimeSocket.close()),
        (this.socketStatus = Bi.CLOSED);
    }
    _closeSocket() {
      this.keepAliveHeartbeatIntervalId &&
        (clearInterval(this.keepAliveHeartbeatIntervalId),
        (this.keepAliveHeartbeatIntervalId = void 0)),
        this.connectionStateMonitor.record(aa.CLOSED);
    }
    _timeoutStartSubscriptionAck(t) {
      let r = this.subscriptionObserverMap.get(t);
      if (r) {
        let { observer: n, query: i, variables: o } = r;
        if (!n) return;
        this.subscriptionObserverMap.set(t, {
          observer: n,
          query: i,
          variables: o,
          subscriptionState: Dc.FAILED,
        }),
          this._closeSocket(),
          this.logger.debug(
            "timeoutStartSubscription",
            JSON.stringify({ query: i, variables: o }),
          );
      }
    }
    _initializeWebSocketConnection({
      appSyncGraphqlEndpoint: t,
      authenticationType: r,
      apiKey: n,
      region: i,
      additionalCustomHeaders: o,
    }) {
      if (this.socketStatus !== Bi.READY)
        return new Promise(async (a, s) => {
          if (
            (this.promiseArray.push({ res: a, rej: s }),
            this.socketStatus === Bi.CLOSED)
          )
            try {
              this.socketStatus = Bi.CONNECTING;
              let l = await ik({
                  authenticationType: r,
                  payload: "{}",
                  canonicalUri: this.wsConnectUri,
                  apiKey: n,
                  appSyncGraphqlEndpoint: t,
                  region: i,
                  additionalCustomHeaders: o,
                }),
                d = l ? JSON.stringify(l) : "",
                m = `header-${uV.convert(d, { urlSafe: !0, skipPadding: !0 })}`,
                h = Ohe(o),
                y = The(t, h);
              await this._establishRetryableConnection(y, m),
                this.promiseArray.forEach(({ res: _ }) => {
                  this.logger.debug("Notifying connection successful"), _();
                }),
                (this.socketStatus = Bi.READY),
                (this.promiseArray = []);
            } catch (u) {
              this.logger.debug("Connection exited with", u),
                this.promiseArray.forEach(({ rej: l }) => {
                  l(u);
                }),
                (this.promiseArray = []),
                this.awsRealTimeSocket &&
                  this.awsRealTimeSocket.readyState === WebSocket.OPEN &&
                  this.awsRealTimeSocket.close(3001),
                (this.awsRealTimeSocket = void 0),
                (this.socketStatus = Bi.CLOSED);
            }
        });
    }
    async _establishRetryableConnection(t, r) {
      this.logger.debug("Establishing retryable connection"),
        await aV(this._establishConnection.bind(this), [t, r], fhe);
    }
    async _openConnection(t, r) {
      return new Promise((n, i) => {
        let o = this._getNewWebSocket(t, [this.wsProtocolName, r]);
        (o.onerror = () => {
          this.logger.debug("WebSocket connection error");
        }),
          (o.onclose = () => {
            this._closeSocket(), i(new Error("Connection handshake error"));
          }),
          (o.onopen = () => {
            (this.awsRealTimeSocket = o), n();
          });
      });
    }
    _getNewWebSocket(t, r) {
      return new WebSocket(t, r);
    }
    async _initiateHandshake() {
      return new Promise((t, r) => {
        if (!this.awsRealTimeSocket) {
          r(new Error("awsRealTimeSocket undefined"));
          return;
        }
        let n = !1;
        (this.awsRealTimeSocket.onerror = (a) => {
          this.logger.debug(`WebSocket error ${JSON.stringify(a)}`);
        }),
          (this.awsRealTimeSocket.onclose = (a) => {
            this.logger.debug(`WebSocket closed ${a.reason}`),
              this._closeSocket(),
              r(new Error(JSON.stringify(a)));
          }),
          (this.awsRealTimeSocket.onmessage = (a) => {
            if (typeof a.data != "string") return;
            this.logger.debug(
              `subscription message from AWS AppSyncRealTime: ${a.data} `,
            );
            let s = JSON.parse(a.data),
              { type: u } = s,
              l = this._extractConnectionTimeout(s);
            if (u === wo.GQL_CONNECTION_ACK) {
              (n = !0),
                this._registerWebsocketHandlers(l),
                t("Connected to AWS AppSyncRealTime");
              return;
            }
            if (u === wo.GQL_CONNECTION_ERROR) {
              let { errorType: d, errorCode: f } =
                this._extractErrorCodeAndType(s);
              r({ errorType: d, errorCode: f });
            }
          });
        let i = { type: wo.GQL_CONNECTION_INIT };
        this.awsRealTimeSocket.send(JSON.stringify(i));
        let o = (a) => {
          a ||
            (this.connectionStateMonitor.record(aa.CONNECTION_FAILED),
            r(
              new Error(
                `Connection timeout: ack from AWSAppSyncRealTime was not received after ${nK} ms`,
              ),
            ));
        };
        setTimeout(() => {
          o(n);
        }, nK);
      });
    }
    _registerWebsocketHandlers(t) {
      this.awsRealTimeSocket &&
        ((this.keepAliveHeartbeatIntervalId = setInterval(() => {
          this.keepAliveHeartbeat(t);
        }, _he)),
        (this.awsRealTimeSocket.onmessage =
          this._handleIncomingSubscriptionMessage.bind(this)),
        (this.awsRealTimeSocket.onerror = (r) => {
          this.logger.debug(r), this._errorDisconnect(ka.CONNECTION_CLOSED);
        }),
        (this.awsRealTimeSocket.onclose = (r) => {
          this.logger.debug(`WebSocket closed ${r.reason}`),
            this._closeSocket(),
            this._errorDisconnect(ka.CONNECTION_CLOSED);
        }));
    }
  };
var xhe = "AWSAppSyncRealTimeProvider",
  ukt = "graphql-ws",
  lkt = "/connect",
  sk = class extends ak {
    constructor() {
      super({ providerName: xhe, wsProtocolName: ukt, connectUri: lkt });
    }
    getProviderName() {
      return xhe;
    }
    subscribe(t, r) {
      return super.subscribe(t, r);
    }
    async _prepareSubscriptionPayload({
      options: t,
      subscriptionId: r,
      customUserAgentDetails: n,
      additionalCustomHeaders: i,
      libraryConfigHeaders: o,
    }) {
      let {
          appSyncGraphqlEndpoint: a,
          authenticationType: s,
          query: u,
          variables: l,
          apiKey: d,
          region: f,
        } = t,
        h = JSON.stringify({ query: u, variables: l }),
        y = {
          ...(await ik({
            apiKey: d,
            appSyncGraphqlEndpoint: a,
            authenticationType: s,
            payload: h,
            canonicalUri: "",
            region: f,
            additionalCustomHeaders: i,
          })),
          ...o,
          ...i,
          [hS]: wa(n),
        },
        _ = {
          id: r,
          payload: { data: h, extensions: { authorization: { ...y } } },
          type: wo.GQL_START,
        };
      return JSON.stringify(_);
    }
    _handleSubscriptionData(t) {
      this.logger.debug(
        `subscription message from AWS AppSync RealTime: ${t.data}`,
      );
      let { id: r = "", payload: n, type: i } = JSON.parse(String(t.data)),
        {
          observer: o = null,
          query: a = "",
          variables: s = {},
        } = this.subscriptionObserverMap.get(r) || {};
      return (
        this.logger.debug({ id: r, observer: o, query: a, variables: s }),
        i === wo.DATA && n && n.data
          ? (o
              ? o.next(n)
              : this.logger.debug(`observer not found for id: ${r}`),
            [!0, { id: r, type: i, payload: n }])
          : [!1, { id: r, type: i, payload: n }]
      );
    }
    _unsubscribeMessage(t) {
      return { id: t, type: wo.GQL_STOP };
    }
    _extractConnectionTimeout(t) {
      let { payload: { connectionTimeoutMs: r = yhe } = {} } = t;
      return r;
    }
    _extractErrorCodeAndType(t) {
      let {
        payload: {
          errors: [{ errorType: r = "", errorCode: n = 0 } = {}] = [],
        } = {},
      } = t;
      return { errorCode: n, errorType: r };
    }
  };
c();
c();
c();
var Da = class e extends Br {
  constructor(t) {
    super(t), (this.constructor = e), Object.setPrototypeOf(this, e.prototype);
  }
};
c();
var Mm;
(function (e) {
  (e.NoAuthSession = "NoAuthSession"),
    (e.NoRegion = "NoRegion"),
    (e.NoCustomEndpoint = "NoCustomEndpoint");
})(Mm || (Mm = {}));
var Nhe = {
  [Mm.NoAuthSession]: { message: "Auth session should not be empty." },
  [Mm.NoRegion]: { message: "Missing region." },
  [Mm.NoCustomEndpoint]: {
    message: "Custom endpoint region is present without custom endpoint.",
  },
};
function khe(e, t) {
  let { message: r, recoverySuggestion: n } = Nhe[t];
  if (!e) throw new Da({ name: t, message: r, recoverySuggestion: n });
}
var dkt = new Ot("GraphQLAPI resolveConfig"),
  aK = (e) => {
    let t = e.getConfig();
    t.API?.GraphQL ||
      dkt.warn(
        "The API configuration is missing. This is likely due to Amplify.configure() not being called prior to generateClient().",
      );
    let {
      apiKey: r,
      customEndpoint: n,
      customEndpointRegion: i,
      defaultAuthMode: o,
      endpoint: a,
      region: s,
    } = t.API?.GraphQL ?? {};
    return (
      khe(!(!n && i), Mm.NoCustomEndpoint),
      {
        apiKey: r,
        customEndpoint: n,
        customEndpointRegion: i,
        defaultAuthMode: o,
        endpoint: a,
        region: s,
      }
    );
  };
c();
var sK = (e) => {
  let t = e.libraryOptions?.API?.GraphQL?.headers,
    r = e.libraryOptions?.API?.GraphQL?.withCredentials;
  return { headers: t, withCredentials: r };
};
c();
function cK(e) {
  return (
    e.errors &&
      Array.isArray(e.errors) &&
      e.errors.forEach((t) => {
        fkt(t) &&
          ((t.message = "Unauthorized"),
          (t.recoverySuggestion = `If you're calling an Amplify-generated API, make sure to set the "authMode" in generateClient({ authMode: '...' }) to the backend authorization rule's auth provider ('apiKey', 'userPool', 'iam', 'oidc', 'lambda')`));
      }),
    e
  );
}
function fkt(e) {
  return !!(
    e?.originalError?.name?.startsWith("UnauthorizedException") ||
    (e.message?.startsWith("Connection failed:") &&
      e.message?.includes("Permission denied"))
  );
}
c();
c();
var nf;
(function (e) {
  (e.NO_API_KEY = "No api-key configured"),
    (e.NO_CURRENT_USER = "No current user"),
    (e.NO_CREDENTIALS = "No credentials"),
    (e.NO_FEDERATED_JWT = "No federated jwt"),
    (e.NO_AUTH_TOKEN = "No auth token specified");
})(nf || (nf = {}));
var uK = Symbol("amplify"),
  X0 = Symbol("authMode"),
  lK = Symbol("authToken"),
  ck = Symbol("apiKey"),
  dK = Symbol("headers"),
  J0 = Symbol("endpoint");
function Z0(e) {
  let t = e;
  return {
    amplify: t[uK],
    apiKey: t[ck],
    authMode: t[X0],
    authToken: t[lK],
    endpoint: t[J0],
    headers: t[dK],
  };
}
var Dhe = {
    name: "NoApiKey",
    message: nf.NO_API_KEY,
    recoverySuggestion:
      'The API request was made with `authMode: "apiKey"` but no API Key was passed into `Amplify.configure()`. Review if your API key is passed into the `Amplify.configure()` function.',
  },
  Lhe = {
    name: "NoCredentials",
    message: nf.NO_CREDENTIALS,
    recoverySuggestion:
      'The API request was made with `authMode: "iam"` but no authentication credentials are available.\n\nIf you intended to make a request using an authenticated role, review if your user is signed in before making the request.\n\nIf you intend to make a request using an unauthenticated role or also known as "guest access", verify if "Auth.Cognito.allowGuestAccess" is set to "true" in the `Amplify.configure()` function.',
  },
  Mhe = {
    name: "NoValidAuthTokens",
    message: nf.NO_FEDERATED_JWT,
    recoverySuggestion:
      "If you intended to make an authenticated API request, review if the current user is signed in.",
  },
  qhe = {
    name: "NoSignedUser",
    message: nf.NO_CURRENT_USER,
    recoverySuggestion:
      "Review the underlying exception field for more details. If you intended to make an authenticated API request, review if the current user is signed in.",
  },
  jhe = {
    name: "NoAuthorizationHeader",
    message: nf.NO_AUTH_TOKEN,
    recoverySuggestion:
      'The API request was made with `authMode: "lambda"` but no `authToken` is set. Review if a valid authToken is passed into the request options or in the `Amplify.configure()` function.',
  },
  Fhe = {
    name: "NoEndpoint",
    message: "No GraphQL endpoint configured in `Amplify.configure()`.",
    recoverySuggestion:
      "Review if the GraphQL API endpoint is set in the `Amplify.configure()` function.",
  };
c();
var Bhe = A(XN(), 1),
  fK = (e) => ({
    data: {},
    errors: [new Bhe.GraphQLError(e.message, null, null, null, null, e)],
  });
c();
function Uhe(e) {
  if (!e) return !1;
  let t = e;
  return Array.isArray(t.errors) && t.errors.length > 0;
}
c();
async function Hhe(e, t, r, n = {}) {
  let i = {};
  switch (t) {
    case "apiKey":
      if (!r) throw new Da(Dhe);
      i = { "X-Api-Key": r };
      break;
    case "iam": {
      if ((await e.Auth.fetchAuthSession()).credentials === void 0)
        throw new Da(Lhe);
      break;
    }
    case "oidc":
    case "userPool": {
      let o;
      try {
        o = (await e.Auth.fetchAuthSession()).tokens?.accessToken.toString();
      } catch (a) {
        throw new Da({ ...qhe, underlyingError: a });
      }
      if (!o) throw new Da(Mhe);
      i = { Authorization: o };
      break;
    }
    case "lambda":
      if (typeof n == "object" && !n.Authorization) throw new Da(jhe);
      i = { Authorization: n.Authorization };
      break;
  }
  return i;
}
var pkt = "x-amz-user-agent",
  mkt = (e) => typeof e != "function",
  eC = class {
    constructor() {
      (this.appSyncRealTime = new Map()),
        (this._api = {
          post: eK,
          cancelREST: tK,
          isCancelErrorREST: JN,
          updateRequestToBeCancellable: rK,
        });
    }
    getModuleName() {
      return "InternalGraphQLAPI";
    }
    getGraphqlOperationType(t) {
      let n = (0, Lc.parse)(t).definitions,
        [{ operation: i }] = n;
      return i;
    }
    graphql(
      t,
      {
        query: r,
        variables: n = {},
        authMode: i,
        authToken: o,
        endpoint: a,
        apiKey: s,
      },
      u,
      l,
    ) {
      let d =
          typeof r == "string"
            ? (0, Lc.parse)(r)
            : (0, Lc.parse)((0, Lc.print)(r)),
        [f = {}] = d.definitions.filter(
          (y) => y.kind === "OperationDefinition",
        ),
        { operation: m } = f,
        h = u || {};
      switch (m) {
        case "query":
        case "mutation": {
          let y = new AbortController(),
            _;
          return (
            mkt(t)
              ? (_ = this._graphql(
                  t,
                  {
                    query: d,
                    variables: n,
                    authMode: i,
                    apiKey: s,
                    endpoint: a,
                  },
                  h,
                  y,
                  l,
                  o,
                ))
              : (_ = t(
                  async (b) =>
                    await this._graphql(
                      b,
                      {
                        query: d,
                        variables: n,
                        authMode: i,
                        apiKey: s,
                        endpoint: a,
                      },
                      h,
                      y,
                      l,
                      o,
                    ),
                )),
            this._api.updateRequestToBeCancellable(_, y),
            _
          );
        }
        case "subscription":
          return this._graphqlSubscribe(
            t,
            { query: d, variables: n, authMode: i, apiKey: s, endpoint: a },
            h,
            l,
            o,
          );
        default:
          throw new Error(`invalid operation type: ${m}`);
      }
    }
    async _graphql(
      t,
      { query: r, variables: n, authMode: i, endpoint: o, apiKey: a },
      s = {},
      u,
      l,
      d,
    ) {
      let {
          apiKey: f,
          region: m,
          endpoint: h,
          customEndpoint: y,
          customEndpointRegion: _,
          defaultAuthMode: E,
        } = aK(t),
        b = i || E || "iam",
        O = b === "identityPool" ? "iam" : b,
        { headers: C, withCredentials: P } = sK(t),
        k;
      if (typeof s == "function") {
        let j = {
          method: "POST",
          url: new jn(o || y || h || "").toString(),
          queryString: (0, Lc.print)(r),
        };
        k = await s(j);
      } else k = s;
      d && (k = { ...k, Authorization: d });
      let H = await Hhe(t, O, a ?? f, k),
        B = {
          ...(!y && H),
          ...((y && (_ ? H : {})) || {}),
          ...(C && (await C({ query: (0, Lc.print)(r), variables: n }))),
          ...k,
          ...(!y && { [pkt]: wa(l) }),
        },
        L = { query: (0, Lc.print)(r), variables: n || null },
        Z;
      (y && !_) ||
      (O !== "oidc" && O !== "userPool" && O !== "iam" && O !== "lambda")
        ? (Z = void 0)
        : (Z = { service: _ ? "execute-api" : "appsync", region: _ || m });
      let ft = o || y || h;
      if (!ft) throw fK(new Da(Fhe));
      let Ct;
      try {
        let { body: j } = await this._api.post(t, {
          url: new jn(ft),
          options: {
            headers: B,
            body: L,
            signingServiceInfo: Z,
            withCredentials: P,
          },
          abortController: u,
        });
        Ct = await j.json();
      } catch (j) {
        if (this.isCancelError(j)) throw j;
        Ct = fK(j);
      }
      if (Uhe(Ct)) throw cK(Ct);
      return Ct;
    }
    isCancelError(t) {
      return this._api.isCancelErrorREST(t);
    }
    cancel(t, r) {
      return this._api.cancelREST(t, r);
    }
    _graphqlSubscribe(
      t,
      { query: r, variables: n, authMode: i, apiKey: o, endpoint: a },
      s = {},
      u,
      l,
    ) {
      let d = aK(t),
        f = i || d?.defaultAuthMode || "iam",
        m = f === "identityPool" ? "iam" : f,
        { headers: h } = sK(t),
        y = a ?? d?.endpoint,
        _ = y ?? "none",
        E = this.appSyncRealTime.get(_) ?? new sk();
      return (
        this.appSyncRealTime.set(_, E),
        E.subscribe(
          {
            query: (0, Lc.print)(r),
            variables: n,
            appSyncGraphqlEndpoint: y,
            region: d?.region,
            authenticationType: m,
            apiKey: o ?? d?.apiKey,
            additionalHeaders: s,
            authToken: l,
            libraryConfigHeaders: h,
          },
          u,
        ).pipe(
          (0, Ghe.catchError)((b) => {
            throw b.errors ? cK(b) : b;
          }),
        )
      );
    }
  },
  Dpn = new eC();
c();
c();
c();
c();
c();
var Vhe = Symbol();
c();
c();
c();
var Whe = A(kd(), 1);
c();
c();
function uk(e) {
  let t = new Set();
  for (let r of e.attributes || [])
    if (hkt(r))
      for (let n of r.properties.rules)
        n.allow === "owner"
          ? t.add(n.ownerField || "owner")
          : n.allow === "groups" &&
            n.groupsField !== void 0 &&
            t.add(n.groupsField);
  return Array.from(t);
}
function hkt(e) {
  return e?.type === "auth" &&
    typeof e?.properties == "object" &&
    Array.isArray(e?.properties?.rules)
    ? (e?.properties?.rules).every((t) => !!t.allow)
    : !1;
}
c();
function tC(e) {
  return `${e[0].toUpperCase()}${e.slice(1)}`;
}
c();
function sa(e) {
  let t,
    r,
    n = new Promise((i, o) => {
      (t = i), (r = o);
    });
  return (
    e(n)
      .then((i) => {
        t(i);
      })
      .catch((i) => {
        r(i);
      }),
    n
  );
}
c();
var lk = new WeakMap();
function ca(e, t) {
  return (
    lk.set(t, e),
    e.finally(() => {
      lk.delete(t);
    })
  );
}
function pK(e) {
  let t = e.cancel.bind(e);
  e.cancel = function (r, n) {
    let i = new Set(),
      o = r;
    for (; o && lk.has(o); ) {
      if (i.has(o))
        throw new Error(
          "A cycle was detected in the modeled graphql cancellation chain. This is a bug. Please report it!",
        );
      i.add(o), (o = lk.get(o));
    }
    return t(o, n);
  };
}
var by = { HAS_ONE: "HAS_ONE", HAS_MANY: "HAS_MANY", BELONGS_TO: "BELONGS_TO" },
  $he = {
    ID: "ID",
    String: "String",
    AWSDate: "String",
    AWSTime: "String",
    AWSDateTime: "String",
    AWSTimestamp: "Int",
    AWSEmail: "String",
    AWSPhone: "String",
    AWSURL: "String",
    AWSIPAddress: "String",
    AWSJSON: "String",
    Boolean: "Boolean",
    Int: "Int",
    Float: "Float",
  },
  dk = (e) =>
    e.length === 1
      ? e[0]
      : e.reduce((t, r, n) => (n === 0 ? r : t + tC(r)), ""),
  ua = (e, t, r) => {
    if (!r) return null;
    let n = {};
    for (let [i, o] of Object.entries(r)) {
      let a = t ? e.models[t]?.fields[i] : void 0,
        s = { fieldDef: a, value: o };
      gkt(s)
        ? (n[i] = s.value.items.map((u) => ua(e, s.fieldDef.type.model, u)))
        : vkt(a)
          ? (n[i] = ua(e, a.type.model, o))
          : (n[i] = o);
    }
    return n;
  };
function gkt(e) {
  return (
    typeof e.fieldDef?.type == "object" &&
    "model" in e.fieldDef.type &&
    typeof e.fieldDef.type.model == "string" &&
    e.fieldDef.isArray &&
    Array.isArray(e.value?.items)
  );
}
function vkt(e) {
  return (
    typeof e?.type == "object" &&
    "model" in e.type &&
    typeof e.type.model == "string"
  );
}
function Oo(e, t, r, n, i, o, a = !1) {
  let s = n.models[t],
    u = s.fields,
    l = Object.entries(u)
      .filter(([d, f]) => f?.type?.model !== void 0)
      .map(([d]) => d);
  return r.map((d) => {
    if (d == null) return d;
    let f = {};
    for (let m of l) {
      let h = u[m],
        _ = (h?.type).model,
        E = n.models[_],
        b = E.primaryKeyInfo.primaryKeyFieldName,
        O = E.primaryKeyInfo.sortKeyFieldNames,
        C = h.association?.connectionType,
        P = [];
      h.association &&
        "associatedWith" in h.association &&
        (P = h.association.associatedWith);
      let k = [];
      switch (
        (h.association &&
          "targetNames" in h.association &&
          k.push(...h.association.targetNames),
        C)
      ) {
        case by.BELONGS_TO: {
          let H = O.reduce((B, L) => (d[L] && (B[L] = d[L]), B), {});
          if (e.models[_]?.get === void 0) break;
          a
            ? (f[m] = (B, L) =>
                d[k[0]]
                  ? e.models[_].get(
                      B,
                      { [b]: d[k[0]], ...H },
                      {
                        authMode: L?.authMode || i,
                        authToken: L?.authToken || o,
                      },
                    )
                  : { data: null })
            : (f[m] = (B) =>
                d[k[0]]
                  ? e.models[_].get(
                      { [b]: d[k[0]], ...H },
                      {
                        authMode: B?.authMode || i,
                        authToken: B?.authToken || o,
                      },
                    )
                  : { data: null });
          break;
        }
        case by.HAS_ONE:
        case by.HAS_MANY: {
          let H =
              C === by.HAS_ONE
                ? (j) => ({
                    data: j?.data.shift() || null,
                    errors: j.errors,
                    extensions: j.extensions,
                  })
                : (j) => j,
            B = s.primaryKeyInfo.primaryKeyFieldName,
            L = s.primaryKeyInfo.sortKeyFieldNames,
            Z = E.fields[P[0]];
          if (Z.type.model) {
            let j = [];
            Z.association &&
              "targetNames" in Z.association &&
              (j = Z.association?.targetNames);
            let ce = j.map((Ve, $t) =>
              $t === 0
                ? { [Ve]: { eq: d[B] } }
                : { [Ve]: { eq: d[L[$t - 1]] } },
            );
            if (e.models[_]?.list === void 0) break;
            a
              ? (f[m] = (Ve, $t) =>
                  d[B]
                    ? sa(async (Yo) => {
                        let Ts = e.models[_].list(Ve, {
                            filter: { and: ce },
                            limit: $t?.limit,
                            nextToken: $t?.nextToken,
                            authMode: $t?.authMode || i,
                            authToken: $t?.authToken || o,
                          }),
                          nA = ca(Ts, Yo);
                        return H(await nA);
                      })
                    : [])
              : (f[m] = (Ve) =>
                  d[B]
                    ? sa(async ($t) => {
                        let Yo = e.models[_].list({
                            filter: { and: ce },
                            limit: Ve?.limit,
                            nextToken: Ve?.nextToken,
                            authMode: Ve?.authMode || i,
                            authToken: Ve?.authToken || o,
                          }),
                          Ts = ca(Yo, $t);
                        return H(await Ts);
                      })
                    : []);
            break;
          }
          let Ct = P.map((j, ce) =>
            ce === 0 ? { [j]: { eq: d[B] } } : { [j]: { eq: d[L[ce - 1]] } },
          );
          if (e.models[_]?.list === void 0) break;
          a
            ? (f[m] = (j, ce) =>
                d[B]
                  ? sa(async (Ve) => {
                      let $t = e.models[_].list(j, {
                          filter: { and: Ct },
                          limit: ce?.limit,
                          nextToken: ce?.nextToken,
                          authMode: ce?.authMode || i,
                          authToken: ce?.authToken || o,
                        }),
                        Yo = ca($t, Ve);
                      return H(await Yo);
                    })
                  : [])
            : (f[m] = (j) =>
                d[B]
                  ? sa(async (ce) => {
                      let Ve = e.models[_].list({
                          filter: { and: Ct },
                          limit: j?.limit,
                          nextToken: j?.nextToken,
                          authMode: j?.authMode || i,
                          authToken: j?.authToken || o,
                        }),
                        $t = ca(Ve, ce);
                      return H(await $t);
                    })
                  : []);
          break;
        }
      }
    }
    return { ...d, ...f };
  });
}
var fk = {
    CREATE: { operationPrefix: "create", usePlural: !1 },
    GET: { operationPrefix: "get", usePlural: !1 },
    UPDATE: { operationPrefix: "update", usePlural: !1 },
    DELETE: { operationPrefix: "delete", usePlural: !1 },
    LIST: { operationPrefix: "list", usePlural: !0 },
    INDEX_QUERY: { operationPrefix: "", usePlural: !1 },
    ONCREATE: { operationPrefix: "onCreate", usePlural: !1 },
    ONUPDATE: { operationPrefix: "onUpdate", usePlural: !1 },
    ONDELETE: { operationPrefix: "onDelete", usePlural: !1 },
    OBSERVEQUERY: { operationPrefix: "observeQuery", usePlural: !1 },
  },
  mK = "*",
  nC = (e, t) => {
    let { fields: r } = e,
      n = Object.values(r)
        .map(({ type: i, name: o }) => {
          if (typeof i.enum == "string") return [o, Sy];
          if (typeof i.nonModel == "string")
            return [o, nC(t.nonModels[i.nonModel], t)];
          if (typeof i == "string") return [o, Sy];
        })
        .filter((i) => i !== void 0);
    return Object.fromEntries(n);
  },
  ykt = (e, t) => {
    let { fields: r } = e,
      n = Object.values(r)
        .map(({ type: o, name: a }) => {
          if (typeof o.enum == "string" || typeof o == "string") return [a, Sy];
          if (typeof o.nonModel == "string")
            return [a, nC(t.nonModels[o.nonModel], t)];
        })
        .filter((o) => o !== void 0),
      i = uk(e).map((o) => [o, Sy]);
    return Object.fromEntries(n.concat(i));
  };
function _kt(e) {
  let { fields: t } = e,
    r = Object.values(t)
      .map(({ type: i, name: o }) => {
        if (typeof i == "string") return o;
        if (typeof i == "object") {
          if (typeof i?.enum == "string") return o;
          if (typeof i?.nonModel == "string") return `${o}.${mK}`;
        }
      })
      .filter(Boolean),
    n = uk(e);
  return Array.from(new Set(r.concat(n)));
}
var Sy = "";
function Ekt(e, t, r) {
  let n = (i, o) => {
    let [a, ...s] = i.split("."),
      u = s[0],
      l = e.models[o] ?? e.nonModels[o],
      d = l?.fields,
      f = d?.[a]?.type?.model,
      m = e.models[f],
      h = d?.[a]?.type?.nonModel,
      y = e.nonModels[h],
      _ = m ? "model" : y ? "nonModel" : "field";
    if (_ === "nonModel") {
      let E = {};
      if (!u)
        throw Error(
          `${a} must declare a wildcard (*) or a field of custom type ${h}`,
        );
      return (
        u === mK ? (E = { [a]: nC(y, e) }) : (E = { [a]: n(s.join("."), h) }), E
      );
    } else if (_ === "model") {
      let E = {};
      if (!u)
        throw Error(
          `${a} must declare a wildcard (*) or a field of model ${f}`,
        );
      if (u === mK) {
        let b = e.models[f];
        E = { [a]: ykt(b, e) };
      } else E = { [a]: n(s.join("."), f) };
      return d[a]?.isArray && (E = { [a]: { items: E[a] } }), E;
    } else {
      let E = d?.[a],
        b = e.nonModels[o],
        O = b?.fields?.[a];
      if (b) {
        if (!O) throw Error(`${a} is not a field of custom type ${o}`);
      } else {
        let C = uk(l).includes(a);
        if (!E && !C) throw Error(`${a} is not a field of model ${o}`);
      }
      return { [a]: Sy };
    }
  };
  return r.reduce((i, o) => Khe(n(o, t), i), {});
}
function rC(e) {
  let t = [];
  return (
    Object.entries(e).forEach(([r, n]) => {
      n === Sy
        ? t.push(r)
        : typeof n == "object" &&
          n !== null &&
          (n?.items
            ? t.push(r, "{", "items", "{", rC(n.items), "}", "}")
            : t.push(r, "{", rC(n), "}"));
    }),
    t.join(" ")
  );
}
function Khe(e, t) {
  let r = (n) => n && typeof n == "object";
  for (let n in e)
    Object.prototype.hasOwnProperty.call(e, n) &&
      (Object.prototype.hasOwnProperty.call(t, n) && r(t[n])
        ? Khe(e[n], t[n])
        : (t[n] = e[n]));
  return t;
}
function hK(e, t, r) {
  let n = e.models[t],
    i = Ekt(e, t, r ?? _kt(n));
  return rC(i);
}
function of(e, t, r, n, i) {
  let {
      name: o,
      pluralName: a,
      fields: s,
      primaryKeyInfo: {
        isCustomPrimaryKey: u,
        primaryKeyFieldName: l,
        sortKeyFieldNames: d,
      },
      attributes: f,
    } = t,
    m = o.charAt(0).toUpperCase() + o.slice(1),
    h = a.charAt(0).toUpperCase() + a.slice(1),
    { operationPrefix: y, usePlural: _ } = fk[r],
    { selectionSet: E } = n || {},
    b,
    O;
  if (y) b = `${y}${_ ? h : m}`;
  else if (i) {
    let { queryField: Ct, pk: j, sk: ce = [] } = i;
    b = Ct;
    let Ve = {};
    if (ce.length === 1) {
      let [$t] = ce,
        Yo = typeof s[$t].type == "string" ? s[$t].type : "String",
        Ts = $he[Yo];
      Ve = { [$t]: `Model${Ts}KeyConditionInput` };
    } else if (ce.length > 1) {
      let $t = dk(ce),
        Yo = f?.find((Ts) => Ts?.properties?.queryField === Ct)?.properties
          ?.name;
      Ve = { [$t]: `Model${tC(o)}${tC(Yo)}CompositeKeyConditionInput` };
    }
    O = {
      [j]: `${Object.prototype.hasOwnProperty.call(s[j].type, "enum") ? s[j].type.enum : s[j].type}!`,
      ...Ve,
    };
  } else
    throw new Error(
      "Error generating GraphQL Document - invalid operation name",
    );
  let C,
    P,
    k,
    H = hK(e, o, E),
    B = { [l]: `${s[l].type}!` },
    L = {},
    Z = (Ct) => {
      if (d.length === 0) return {};
      if (Ct === "get")
        return d.reduce((j, ce) => {
          let Ve = s[ce].type;
          return Ct === "get" && (j[ce] = `${Ve}!`), j;
        }, {});
      if (d.length === 1) {
        let [j] = d,
          ce = typeof s[j].type == "string" ? s[j].type : "String",
          Ve = $he[ce];
        return { [j]: `Model${Ve}KeyConditionInput` };
      } else
        return { [dk(d)]: `Model${tC(o)}PrimaryCompositeKeyConditionInput` };
    };
  switch (
    (u &&
      (Object.assign(B, Z("get")),
      Object.assign(
        L,
        { [l]: `${s[l].type}`, sortDirection: "ModelSortDirection" },
        Z("list"),
      )),
    r)
  ) {
    case "CREATE":
    case "UPDATE":
    case "DELETE":
      k ??
        (k = {
          input: `${y.charAt(0).toLocaleUpperCase() + y.slice(1)}${m}Input!`,
        }),
        C ?? (C = "mutation");
    case "GET":
      k ?? (k = B), P ?? (P = H);
    case "LIST":
      k ??
        (k = {
          ...L,
          filter: `Model${m}FilterInput`,
          limit: "Int",
          nextToken: "String",
        }),
        C ?? (C = "query"),
        P ?? (P = `items { ${H} } nextToken __typename`);
    case "INDEX_QUERY":
      k ??
        (k = {
          ...O,
          filter: `Model${m}FilterInput`,
          sortDirection: "ModelSortDirection",
          limit: "Int",
          nextToken: "String",
        }),
        C ?? (C = "query"),
        P ?? (P = `items { ${H} } nextToken __typename`);
    case "ONCREATE":
    case "ONUPDATE":
    case "ONDELETE":
      k ?? (k = { filter: `ModelSubscription${m}FilterInput` }),
        C ?? (C = "subscription"),
        P ?? (P = H);
      break;
    case "OBSERVEQUERY":
    default:
      throw new Error(
        "Internal error: Attempted to generate graphql document for observeQuery. Please report this error.",
      );
  }
  return `${C}${k ? `(${Object.entries(k).map(([Ct, j]) => `$${Ct}: ${j}`)})` : ""} { ${b}${k ? `(${Object.keys(k).map((Ct) => `${Ct}: $${Ct}`)})` : ""} { ${P} } }`;
}
function af(e, t, r, n, i) {
  let {
      fields: o,
      primaryKeyInfo: {
        isCustomPrimaryKey: a,
        primaryKeyFieldName: s,
        sortKeyFieldNames: u,
      },
    } = e,
    l = u?.length && dk(u),
    d = {};
  switch (t) {
    case "CREATE":
      d = { input: r ? zhe(r, e, n) : {} };
      break;
    case "UPDATE":
      d = {
        input: r
          ? Object.fromEntries(
              Object.entries(zhe(r, e, n)).filter(([f]) => {
                let { isReadOnly: m } = o[f];
                return !m;
              }),
            )
          : {},
      };
      break;
    case "GET":
    case "DELETE":
      r &&
        (d = a
          ? [s, ...u].reduce((f, m) => ((f[m] = r[m]), f), {})
          : { [s]: r[s] }),
        t === "DELETE" && (d = { input: d });
      break;
    case "LIST":
      r?.filter && (d.filter = r.filter),
        r?.sortDirection && (d.sortDirection = r.sortDirection),
        r && r[s] && (d[s] = r[s]),
        l && r && r[l] && (d[l] = r[l]),
        r?.nextToken && (d.nextToken = r.nextToken),
        r?.limit && (d.limit = r.limit);
      break;
    case "INDEX_QUERY": {
      let { pk: f, sk: m = [] } = i,
        h = m?.length && dk(m);
      (d[f] = r[f]),
        h && r && r[h] && (d[h] = r[h]),
        r?.filter && (d.filter = r.filter),
        r?.sortDirection && (d.sortDirection = r.sortDirection),
        r?.nextToken && (d.nextToken = r.nextToken),
        r?.limit && (d.limit = r.limit);
      break;
    }
    case "ONCREATE":
    case "ONUPDATE":
    case "ONDELETE":
      r?.filter && (d = { filter: r.filter });
      break;
    case "OBSERVEQUERY":
      throw new Error(
        "Internal error: Attempted to build variables for observeQuery. Please report this error.",
      );
    default: {
      let f = t;
      throw new Error(`Unhandled operation case: ${f}`);
    }
  }
  return d;
}
function zhe(e, t, r) {
  let { fields: n } = t,
    i = {};
  return (
    Object.entries(e).forEach(([o, a]) => {
      let u = n[o]?.type?.model;
      if (u) {
        let l = n[o]?.association,
          f = r.models[u].primaryKeyInfo;
        if (l?.connectionType === by.HAS_ONE) {
          let m = l;
          m.targetNames.forEach((h, y) => {
            let _ = m.associatedWith[y];
            i[h] = a[_];
          });
        }
        l?.connectionType === by.BELONGS_TO &&
          l.targetNames.forEach((h, y) => {
            if (y === 0) {
              let _ = f.primaryKeyFieldName;
              i[h] = a[_];
            } else {
              let _ = f.sortKeyFieldNames[y - 1];
              i[h] = a[_];
            }
          });
      } else i[o] = a;
    }),
    i
  );
}
function Bs(e, t, r = {}) {
  let n = t(e);
  return {
    authMode: r.authMode || n.authMode,
    authToken: r.authToken || n.authToken,
  };
}
function Us(e, t, r) {
  let n = t(e).headers || {};
  return r && (n = r), n;
}
c();
function iC(e) {
  if (e?.errors) return { ...e, data: [] };
  throw e;
}
function Cy(e) {
  if (e.errors) return { ...e, data: null };
  throw e;
}
c();
var oC = Symbol("INTERNAL_USER_AGENT_OVERRIDE"),
  Tn;
(function (e) {
  (e.CreateConversation = "1"),
    (e.GetConversation = "2"),
    (e.ListConversations = "3"),
    (e.DeleteConversation = "4"),
    (e.SendMessage = "5"),
    (e.ListMessages = "6"),
    (e.OnStreamEvent = "7"),
    (e.Generation = "8"),
    (e.UpdateConversation = "9");
})(Tn || (Tn = {}));
var Xn = (e) => ({ category: "ai", action: e });
function qm(e) {
  return e ? { [oC]: e } : void 0;
}
var bkt = (e) => typeof e?.token?.value == "symbol";
function sf(e, t, r, n, i, o, a) {
  let s = n.arguments !== void 0;
  return (...l) => {
    let d = l[l.length - 1],
      f,
      m;
    if (i)
      if (bkt(l[0])) f = l[0];
      else
        throw new Error(
          `Invalid first argument passed to ${n.name}. Expected contextSpec`,
        );
    return (
      s && (i ? (m = l[1]) : (m = l[0])),
      r === "subscription"
        ? Tkt(e, t, n, o, m, d, a)
        : Okt(e, t, r, n, o, m, d, f, a)
    );
  };
}
function wy(e, t) {
  return typeof e[t] == "string";
}
function Skt(e) {
  return e instanceof Object && "enum" in e;
}
function Ckt(e) {
  return e instanceof Object && "input" in e;
}
function wkt({ type: e, isRequired: t }) {
  let r = t ? "!" : "";
  return Skt(e) ? `${e.enum}${r}` : Ckt(e) ? `${e.input}${r}` : `${e}${r}`;
}
function Qhe(e) {
  if (e.arguments === void 0) return "";
  let t = Object.entries(e.arguments)
    .map(([r, n]) => {
      let i = wkt(n),
        o = n.isArray ? `[${i}]${n.isArrayNullable ? "" : "!"}` : i;
      return `$${r}: ${o}`;
    })
    .join(", ");
  return t.length > 0 ? `(${t})` : "";
}
function Yhe(e) {
  if (e.arguments === void 0) return "";
  let t = Object.keys(e.arguments)
    .map((r) => `${r}: $${r}`)
    .join(", ");
  return t.length > 0 ? `(${t})` : "";
}
function Xhe(e, t) {
  if (wy(t, "type") || wy(t.type, "enum")) return "";
  if (wy(t.type, "nonModel")) {
    let r = e.nonModels[t.type.nonModel];
    return `{${rC(nC(r, e))}}`;
  } else return wy(t.type, "model") ? `{${hK(e, t.type.model)}}` : "";
}
function Jhe(e, t = {}) {
  let r = {};
  if (e.arguments === void 0) return r;
  for (let n of Object.values(e.arguments))
    if (typeof t[n.name] < "u") r[n.name] = t[n.name];
    else if (n.isRequired)
      throw new Error(`${e.name} requires arguments '${n.name}'`);
  return r;
}
function Okt(e, t, r, n, i, o, a, s, u) {
  return sa(async (l) => {
    let { name: d } = n,
      f = Bs(e, i, a),
      m = Us(e, i, a?.headers),
      h = Qhe(n),
      y = Yhe(n),
      _ = Xhe(t, n),
      E = wy(n.type, "model") ? n.type.model : void 0,
      b = `
    ${r.toLocaleLowerCase()}${h} {
      ${d}${y} ${_}
    }
  `,
      O = Jhe(n, o),
      C = qm(u);
    try {
      let P = s
          ? e.graphql(s, { ...f, query: b, variables: O }, m)
          : e.graphql({ ...f, query: b, variables: O, ...C }, m),
        k = ca(P, l),
        { data: H, extensions: B } = await k;
      if (H) {
        let [L] = Object.keys(H),
          Z = Array.isArray(H[L]),
          ft = Z ? H[L].filter((j) => j) : H[L],
          Ct = E
            ? Oo(e, E, Z ? ft : [ft], t, f.authMode, f.authToken, !!s)
            : ft;
        return {
          data: !Z && Array.isArray(Ct) ? Ct.shift() : Ct,
          extensions: B,
        };
      } else return { data: null, extensions: B };
    } catch (P) {
      let { data: k, errors: H } = P;
      if (k && Object.keys(k).length !== 0 && H) {
        let [B] = Object.keys(k),
          L = Array.isArray(k[B]),
          Z = L ? k[B].filter((ft) => ft) : k[B];
        if (Z) {
          let ft = E
            ? Oo(e, E, L ? Z : [Z], t, f.authMode, f.authToken, !!s)
            : Z;
          return { data: !L && Array.isArray(ft) ? ft.shift() : ft, errors: H };
        } else return Cy(P);
      } else return Cy(P);
    }
  });
}
function Tkt(e, t, r, n, i, o, a) {
  let s = "subscription",
    { name: u } = r,
    l = Bs(e, n, o),
    d = Us(e, n, o?.headers),
    f = Qhe(r),
    m = Yhe(r),
    h = Xhe(t, r),
    y = wy(r.type, "model") ? r.type.model : void 0,
    _ = `
    ${s.toLocaleLowerCase()}${f} {
      ${u}${m} ${h}
    }
  `,
    E = Jhe(r, i),
    b = qm(a);
  return e.graphql({ ...l, query: _, variables: E, ...b }, d).pipe(
    (0, Whe.map)((C) => {
      let [P] = Object.keys(C.data),
        k = C.data[P],
        [H] = y ? Oo(e, y, [k], t, l.authMode, l.authToken) : [k];
      return H;
    }),
  );
}
var Akt = {
  queries: "query",
  mutations: "mutation",
  subscriptions: "subscription",
};
function gK(e, t, r, n) {
  if (!t) return {};
  let i = t.modelIntrospection;
  if (!i) return {};
  let o = i[r];
  if (!o) return {};
  let a = {},
    s = n(e).amplify === null;
  for (let u of Object.values(o)) a[u.name] = sf(e, i, Akt[r], u, s, n);
  return a;
}
function vK(e, t, r) {
  return gK(e, t, "mutations", r);
}
function yK(e, t, r) {
  return gK(e, t, "queries", r);
}
function Zhe(e, t, r) {
  return gK(e, t, "subscriptions", r);
}
c();
c();
c();
function Hs(e, t, r, n, i, o = !1, a) {
  return o
    ? (l, d, f) => ege(e, t, r, d, f, n, i, l, a)
    : (l, d) => ege(e, t, r, l, d, n, i, void 0, a);
}
function ege(e, t, r, n, i, o, a, s, u) {
  return sa(async (l) => {
    let { name: d } = r,
      f = of(t, r, o, i),
      m = af(r, o, n, t),
      h = Bs(e, a, i),
      y = Us(e, a, i?.headers),
      _ = qm(u);
    try {
      let E = s
          ? e.graphql(s, { ...h, query: f, variables: m }, y)
          : e.graphql({ ...h, query: f, variables: m, ..._ }, y),
        b = ca(E, l),
        { data: O, extensions: C } = await b;
      if (O) {
        let [P] = Object.keys(O),
          k = ua(t, d, O[P]);
        if (k === null) return { data: null, extensions: C };
        if (i?.selectionSet) return { data: k, extensions: C };
        {
          let [H] = Oo(e, d, [k], t, h.authMode, h.authToken, !!s);
          return { data: H, extensions: C };
        }
      } else return { data: null, extensions: C };
    } catch (E) {
      let { data: b, errors: O } = E;
      if (b && Object.keys(b).length !== 0 && O) {
        let [C] = Object.keys(b),
          P = ua(t, d, b[C]);
        if (P) {
          if (i?.selectionSet) return { data: P, errors: O };
          {
            let [k] = Oo(e, d, [P], t, h.authMode, h.authToken, !!s);
            return { data: k, errors: O };
          }
        } else return Cy(E);
      } else return Cy(E);
    }
  });
}
c();
c();
c();
function jm(e, t, r, n, i = !1, o) {
  return i
    ? (u, l) => tge(e, t, r, n, l, u, o)
    : (u) => tge(e, t, r, n, u, void 0, o);
}
function tge(e, t, r, n, i, o, a) {
  return sa(async (s) => {
    let { name: u } = r,
      l = of(t, r, "LIST", i),
      d = af(r, "LIST", i, t),
      f = Bs(e, n, i),
      m = Us(e, n, i?.headers),
      h = qm(a);
    try {
      let y = o
          ? e.graphql(o, { ...f, query: l, variables: d }, m)
          : e.graphql({ ...f, query: l, variables: d, ...h }, m),
        _ = ca(y, s),
        { data: E, extensions: b } = await _;
      if (E !== void 0) {
        let [O] = Object.keys(E);
        if (E[O].items) {
          let C = E[O].items.map((P) => ua(t, u, P));
          return i?.selectionSet
            ? { data: C, nextToken: E[O].nextToken, extensions: b }
            : {
                data: Oo(e, u, C, t, f.authMode, f.authToken, !!o),
                nextToken: E[O].nextToken,
                extensions: b,
              };
        }
        return { data: E[O], nextToken: E[O].nextToken, extensions: b };
      }
    } catch (y) {
      let { data: _, errors: E } = y;
      if (_ != null && Object.keys(_).length !== 0 && E) {
        let [b] = Object.keys(_);
        if (_[b]?.items) {
          let O = _[b].items.map((C) => ua(t, u, C));
          return O
            ? i?.selectionSet
              ? { data: O, nextToken: _[b]?.nextToken, errors: E }
              : {
                  data: Oo(e, u, O, t, f.authMode, f.authToken, !!o),
                  nextToken: _[b]?.nextToken,
                  errors: E,
                }
            : { data: _[b], nextToken: _[b]?.nextToken, errors: E };
        } else return iC(y);
      } else return iC(y);
    }
  });
}
c();
c();
var vge = A(Ek(), 1),
  yge = (e) =>
    e.map((t) =>
      t.image ? _ge(t) : t.toolUse ? lDt(t) : t.toolResult ? dDt(t) : Ege(t),
    ),
  _ge = ({ image: e }) => ({
    image: {
      ...e,
      source: { ...e.source, bytes: (0, vge.fromBase64)(e.source.bytes) },
    },
  }),
  uDt = ({ json: e }) => ({ json: JSON.parse(e) }),
  lDt = ({ toolUse: e }) => ({ toolUse: { ...e, input: JSON.parse(e.input) } }),
  dDt = ({ toolResult: e }) => ({
    toolResult: {
      toolUseId: e.toolUseId,
      content: e.content.map((t) =>
        t.image ? _ge(t) : t.json ? uDt(t) : Ege(t),
      ),
    },
  }),
  Ege = (e) =>
    Object.fromEntries(Object.entries(e).filter(([t, r]) => r !== null));
var bk = ({ content: e, createdAt: t, id: r, conversationId: n, role: i }) => ({
  content: yge(e ?? []),
  conversationId: n,
  createdAt: t,
  id: r,
  role: i,
});
var bge = (e, t, r, n, i) => async (o) => {
  let a = jm(e, t, n, i, !1, Xn(Tn.ListMessages)),
    {
      data: s,
      nextToken: u,
      errors: l,
    } = await a({ ...o, filter: { conversationId: { eq: r } } });
  return { data: s.map((d) => bk(d)), nextToken: u, errors: l };
};
c();
c();
var Sge = ({
    id: e,
    conversationId: t,
    associatedUserMessageId: r,
    contentBlockIndex: n,
    contentBlockDoneAtIndex: i,
    contentBlockDeltaIndex: o,
    contentBlockText: a,
    contentBlockToolUse: s,
    stopReason: u,
    errors: l,
  }) =>
    l
      ? {
          error: {
            id: e,
            conversationId: t,
            associatedUserMessageId: r,
            errors: l,
          },
        }
      : {
          next: pDt({
            id: e,
            conversationId: t,
            associatedUserMessageId: r,
            contentBlockIndex: n,
            contentBlockDoneAtIndex: i,
            contentBlockDeltaIndex: o,
            text: a,
            toolUse: fDt(s),
            stopReason: u,
          }),
        },
  fDt = (e) => {
    if (e) return { ...e, input: JSON.parse(e.input) };
  },
  pDt = (e) =>
    Object.fromEntries(Object.entries(e).filter(([t, r]) => r !== null));
var Cge = (e, t, r, n, i) => (o) => {
  let { conversations: a } = t;
  if (!a) return {};
  let s = a[n].message.subscribe;
  return sf(
    e,
    t,
    "subscription",
    s,
    !1,
    i,
    Xn(Tn.OnStreamEvent),
  )({ conversationId: r }).subscribe((l) => {
    let { next: d, error: f } = Sge(l);
    f && o.error(f), d && o.next(d);
  });
};
c();
c();
var wge = A(Ek(), 1),
  Oge = (e) => JSON.stringify(e),
  Tge = (e) => e.map((t) => (t.image ? Pge(t) : t.toolResult ? hDt(t) : t)),
  Age = ({ tools: e }) => ({
    tools: Object.entries(e).map(([t, r]) => ({
      toolSpec: {
        name: t,
        description: r.description,
        inputSchema: { json: JSON.stringify(r.inputSchema.json) },
      },
    })),
  }),
  Pge = ({ image: e }) => ({
    image: {
      ...e,
      source: { ...e.source, bytes: (0, wge.toBase64)(e.source.bytes) },
    },
  }),
  mDt = ({ json: e }) => ({ json: JSON.stringify(e) }),
  hDt = ({ toolResult: e }) => ({
    toolResult: {
      ...e,
      content: e.content.map((t) => (t.image ? Pge(t) : t.json ? mDt(t) : t)),
    },
  });
var Rge = (e, t, r, n, i) => async (o) => {
  let { conversations: a } = t;
  if (!a) return {};
  let s = typeof o == "string" ? { content: [{ text: o }] } : o,
    { content: u, aiContext: l, toolConfiguration: d } = s,
    f = a[n].message.send,
    m = sf(e, t, "mutation", f, !1, i, Xn(Tn.SendMessage)),
    { data: h, errors: y } = await m({
      conversationId: r,
      content: Tge(u),
      ...(l && { aiContext: Oge(l) }),
      ...(d && { toolConfiguration: Age(d) }),
    });
  return { data: h && bk(h), errors: y };
};
var Mc = (e, t, r, n, i, o, a, s, u, l) => {
  if (!r)
    throw new Error(
      `An error occurred converting a ${o} conversation: Missing ID`,
    );
  return {
    id: r,
    createdAt: n,
    updatedAt: i,
    metadata: u,
    name: l,
    onStreamEvent: Cge(e, t, r, o, s),
    sendMessage: Rge(e, t, r, o, s),
    listMessages: bge(e, t, r, a, s),
  };
};
var Ige = (e, t, r, n, i, o) => async (a) => {
  let { name: s, metadata: u } = a ?? {},
    l = JSON.stringify(u),
    d = Hs(e, t, n, "CREATE", o, !1, Xn(Tn.CreateConversation)),
    { data: f, errors: m } = await d({ name: s, metadata: l });
  return {
    data: Mc(
      e,
      t,
      f?.id,
      f?.createdAt,
      f?.updatedAt,
      r,
      i,
      o,
      f?.metadata,
      f?.name,
    ),
    errors: m,
  };
};
c();
var xge =
  (e, t, r, n, i, o) =>
  async ({ id: a }) => {
    let s = Hs(e, t, n, "GET", o, !1, Xn(Tn.GetConversation)),
      { data: u, errors: l } = await s({ id: a });
    return {
      data:
        u &&
        Mc(e, t, u.id, u.createdAt, u.updatedAt, r, i, o, u?.metadata, u?.name),
      errors: l,
    };
  };
c();
var Nge = (e, t, r, n, i, o) => async (a) => {
  let s = jm(e, t, n, o, !1, Xn(Tn.ListConversations)),
    { data: u, nextToken: l, errors: d } = await s(a);
  return {
    data: u.map((f) =>
      Mc(e, t, f.id, f.createdAt, f.updatedAt, r, i, o, f?.metadata, f?.name),
    ),
    nextToken: l,
    errors: d,
  };
};
c();
var kge =
  (e, t, r, n, i, o) =>
  async ({ id: a }) => {
    let s = Hs(e, t, n, "DELETE", o, !1, Xn(Tn.DeleteConversation)),
      { data: u, errors: l } = await s({ id: a });
    return {
      data:
        u &&
        Mc(
          e,
          t,
          u?.id,
          u?.createdAt,
          u?.updatedAt,
          r,
          i,
          o,
          u?.metadata,
          u?.name,
        ),
      errors: l,
    };
  };
c();
var Dge =
  (e, t, r, n, i, o) =>
  async ({ id: a, metadata: s, name: u }) => {
    let l = JSON.stringify(s),
      d = Hs(e, t, n, "UPDATE", o, !1, Xn(Tn.UpdateConversation)),
      { data: f, errors: m } = await d({ id: a, metadata: l, name: u });
    return {
      data:
        f &&
        Mc(
          e,
          t,
          f?.id,
          f?.createdAt,
          f?.updatedAt,
          r,
          i,
          o,
          f?.metadata,
          f?.name,
        ),
      errors: m,
    };
  };
function Lge(e, t, r) {
  let n = t?.modelIntrospection;
  if (!n?.conversations) return {};
  let i = {};
  for (let {
    name: o,
    conversation: a,
    message: s,
    models: u,
    nonModels: l,
    enums: d,
  } of Object.values(n.conversations)) {
    let f = u[a.modelName],
      m = u[s.modelName];
    if (!f || !m) return {};
    let h = {
      ...n,
      models: { ...n.models, ...u },
      nonModels: { ...n.nonModels, ...l },
      enums: { ...n.enums, ...d },
    };
    i[o] = {
      update: Dge(e, h, o, f, m, r),
      create: Ige(e, h, o, f, m, r),
      get: xge(e, h, o, f, m, r),
      delete: kge(e, h, o, f, m, r),
      list: Nge(e, h, o, f, m, r),
    };
  }
  return i;
}
c();
function Mge(e, t, r) {
  let n = t?.modelIntrospection;
  if (!n?.generations) return {};
  let i = {};
  for (let o of Object.values(n.generations))
    i[o.name] = sf(e, n, "query", o, !1, r, Xn(Tn.Generation));
  return i;
}
c();
var CK = (e) => {
  let t = e.modelIntrospection;
  if (!t) return {};
  let r = {};
  for (let [n, i] of Object.entries(t.enums))
    r[i.name] = { values: () => i.values };
  return r;
};
c();
c();
function wK(e, t, r, n, i, o = !1) {
  return o
    ? (u, l, d) => qge(e, t, r, n, i, { ...l, ...d }, u)
    : (u, l) => qge(e, t, r, n, i, { ...u, ...l });
}
function gDt(e, t, r, n, i) {
  let { data: o, extensions: a } = r,
    [s] = Object.keys(o);
  if (o[s].items) {
    let u = o[s].items.map((l) => ua(e, t, l));
    return { data: n ? u : i(u), nextToken: o[s].nextToken, extensions: a };
  }
  return { data: o[s], nextToken: o[s].nextToken, extensions: a };
}
function qge(e, t, r, n, i, o, a) {
  return sa(async (s) => {
    let { name: u } = r,
      l = of(t, r, "INDEX_QUERY", o, n),
      d = af(r, "INDEX_QUERY", o, t, n),
      f = Bs(e, i, o),
      m = (h) => Oo(e, u, h, t, f.authMode, f.authToken, !!a);
    try {
      let h = Us(e, i, o?.headers),
        _ = [{ ...f, query: l, variables: d }, h];
      a !== void 0 && _.unshift(a);
      let E = e.graphql(..._),
        O = await ca(E, s);
      if (O.data !== void 0) return gDt(t, u, O, o?.selectionSet, m);
    } catch (h) {
      let { data: y, errors: _ } = h;
      if (y != null && Object.keys(y).length !== 0 && _) {
        let [E] = Object.keys(y);
        if (y[E]?.items) {
          let b = y[E]?.items.map((O) => ua(t, u, O));
          if (b)
            return {
              data: o?.selectionSet ? b : m(b),
              nextToken: y[E]?.nextToken,
            };
        }
        return { data: y[E], nextToken: y[E]?.nextToken };
      } else return iC(h);
    }
  });
}
c();
var jge = A(kd(), 1);
function Fge(e, t, r, n, i) {
  let { name: o } = r;
  return (s) => {
    let u = of(t, r, n, s),
      l = af(r, n, s, t),
      d = Bs(e, i, s),
      f = Us(e, i, s?.headers);
    return e.graphql({ ...d, query: u, variables: l }, f).pipe(
      (0, jge.map)((h) => {
        let [y] = Object.keys(h.data),
          _ = h.data[y],
          E = ua(t, o, _);
        if (E === null) return null;
        if (s?.selectionSet) return E;
        {
          let [b] = Oo(e, o, [E], t, d.authMode, d.authToken);
          return b;
        }
      }),
    );
  };
}
c();
var Hge = A(kd(), 1);
c();
function Bge(e) {
  let { primaryKeyFieldName: t, sortKeyFieldNames: r } = e.primaryKeyInfo;
  return [t, ...r];
}
c();
function Uge(e, t, r) {
  let n = Object.fromEntries(r.map((i) => [i, e[i]]));
  for (let i = 0; i < t.length; i++)
    if (Object.keys(n).every((o) => n[o] === t[i][o])) return i;
  return -1;
}
function Gge(e, t) {
  let { name: r } = t;
  return (i) =>
    new Hge.Observable((o) => {
      let a = [],
        s = [],
        u = (...y) => s.push(...y),
        l = e[r].onCreate(i).subscribe({
          next(y) {
            u({ item: y, type: "create" });
          },
          error(y) {
            o.error({ type: "onCreate", error: y });
          },
        }),
        d = e[r].onUpdate(i).subscribe({
          next(y) {
            u({ item: y, type: "update" });
          },
          error(y) {
            o.error({ type: "onUpdate", error: y });
          },
        }),
        f = e[r].onDelete(i).subscribe({
          next(y) {
            u({ item: y, type: "delete" });
          },
          error(y) {
            o.error({ type: "onDelete", error: y });
          },
        });
      function m(y) {
        for (let _ of y) {
          let E = Uge(_.item, a, h);
          switch (_.type) {
            case "create":
              E < 0 && a.push(_.item);
              break;
            case "update":
              E >= 0 && (a[E] = _.item);
              break;
            case "delete":
              E >= 0 && a.splice(E, 1);
              break;
            default:
              console.error("Unrecognized message in observeQuery.", _);
          }
        }
        o.next({ items: a, isSynced: !0 });
      }
      let h = Bge(t);
      return (
        (async () => {
          let y = !0,
            _ = null;
          for (; !o.closed && (y || _); ) {
            y = !1;
            let {
              data: E,
              errors: b,
              nextToken: O,
            } = await e[r].list({ ...i, nextToken: _ });
            (_ = O), a.push(...E);
            let C = s.length === 0 && _ == null;
            if ((o.next({ items: a, isSynced: C }), Array.isArray(b)))
              for (let P of b) o.error(P);
          }
          s.length > 0 && m(s), (u = (...E) => (m(E), a.length));
        })(),
        () => {
          l.unsubscribe(), d.unsubscribe(), f.unsubscribe();
        }
      );
    });
}
c();
var vDt = (e) =>
    e.type === "key" &&
    e.properties?.name &&
    e.properties?.queryField &&
    e.properties?.fields.length > 0,
  OK = (e) =>
    e.attributes?.filter(vDt).map((r) => {
      let n = r.properties.queryField,
        [i, ...o] = r.properties.fields;
      return { queryField: n, pk: i, sk: o };
    }) || [],
  TK = (e, t) => {
    let r = e.models[t].attributes?.find((s) => s.type === "model"),
      n = {
        queries: ["list", "get", "observeQuery"],
        mutations: ["create", "update", "delete"],
        subscriptions: ["onCreate", "onUpdate", "onDelete"],
      },
      i = [];
    if (!r) return fk;
    if (r.properties)
      for (let [s, u] of Object.entries(r.properties))
        s in n &&
          (u === null
            ? i.push(...n[s])
            : u instanceof Object && i.push(...Object.keys(u)));
    i.includes("list") && i.push("observeQuery");
    let o = i.map((s) => s.toUpperCase());
    return Object.fromEntries(
      Object.entries(fk).filter(([s]) => !o.includes(s)),
    );
  };
function Vge(e, t, r) {
  let n = {},
    i = t.modelIntrospection;
  if (!i) return {};
  let o = ["ONCREATE", "ONUPDATE", "ONDELETE"];
  for (let a of Object.values(i.models)) {
    let { name: s } = a;
    n[s] = {};
    let u = TK(i, s);
    Object.entries(u).forEach(([d, { operationPrefix: f }]) => {
      let m = d;
      m === "LIST"
        ? (n[s][f] = jm(e, i, a, r))
        : o.includes(m)
          ? (n[s][f] = Fge(e, i, a, m, r))
          : m === "OBSERVEQUERY"
            ? (n[s][f] = Gge(n, a))
            : (n[s][f] = Hs(e, i, a, m, r));
    });
    let l = OK(a);
    for (let d of l) n[s][d.queryField] = wK(e, i, a, d, r);
  }
  return n;
}
function Sk(e, t, r) {
  return (
    pK(e),
    (e.models = Vge(e, t, r)),
    (e.enums = CK(t)),
    (e.queries = yK(e, t, r)),
    (e.mutations = vK(e, t, r)),
    (e.subscriptions = Zhe(e, t, r)),
    (e.conversations = Lge(e, t, r)),
    (e.generations = Mge(e, t, r)),
    e
  );
}
c();
c();
var Jgn = A(Ek(), 1);
c();
function yDt(e) {
  return oC in e;
}
var AK = class extends eC {
    getModuleName() {
      return "GraphQLAPI";
    }
    graphql(t, r, n) {
      let i = { category: $p.API, action: ES.GraphQl };
      if (yDt(r)) {
        let { [oC]: o, ...a } = r;
        return super.graphql(t, a, n, { ...i, ...o });
      }
      return super.graphql(t, r, n, { ...i });
    }
    isCancelError(t) {
      return super.isCancelError(t);
    }
    cancel(t, r) {
      return super.cancel(t, r);
    }
  },
  Ck = new AK();
function $ge(e, t) {
  let r = Z0(this),
    n = r.endpoint,
    i = r.authMode,
    o = r.apiKey;
  if (
    ((e.authMode = e.authMode || i),
    (e.apiKey = e.apiKey ?? o),
    (e.authToken = e.authToken || r.authToken),
    n && e.authMode === "apiKey" && !e.apiKey)
  )
    throw new Error(
      "graphql() requires an explicit `apiKey` for a custom `endpoint` when `authMode = 'apiKey'`.",
    );
  let a = t || r.headers;
  return Ck.graphql(r.amplify, { ...e, endpoint: n }, a);
}
function zge(e, t) {
  return Ck.cancel(e, t);
}
function Kge(e) {
  return Ck.isCancelError(e);
}
c();
c();
function PK(e) {
  return e !== void 0;
}
c();
function Wge(e) {
  return e.event === "configure";
}
function RK(e) {
  let t = {
      [uK]: e.amplify,
      [X0]: e.authMode,
      [lK]: e.authToken,
      [ck]: "apiKey" in e ? e.apiKey : void 0,
      [J0]: "endpoint" in e ? e.endpoint : void 0,
      [dK]: e.headers,
      graphql: $ge,
      cancel: zge,
      isCancelError: Kge,
      models: aC,
      enums: aC,
      queries: aC,
      mutations: aC,
      subscriptions: aC,
    },
    r = e.amplify.getConfig().API?.GraphQL;
  if (t[J0]) {
    if (!t[X0])
      throw new Error(
        "generateClient() requires an explicit `authMode` when `endpoint` is provided.",
      );
    if (t[X0] === "apiKey" && !t[ck])
      throw new Error(
        "generateClient() requires an explicit `apiKey` when `endpoint` is provided and `authMode = 'apiKey'`.",
      );
  }
  return t[J0] || (PK(r) ? Sk(t, r, Z0) : _Dt(t)), t;
}
var _Dt = (e) => {
    fi.listen("core", (t) => {
      if (!Wge(t.payload)) return;
      let r = t.payload.data.API?.GraphQL;
      PK(r) && Sk(e, r, Z0);
    });
  },
  aC = new Proxy(
    {},
    {
      get() {
        throw new Error(
          "Client could not be generated. This is likely due to `Amplify.configure()` not being called prior to `generateClient()` or because the configuration passed to `Amplify.configure()` is missing GraphQL provider configuration.",
        );
      },
    },
  );
function IK(e) {
  return RK({ ...(e || {}), amplify: Qn });
}
c();
c();
c();
var Brt = A(gLe(), 1),
  Hp = A(Frt(), 1),
  WVr = "_MODEL_INTROSPECTION_SCHEMA_KEY",
  QVr = "_MODEL_INTROSPECTION_SCHEMA_BUCKET_NAME",
  YVr = "_GRAPHQL_ENDPOINT",
  XVr = (e, t) => ({
    API: {
      GraphQL: {
        endpoint: e.dataEndpoint,
        region: e.AWS_REGION,
        defaultAuthMode: "iam",
        modelIntrospection: t,
      },
    },
  }),
  JVr = (e) => ({
    Auth: {
      credentialsProvider: {
        getCredentialsAndIdentityId: async () => ({
          credentials: {
            accessKeyId: e.AWS_ACCESS_KEY_ID,
            secretAccessKey: e.AWS_SECRET_ACCESS_KEY,
            sessionToken: e.AWS_SESSION_TOKEN,
          },
        }),
        clearCredentialsAndIdentityId: () => {},
      },
    },
  }),
  ZVr = (e, t) => {
    let r = `${t}${QVr}`,
      n = `${t}${WVr}`,
      i = `${t}${YVr}`;
    if (
      !(
        r in e &&
        n in e &&
        i in e &&
        typeof e[r] == "string" &&
        typeof e[n] == "string" &&
        typeof e[i] == "string"
      )
    )
      throw new Error(
        `The data environment variables are malformed. env=${JSON.stringify(e)}`,
      );
    let o = e[r],
      a = e[n],
      s = e[i];
    return { ...e, dataBucket: o, dataKey: a, dataEndpoint: s };
  },
  d3 = async (e, t) => {
    t || (t = new Hp.S3Client());
    let r = new Brt.NamingConverter().toScreamingSnakeCase(
        e.AMPLIFY_DATA_DEFAULT_NAME,
      ),
      n = ZVr(e, r),
      i;
    try {
      let u = await (
        await t.send(
          new Hp.GetObjectCommand({ Bucket: n.dataBucket, Key: n.dataKey }),
        )
      ).Body?.transformToString();
      i = JSON.parse(u ?? "{}");
    } catch (s) {
      throw s instanceof Hp.NoSuchKey
        ? new Error(
            "Error retrieving the schema from S3. Please confirm that your project has a `defineData` included in the `defineBackend` definition.",
            { cause: s },
          )
        : s instanceof Hp.S3ServiceException
          ? new Error(
              `Error retrieving the schema from S3. You may need to grant this function authorization on the schema. ${s.name}: ${s.message}.`,
              { cause: s },
            )
          : s;
    }
    let o = JVr(e);
    return { resourceConfig: XVr(n, i), libraryOptions: o };
  };
c();
var Urt = process.env;
var { resourceConfig: e$r, libraryOptions: t$r } = await d3({ ...Urt });
hV.configure(e$r, t$r);
var r$r = IK(),
  m5n = async (e) => (
    await r$r.models.user.create({
      id: e.request.userAttributes.sub,
      username: e.userName,
      email: e.request.userAttributes.email,
      displayName: e.request.userAttributes.preferred_username,
      owner: `${e.request.userAttributes.sub}::${e.userName}`,
    }),
    e
  );
export { m5n as handler };
/*! Bundled license information:

js-cookie/dist/js.cookie.mjs:
  (*! js-cookie v3.0.5 | MIT *)
*/
//# sourceMappingURL=index.mjs.map
